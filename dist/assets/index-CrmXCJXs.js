function fG(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const i in s)if(i!=="default"&&!(i in n)){const r=Object.getOwnPropertyDescriptor(s,i);r&&Object.defineProperty(n,i,r.get?r:{enumerable:!0,get:()=>s[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const fI="180",mG={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},gG={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},e3=0,OS=1,t3=2,AG=3,yG=0,xE=1,n3=2,ta=3,Za=0,ji=1,io=2,qa=0,cu=1,zS=2,US=3,QS=4,s3=5,Nl=100,i3=101,r3=102,o3=103,a3=104,l3=200,c3=201,u3=202,h3=203,V0=204,G0=205,d3=206,p3=207,f3=208,m3=209,g3=210,A3=211,y3=212,x3=213,b3=214,W0=0,H0=1,q0=2,Au=3,Y0=4,X0=5,j0=6,K0=7,jg=0,I3=1,C3=2,Ya=0,w3=1,v3=2,S3=3,E3=4,_3=5,T3=6,B3=7,VS="attached",k3="detached",mI=300,el=301,Gl=302,og=303,ag=304,wp=306,Xd=1e3,Pr=1001,lg=1002,bs=1003,bE=1004,xG=1004,zd=1005,bG=1005,Os=1006,Wm=1007,IG=1007,la=1008,M3=1008,Di=1009,IE=1010,CE=1011,jd=1012,gI=1013,Ri=1014,gr=1015,vp=1016,AI=1017,yI=1018,Kd=1020,wE=35902,vE=35899,SE=1021,EE=1022,ys=1023,Jd=1026,Zd=1027,xI=1028,Kg=1029,_E=1030,Jg=1031,CG=1032,ha=1033,Hm=33776,qm=33777,Ym=33778,Xm=33779,J0=35840,Z0=35841,eb=35842,tb=35843,nb=36196,sb=37492,ib=37496,rb=37808,ob=37809,ab=37810,lb=37811,cb=37812,ub=37813,hb=37814,db=37815,pb=37816,fb=37817,mb=37818,gb=37819,Ab=37820,yb=37821,xb=36492,bb=36494,Ib=36495,Cb=36283,wb=36284,vb=36285,Sb=36286,N3=2200,R3=2201,D3=2202,cg=2300,Eb=2301,y0=2302,jc=2400,Kc=2401,ug=2402,bI=2500,TE=2501,wG=0,vG=1,SG=2,F3=3200,$3=3201,EG=3202,_G=3203,ic=0,P3=1,Qa="",Ei="srgb",yu="srgb-linear",hg="linear",kn="srgb",TG=0,$c=7680,BG=7681,kG=7682,MG=7683,NG=34055,RG=34056,DG=5386,FG=512,$G=513,PG=514,LG=515,OG=516,zG=517,UG=518,GS=519,L3=512,O3=513,z3=514,BE=515,U3=516,Q3=517,V3=518,G3=519,dg=35044,W3=35048,QG=35040,VG=35045,GG=35049,WG=35041,HG=35046,qG=35050,YG=35042,XG="100",pg="300 es",Lr=2e3,ep=2001,jG={COMPUTE:"compute",RENDER:"render"},KG={PERSPECTIVE:"perspective",LINEAR:"linear",FLAT:"flat"},JG={NORMAL:"normal",CENTROID:"centroid",SAMPLE:"sample",FIRST:"first",EITHER:"either"};class Ca{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){const s=this._listeners;return s===void 0?!1:s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){const s=this._listeners;if(s===void 0)return;const i=s[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){const t=this._listeners;if(t===void 0)return;const s=t[e.type];if(s!==void 0){e.target=this;const i=s.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,e);e.target=null}}}const bi=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Sk=1234567;const uu=Math.PI/180,tp=180/Math.PI;function Qr(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(bi[n&255]+bi[n>>8&255]+bi[n>>16&255]+bi[n>>24&255]+"-"+bi[e&255]+bi[e>>8&255]+"-"+bi[e>>16&15|64]+bi[e>>24&255]+"-"+bi[t&63|128]+bi[t>>8&255]+"-"+bi[t>>16&255]+bi[t>>24&255]+bi[s&255]+bi[s>>8&255]+bi[s>>16&255]+bi[s>>24&255]).toLowerCase()}function Ot(n,e,t){return Math.max(e,Math.min(t,n))}function kE(n,e){return(n%e+e)%e}function ZG(n,e,t,s,i){return s+(n-e)*(i-s)/(t-e)}function eW(n,e,t){return n!==e?(t-n)/(e-n):0}function jm(n,e,t){return(1-t)*n+t*e}function tW(n,e,t,s){return jm(n,e,1-Math.exp(-t*s))}function nW(n,e=1){return e-Math.abs(kE(n,e*2)-e)}function sW(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function iW(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function rW(n,e){return n+Math.floor(Math.random()*(e-n+1))}function oW(n,e){return n+Math.random()*(e-n)}function aW(n){return n*(.5-Math.random())}function lW(n){n!==void 0&&(Sk=n);let e=Sk+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function cW(n){return n*uu}function uW(n){return n*tp}function hW(n){return(n&n-1)===0&&n!==0}function dW(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function pW(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function fW(n,e,t,s,i){const r=Math.cos,o=Math.sin,a=r(t/2),l=o(t/2),c=r((e+s)/2),u=o((e+s)/2),h=r((e-s)/2),d=o((e-s)/2),p=r((s-e)/2),f=o((s-e)/2);switch(i){case"XYX":n.set(a*u,l*h,l*d,a*c);break;case"YZY":n.set(l*d,a*u,l*h,a*c);break;case"ZXZ":n.set(l*h,l*d,a*u,a*c);break;case"XZX":n.set(a*u,l*f,l*p,a*c);break;case"YXY":n.set(l*p,a*u,l*f,a*c);break;case"ZYZ":n.set(l*f,l*p,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Yi(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Jt(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const ME={DEG2RAD:uu,RAD2DEG:tp,generateUUID:Qr,clamp:Ot,euclideanModulo:kE,mapLinear:ZG,inverseLerp:eW,lerp:jm,damp:tW,pingpong:nW,smoothstep:sW,smootherstep:iW,randInt:rW,randFloat:oW,randFloatSpread:aW,seededRandom:lW,degToRad:cW,radToDeg:uW,isPowerOfTwo:hW,ceilPowerOfTwo:dW,floorPowerOfTwo:pW,setQuaternionFromProperEuler:fW,normalize:Jt,denormalize:Yi};class $e{constructor(e=0,t=0){$e.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,s=this.y,i=e.elements;return this.x=i[0]*t+i[3]*s+i[6],this.y=i[1]*t+i[4]*s+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Ot(this.x,e.x,t.x),this.y=Ot(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=Ot(this.x,e,t),this.y=Ot(this.y,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Ot(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(Ot(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y;return t*t+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const s=Math.cos(t),i=Math.sin(t),r=this.x-e.x,o=this.y-e.y;return this.x=r*s-o*i+e.x,this.y=r*i+o*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class $n{constructor(e=0,t=0,s=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=s,this._w=i}static slerpFlat(e,t,s,i,r,o,a){let l=s[i+0],c=s[i+1],u=s[i+2],h=s[i+3];const d=r[o+0],p=r[o+1],f=r[o+2],g=r[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h;return}if(a===1){e[t+0]=d,e[t+1]=p,e[t+2]=f,e[t+3]=g;return}if(h!==g||l!==d||c!==p||u!==f){let m=1-a;const A=l*d+c*p+u*f+h*g,y=A>=0?1:-1,b=1-A*A;if(b>Number.EPSILON){const C=Math.sqrt(b),w=Math.atan2(C,A*y);m=Math.sin(m*w)/C,a=Math.sin(a*w)/C}const x=a*y;if(l=l*m+d*x,c=c*m+p*x,u=u*m+f*x,h=h*m+g*x,m===1-a){const C=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=C,c*=C,u*=C,h*=C}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,s,i,r,o){const a=s[i],l=s[i+1],c=s[i+2],u=s[i+3],h=r[o],d=r[o+1],p=r[o+2],f=r[o+3];return e[t]=a*f+u*h+l*p-c*d,e[t+1]=l*f+u*d+c*h-a*p,e[t+2]=c*f+u*p+a*d-l*h,e[t+3]=u*f-a*h-l*d-c*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,s,i){return this._x=e,this._y=t,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const s=e._x,i=e._y,r=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(s/2),u=a(i/2),h=a(r/2),d=l(s/2),p=l(i/2),f=l(r/2);switch(o){case"XYZ":this._x=d*u*h+c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h-d*p*f;break;case"YXZ":this._x=d*u*h+c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h+d*p*f;break;case"ZXY":this._x=d*u*h-c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h-d*p*f;break;case"ZYX":this._x=d*u*h-c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h+d*p*f;break;case"YZX":this._x=d*u*h+c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h-d*p*f;break;case"XZY":this._x=d*u*h-c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const s=t/2,i=Math.sin(s);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],i=t[4],r=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=s+a+h;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-l)*p,this._y=(r-c)*p,this._z=(o-i)*p}else if(s>a&&s>h){const p=2*Math.sqrt(1+s-a-h);this._w=(u-l)/p,this._x=.25*p,this._y=(i+o)/p,this._z=(r+c)/p}else if(a>h){const p=2*Math.sqrt(1+a-s-h);this._w=(r-c)/p,this._x=(i+o)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+h-s-a);this._w=(o-i)/p,this._x=(r+c)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<1e-8?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ot(this.dot(e),-1,1)))}rotateTowards(e,t){const s=this.angleTo(e);if(s===0)return this;const i=Math.min(1,t/s);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const s=e._x,i=e._y,r=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=s*u+o*a+i*c-r*l,this._y=i*u+o*l+r*a-s*c,this._z=r*u+o*c+s*l-i*a,this._w=o*u-s*a-i*l-r*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const s=this._x,i=this._y,r=this._z,o=this._w;let a=o*e._w+s*e._x+i*e._y+r*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=s,this._y=i,this._z=r,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*s+t*this._x,this._y=p*i+t*this._y,this._z=p*r+t*this._z,this.normalize(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=o*h+this._w*d,this._x=s*h+this._x*d,this._y=i*h+this._y*d,this._z=r*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,s){return this.copy(e).slerp(t,s)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),s=Math.random(),i=Math.sqrt(1-s),r=Math.sqrt(s);return this.set(i*Math.sin(e),i*Math.cos(e),r*Math.sin(t),r*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class U{constructor(e=0,t=0,s=0){U.prototype.isVector3=!0,this.x=e,this.y=t,this.z=s}set(e,t,s){return s===void 0&&(s=this.z),this.x=e,this.y=t,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(Ek.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Ek.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,s=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*s+r[6]*i,this.y=r[1]*t+r[4]*s+r[7]*i,this.z=r[2]*t+r[5]*s+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,r=e.elements,o=1/(r[3]*t+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*s+r[8]*i+r[12])*o,this.y=(r[1]*t+r[5]*s+r[9]*i+r[13])*o,this.z=(r[2]*t+r[6]*s+r[10]*i+r[14])*o,this}applyQuaternion(e){const t=this.x,s=this.y,i=this.z,r=e.x,o=e.y,a=e.z,l=e.w,c=2*(o*i-a*s),u=2*(a*t-r*i),h=2*(r*s-o*t);return this.x=t+l*c+o*h-a*u,this.y=s+l*u+a*c-r*h,this.z=i+l*h+r*u-o*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,s=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*s+r[8]*i,this.y=r[1]*t+r[5]*s+r[9]*i,this.z=r[2]*t+r[6]*s+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Ot(this.x,e.x,t.x),this.y=Ot(this.y,e.y,t.y),this.z=Ot(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=Ot(this.x,e,t),this.y=Ot(this.y,e,t),this.z=Ot(this.z,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Ot(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const s=e.x,i=e.y,r=e.z,o=t.x,a=t.y,l=t.z;return this.x=i*l-r*a,this.y=r*o-s*l,this.z=s*a-i*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const s=e.dot(this)/t;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return sv.copy(this).projectOnVector(e),this.sub(sv)}reflect(e){return this.sub(sv.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(Ot(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y,i=this.z-e.z;return t*t+s*s+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,s){const i=Math.sin(t)*e;return this.x=i*Math.sin(s),this.y=Math.cos(t)*e,this.z=i*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,s){return this.x=e*Math.sin(t),this.y=s,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=s,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,s=Math.sqrt(1-t*t);return this.x=s*Math.cos(e),this.y=t,this.z=s*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const sv=new U,Ek=new $n;class Ht{constructor(e,t,s,i,r,o,a,l,c){Ht.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,s,i,r,o,a,l,c)}set(e,t,s,i,r,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=i,u[2]=a,u[3]=t,u[4]=r,u[5]=l,u[6]=s,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],this}extractBasis(e,t,s){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,r=this.elements,o=s[0],a=s[3],l=s[6],c=s[1],u=s[4],h=s[7],d=s[2],p=s[5],f=s[8],g=i[0],m=i[3],A=i[6],y=i[1],b=i[4],x=i[7],C=i[2],w=i[5],E=i[8];return r[0]=o*g+a*y+l*C,r[3]=o*m+a*b+l*w,r[6]=o*A+a*x+l*E,r[1]=c*g+u*y+h*C,r[4]=c*m+u*b+h*w,r[7]=c*A+u*x+h*E,r[2]=d*g+p*y+f*C,r[5]=d*m+p*b+f*w,r[8]=d*A+p*x+f*E,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-s*r*u+s*a*l+i*r*c-i*o*l}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,d=a*l-u*r,p=c*r-o*l,f=t*h+s*d+i*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/f;return e[0]=h*g,e[1]=(i*c-u*s)*g,e[2]=(a*s-i*o)*g,e[3]=d*g,e[4]=(u*t-i*l)*g,e[5]=(i*r-a*t)*g,e[6]=p*g,e[7]=(s*l-c*t)*g,e[8]=(o*t-s*r)*g,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,s,i,r,o,a){const l=Math.cos(r),c=Math.sin(r);return this.set(s*l,s*c,-s*(l*o+c*a)+o+e,-i*c,i*l,-i*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(iv.makeScale(e,t)),this}rotate(e){return this.premultiply(iv.makeRotation(-e)),this}translate(e,t){return this.premultiply(iv.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,s,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<9;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<9;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const iv=new Ht;function H3(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}const mW={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Ud(n,e){return new mW[n](e)}function fg(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function q3(){const n=fg("canvas");return n.style.display="block",n}const _k={};function mg(n){n in _k||(_k[n]=!0,console.warn(n))}function gW(n,e,t){return new Promise(function(s,i){function r(){switch(n.clientWaitSync(e,n.SYNC_FLUSH_COMMANDS_BIT,0)){case n.WAIT_FAILED:i();break;case n.TIMEOUT_EXPIRED:setTimeout(r,t);break;default:s()}}setTimeout(r,t)})}const Tk=new Ht().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Bk=new Ht().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function AW(){const n={enabled:!0,workingColorSpace:yu,spaces:{},convert:function(i,r,o){return this.enabled===!1||r===o||!r||!o||(this.spaces[r].transfer===kn&&(i.r=Xa(i.r),i.g=Xa(i.g),i.b=Xa(i.b)),this.spaces[r].primaries!==this.spaces[o].primaries&&(i.applyMatrix3(this.spaces[r].toXYZ),i.applyMatrix3(this.spaces[o].fromXYZ)),this.spaces[o].transfer===kn&&(i.r=Gd(i.r),i.g=Gd(i.g),i.b=Gd(i.b))),i},workingToColorSpace:function(i,r){return this.convert(i,this.workingColorSpace,r)},colorSpaceToWorking:function(i,r){return this.convert(i,r,this.workingColorSpace)},getPrimaries:function(i){return this.spaces[i].primaries},getTransfer:function(i){return i===Qa?hg:this.spaces[i].transfer},getToneMappingMode:function(i){return this.spaces[i].outputColorSpaceConfig.toneMappingMode||"standard"},getLuminanceCoefficients:function(i,r=this.workingColorSpace){return i.fromArray(this.spaces[r].luminanceCoefficients)},define:function(i){Object.assign(this.spaces,i)},_getMatrix:function(i,r,o){return i.copy(this.spaces[r].toXYZ).multiply(this.spaces[o].fromXYZ)},_getDrawingBufferColorSpace:function(i){return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(i=this.workingColorSpace){return this.spaces[i].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(i,r){return mg("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),n.workingToColorSpace(i,r)},toWorkingColorSpace:function(i,r){return mg("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),n.colorSpaceToWorking(i,r)}},e=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],s=[.3127,.329];return n.define({[yu]:{primaries:e,whitePoint:s,transfer:hg,toXYZ:Tk,fromXYZ:Bk,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:Ei},outputColorSpaceConfig:{drawingBufferColorSpace:Ei}},[Ei]:{primaries:e,whitePoint:s,transfer:kn,toXYZ:Tk,fromXYZ:Bk,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:Ei}}}),n}const gn=AW();function Xa(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Gd(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let ad;class Y3{static getDataURL(e,t="image/png"){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let s;if(e instanceof HTMLCanvasElement)s=e;else{ad===void 0&&(ad=fg("canvas")),ad.width=e.width,ad.height=e.height;const i=ad.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),s=ad}return s.toDataURL(t)}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=fg("canvas");t.width=e.width,t.height=e.height;const s=t.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const i=s.getImageData(0,0,e.width,e.height),r=i.data;for(let o=0;o<r.length;o++)r[o]=Xa(r[o]/255)*255;return s.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let s=0;s<t.length;s++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[s]=Math.floor(Xa(t[s]/255)*255):t[s]=Xa(t[s]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let yW=0;class Rl{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:yW++}),this.uuid=Qr(),this.data=e,this.dataReady=!0,this.version=0}getSize(e){const t=this.data;return typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement?e.set(t.videoWidth,t.videoHeight,0):t instanceof VideoFrame?e.set(t.displayHeight,t.displayWidth,0):t!==null?e.set(t.width,t.height,t.depth||0):e.set(0,0,0),e}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?r.push(rv(i[o].image)):r.push(rv(i[o]))}else r=rv(i);s.url=r}return t||(e.images[this.uuid]=s),s}}function rv(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?Y3.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let xW=0;const ov=new U;class cs extends Ca{constructor(e=cs.DEFAULT_IMAGE,t=cs.DEFAULT_MAPPING,s=Pr,i=Pr,r=Os,o=la,a=ys,l=Di,c=cs.DEFAULT_ANISOTROPY,u=Qa){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:xW++}),this.uuid=Qr(),this.name="",this.source=new Rl(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=s,this.wrapT=i,this.magFilter=r,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new $e(0,0),this.repeat=new $e(1,1),this.center=new $e(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ht,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=u,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(e&&e.depth&&e.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(ov).x}get height(){return this.source.getSize(ov).y}get depth(){return this.source.getSize(ov).z}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.isArrayTexture=e.isArrayTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}setValues(e){for(const t in e){const s=e[t];if(s===void 0){console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);continue}i&&s&&i.isVector2&&s.isVector2||i&&s&&i.isVector3&&s.isVector3||i&&s&&i.isMatrix3&&s.isMatrix3?i.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),t||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==mI)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Xd:e.x=e.x-Math.floor(e.x);break;case Pr:e.x=e.x<0?0:1;break;case lg:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Xd:e.y=e.y-Math.floor(e.y);break;case Pr:e.y=e.y<0?0:1;break;case lg:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}cs.DEFAULT_IMAGE=null;cs.DEFAULT_MAPPING=mI;cs.DEFAULT_ANISOTROPY=1;class Yt{constructor(e=0,t=0,s=0,i=1){Yt.prototype.isVector4=!0,this.x=e,this.y=t,this.z=s,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,r=this.w,o=e.elements;return this.x=o[0]*t+o[4]*s+o[8]*i+o[12]*r,this.y=o[1]*t+o[5]*s+o[9]*i+o[13]*r,this.z=o[2]*t+o[6]*s+o[10]*i+o[14]*r,this.w=o[3]*t+o[7]*s+o[11]*i+o[15]*r,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,s,i,r;const l=e.elements,c=l[0],u=l[4],h=l[8],d=l[1],p=l[5],f=l[9],g=l[2],m=l[6],A=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-g)<.01&&Math.abs(f-m)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+g)<.1&&Math.abs(f+m)<.1&&Math.abs(c+p+A-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const b=(c+1)/2,x=(p+1)/2,C=(A+1)/2,w=(u+d)/4,E=(h+g)/4,T=(f+m)/4;return b>x&&b>C?b<.01?(s=0,i=.707106781,r=.707106781):(s=Math.sqrt(b),i=w/s,r=E/s):x>C?x<.01?(s=.707106781,i=0,r=.707106781):(i=Math.sqrt(x),s=w/i,r=T/i):C<.01?(s=.707106781,i=.707106781,r=0):(r=Math.sqrt(C),s=E/r,i=T/r),this.set(s,i,r,t),this}let y=Math.sqrt((m-f)*(m-f)+(h-g)*(h-g)+(d-u)*(d-u));return Math.abs(y)<.001&&(y=1),this.x=(m-f)/y,this.y=(h-g)/y,this.z=(d-u)/y,this.w=Math.acos((c+p+A-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Ot(this.x,e.x,t.x),this.y=Ot(this.y,e.y,t.y),this.z=Ot(this.z,e.z,t.z),this.w=Ot(this.w,e.w,t.w),this}clampScalar(e,t){return this.x=Ot(this.x,e,t),this.y=Ot(this.y,e,t),this.z=Ot(this.z,e,t),this.w=Ot(this.w,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Ot(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this.w=e.w+(t.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class NE extends Ca{constructor(e=1,t=1,s={}){super(),s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Os,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},s),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=s.depth,this.scissor=new Yt(0,0,e,t),this.scissorTest=!1,this.viewport=new Yt(0,0,e,t);const i={width:e,height:t,depth:s.depth},r=new cs(i);this.textures=[];const o=s.count;for(let a=0;a<o;a++)this.textures[a]=r.clone(),this.textures[a].isRenderTargetTexture=!0,this.textures[a].renderTarget=this;this._setTextureOptions(s),this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.resolveDepthBuffer=s.resolveDepthBuffer,this.resolveStencilBuffer=s.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=s.depthTexture,this.samples=s.samples,this.multiview=s.multiview}_setTextureOptions(e={}){const t={minFilter:Os,generateMipmaps:!1,flipY:!1,internalFormat:null};e.mapping!==void 0&&(t.mapping=e.mapping),e.wrapS!==void 0&&(t.wrapS=e.wrapS),e.wrapT!==void 0&&(t.wrapT=e.wrapT),e.wrapR!==void 0&&(t.wrapR=e.wrapR),e.magFilter!==void 0&&(t.magFilter=e.magFilter),e.minFilter!==void 0&&(t.minFilter=e.minFilter),e.format!==void 0&&(t.format=e.format),e.type!==void 0&&(t.type=e.type),e.anisotropy!==void 0&&(t.anisotropy=e.anisotropy),e.colorSpace!==void 0&&(t.colorSpace=e.colorSpace),e.flipY!==void 0&&(t.flipY=e.flipY),e.generateMipmaps!==void 0&&(t.generateMipmaps=e.generateMipmaps),e.internalFormat!==void 0&&(t.internalFormat=e.internalFormat);for(let s=0;s<this.textures.length;s++)this.textures[s].setValues(t)}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,t,s=1){if(this.width!==e||this.height!==t||this.depth!==s){this.width=e,this.height=t,this.depth=s;for(let i=0,r=this.textures.length;i<r;i++)this.textures[i].image.width=e,this.textures[i].image.height=t,this.textures[i].image.depth=s,this.textures[i].isArrayTexture=this.textures[i].image.depth>1;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let t=0,s=e.textures.length;t<s;t++){this.textures[t]=e.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;const i=Object.assign({},e.textures[t].image);this.textures[t].source=new Rl(i)}return this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class ao extends NE{constructor(e=1,t=1,s={}){super(e,t,s),this.isWebGLRenderTarget=!0}}class ko extends cs{constructor(e=null,t=1,s=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=bs,this.minFilter=bs,this.wrapR=Pr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class RE extends ao{constructor(e=1,t=1,s=1,i={}){super(e,t,i),this.isWebGLArrayRenderTarget=!0,this.depth=s,this.texture=new ko(null,e,t,s),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class Zg extends cs{constructor(e=null,t=1,s=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=bs,this.minFilter=bs,this.wrapR=Pr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class bW extends ao{constructor(e=1,t=1,s=1,i={}){super(e,t,i),this.isWebGL3DRenderTarget=!0,this.depth=s,this.texture=new Zg(null,e,t,s),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class Us{constructor(e=new U(1/0,1/0,1/0),t=new U(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t+=3)this.expandByPoint(Ao.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,s=e.count;t<s;t++)this.expandByPoint(Ao.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=Ao.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0){const r=s.getAttribute("position");if(t===!0&&r!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=r.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,Ao):Ao.fromBufferAttribute(r,o),Ao.applyMatrix4(e.matrixWorld),this.expandByPoint(Ao);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),ax.copy(e.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),ax.copy(s.boundingBox)),ax.applyMatrix4(e.matrixWorld),this.union(ax)}const i=e.children;for(let r=0,o=i.length;r<o;r++)this.expandByObject(i[r],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,Ao),Ao.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,s;return e.normal.x>0?(t=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),t<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(hm),lx.subVectors(this.max,hm),ld.subVectors(e.a,hm),cd.subVectors(e.b,hm),ud.subVectors(e.c,hm),bl.subVectors(cd,ld),Il.subVectors(ud,cd),bc.subVectors(ld,ud);let t=[0,-bl.z,bl.y,0,-Il.z,Il.y,0,-bc.z,bc.y,bl.z,0,-bl.x,Il.z,0,-Il.x,bc.z,0,-bc.x,-bl.y,bl.x,0,-Il.y,Il.x,0,-bc.y,bc.x,0];return!av(t,ld,cd,ud,lx)||(t=[1,0,0,0,1,0,0,0,1],!av(t,ld,cd,ud,lx))?!1:(cx.crossVectors(bl,Il),t=[cx.x,cx.y,cx.z],av(t,ld,cd,ud,lx))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Ao).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Ao).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Ra[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Ra[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Ra[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Ra[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Ra[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Ra[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Ra[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Ra[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Ra),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(e){return this.min.fromArray(e.min),this.max.fromArray(e.max),this}}const Ra=[new U,new U,new U,new U,new U,new U,new U,new U],Ao=new U,ax=new Us,ld=new U,cd=new U,ud=new U,bl=new U,Il=new U,bc=new U,hm=new U,lx=new U,cx=new U,Ic=new U;function av(n,e,t,s,i){for(let r=0,o=n.length-3;r<=o;r+=3){Ic.fromArray(n,r);const a=i.x*Math.abs(Ic.x)+i.y*Math.abs(Ic.y)+i.z*Math.abs(Ic.z),l=e.dot(Ic),c=t.dot(Ic),u=s.dot(Ic);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const IW=new Us,dm=new U,lv=new U;class pi{constructor(e=new U,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const s=this.center;t!==void 0?s.copy(t):IW.setFromPoints(e).getCenter(s);let i=0;for(let r=0,o=e.length;r<o;r++)i=Math.max(i,s.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const s=this.center.distanceToSquared(e);return t.copy(e),s>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;dm.subVectors(e,this.center);const t=dm.lengthSq();if(t>this.radius*this.radius){const s=Math.sqrt(t),i=(s-this.radius)*.5;this.center.addScaledVector(dm,i/s),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(lv.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(dm.copy(e.center).add(lv)),this.expandByPoint(dm.copy(e.center).sub(lv))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(e){return this.radius=e.radius,this.center.fromArray(e.center),this}}const Da=new U,cv=new U,ux=new U,Cl=new U,uv=new U,hx=new U,hv=new U;class Sp{constructor(e=new U,t=new U(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Da)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const s=t.dot(this.direction);return s<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Da.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Da.copy(this.origin).addScaledVector(this.direction,t),Da.distanceToSquared(e))}distanceSqToSegment(e,t,s,i){cv.copy(e).add(t).multiplyScalar(.5),ux.copy(t).sub(e).normalize(),Cl.copy(this.origin).sub(cv);const r=e.distanceTo(t)*.5,o=-this.direction.dot(ux),a=Cl.dot(this.direction),l=-Cl.dot(ux),c=Cl.lengthSq(),u=Math.abs(1-o*o);let h,d,p,f;if(u>0)if(h=o*l-a,d=o*a-l,f=r*u,h>=0)if(d>=-f)if(d<=f){const g=1/u;h*=g,d*=g,p=h*(h+o*d+2*a)+d*(o*h+d+2*l)+c}else d=r,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;else d=-r,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;else d<=-f?(h=Math.max(0,-(-o*r+a)),d=h>0?-r:Math.min(Math.max(-r,-l),r),p=-h*h+d*(d+2*l)+c):d<=f?(h=0,d=Math.min(Math.max(-r,-l),r),p=d*(d+2*l)+c):(h=Math.max(0,-(o*r+a)),d=h>0?r:Math.min(Math.max(-r,-l),r),p=-h*h+d*(d+2*l)+c);else d=o>0?-r:r,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;return s&&s.copy(this.origin).addScaledVector(this.direction,h),i&&i.copy(cv).addScaledVector(ux,d),p}intersectSphere(e,t){Da.subVectors(e.center,this.origin);const s=Da.dot(this.direction),i=Da.dot(Da)-s*s,r=e.radius*e.radius;if(i>r)return null;const o=Math.sqrt(r-i),a=s-o,l=s+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return e.radius<0?!1:this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/t;return s>=0?s:null}intersectPlane(e,t){const s=this.distanceToPlane(e);return s===null?null:this.at(s,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let s,i,r,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(s=(e.min.x-d.x)*c,i=(e.max.x-d.x)*c):(s=(e.max.x-d.x)*c,i=(e.min.x-d.x)*c),u>=0?(r=(e.min.y-d.y)*u,o=(e.max.y-d.y)*u):(r=(e.max.y-d.y)*u,o=(e.min.y-d.y)*u),s>o||r>i||((r>s||isNaN(s))&&(s=r),(o<i||isNaN(i))&&(i=o),h>=0?(a=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(a=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),s>l||a>i)||((a>s||s!==s)&&(s=a),(l<i||i!==i)&&(i=l),i<0)?null:this.at(s>=0?s:i,t)}intersectsBox(e){return this.intersectBox(e,Da)!==null}intersectTriangle(e,t,s,i,r){uv.subVectors(t,e),hx.subVectors(s,e),hv.crossVectors(uv,hx);let o=this.direction.dot(hv),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;Cl.subVectors(this.origin,e);const l=a*this.direction.dot(hx.crossVectors(Cl,hx));if(l<0)return null;const c=a*this.direction.dot(uv.cross(Cl));if(c<0||l+c>o)return null;const u=-a*Cl.dot(hv);return u<0?null:this.at(u/o,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class kt{constructor(e,t,s,i,r,o,a,l,c,u,h,d,p,f,g,m){kt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,s,i,r,o,a,l,c,u,h,d,p,f,g,m)}set(e,t,s,i,r,o,a,l,c,u,h,d,p,f,g,m){const A=this.elements;return A[0]=e,A[4]=t,A[8]=s,A[12]=i,A[1]=r,A[5]=o,A[9]=a,A[13]=l,A[2]=c,A[6]=u,A[10]=h,A[14]=d,A[3]=p,A[7]=f,A[11]=g,A[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new kt().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,i=1/hd.setFromMatrixColumn(e,0).length(),r=1/hd.setFromMatrixColumn(e,1).length(),o=1/hd.setFromMatrixColumn(e,2).length();return t[0]=s[0]*i,t[1]=s[1]*i,t[2]=s[2]*i,t[3]=0,t[4]=s[4]*r,t[5]=s[5]*r,t[6]=s[6]*r,t[7]=0,t[8]=s[8]*o,t[9]=s[9]*o,t[10]=s[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,s=e.x,i=e.y,r=e.z,o=Math.cos(s),a=Math.sin(s),l=Math.cos(i),c=Math.sin(i),u=Math.cos(r),h=Math.sin(r);if(e.order==="XYZ"){const d=o*u,p=o*h,f=a*u,g=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=p+f*c,t[5]=d-g*c,t[9]=-a*l,t[2]=g-d*c,t[6]=f+p*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*u,p=l*h,f=c*u,g=c*h;t[0]=d+g*a,t[4]=f*a-p,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=p*a-f,t[6]=g+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*u,p=l*h,f=c*u,g=c*h;t[0]=d-g*a,t[4]=-o*h,t[8]=f+p*a,t[1]=p+f*a,t[5]=o*u,t[9]=g-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*u,p=o*h,f=a*u,g=a*h;t[0]=l*u,t[4]=f*c-p,t[8]=d*c+g,t[1]=l*h,t[5]=g*c+d,t[9]=p*c-f,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,p=o*c,f=a*l,g=a*c;t[0]=l*u,t[4]=g-d*h,t[8]=f*h+p,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=p*h+f,t[10]=d-g*h}else if(e.order==="XZY"){const d=o*l,p=o*c,f=a*l,g=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+g,t[5]=o*u,t[9]=p*h-f,t[2]=f*h-p,t[6]=a*u,t[10]=g*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(CW,e,wW)}lookAt(e,t,s){const i=this.elements;return kr.subVectors(e,t),kr.lengthSq()===0&&(kr.z=1),kr.normalize(),wl.crossVectors(s,kr),wl.lengthSq()===0&&(Math.abs(s.z)===1?kr.x+=1e-4:kr.z+=1e-4,kr.normalize(),wl.crossVectors(s,kr)),wl.normalize(),dx.crossVectors(kr,wl),i[0]=wl.x,i[4]=dx.x,i[8]=kr.x,i[1]=wl.y,i[5]=dx.y,i[9]=kr.y,i[2]=wl.z,i[6]=dx.z,i[10]=kr.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,r=this.elements,o=s[0],a=s[4],l=s[8],c=s[12],u=s[1],h=s[5],d=s[9],p=s[13],f=s[2],g=s[6],m=s[10],A=s[14],y=s[3],b=s[7],x=s[11],C=s[15],w=i[0],E=i[4],T=i[8],v=i[12],S=i[1],_=i[5],N=i[9],D=i[13],P=i[2],L=i[6],z=i[10],q=i[14],V=i[3],X=i[7],te=i[11],se=i[15];return r[0]=o*w+a*S+l*P+c*V,r[4]=o*E+a*_+l*L+c*X,r[8]=o*T+a*N+l*z+c*te,r[12]=o*v+a*D+l*q+c*se,r[1]=u*w+h*S+d*P+p*V,r[5]=u*E+h*_+d*L+p*X,r[9]=u*T+h*N+d*z+p*te,r[13]=u*v+h*D+d*q+p*se,r[2]=f*w+g*S+m*P+A*V,r[6]=f*E+g*_+m*L+A*X,r[10]=f*T+g*N+m*z+A*te,r[14]=f*v+g*D+m*q+A*se,r[3]=y*w+b*S+x*P+C*V,r[7]=y*E+b*_+x*L+C*X,r[11]=y*T+b*N+x*z+C*te,r[15]=y*v+b*D+x*q+C*se,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],i=e[8],r=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],p=e[14],f=e[3],g=e[7],m=e[11],A=e[15];return f*(+r*l*h-i*c*h-r*a*d+s*c*d+i*a*p-s*l*p)+g*(+t*l*p-t*c*d+r*o*d-i*o*p+i*c*u-r*l*u)+m*(+t*c*h-t*a*p-r*o*h+s*o*p+r*a*u-s*c*u)+A*(-i*a*u-t*l*h+t*a*d+i*o*h-s*o*d+s*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],A=e[15],y=h*m*c-g*d*c+g*l*p-a*m*p-h*l*A+a*d*A,b=f*d*c-u*m*c-f*l*p+o*m*p+u*l*A-o*d*A,x=u*g*c-f*h*c+f*a*p-o*g*p-u*a*A+o*h*A,C=f*h*l-u*g*l-f*a*d+o*g*d+u*a*m-o*h*m,w=t*y+s*b+i*x+r*C;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const E=1/w;return e[0]=y*E,e[1]=(g*d*r-h*m*r-g*i*p+s*m*p+h*i*A-s*d*A)*E,e[2]=(a*m*r-g*l*r+g*i*c-s*m*c-a*i*A+s*l*A)*E,e[3]=(h*l*r-a*d*r-h*i*c+s*d*c+a*i*p-s*l*p)*E,e[4]=b*E,e[5]=(u*m*r-f*d*r+f*i*p-t*m*p-u*i*A+t*d*A)*E,e[6]=(f*l*r-o*m*r-f*i*c+t*m*c+o*i*A-t*l*A)*E,e[7]=(o*d*r-u*l*r+u*i*c-t*d*c-o*i*p+t*l*p)*E,e[8]=x*E,e[9]=(f*h*r-u*g*r-f*s*p+t*g*p+u*s*A-t*h*A)*E,e[10]=(o*g*r-f*a*r+f*s*c-t*g*c-o*s*A+t*a*A)*E,e[11]=(u*a*r-o*h*r-u*s*c+t*h*c+o*s*p-t*a*p)*E,e[12]=C*E,e[13]=(u*g*i-f*h*i+f*s*d-t*g*d-u*s*m+t*h*m)*E,e[14]=(f*a*i-o*g*i-f*s*l+t*g*l+o*s*m-t*a*m)*E,e[15]=(o*h*i-u*a*i+u*s*l-t*h*l-o*s*d+t*a*d)*E,this}scale(e){const t=this.elements,s=e.x,i=e.y,r=e.z;return t[0]*=s,t[4]*=i,t[8]*=r,t[1]*=s,t[5]*=i,t[9]*=r,t[2]*=s,t[6]*=i,t[10]*=r,t[3]*=s,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,i))}makeTranslation(e,t,s){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),i=Math.sin(t),r=1-s,o=e.x,a=e.y,l=e.z,c=r*o,u=r*a;return this.set(c*o+s,c*a-i*l,c*l+i*a,0,c*a+i*l,u*a+s,u*l-i*o,0,c*l-i*a,u*l+i*o,r*l*l+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,i,r,o){return this.set(1,s,r,0,e,1,o,0,t,i,1,0,0,0,0,1),this}compose(e,t,s){const i=this.elements,r=t._x,o=t._y,a=t._z,l=t._w,c=r+r,u=o+o,h=a+a,d=r*c,p=r*u,f=r*h,g=o*u,m=o*h,A=a*h,y=l*c,b=l*u,x=l*h,C=s.x,w=s.y,E=s.z;return i[0]=(1-(g+A))*C,i[1]=(p+x)*C,i[2]=(f-b)*C,i[3]=0,i[4]=(p-x)*w,i[5]=(1-(d+A))*w,i[6]=(m+y)*w,i[7]=0,i[8]=(f+b)*E,i[9]=(m-y)*E,i[10]=(1-(d+g))*E,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,s){const i=this.elements;let r=hd.set(i[0],i[1],i[2]).length();const o=hd.set(i[4],i[5],i[6]).length(),a=hd.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],yo.copy(this);const c=1/r,u=1/o,h=1/a;return yo.elements[0]*=c,yo.elements[1]*=c,yo.elements[2]*=c,yo.elements[4]*=u,yo.elements[5]*=u,yo.elements[6]*=u,yo.elements[8]*=h,yo.elements[9]*=h,yo.elements[10]*=h,t.setFromRotationMatrix(yo),s.x=r,s.y=o,s.z=a,this}makePerspective(e,t,s,i,r,o,a=Lr,l=!1){const c=this.elements,u=2*r/(t-e),h=2*r/(s-i),d=(t+e)/(t-e),p=(s+i)/(s-i);let f,g;if(l)f=r/(o-r),g=o*r/(o-r);else if(a===Lr)f=-(o+r)/(o-r),g=-2*o*r/(o-r);else if(a===ep)f=-o/(o-r),g=-o*r/(o-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return c[0]=u,c[4]=0,c[8]=d,c[12]=0,c[1]=0,c[5]=h,c[9]=p,c[13]=0,c[2]=0,c[6]=0,c[10]=f,c[14]=g,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(e,t,s,i,r,o,a=Lr,l=!1){const c=this.elements,u=2/(t-e),h=2/(s-i),d=-(t+e)/(t-e),p=-(s+i)/(s-i);let f,g;if(l)f=1/(o-r),g=o/(o-r);else if(a===Lr)f=-2/(o-r),g=-(o+r)/(o-r);else if(a===ep)f=-1/(o-r),g=-r/(o-r);else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return c[0]=u,c[4]=0,c[8]=0,c[12]=d,c[1]=0,c[5]=h,c[9]=0,c[13]=p,c[2]=0,c[6]=0,c[10]=f,c[14]=g,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<16;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}const hd=new U,yo=new kt,CW=new U(0,0,0),wW=new U(1,1,1),wl=new U,dx=new U,kr=new U,kk=new kt,Mk=new $n;class Wr{constructor(e=0,t=0,s=0,i=Wr.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=s,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,s,i=this._order){return this._x=e,this._y=t,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,s=!0){const i=e.elements,r=i[0],o=i[4],a=i[8],l=i[1],c=i[5],u=i[9],h=i[2],d=i[6],p=i[10];switch(t){case"XYZ":this._y=Math.asin(Ot(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Ot(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(Ot(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-Ot(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(Ot(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-Ot(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,s){return kk.makeRotationFromQuaternion(e),this.setFromRotationMatrix(kk,t,s)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Mk.setFromEuler(this),this.setFromQuaternion(Mk,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Wr.DEFAULT_ORDER="XYZ";class II{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let vW=0;const Nk=new U,dd=new $n,Fa=new kt,px=new U,pm=new U,SW=new U,EW=new $n,Rk=new U(1,0,0),Dk=new U(0,1,0),Fk=new U(0,0,1),$k={type:"added"},_W={type:"removed"},pd={type:"childadded",child:null},dv={type:"childremoved",child:null};class un extends Ca{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:vW++}),this.uuid=Qr(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=un.DEFAULT_UP.clone();const e=new U,t=new Wr,s=new $n,i=new U(1,1,1);function r(){s.setFromEuler(t,!1)}function o(){t.setFromQuaternion(s,void 0,!1)}t._onChange(r),s._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new kt},normalMatrix:{value:new Ht}}),this.matrix=new kt,this.matrixWorld=new kt,this.matrixAutoUpdate=un.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=un.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new II,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return dd.setFromAxisAngle(e,t),this.quaternion.multiply(dd),this}rotateOnWorldAxis(e,t){return dd.setFromAxisAngle(e,t),this.quaternion.premultiply(dd),this}rotateX(e){return this.rotateOnAxis(Rk,e)}rotateY(e){return this.rotateOnAxis(Dk,e)}rotateZ(e){return this.rotateOnAxis(Fk,e)}translateOnAxis(e,t){return Nk.copy(e).applyQuaternion(this.quaternion),this.position.add(Nk.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Rk,e)}translateY(e){return this.translateOnAxis(Dk,e)}translateZ(e){return this.translateOnAxis(Fk,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Fa.copy(this.matrixWorld).invert())}lookAt(e,t,s){e.isVector3?px.copy(e):px.set(e,t,s);const i=this.parent;this.updateWorldMatrix(!0,!1),pm.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Fa.lookAt(pm,px,this.up):Fa.lookAt(px,pm,this.up),this.quaternion.setFromRotationMatrix(Fa),i&&(Fa.extractRotation(i.matrixWorld),dd.setFromRotationMatrix(Fa),this.quaternion.premultiply(dd.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent($k),pd.child=e,this.dispatchEvent(pd),pd.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(_W),dv.child=e,this.dispatchEvent(dv),dv.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Fa.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Fa.multiply(e.parent.matrixWorld)),e.applyMatrix4(Fa),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent($k),pd.child=e,this.dispatchEvent(pd),pd.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let s=0,i=this.children.length;s<i;s++){const o=this.children[s].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,s=[]){this[e]===t&&s.push(this);const i=this.children;for(let r=0,o=i.length;r<o;r++)i[r].getObjectsByProperty(e,t,s);return s}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(pm,e,SW),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(pm,EW,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].updateMatrixWorld(e)}updateWorldMatrix(e,t){const s=this.parent;if(e===!0&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const i=this.children;for(let r=0,o=i.length;r<o;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",s={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.geometryInfo=this._geometryInfo.map(a=>({...a,boundingBox:a.boundingBox?a.boundingBox.toJSON():void 0,boundingSphere:a.boundingSphere?a.boundingSphere.toJSON():void 0})),i.instanceInfo=this._instanceInfo.map(a=>({...a})),i.availableInstanceIds=this._availableInstanceIds.slice(),i.availableGeometryIds=this._availableGeometryIds.slice(),i.nextIndexStart=this._nextIndexStart,i.nextVertexStart=this._nextVertexStart,i.geometryCount=this._geometryCount,i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.matricesTexture=this._matricesTexture.toJSON(e),i.indirectTexture=this._indirectTexture.toJSON(e),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(i.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(i.boundingBox=this.boundingBox.toJSON()));function r(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];r(e.shapes,h)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(r(e.materials,this.material[l]));i.material=a}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];i.animations.push(r(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),u=o(e.images),h=o(e.shapes),d=o(e.skeletons),p=o(e.animations),f=o(e.nodes);a.length>0&&(s.geometries=a),l.length>0&&(s.materials=l),c.length>0&&(s.textures=c),u.length>0&&(s.images=u),h.length>0&&(s.shapes=h),d.length>0&&(s.skeletons=d),p.length>0&&(s.animations=p),f.length>0&&(s.nodes=f)}return s.object=i,s;function o(a){const l=[];for(const c in a){const u=a[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let s=0;s<e.children.length;s++){const i=e.children[s];this.add(i.clone())}return this}}un.DEFAULT_UP=new U(0,1,0);un.DEFAULT_MATRIX_AUTO_UPDATE=!0;un.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const xo=new U,$a=new U,pv=new U,Pa=new U,fd=new U,md=new U,Pk=new U,fv=new U,mv=new U,gv=new U,Av=new Yt,yv=new Yt,xv=new Yt;class fr{constructor(e=new U,t=new U,s=new U){this.a=e,this.b=t,this.c=s}static getNormal(e,t,s,i){i.subVectors(s,t),xo.subVectors(e,t),i.cross(xo);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,s,i,r){xo.subVectors(i,t),$a.subVectors(s,t),pv.subVectors(e,t);const o=xo.dot(xo),a=xo.dot($a),l=xo.dot(pv),c=$a.dot($a),u=$a.dot(pv),h=o*c-a*a;if(h===0)return r.set(0,0,0),null;const d=1/h,p=(c*l-a*u)*d,f=(o*u-a*l)*d;return r.set(1-p-f,f,p)}static containsPoint(e,t,s,i){return this.getBarycoord(e,t,s,i,Pa)===null?!1:Pa.x>=0&&Pa.y>=0&&Pa.x+Pa.y<=1}static getInterpolation(e,t,s,i,r,o,a,l){return this.getBarycoord(e,t,s,i,Pa)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(r,Pa.x),l.addScaledVector(o,Pa.y),l.addScaledVector(a,Pa.z),l)}static getInterpolatedAttribute(e,t,s,i,r,o){return Av.setScalar(0),yv.setScalar(0),xv.setScalar(0),Av.fromBufferAttribute(e,t),yv.fromBufferAttribute(e,s),xv.fromBufferAttribute(e,i),o.setScalar(0),o.addScaledVector(Av,r.x),o.addScaledVector(yv,r.y),o.addScaledVector(xv,r.z),o}static isFrontFacing(e,t,s,i){return xo.subVectors(s,t),$a.subVectors(e,t),xo.cross($a).dot(i)<0}set(e,t,s){return this.a.copy(e),this.b.copy(t),this.c.copy(s),this}setFromPointsAndIndices(e,t,s,i){return this.a.copy(e[t]),this.b.copy(e[s]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,s,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return xo.subVectors(this.c,this.b),$a.subVectors(this.a,this.b),xo.cross($a).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return fr.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return fr.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,s,i,r){return fr.getInterpolation(e,this.a,this.b,this.c,t,s,i,r)}containsPoint(e){return fr.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return fr.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const s=this.a,i=this.b,r=this.c;let o,a;fd.subVectors(i,s),md.subVectors(r,s),fv.subVectors(e,s);const l=fd.dot(fv),c=md.dot(fv);if(l<=0&&c<=0)return t.copy(s);mv.subVectors(e,i);const u=fd.dot(mv),h=md.dot(mv);if(u>=0&&h<=u)return t.copy(i);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(s).addScaledVector(fd,o);gv.subVectors(e,r);const p=fd.dot(gv),f=md.dot(gv);if(f>=0&&p<=f)return t.copy(r);const g=p*c-l*f;if(g<=0&&c>=0&&f<=0)return a=c/(c-f),t.copy(s).addScaledVector(md,a);const m=u*f-p*h;if(m<=0&&h-u>=0&&p-f>=0)return Pk.subVectors(r,i),a=(h-u)/(h-u+(p-f)),t.copy(i).addScaledVector(Pk,a);const A=1/(m+g+d);return o=g*A,a=d*A,t.copy(s).addScaledVector(fd,o).addScaledVector(md,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const X3={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},vl={h:0,s:0,l:0},fx={h:0,s:0,l:0};function bv(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class ot{constructor(e,t,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,s)}set(e,t,s){if(t===void 0&&s===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,s);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Ei){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,gn.colorSpaceToWorking(this,t),this}setRGB(e,t,s,i=gn.workingColorSpace){return this.r=e,this.g=t,this.b=s,gn.colorSpaceToWorking(this,i),this}setHSL(e,t,s,i=gn.workingColorSpace){if(e=kE(e,1),t=Ot(t,0,1),s=Ot(s,0,1),t===0)this.r=this.g=this.b=s;else{const r=s<=.5?s*(1+t):s+t-s*t,o=2*s-r;this.r=bv(o,r,e+1/3),this.g=bv(o,r,e),this.b=bv(o,r,e-1/3)}return gn.colorSpaceToWorking(this,i),this}setStyle(e,t=Ei){function s(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let r;const o=i[1],a=i[2];switch(o){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,t);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,t);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],o=r.length;if(o===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(r,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=Ei){const s=X3[e.toLowerCase()];return s!==void 0?this.setHex(s,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Xa(e.r),this.g=Xa(e.g),this.b=Xa(e.b),this}copyLinearToSRGB(e){return this.r=Gd(e.r),this.g=Gd(e.g),this.b=Gd(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Ei){return gn.workingToColorSpace(Ii.copy(this),e),Math.round(Ot(Ii.r*255,0,255))*65536+Math.round(Ot(Ii.g*255,0,255))*256+Math.round(Ot(Ii.b*255,0,255))}getHexString(e=Ei){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=gn.workingColorSpace){gn.workingToColorSpace(Ii.copy(this),t);const s=Ii.r,i=Ii.g,r=Ii.b,o=Math.max(s,i,r),a=Math.min(s,i,r);let l,c;const u=(a+o)/2;if(a===o)l=0,c=0;else{const h=o-a;switch(c=u<=.5?h/(o+a):h/(2-o-a),o){case s:l=(i-r)/h+(i<r?6:0);break;case i:l=(r-s)/h+2;break;case r:l=(s-i)/h+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,t=gn.workingColorSpace){return gn.workingToColorSpace(Ii.copy(this),t),e.r=Ii.r,e.g=Ii.g,e.b=Ii.b,e}getStyle(e=Ei){gn.workingToColorSpace(Ii.copy(this),e);const t=Ii.r,s=Ii.g,i=Ii.b;return e!==Ei?`color(${e} ${t.toFixed(3)} ${s.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(s*255)},${Math.round(i*255)})`}offsetHSL(e,t,s){return this.getHSL(vl),this.setHSL(vl.h+e,vl.s+t,vl.l+s)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,s){return this.r=e.r+(t.r-e.r)*s,this.g=e.g+(t.g-e.g)*s,this.b=e.b+(t.b-e.b)*s,this}lerpHSL(e,t){this.getHSL(vl),e.getHSL(fx);const s=jm(vl.h,fx.h,t),i=jm(vl.s,fx.s,t),r=jm(vl.l,fx.l,t);return this.setHSL(s,i,r),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,s=this.g,i=this.b,r=e.elements;return this.r=r[0]*t+r[3]*s+r[6]*i,this.g=r[1]*t+r[4]*s+r[7]*i,this.b=r[2]*t+r[5]*s+r[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Ii=new ot;ot.NAMES=X3;let TW=0;class Li extends Ca{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:TW++}),this.uuid=Qr(),this.name="",this.type="Material",this.blending=cu,this.side=Za,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=V0,this.blendDst=G0,this.blendEquation=Nl,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new ot(0,0,0),this.blendAlpha=0,this.depthFunc=Au,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=GS,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=$c,this.stencilZFail=$c,this.stencilZPass=$c,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const s=e[t];if(s===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(s):i&&i.isVector3&&s&&s.isVector3?i.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const s={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.sheenColorMap&&this.sheenColorMap.isTexture&&(s.sheenColorMap=this.sheenColorMap.toJSON(e).uuid),this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture&&(s.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(e).uuid),this.dispersion!==void 0&&(s.dispersion=this.dispersion),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapRotation!==void 0&&(s.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==cu&&(s.blending=this.blending),this.side!==Za&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==V0&&(s.blendSrc=this.blendSrc),this.blendDst!==G0&&(s.blendDst=this.blendDst),this.blendEquation!==Nl&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==Au&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==GS&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==$c&&(s.stencilFail=this.stencilFail),this.stencilZFail!==$c&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==$c&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function i(r){const o=[];for(const a in r){const l=r[a];delete l.metadata,o.push(l)}return o}if(t){const r=i(e.textures),o=i(e.images);r.length>0&&(s.textures=r),o.length>0&&(s.images=o)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let s=null;if(t!==null){const i=t.length;s=new Array(i);for(let r=0;r!==i;++r)s[r]=t[r].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class wa extends Li{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new ot(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Wr,this.combine=jg,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Va=BW();function BW(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),s=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(s[l]=0,s[l|256]=32768,i[l]=24,i[l|256]=24):c<-14?(s[l]=1024>>-c-14,s[l|256]=1024>>-c-14|32768,i[l]=-c-1,i[l|256]=-c-1):c<=15?(s[l]=c+15<<10,s[l|256]=c+15<<10|32768,i[l]=13,i[l|256]=13):c<128?(s[l]=31744,s[l|256]=64512,i[l]=24,i[l|256]=24):(s[l]=31744,s[l|256]=64512,i[l]=13,i[l|256]=13)}const r=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,u=0;for(;(c&8388608)===0;)c<<=1,u-=8388608;c&=-8388609,u+=947912704,r[l]=c|u}for(let l=1024;l<2048;++l)r[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:t,baseTable:s,shiftTable:i,mantissaTable:r,exponentTable:o,offsetTable:a}}function ur(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=Ot(n,-65504,65504),Va.floatView[0]=n;const e=Va.uint32View[0],t=e>>23&511;return Va.baseTable[t]+((e&8388607)>>Va.shiftTable[t])}function Bm(n){const e=n>>10;return Va.uint32View[0]=Va.mantissaTable[Va.offsetTable[e]+(n&1023)]+Va.exponentTable[e],Va.floatView[0]}class kW{static toHalfFloat(e){return ur(e)}static fromHalfFloat(e){return Bm(e)}}const Ss=new U,mx=new $e;let MW=0;class Sn{constructor(e,t,s=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:MW++}),this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=s,this.usage=dg,this.updateRanges=[],this.gpuType=gr,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,s){e*=this.itemSize,s*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[s+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,s=this.count;t<s;t++)mx.fromBufferAttribute(this,t),mx.applyMatrix3(e),this.setXY(t,mx.x,mx.y);else if(this.itemSize===3)for(let t=0,s=this.count;t<s;t++)Ss.fromBufferAttribute(this,t),Ss.applyMatrix3(e),this.setXYZ(t,Ss.x,Ss.y,Ss.z);return this}applyMatrix4(e){for(let t=0,s=this.count;t<s;t++)Ss.fromBufferAttribute(this,t),Ss.applyMatrix4(e),this.setXYZ(t,Ss.x,Ss.y,Ss.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)Ss.fromBufferAttribute(this,t),Ss.applyNormalMatrix(e),this.setXYZ(t,Ss.x,Ss.y,Ss.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)Ss.fromBufferAttribute(this,t),Ss.transformDirection(e),this.setXYZ(t,Ss.x,Ss.y,Ss.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let s=this.array[e*this.itemSize+t];return this.normalized&&(s=Yi(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Jt(s,this.array)),this.array[e*this.itemSize+t]=s,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Yi(t,this.array)),t}setX(e,t){return this.normalized&&(t=Jt(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Yi(t,this.array)),t}setY(e,t){return this.normalized&&(t=Jt(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Yi(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Jt(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Yi(t,this.array)),t}setW(e,t){return this.normalized&&(t=Jt(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Jt(t,this.array),s=Jt(s,this.array)),this.array[e+0]=t,this.array[e+1]=s,this}setXYZ(e,t,s,i){return e*=this.itemSize,this.normalized&&(t=Jt(t,this.array),s=Jt(s,this.array),i=Jt(i,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this}setXYZW(e,t,s,i,r){return e*=this.itemSize,this.normalized&&(t=Jt(t,this.array),s=Jt(s,this.array),i=Jt(i,this.array),r=Jt(r,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==dg&&(e.usage=this.usage),e}}class NW extends Sn{constructor(e,t,s){super(new Int8Array(e),t,s)}}class RW extends Sn{constructor(e,t,s){super(new Uint8Array(e),t,s)}}class DW extends Sn{constructor(e,t,s){super(new Uint8ClampedArray(e),t,s)}}class FW extends Sn{constructor(e,t,s){super(new Int16Array(e),t,s)}}class DE extends Sn{constructor(e,t,s){super(new Uint16Array(e),t,s)}}class $W extends Sn{constructor(e,t,s){super(new Int32Array(e),t,s)}}class FE extends Sn{constructor(e,t,s){super(new Uint32Array(e),t,s)}}class PW extends Sn{constructor(e,t,s){super(new Uint16Array(e),t,s),this.isFloat16BufferAttribute=!0}getX(e){let t=Bm(this.array[e*this.itemSize]);return this.normalized&&(t=Yi(t,this.array)),t}setX(e,t){return this.normalized&&(t=Jt(t,this.array)),this.array[e*this.itemSize]=ur(t),this}getY(e){let t=Bm(this.array[e*this.itemSize+1]);return this.normalized&&(t=Yi(t,this.array)),t}setY(e,t){return this.normalized&&(t=Jt(t,this.array)),this.array[e*this.itemSize+1]=ur(t),this}getZ(e){let t=Bm(this.array[e*this.itemSize+2]);return this.normalized&&(t=Yi(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Jt(t,this.array)),this.array[e*this.itemSize+2]=ur(t),this}getW(e){let t=Bm(this.array[e*this.itemSize+3]);return this.normalized&&(t=Yi(t,this.array)),t}setW(e,t){return this.normalized&&(t=Jt(t,this.array)),this.array[e*this.itemSize+3]=ur(t),this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Jt(t,this.array),s=Jt(s,this.array)),this.array[e+0]=ur(t),this.array[e+1]=ur(s),this}setXYZ(e,t,s,i){return e*=this.itemSize,this.normalized&&(t=Jt(t,this.array),s=Jt(s,this.array),i=Jt(i,this.array)),this.array[e+0]=ur(t),this.array[e+1]=ur(s),this.array[e+2]=ur(i),this}setXYZW(e,t,s,i,r){return e*=this.itemSize,this.normalized&&(t=Jt(t,this.array),s=Jt(s,this.array),i=Jt(i,this.array),r=Jt(r,this.array)),this.array[e+0]=ur(t),this.array[e+1]=ur(s),this.array[e+2]=ur(i),this.array[e+3]=ur(r),this}}class gt extends Sn{constructor(e,t,s){super(new Float32Array(e),t,s)}}let LW=0;const eo=new kt,Iv=new un,gd=new U,Mr=new Us,fm=new Us,Js=new U;class Xt extends Ca{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:LW++}),this.uuid=Qr(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(H3(e)?FE:DE)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,s=0){this.groups.push({start:e,count:t,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const r=new Ht().getNormalMatrix(e);s.applyNormalMatrix(r),s.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return eo.makeRotationFromQuaternion(e),this.applyMatrix4(eo),this}rotateX(e){return eo.makeRotationX(e),this.applyMatrix4(eo),this}rotateY(e){return eo.makeRotationY(e),this.applyMatrix4(eo),this}rotateZ(e){return eo.makeRotationZ(e),this.applyMatrix4(eo),this}translate(e,t,s){return eo.makeTranslation(e,t,s),this.applyMatrix4(eo),this}scale(e,t,s){return eo.makeScale(e,t,s),this.applyMatrix4(eo),this}lookAt(e){return Iv.lookAt(e),Iv.updateMatrix(),this.applyMatrix4(Iv.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(gd).negate(),this.translate(gd.x,gd.y,gd.z),this}setFromPoints(e){const t=this.getAttribute("position");if(t===void 0){const s=[];for(let i=0,r=e.length;i<r;i++){const o=e[i];s.push(o.x,o.y,o.z||0)}this.setAttribute("position",new gt(s,3))}else{const s=Math.min(e.length,t.count);for(let i=0;i<s;i++){const r=e[i];t.setXYZ(i,r.x,r.y,r.z||0)}e.length>t.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Us);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new U(-1/0,-1/0,-1/0),new U(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let s=0,i=t.length;s<i;s++){const r=t[s];Mr.setFromBufferAttribute(r),this.morphTargetsRelative?(Js.addVectors(this.boundingBox.min,Mr.min),this.boundingBox.expandByPoint(Js),Js.addVectors(this.boundingBox.max,Mr.max),this.boundingBox.expandByPoint(Js)):(this.boundingBox.expandByPoint(Mr.min),this.boundingBox.expandByPoint(Mr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new pi);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new U,1/0);return}if(e){const s=this.boundingSphere.center;if(Mr.setFromBufferAttribute(e),t)for(let r=0,o=t.length;r<o;r++){const a=t[r];fm.setFromBufferAttribute(a),this.morphTargetsRelative?(Js.addVectors(Mr.min,fm.min),Mr.expandByPoint(Js),Js.addVectors(Mr.max,fm.max),Mr.expandByPoint(Js)):(Mr.expandByPoint(fm.min),Mr.expandByPoint(fm.max))}Mr.getCenter(s);let i=0;for(let r=0,o=e.count;r<o;r++)Js.fromBufferAttribute(e,r),i=Math.max(i,s.distanceToSquared(Js));if(t)for(let r=0,o=t.length;r<o;r++){const a=t[r],l=this.morphTargetsRelative;for(let c=0,u=a.count;c<u;c++)Js.fromBufferAttribute(a,c),l&&(gd.fromBufferAttribute(e,c),Js.add(gd)),i=Math.max(i,s.distanceToSquared(Js))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=t.position,i=t.normal,r=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Sn(new Float32Array(4*s.count),4));const o=this.getAttribute("tangent"),a=[],l=[];for(let T=0;T<s.count;T++)a[T]=new U,l[T]=new U;const c=new U,u=new U,h=new U,d=new $e,p=new $e,f=new $e,g=new U,m=new U;function A(T,v,S){c.fromBufferAttribute(s,T),u.fromBufferAttribute(s,v),h.fromBufferAttribute(s,S),d.fromBufferAttribute(r,T),p.fromBufferAttribute(r,v),f.fromBufferAttribute(r,S),u.sub(c),h.sub(c),p.sub(d),f.sub(d);const _=1/(p.x*f.y-f.x*p.y);isFinite(_)&&(g.copy(u).multiplyScalar(f.y).addScaledVector(h,-p.y).multiplyScalar(_),m.copy(h).multiplyScalar(p.x).addScaledVector(u,-f.x).multiplyScalar(_),a[T].add(g),a[v].add(g),a[S].add(g),l[T].add(m),l[v].add(m),l[S].add(m))}let y=this.groups;y.length===0&&(y=[{start:0,count:e.count}]);for(let T=0,v=y.length;T<v;++T){const S=y[T],_=S.start,N=S.count;for(let D=_,P=_+N;D<P;D+=3)A(e.getX(D+0),e.getX(D+1),e.getX(D+2))}const b=new U,x=new U,C=new U,w=new U;function E(T){C.fromBufferAttribute(i,T),w.copy(C);const v=a[T];b.copy(v),b.sub(C.multiplyScalar(C.dot(v))).normalize(),x.crossVectors(w,v);const _=x.dot(l[T])<0?-1:1;o.setXYZW(T,b.x,b.y,b.z,_)}for(let T=0,v=y.length;T<v;++T){const S=y[T],_=S.start,N=S.count;for(let D=_,P=_+N;D<P;D+=3)E(e.getX(D+0)),E(e.getX(D+1)),E(e.getX(D+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Sn(new Float32Array(t.count*3),3),this.setAttribute("normal",s);else for(let d=0,p=s.count;d<p;d++)s.setXYZ(d,0,0,0);const i=new U,r=new U,o=new U,a=new U,l=new U,c=new U,u=new U,h=new U;if(e)for(let d=0,p=e.count;d<p;d+=3){const f=e.getX(d+0),g=e.getX(d+1),m=e.getX(d+2);i.fromBufferAttribute(t,f),r.fromBufferAttribute(t,g),o.fromBufferAttribute(t,m),u.subVectors(o,r),h.subVectors(i,r),u.cross(h),a.fromBufferAttribute(s,f),l.fromBufferAttribute(s,g),c.fromBufferAttribute(s,m),a.add(u),l.add(u),c.add(u),s.setXYZ(f,a.x,a.y,a.z),s.setXYZ(g,l.x,l.y,l.z),s.setXYZ(m,c.x,c.y,c.z)}else for(let d=0,p=t.count;d<p;d+=3)i.fromBufferAttribute(t,d+0),r.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),u.subVectors(o,r),h.subVectors(i,r),u.cross(h),s.setXYZ(d+0,u.x,u.y,u.z),s.setXYZ(d+1,u.x,u.y,u.z),s.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,s=e.count;t<s;t++)Js.fromBufferAttribute(e,t),Js.normalize(),e.setXYZ(t,Js.x,Js.y,Js.z)}toNonIndexed(){function e(a,l){const c=a.array,u=a.itemSize,h=a.normalized,d=new c.constructor(l.length*u);let p=0,f=0;for(let g=0,m=l.length;g<m;g++){a.isInterleavedBufferAttribute?p=l[g]*a.data.stride+a.offset:p=l[g]*u;for(let A=0;A<u;A++)d[f++]=c[p++]}return new Sn(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Xt,s=this.index.array,i=this.attributes;for(const a in i){const l=i[a],c=e(l,s);t.setAttribute(a,c)}const r=this.morphAttributes;for(const a in r){const l=[],c=r[a];for(let u=0,h=c.length;u<h;u++){const d=c[u],p=e(d,s);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const s=this.attributes;for(const l in s){const c=s[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const p=c[h];u.push(p.toJSON(e.data))}u.length>0&&(i[l]=u,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere=a.toJSON()),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone());const i=e.attributes;for(const c in i){const u=i[c];this.setAttribute(c,u.clone(t))}const r=e.morphAttributes;for(const c in r){const u=[],h=r[c];for(let d=0,p=h.length;d<p;d++)u.push(h[d].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,u=o.length;c<u;c++){const h=o[c];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Lk=new kt,Cc=new Sp,gx=new pi,Ok=new U,Ax=new U,yx=new U,xx=new U,Cv=new U,bx=new U,zk=new U,Ix=new U;class On extends un{constructor(e=new Xt,t=new wa){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}getVertexPosition(e,t){const s=this.geometry,i=s.attributes.position,r=s.morphAttributes.position,o=s.morphTargetsRelative;t.fromBufferAttribute(i,e);const a=this.morphTargetInfluences;if(r&&a){bx.set(0,0,0);for(let l=0,c=r.length;l<c;l++){const u=a[l],h=r[l];u!==0&&(Cv.fromBufferAttribute(h,e),o?bx.addScaledVector(Cv,u):bx.addScaledVector(Cv.sub(t),u))}t.add(bx)}return t}raycast(e,t){const s=this.geometry,i=this.material,r=this.matrixWorld;i!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),gx.copy(s.boundingSphere),gx.applyMatrix4(r),Cc.copy(e.ray).recast(e.near),!(gx.containsPoint(Cc.origin)===!1&&(Cc.intersectSphere(gx,Ok)===null||Cc.origin.distanceToSquared(Ok)>(e.far-e.near)**2))&&(Lk.copy(r).invert(),Cc.copy(e.ray).applyMatrix4(Lk),!(s.boundingBox!==null&&Cc.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(e,t,Cc)))}_computeIntersections(e,t,s){let i;const r=this.geometry,o=this.material,a=r.index,l=r.attributes.position,c=r.attributes.uv,u=r.attributes.uv1,h=r.attributes.normal,d=r.groups,p=r.drawRange;if(a!==null)if(Array.isArray(o))for(let f=0,g=d.length;f<g;f++){const m=d[f],A=o[m.materialIndex],y=Math.max(m.start,p.start),b=Math.min(a.count,Math.min(m.start+m.count,p.start+p.count));for(let x=y,C=b;x<C;x+=3){const w=a.getX(x),E=a.getX(x+1),T=a.getX(x+2);i=Cx(this,A,e,s,c,u,h,w,E,T),i&&(i.faceIndex=Math.floor(x/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{const f=Math.max(0,p.start),g=Math.min(a.count,p.start+p.count);for(let m=f,A=g;m<A;m+=3){const y=a.getX(m),b=a.getX(m+1),x=a.getX(m+2);i=Cx(this,o,e,s,c,u,h,y,b,x),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}else if(l!==void 0)if(Array.isArray(o))for(let f=0,g=d.length;f<g;f++){const m=d[f],A=o[m.materialIndex],y=Math.max(m.start,p.start),b=Math.min(l.count,Math.min(m.start+m.count,p.start+p.count));for(let x=y,C=b;x<C;x+=3){const w=x,E=x+1,T=x+2;i=Cx(this,A,e,s,c,u,h,w,E,T),i&&(i.faceIndex=Math.floor(x/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{const f=Math.max(0,p.start),g=Math.min(l.count,p.start+p.count);for(let m=f,A=g;m<A;m+=3){const y=m,b=m+1,x=m+2;i=Cx(this,o,e,s,c,u,h,y,b,x),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}}}function OW(n,e,t,s,i,r,o,a){let l;if(e.side===ji?l=s.intersectTriangle(o,r,i,!0,a):l=s.intersectTriangle(i,r,o,e.side===Za,a),l===null)return null;Ix.copy(a),Ix.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(Ix);return c<t.near||c>t.far?null:{distance:c,point:Ix.clone(),object:n}}function Cx(n,e,t,s,i,r,o,a,l,c){n.getVertexPosition(a,Ax),n.getVertexPosition(l,yx),n.getVertexPosition(c,xx);const u=OW(n,e,t,s,Ax,yx,xx,zk);if(u){const h=new U;fr.getBarycoord(zk,Ax,yx,xx,h),i&&(u.uv=fr.getInterpolatedAttribute(i,a,l,c,h,new $e)),r&&(u.uv1=fr.getInterpolatedAttribute(r,a,l,c,h,new $e)),o&&(u.normal=fr.getInterpolatedAttribute(o,a,l,c,h,new U),u.normal.dot(s.direction)>0&&u.normal.multiplyScalar(-1));const d={a,b:l,c,normal:new U,materialIndex:0};fr.getNormal(Ax,yx,xx,d.normal),u.face=d,u.barycoord=h}return u}class rc extends Xt{constructor(e=1,t=1,s=1,i=1,r=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:s,widthSegments:i,heightSegments:r,depthSegments:o};const a=this;i=Math.floor(i),r=Math.floor(r),o=Math.floor(o);const l=[],c=[],u=[],h=[];let d=0,p=0;f("z","y","x",-1,-1,s,t,e,o,r,0),f("z","y","x",1,-1,s,t,-e,o,r,1),f("x","z","y",1,1,e,s,t,i,o,2),f("x","z","y",1,-1,e,s,-t,i,o,3),f("x","y","z",1,-1,e,t,s,i,r,4),f("x","y","z",-1,-1,e,t,-s,i,r,5),this.setIndex(l),this.setAttribute("position",new gt(c,3)),this.setAttribute("normal",new gt(u,3)),this.setAttribute("uv",new gt(h,2));function f(g,m,A,y,b,x,C,w,E,T,v){const S=x/E,_=C/T,N=x/2,D=C/2,P=w/2,L=E+1,z=T+1;let q=0,V=0;const X=new U;for(let te=0;te<z;te++){const se=te*_-D;for(let fe=0;fe<L;fe++){const me=fe*S-N;X[g]=me*y,X[m]=se*b,X[A]=P,c.push(X.x,X.y,X.z),X[g]=0,X[m]=0,X[A]=w>0?1:-1,u.push(X.x,X.y,X.z),h.push(fe/E),h.push(1-te/T),q+=1}}for(let te=0;te<T;te++)for(let se=0;se<E;se++){const fe=d+se+L*te,me=d+se+L*(te+1),Te=d+(se+1)+L*(te+1),Ee=d+(se+1)+L*te;l.push(fe,me,Ee),l.push(me,Te,Ee),V+=6}a.addGroup(p,V,v),p+=V,d+=q}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new rc(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function np(n){const e={};for(const t in n){e[t]={};for(const s in n[t]){const i=n[t][s];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][s]=null):e[t][s]=i.clone():Array.isArray(i)?e[t][s]=i.slice():e[t][s]=i}}return e}function Wi(n){const e={};for(let t=0;t<n.length;t++){const s=np(n[t]);for(const i in s)e[i]=s[i]}return e}function zW(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function j3(n){const e=n.getRenderTarget();return e===null?n.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:gn.workingColorSpace}const K3={clone:np,merge:Wi};var UW=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,QW=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Hr extends Li{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=UW,this.fragmentShader=QW,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=np(e.uniforms),this.uniformsGroups=zW(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?t.uniforms[i]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[i]={type:"m4",value:o.toArray()}:t.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const s={};for(const i in this.extensions)this.extensions[i]===!0&&(s[i]=!0);return Object.keys(s).length>0&&(t.extensions=s),t}}class CI extends un{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new kt,this.projectionMatrix=new kt,this.projectionMatrixInverse=new kt,this.coordinateSystem=Lr,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Sl=new U,Uk=new $e,Qk=new $e;class Es extends CI{constructor(e=50,t=1,s=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=tp*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(uu*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return tp*2*Math.atan(Math.tan(uu*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,s){Sl.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(Sl.x,Sl.y).multiplyScalar(-e/Sl.z),Sl.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),s.set(Sl.x,Sl.y).multiplyScalar(-e/Sl.z)}getViewSize(e,t){return this.getViewBounds(e,Uk,Qk),t.subVectors(Qk,Uk)}setViewOffset(e,t,s,i,r,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(uu*.5*this.fov)/this.zoom,s=2*t,i=this.aspect*s,r=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;r+=o.offsetX*i/l,t-=o.offsetY*s/c,i*=o.width/l,s*=o.height/c}const a=this.filmOffset;a!==0&&(r+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-s,e,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Ad=-90,yd=1;class $E extends un{constructor(e,t,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Es(Ad,yd,e,t);i.layers=this.layers,this.add(i);const r=new Es(Ad,yd,e,t);r.layers=this.layers,this.add(r);const o=new Es(Ad,yd,e,t);o.layers=this.layers,this.add(o);const a=new Es(Ad,yd,e,t);a.layers=this.layers,this.add(a);const l=new Es(Ad,yd,e,t);l.layers=this.layers,this.add(l);const c=new Es(Ad,yd,e,t);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[s,i,r,o,a,l]=t;for(const c of t)this.remove(c);if(e===Lr)s.up.set(0,1,0),s.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===ep)s.up.set(0,-1,0),s.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of t)this.add(c),c.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[r,o,a,l,c,u]=this.children,h=e.getRenderTarget(),d=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),f=e.xr.enabled;e.xr.enabled=!1;const g=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0,i),e.render(t,r),e.setRenderTarget(s,1,i),e.render(t,o),e.setRenderTarget(s,2,i),e.render(t,a),e.setRenderTarget(s,3,i),e.render(t,l),e.setRenderTarget(s,4,i),e.render(t,c),s.texture.generateMipmaps=g,e.setRenderTarget(s,5,i),e.render(t,u),e.setRenderTarget(h,d,p),e.xr.enabled=f,s.texture.needsPMREMUpdate=!0}}class eA extends cs{constructor(e=[],t=el,s,i,r,o,a,l,c,u){super(e,t,s,i,r,o,a,l,c,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class PE extends ao{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},i=[s,s,s,s,s,s];this.texture=new eA(i),this._setTextureOptions(t),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new rc(5,5,5),r=new Hr({name:"CubemapFromEquirect",uniforms:np(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:ji,blending:qa});r.uniforms.tEquirect.value=t;const o=new On(i,r),a=t.minFilter;return t.minFilter===la&&(t.minFilter=Os),new $E(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t=!0,s=!0,i=!0){const r=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,s,i);e.setRenderTarget(r)}}class Jc extends un{constructor(){super(),this.isGroup=!0,this.type="Group"}}const VW={type:"move"};class x0{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Jc,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Jc,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new U,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new U),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Jc,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new U,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new U),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const s of e.hand.values())this._getHandJoint(t,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,s){let i=null,r=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){o=!0;for(const g of e.hand.values()){const m=t.getJointPose(g,s),A=this._getHandJoint(c,g);m!==null&&(A.matrix.fromArray(m.transform.matrix),A.matrix.decompose(A.position,A.rotation,A.scale),A.matrixWorldNeedsUpdate=!0,A.jointRadius=m.radius),A.visible=m!==null}const u=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],d=u.position.distanceTo(h.position),p=.02,f=.005;c.inputState.pinching&&d>p+f?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=p-f&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,s),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(i=t.getPose(e.targetRaySpace,s),i===null&&r!==null&&(i=r),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(VW)))}return a!==null&&(a.visible=i!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const s=new Jc;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[t.jointName]=s,e.add(s)}return e.joints[t.jointName]}}class wI{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new ot(e),this.density=t}clone(){return new wI(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class vI{constructor(e,t=1,s=1e3){this.isFog=!0,this.name="",this.color=new ot(e),this.near=t,this.far=s}clone(){return new vI(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class LE extends un{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Wr,this.environmentIntensity=1,this.environmentRotation=new Wr,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}class SI{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=dg,this.updateRanges=[],this.version=0,this.uuid=Qr()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,s){e*=this.stride,s*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[s+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Qr()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(t,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Qr()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Vi=new U;class xu{constructor(e,t,s,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=s,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,s=this.data.count;t<s;t++)Vi.fromBufferAttribute(this,t),Vi.applyMatrix4(e),this.setXYZ(t,Vi.x,Vi.y,Vi.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)Vi.fromBufferAttribute(this,t),Vi.applyNormalMatrix(e),this.setXYZ(t,Vi.x,Vi.y,Vi.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)Vi.fromBufferAttribute(this,t),Vi.transformDirection(e),this.setXYZ(t,Vi.x,Vi.y,Vi.z);return this}getComponent(e,t){let s=this.array[e*this.data.stride+this.offset+t];return this.normalized&&(s=Yi(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Jt(s,this.array)),this.data.array[e*this.data.stride+this.offset+t]=s,this}setX(e,t){return this.normalized&&(t=Jt(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Jt(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Jt(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Jt(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Yi(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Yi(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Yi(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Yi(t,this.array)),t}setXY(e,t,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Jt(t,this.array),s=Jt(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this}setXYZ(e,t,s,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Jt(t,this.array),s=Jt(s,this.array),i=Jt(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this}setXYZW(e,t,s,i,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Jt(t,this.array),s=Jt(s,this.array),i=Jt(i,this.array),r=Jt(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new Sn(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new xu(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class OE extends Li{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new ot(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let xd;const mm=new U,bd=new U,Id=new U,Cd=new $e,gm=new $e,J3=new kt,wx=new U,Am=new U,vx=new U,Vk=new $e,wv=new $e,Gk=new $e;class Z3 extends un{constructor(e=new OE){if(super(),this.isSprite=!0,this.type="Sprite",xd===void 0){xd=new Xt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),s=new SI(t,5);xd.setIndex([0,1,2,0,2,3]),xd.setAttribute("position",new xu(s,3,0,!1)),xd.setAttribute("uv",new xu(s,2,3,!1))}this.geometry=xd,this.material=e,this.center=new $e(.5,.5),this.count=1}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),bd.setFromMatrixScale(this.matrixWorld),J3.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Id.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&bd.multiplyScalar(-Id.z);const s=this.material.rotation;let i,r;s!==0&&(r=Math.cos(s),i=Math.sin(s));const o=this.center;Sx(wx.set(-.5,-.5,0),Id,o,bd,i,r),Sx(Am.set(.5,-.5,0),Id,o,bd,i,r),Sx(vx.set(.5,.5,0),Id,o,bd,i,r),Vk.set(0,0),wv.set(1,0),Gk.set(1,1);let a=e.ray.intersectTriangle(wx,Am,vx,!1,mm);if(a===null&&(Sx(Am.set(-.5,.5,0),Id,o,bd,i,r),wv.set(0,1),a=e.ray.intersectTriangle(wx,vx,Am,!1,mm),a===null))return;const l=e.ray.origin.distanceTo(mm);l<e.near||l>e.far||t.push({distance:l,point:mm.clone(),uv:fr.getInterpolation(mm,wx,Am,vx,Vk,wv,Gk,new $e),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function Sx(n,e,t,s,i,r){Cd.subVectors(n,t).addScalar(.5).multiply(s),i!==void 0?(gm.x=r*Cd.x-i*Cd.y,gm.y=i*Cd.x+r*Cd.y):gm.copy(Cd),n.copy(e),n.x+=gm.x,n.y+=gm.y,n.applyMatrix4(J3)}const Ex=new U,Wk=new U;class eF extends un{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let s=0,i=t.length;s<i;s++){const r=t[s];this.addLevel(r.object.clone(),r.distance,r.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,s=0){t=Math.abs(t);const i=this.levels;let r;for(r=0;r<i.length&&!(t<i[r].distance);r++);return i.splice(r,0,{distance:t,hysteresis:s,object:e}),this.add(e),this}removeLevel(e){const t=this.levels;for(let s=0;s<t.length;s++)if(t[s].distance===e){const i=t.splice(s,1);return this.remove(i[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let s,i;for(s=1,i=t.length;s<i;s++){let r=t[s].distance;if(t[s].object.visible&&(r-=r*t[s].hysteresis),e<r)break}return t[s-1].object}return null}raycast(e,t){if(this.levels.length>0){Ex.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(Ex);this.getObjectForDistance(i).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){Ex.setFromMatrixPosition(e.matrixWorld),Wk.setFromMatrixPosition(this.matrixWorld);const s=Ex.distanceTo(Wk)/e.zoom;t[0].object.visible=!0;let i,r;for(i=1,r=t.length;i<r;i++){let o=t[i].distance;if(t[i].object.visible&&(o-=o*t[i].hysteresis),s>=o)t[i-1].object.visible=!1,t[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<r;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const s=this.levels;for(let i=0,r=s.length;i<r;i++){const o=s[i];t.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return t}}const Hk=new U,qk=new Yt,Yk=new Yt,GW=new U,Xk=new kt,_x=new U,vv=new pi,jk=new kt,Sv=new Sp;class tF extends On{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=VS,this.bindMatrix=new kt,this.bindMatrixInverse=new kt,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new Us),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,_x),this.boundingBox.expandByPoint(_x)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new pi),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,_x),this.boundingSphere.expandByPoint(_x)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const s=this.material,i=this.matrixWorld;s!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),vv.copy(this.boundingSphere),vv.applyMatrix4(i),e.ray.intersectsSphere(vv)!==!1&&(jk.copy(i).invert(),Sv.copy(e.ray).applyMatrix4(jk),!(this.boundingBox!==null&&Sv.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,Sv)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Yt,t=this.geometry.attributes.skinWeight;for(let s=0,i=t.count;s<i;s++){e.fromBufferAttribute(t,s);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(s,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===VS?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===k3?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const s=this.skeleton,i=this.geometry;qk.fromBufferAttribute(i.attributes.skinIndex,e),Yk.fromBufferAttribute(i.attributes.skinWeight,e),Hk.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const o=Yk.getComponent(r);if(o!==0){const a=qk.getComponent(r);Xk.multiplyMatrices(s.bones[a].matrixWorld,s.boneInverses[a]),t.addScaledVector(GW.copy(Hk).applyMatrix4(Xk),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}class zE extends un{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Mo extends cs{constructor(e=null,t=1,s=1,i,r,o,a,l,c=bs,u=bs,h,d){super(null,o,a,l,c,u,i,r,h,d),this.isDataTexture=!0,this.image={data:e,width:t,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const Kk=new kt,WW=new kt;class EI{constructor(e=[],t=[]){this.uuid=Qr(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,i=this.bones.length;s<i;s++)this.boneInverses.push(new kt)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const s=new kt;this.bones[e]&&s.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&s.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const e=this.bones,t=this.boneInverses,s=this.boneMatrices,i=this.boneTexture;for(let r=0,o=e.length;r<o;r++){const a=e[r]?e[r].matrixWorld:WW;Kk.multiplyMatrices(a,t[r]),Kk.toArray(s,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new EI(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const s=new Mo(t,e,e,ys,gr);return s.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=s,this}getBoneByName(e){for(let t=0,s=this.bones.length;t<s;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let s=0,i=e.bones.length;s<i;s++){const r=e.bones[s];let o=t[r];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),o=new zE),this.bones.push(o),this.boneInverses.push(new kt().fromArray(e.boneInverses[s]))}return this.init(),this}toJSON(){const e={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,s=this.boneInverses;for(let i=0,r=t.length;i<r;i++){const o=t[i];e.bones.push(o.uuid);const a=s[i];e.boneInverses.push(a.toArray())}return e}}class bu extends Sn{constructor(e,t,s,i=1){super(e,t,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const wd=new kt,Jk=new kt,Tx=[],Zk=new Us,HW=new kt,ym=new On,xm=new pi;class nF extends On{constructor(e,t,s){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new bu(new Float32Array(s*16),16),this.instanceColor=null,this.morphTexture=null,this.count=s,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<s;i++)this.setMatrixAt(i,HW)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new Us),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,wd),Zk.copy(e.boundingBox).applyMatrix4(wd),this.boundingBox.union(Zk)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new pi),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,wd),xm.copy(e.boundingSphere).applyMatrix4(wd),this.boundingSphere.union(xm)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,t){const s=t.morphTargetInfluences,i=this.morphTexture.source.data.data,r=s.length+1,o=e*r+1;for(let a=0;a<s.length;a++)s[a]=i[o+a]}raycast(e,t){const s=this.matrixWorld,i=this.count;if(ym.geometry=this.geometry,ym.material=this.material,ym.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),xm.copy(this.boundingSphere),xm.applyMatrix4(s),e.ray.intersectsSphere(xm)!==!1))for(let r=0;r<i;r++){this.getMatrixAt(r,wd),Jk.multiplyMatrices(s,wd),ym.matrixWorld=Jk,ym.raycast(e,Tx);for(let o=0,a=Tx.length;o<a;o++){const l=Tx[o];l.instanceId=r,l.object=this,t.push(l)}Tx.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new bu(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,t){const s=t.morphTargetInfluences,i=s.length+1;this.morphTexture===null&&(this.morphTexture=new Mo(new Float32Array(i*this.count),i,this.count,xI,gr));const r=this.morphTexture.source.data.data;let o=0;for(let c=0;c<s.length;c++)o+=s[c];const a=this.geometry.morphTargetsRelative?1:1-o,l=i*e;r[l]=a,r.set(s,l+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null)}}const Ev=new U,qW=new U,YW=new Ht;class kl{constructor(e=new U(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,s,i){return this.normal.set(e,t,s),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,s){const i=Ev.subVectors(s,t).cross(qW.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const s=e.delta(Ev),i=this.normal.dot(s);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(e.start).addScaledVector(s,r)}intersectsLine(e){const t=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return t<0&&s>0||s<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const s=t||YW.getNormalMatrix(e),i=this.coplanarPoint(Ev).applyMatrix4(e),r=this.normal.applyMatrix3(s).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const wc=new pi,XW=new $e(.5,.5),Bx=new U;class Ep{constructor(e=new kl,t=new kl,s=new kl,i=new kl,r=new kl,o=new kl){this.planes=[e,t,s,i,r,o]}set(e,t,s,i,r,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(s),a[3].copy(i),a[4].copy(r),a[5].copy(o),this}copy(e){const t=this.planes;for(let s=0;s<6;s++)t[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e,t=Lr,s=!1){const i=this.planes,r=e.elements,o=r[0],a=r[1],l=r[2],c=r[3],u=r[4],h=r[5],d=r[6],p=r[7],f=r[8],g=r[9],m=r[10],A=r[11],y=r[12],b=r[13],x=r[14],C=r[15];if(i[0].setComponents(c-o,p-u,A-f,C-y).normalize(),i[1].setComponents(c+o,p+u,A+f,C+y).normalize(),i[2].setComponents(c+a,p+h,A+g,C+b).normalize(),i[3].setComponents(c-a,p-h,A-g,C-b).normalize(),s)i[4].setComponents(l,d,m,x).normalize(),i[5].setComponents(c-l,p-d,A-m,C-x).normalize();else if(i[4].setComponents(c-l,p-d,A-m,C-x).normalize(),t===Lr)i[5].setComponents(c+l,p+d,A+m,C+x).normalize();else if(t===ep)i[5].setComponents(l,d,m,x).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),wc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),wc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(wc)}intersectsSprite(e){wc.center.set(0,0,0);const t=XW.distanceTo(e.center);return wc.radius=.7071067811865476+t,wc.applyMatrix4(e.matrixWorld),this.intersectsSphere(wc)}intersectsSphere(e){const t=this.planes,s=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(s)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let s=0;s<6;s++){const i=t[s];if(Bx.x=i.normal.x>0?e.max.x:e.min.x,Bx.y=i.normal.y>0?e.max.y:e.min.y,Bx.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Bx)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let s=0;s<6;s++)if(t[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}const Jo=new kt,Zo=new Ep;class _I{constructor(){this.coordinateSystem=Lr}intersectsObject(e,t){if(!t.isArrayCamera||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if(Jo.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zo.setFromProjectionMatrix(Jo,i.coordinateSystem,i.reversedDepth),Zo.intersectsObject(e))return!0}return!1}intersectsSprite(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if(Jo.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zo.setFromProjectionMatrix(Jo,i.coordinateSystem,i.reversedDepth),Zo.intersectsSprite(e))return!0}return!1}intersectsSphere(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if(Jo.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zo.setFromProjectionMatrix(Jo,i.coordinateSystem,i.reversedDepth),Zo.intersectsSphere(e))return!0}return!1}intersectsBox(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if(Jo.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zo.setFromProjectionMatrix(Jo,i.coordinateSystem,i.reversedDepth),Zo.intersectsBox(e))return!0}return!1}containsPoint(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if(Jo.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zo.setFromProjectionMatrix(Jo,i.coordinateSystem,i.reversedDepth),Zo.containsPoint(e))return!0}return!1}clone(){return new _I}}function _v(n,e){return n-e}function jW(n,e){return n.z-e.z}function KW(n,e){return e.z-n.z}class JW{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,t,s,i){const r=this.pool,o=this.list;this.index>=r.length&&r.push({start:-1,count:-1,z:-1,index:-1});const a=r[this.index];o.push(a),this.index++,a.start=e,a.count=t,a.z=s,a.index=i}reset(){this.list.length=0,this.index=0}}const lr=new kt,ZW=new ot(1,1,1),eM=new Ep,eH=new _I,kx=new Us,vc=new pi,bm=new U,tM=new U,tH=new U,Tv=new JW,Ci=new On,Mx=[];function nH(n,e,t=0){const s=e.itemSize;if(n.isInterleavedBufferAttribute||n.array.constructor!==e.array.constructor){const i=n.count;for(let r=0;r<i;r++)for(let o=0;o<s;o++)e.setComponent(r+t,o,n.getComponent(r,o))}else e.array.set(n.array,t*s);e.needsUpdate=!0}function Sc(n,e){if(n.constructor!==e.constructor){const t=Math.min(n.length,e.length);for(let s=0;s<t;s++)e[s]=n[s]}else{const t=Math.min(n.length,e.length);e.set(new n.constructor(n.buffer,0,t))}}class sF extends On{constructor(e,t,s=t*2,i){super(new Xt,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=e,this._maxVertexCount=t,this._maxIndexCount=s,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let e=Math.sqrt(this._maxInstanceCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4),s=new Mo(t,e,e,ys,gr);this._matricesTexture=s}_initIndirectTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Uint32Array(e*e),s=new Mo(t,e,e,Kg,Ri);this._indirectTexture=s}_initColorsTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Float32Array(e*e*4).fill(1),s=new Mo(t,e,e,ys,gr);s.colorSpace=gn.workingColorSpace,this._colorsTexture=s}_initializeGeometry(e){const t=this.geometry,s=this._maxVertexCount,i=this._maxIndexCount;if(this._geometryInitialized===!1){for(const r in e.attributes){const o=e.getAttribute(r),{array:a,itemSize:l,normalized:c}=o,u=new a.constructor(s*l),h=new Sn(u,l,c);t.setAttribute(r,h)}if(e.getIndex()!==null){const r=s>65535?new Uint32Array(i):new Uint16Array(i);t.setIndex(new Sn(r,1))}this._geometryInitialized=!0}}_validateGeometry(e){const t=this.geometry;if(!!e.getIndex()!=!!t.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const s in t.attributes){if(!e.hasAttribute(s))throw new Error(`THREE.BatchedMesh: Added geometry missing "${s}". All geometries must have consistent attributes.`);const i=e.getAttribute(s),r=t.getAttribute(s);if(i.itemSize!==r.itemSize||i.normalized!==r.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(e){const t=this._instanceInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)}validateGeometryId(e){const t=this._geometryInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Us);const e=this.boundingBox,t=this._instanceInfo;e.makeEmpty();for(let s=0,i=t.length;s<i;s++){if(t[s].active===!1)continue;const r=t[s].geometryIndex;this.getMatrixAt(s,lr),this.getBoundingBoxAt(r,kx).applyMatrix4(lr),e.union(kx)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new pi);const e=this.boundingSphere,t=this._instanceInfo;e.makeEmpty();for(let s=0,i=t.length;s<i;s++){if(t[s].active===!1)continue;const r=t[s].geometryIndex;this.getMatrixAt(s,lr),this.getBoundingSphereAt(r,vc).applyMatrix4(lr),e.union(vc)}}addInstance(e){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const s={visible:!0,active:!0,geometryIndex:e};let i=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(_v),i=this._availableInstanceIds.shift(),this._instanceInfo[i]=s):(i=this._instanceInfo.length,this._instanceInfo.push(s));const r=this._matricesTexture;lr.identity().toArray(r.image.data,i*16),r.needsUpdate=!0;const o=this._colorsTexture;return o&&(ZW.toArray(o.image.data,i*4),o.needsUpdate=!0),this._visibilityChanged=!0,i}addGeometry(e,t=-1,s=-1){this._initializeGeometry(e),this._validateGeometry(e);const i={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},r=this._geometryInfo;i.vertexStart=this._nextVertexStart,i.reservedVertexCount=t===-1?e.getAttribute("position").count:t;const o=e.getIndex();if(o!==null&&(i.indexStart=this._nextIndexStart,i.reservedIndexCount=s===-1?o.count:s),i.indexStart!==-1&&i.indexStart+i.reservedIndexCount>this._maxIndexCount||i.vertexStart+i.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let l;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(_v),l=this._availableGeometryIds.shift(),r[l]=i):(l=this._geometryCount,this._geometryCount++,r.push(i)),this.setGeometryAt(l,e),this._nextIndexStart=i.indexStart+i.reservedIndexCount,this._nextVertexStart=i.vertexStart+i.reservedVertexCount,l}setGeometryAt(e,t){if(e>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(t);const s=this.geometry,i=s.getIndex()!==null,r=s.getIndex(),o=t.getIndex(),a=this._geometryInfo[e];if(i&&o.count>a.reservedIndexCount||t.attributes.position.count>a.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const l=a.vertexStart,c=a.reservedVertexCount;a.vertexCount=t.getAttribute("position").count;for(const u in s.attributes){const h=t.getAttribute(u),d=s.getAttribute(u);nH(h,d,l);const p=h.itemSize;for(let f=h.count,g=c;f<g;f++){const m=l+f;for(let A=0;A<p;A++)d.setComponent(m,A,0)}d.needsUpdate=!0,d.addUpdateRange(l*p,c*p)}if(i){const u=a.indexStart,h=a.reservedIndexCount;a.indexCount=t.getIndex().count;for(let d=0;d<o.count;d++)r.setX(u+d,l+o.getX(d));for(let d=o.count,p=h;d<p;d++)r.setX(u+d,l);r.needsUpdate=!0,r.addUpdateRange(u,a.reservedIndexCount)}return a.start=i?a.indexStart:a.vertexStart,a.count=i?a.indexCount:a.vertexCount,a.boundingBox=null,t.boundingBox!==null&&(a.boundingBox=t.boundingBox.clone()),a.boundingSphere=null,t.boundingSphere!==null&&(a.boundingSphere=t.boundingSphere.clone()),this._visibilityChanged=!0,e}deleteGeometry(e){const t=this._geometryInfo;if(e>=t.length||t[e].active===!1)return this;const s=this._instanceInfo;for(let i=0,r=s.length;i<r;i++)s[i].active&&s[i].geometryIndex===e&&this.deleteInstance(i);return t[e].active=!1,this._availableGeometryIds.push(e),this._visibilityChanged=!0,this}deleteInstance(e){return this.validateInstanceId(e),this._instanceInfo[e].active=!1,this._availableInstanceIds.push(e),this._visibilityChanged=!0,this}optimize(){let e=0,t=0;const s=this._geometryInfo,i=s.map((o,a)=>a).sort((o,a)=>s[o].vertexStart-s[a].vertexStart),r=this.geometry;for(let o=0,a=s.length;o<a;o++){const l=i[o],c=s[l];if(c.active!==!1){if(r.index!==null){if(c.indexStart!==t){const{indexStart:u,vertexStart:h,reservedIndexCount:d}=c,p=r.index,f=p.array,g=e-h;for(let m=u;m<u+d;m++)f[m]=f[m]+g;p.array.copyWithin(t,u,u+d),p.addUpdateRange(t,d),c.indexStart=t}t+=c.reservedIndexCount}if(c.vertexStart!==e){const{vertexStart:u,reservedVertexCount:h}=c,d=r.attributes;for(const p in d){const f=d[p],{array:g,itemSize:m}=f;g.copyWithin(e*m,u*m,(u+h)*m),f.addUpdateRange(e*m,h*m)}c.vertexStart=e}e+=c.reservedVertexCount,c.start=r.index?c.indexStart:c.vertexStart,this._nextIndexStart=r.index?c.indexStart+c.reservedIndexCount:0,this._nextVertexStart=c.vertexStart+c.reservedVertexCount}}return this}getBoundingBoxAt(e,t){if(e>=this._geometryCount)return null;const s=this.geometry,i=this._geometryInfo[e];if(i.boundingBox===null){const r=new Us,o=s.index,a=s.attributes.position;for(let l=i.start,c=i.start+i.count;l<c;l++){let u=l;o&&(u=o.getX(u)),r.expandByPoint(bm.fromBufferAttribute(a,u))}i.boundingBox=r}return t.copy(i.boundingBox),t}getBoundingSphereAt(e,t){if(e>=this._geometryCount)return null;const s=this.geometry,i=this._geometryInfo[e];if(i.boundingSphere===null){const r=new pi;this.getBoundingBoxAt(e,kx),kx.getCenter(r.center);const o=s.index,a=s.attributes.position;let l=0;for(let c=i.start,u=i.start+i.count;c<u;c++){let h=c;o&&(h=o.getX(h)),bm.fromBufferAttribute(a,h),l=Math.max(l,r.center.distanceToSquared(bm))}r.radius=Math.sqrt(l),i.boundingSphere=r}return t.copy(i.boundingSphere),t}setMatrixAt(e,t){this.validateInstanceId(e);const s=this._matricesTexture,i=this._matricesTexture.image.data;return t.toArray(i,e*16),s.needsUpdate=!0,this}getMatrixAt(e,t){return this.validateInstanceId(e),t.fromArray(this._matricesTexture.image.data,e*16)}setColorAt(e,t){return this.validateInstanceId(e),this._colorsTexture===null&&this._initColorsTexture(),t.toArray(this._colorsTexture.image.data,e*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(e,t){return this.validateInstanceId(e),t.fromArray(this._colorsTexture.image.data,e*4)}setVisibleAt(e,t){return this.validateInstanceId(e),this._instanceInfo[e].visible===t?this:(this._instanceInfo[e].visible=t,this._visibilityChanged=!0,this)}getVisibleAt(e){return this.validateInstanceId(e),this._instanceInfo[e].visible}setGeometryIdAt(e,t){return this.validateInstanceId(e),this.validateGeometryId(t),this._instanceInfo[e].geometryIndex=t,this}getGeometryIdAt(e){return this.validateInstanceId(e),this._instanceInfo[e].geometryIndex}getGeometryRangeAt(e,t={}){this.validateGeometryId(e);const s=this._geometryInfo[e];return t.vertexStart=s.vertexStart,t.vertexCount=s.vertexCount,t.reservedVertexCount=s.reservedVertexCount,t.indexStart=s.indexStart,t.indexCount=s.indexCount,t.reservedIndexCount=s.reservedIndexCount,t.start=s.start,t.count=s.count,t}setInstanceCount(e){const t=this._availableInstanceIds,s=this._instanceInfo;for(t.sort(_v);t[t.length-1]===s.length-1;)s.pop(),t.pop();if(e<s.length)throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);const i=new Int32Array(e),r=new Int32Array(e);Sc(this._multiDrawCounts,i),Sc(this._multiDrawStarts,r),this._multiDrawCounts=i,this._multiDrawStarts=r,this._maxInstanceCount=e;const o=this._indirectTexture,a=this._matricesTexture,l=this._colorsTexture;o.dispose(),this._initIndirectTexture(),Sc(o.image.data,this._indirectTexture.image.data),a.dispose(),this._initMatricesTexture(),Sc(a.image.data,this._matricesTexture.image.data),l&&(l.dispose(),this._initColorsTexture(),Sc(l.image.data,this._colorsTexture.image.data))}setGeometrySize(e,t){const s=[...this._geometryInfo].filter(a=>a.active);if(Math.max(...s.map(a=>a.vertexStart+a.reservedVertexCount))>e)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...s.map(l=>l.indexStart+l.reservedIndexCount))>t)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);const r=this.geometry;r.dispose(),this._maxVertexCount=e,this._maxIndexCount=t,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new Xt,this._initializeGeometry(r));const o=this.geometry;r.index&&Sc(r.index.array,o.index.array);for(const a in r.attributes)Sc(r.attributes[a].array,o.attributes[a].array)}raycast(e,t){const s=this._instanceInfo,i=this._geometryInfo,r=this.matrixWorld,o=this.geometry;Ci.material=this.material,Ci.geometry.index=o.index,Ci.geometry.attributes=o.attributes,Ci.geometry.boundingBox===null&&(Ci.geometry.boundingBox=new Us),Ci.geometry.boundingSphere===null&&(Ci.geometry.boundingSphere=new pi);for(let a=0,l=s.length;a<l;a++){if(!s[a].visible||!s[a].active)continue;const c=s[a].geometryIndex,u=i[c];Ci.geometry.setDrawRange(u.start,u.count),this.getMatrixAt(a,Ci.matrixWorld).premultiply(r),this.getBoundingBoxAt(c,Ci.geometry.boundingBox),this.getBoundingSphereAt(c,Ci.geometry.boundingSphere),Ci.raycast(e,Mx);for(let h=0,d=Mx.length;h<d;h++){const p=Mx[h];p.object=this,p.batchId=a,t.push(p)}Mx.length=0}Ci.material=null,Ci.geometry.index=null,Ci.geometry.attributes={},Ci.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._geometryInfo=e._geometryInfo.map(t=>({...t,boundingBox:t.boundingBox!==null?t.boundingBox.clone():null,boundingSphere:t.boundingSphere!==null?t.boundingSphere.clone():null})),this._instanceInfo=e._instanceInfo.map(t=>({...t})),this._availableInstanceIds=e._availableInstanceIds.slice(),this._availableGeometryIds=e._availableGeometryIds.slice(),this._nextIndexStart=e._nextIndexStart,this._nextVertexStart=e._nextVertexStart,this._geometryCount=e._geometryCount,this._maxInstanceCount=e._maxInstanceCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._indirectTexture=e._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=e._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(e,t,s,i,r){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const o=i.getIndex(),a=o===null?1:o.array.BYTES_PER_ELEMENT,l=this._instanceInfo,c=this._multiDrawStarts,u=this._multiDrawCounts,h=this._geometryInfo,d=this.perObjectFrustumCulled,p=this._indirectTexture,f=p.image.data,g=s.isArrayCamera?eH:eM;d&&!s.isArrayCamera&&(lr.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse).multiply(this.matrixWorld),eM.setFromProjectionMatrix(lr,s.coordinateSystem,s.reversedDepth));let m=0;if(this.sortObjects){lr.copy(this.matrixWorld).invert(),bm.setFromMatrixPosition(s.matrixWorld).applyMatrix4(lr),tM.set(0,0,-1).transformDirection(s.matrixWorld).transformDirection(lr);for(let b=0,x=l.length;b<x;b++)if(l[b].visible&&l[b].active){const C=l[b].geometryIndex;this.getMatrixAt(b,lr),this.getBoundingSphereAt(C,vc).applyMatrix4(lr);let w=!1;if(d&&(w=!g.intersectsSphere(vc,s)),!w){const E=h[C],T=tH.subVectors(vc.center,bm).dot(tM);Tv.push(E.start,E.count,T,b)}}const A=Tv.list,y=this.customSort;y===null?A.sort(r.transparent?KW:jW):y.call(this,A,s);for(let b=0,x=A.length;b<x;b++){const C=A[b];c[m]=C.start*a,u[m]=C.count,f[m]=C.index,m++}Tv.reset()}else for(let A=0,y=l.length;A<y;A++)if(l[A].visible&&l[A].active){const b=l[A].geometryIndex;let x=!1;if(d&&(this.getMatrixAt(A,lr),this.getBoundingSphereAt(b,vc).applyMatrix4(lr),x=!g.intersectsSphere(vc,s)),!x){const C=h[b];c[m]=C.start*a,u[m]=C.count,f[m]=A,m++}}p.needsUpdate=!0,this._multiDrawCount=m,this._visibilityChanged=!1}onBeforeShadow(e,t,s,i,r,o){this.onBeforeRender(e,null,i,r,o)}}class ir extends Li{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new ot(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const _b=new U,Tb=new U,nM=new kt,Im=new Sp,Nx=new pi,Bv=new U,sM=new U;class Wl extends un{constructor(e=new Xt,t=new ir){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[0];for(let i=1,r=t.count;i<r;i++)_b.fromBufferAttribute(t,i-1),Tb.fromBufferAttribute(t,i),s[i]=s[i-1],s[i]+=_b.distanceTo(Tb);e.setAttribute("lineDistance",new gt(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),Nx.copy(s.boundingSphere),Nx.applyMatrix4(i),Nx.radius+=r,e.ray.intersectsSphere(Nx)===!1)return;nM.copy(i).invert(),Im.copy(e.ray).applyMatrix4(nM);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=this.isLineSegments?2:1,u=s.index,d=s.attributes.position;if(u!==null){const p=Math.max(0,o.start),f=Math.min(u.count,o.start+o.count);for(let g=p,m=f-1;g<m;g+=c){const A=u.getX(g),y=u.getX(g+1),b=Rx(this,e,Im,l,A,y,g);b&&t.push(b)}if(this.isLineLoop){const g=u.getX(f-1),m=u.getX(p),A=Rx(this,e,Im,l,g,m,f-1);A&&t.push(A)}}else{const p=Math.max(0,o.start),f=Math.min(d.count,o.start+o.count);for(let g=p,m=f-1;g<m;g+=c){const A=Rx(this,e,Im,l,g,g+1,g);A&&t.push(A)}if(this.isLineLoop){const g=Rx(this,e,Im,l,f-1,p,f-1);g&&t.push(g)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}function Rx(n,e,t,s,i,r,o){const a=n.geometry.attributes.position;if(_b.fromBufferAttribute(a,i),Tb.fromBufferAttribute(a,r),t.distanceSqToSegment(_b,Tb,Bv,sM)>s)return;Bv.applyMatrix4(n.matrixWorld);const c=e.ray.origin.distanceTo(Bv);if(!(c<e.near||c>e.far))return{distance:c,point:sM.clone().applyMatrix4(n.matrixWorld),index:o,face:null,faceIndex:null,barycoord:null,object:n}}const iM=new U,rM=new U;class va extends Wl{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[];for(let i=0,r=t.count;i<r;i+=2)iM.fromBufferAttribute(t,i),rM.fromBufferAttribute(t,i+1),s[i]=i===0?0:s[i-1],s[i+1]=s[i]+iM.distanceTo(rM);e.setAttribute("lineDistance",new gt(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class iF extends Wl{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class UE extends Li{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new ot(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const oM=new kt,WS=new Sp,Dx=new pi,Fx=new U;class rF extends un{constructor(e=new Xt,t=new UE){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),Dx.copy(s.boundingSphere),Dx.applyMatrix4(i),Dx.radius+=r,e.ray.intersectsSphere(Dx)===!1)return;oM.copy(i).invert(),WS.copy(e.ray).applyMatrix4(oM);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=s.index,h=s.attributes.position;if(c!==null){const d=Math.max(0,o.start),p=Math.min(c.count,o.start+o.count);for(let f=d,g=p;f<g;f++){const m=c.getX(f);Fx.fromBufferAttribute(h,m),aM(Fx,m,l,i,e,t,this)}}else{const d=Math.max(0,o.start),p=Math.min(h.count,o.start+o.count);for(let f=d,g=p;f<g;f++)Fx.fromBufferAttribute(h,f),aM(Fx,f,l,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}function aM(n,e,t,s,i,r,o){const a=WS.distanceSqToPoint(n);if(a<t){const l=new U;WS.closestPointToPoint(n,l),l.applyMatrix4(s);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;r.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,faceIndex:null,barycoord:null,object:o})}}class QE extends cs{constructor(e,t,s,i,r=Os,o=Os,a,l,c){super(e,t,s,i,r,o,a,l,c),this.isVideoTexture=!0,this.generateMipmaps=!1,this._requestVideoFrameCallbackId=0;const u=this;function h(){u.needsUpdate=!0,u._requestVideoFrameCallbackId=e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&(this._requestVideoFrameCallbackId=e.requestVideoFrameCallback(h))}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}dispose(){this._requestVideoFrameCallbackId!==0&&this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),super.dispose()}}class sH extends QE{constructor(e,t,s,i,r,o,a,l){super({},e,t,s,i,r,o,a,l),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(e){this.image=e,this.needsUpdate=!0}}class iH extends cs{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=bs,this.minFilter=bs,this.generateMipmaps=!1,this.needsUpdate=!0}}class TI extends cs{constructor(e,t,s,i,r,o,a,l,c,u,h,d){super(null,o,a,l,c,u,i,r,h,d),this.isCompressedTexture=!0,this.image={width:t,height:s},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class rH extends TI{constructor(e,t,s,i,r,o){super(e,t,s,r,o),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=Pr,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class oH extends TI{constructor(e,t,s){super(void 0,e[0].width,e[0].height,t,s,el),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class aH extends cs{constructor(e,t,s,i,r,o,a,l,c){super(e,t,s,i,r,o,a,l,c),this.isCanvasTexture=!0,this.needsUpdate=!0}}class VE extends cs{constructor(e,t,s=Ri,i,r,o,a=bs,l=bs,c,u=Jd,h=1){if(u!==Jd&&u!==Zd)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");const d={width:e,height:t,depth:h};super(d,i,r,o,a,l,u,s,c),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.source=new Rl(Object.assign({},e.image)),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class GE extends cs{constructor(e=null){super(),this.sourceTexture=e,this.isExternalTexture=!0}copy(e){return super.copy(e),this.sourceTexture=e.sourceTexture,this}}class BI extends Xt{constructor(e=1,t=1,s=4,i=8,r=1){super(),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:s,radialSegments:i,heightSegments:r},t=Math.max(0,t),s=Math.max(1,Math.floor(s)),i=Math.max(3,Math.floor(i)),r=Math.max(1,Math.floor(r));const o=[],a=[],l=[],c=[],u=t/2,h=Math.PI/2*e,d=t,p=2*h+d,f=s*2+r,g=i+1,m=new U,A=new U;for(let y=0;y<=f;y++){let b=0,x=0,C=0,w=0;if(y<=s){const v=y/s,S=v*Math.PI/2;x=-u-e*Math.cos(S),C=e*Math.sin(S),w=-e*Math.cos(S),b=v*h}else if(y<=s+r){const v=(y-s)/r;x=-u+v*t,C=e,w=0,b=h+v*d}else{const v=(y-s-r)/s,S=v*Math.PI/2;x=u+e*Math.sin(S),C=e*Math.cos(S),w=e*Math.sin(S),b=h+d+v*h}const E=Math.max(0,Math.min(1,b/p));let T=0;y===0?T=.5/i:y===f&&(T=-.5/i);for(let v=0;v<=i;v++){const S=v/i,_=S*Math.PI*2,N=Math.sin(_),D=Math.cos(_);A.x=-C*D,A.y=x,A.z=C*N,a.push(A.x,A.y,A.z),m.set(-C*D,w,C*N),m.normalize(),l.push(m.x,m.y,m.z),c.push(S+T,E)}if(y>0){const v=(y-1)*g;for(let S=0;S<i;S++){const _=v+S,N=v+S+1,D=y*g+S,P=y*g+S+1;o.push(_,N,D),o.push(N,P,D)}}}this.setIndex(o),this.setAttribute("position",new gt(a,3)),this.setAttribute("normal",new gt(l,3)),this.setAttribute("uv",new gt(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new BI(e.radius,e.height,e.capSegments,e.radialSegments,e.heightSegments)}}class kI extends Xt{constructor(e=1,t=32,s=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:s,thetaLength:i},t=Math.max(3,t);const r=[],o=[],a=[],l=[],c=new U,u=new $e;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,d=3;h<=t;h++,d+=3){const p=s+h/t*i;c.x=e*Math.cos(p),c.y=e*Math.sin(p),o.push(c.x,c.y,c.z),a.push(0,0,1),u.x=(o[d]/e+1)/2,u.y=(o[d+1]/e+1)/2,l.push(u.x,u.y)}for(let h=1;h<=t;h++)r.push(h,h+1,0);this.setIndex(r),this.setAttribute("position",new gt(o,3)),this.setAttribute("normal",new gt(a,3)),this.setAttribute("uv",new gt(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new kI(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class tA extends Xt{constructor(e=1,t=1,s=1,i=32,r=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:s,radialSegments:i,heightSegments:r,openEnded:o,thetaStart:a,thetaLength:l};const c=this;i=Math.floor(i),r=Math.floor(r);const u=[],h=[],d=[],p=[];let f=0;const g=[],m=s/2;let A=0;y(),o===!1&&(e>0&&b(!0),t>0&&b(!1)),this.setIndex(u),this.setAttribute("position",new gt(h,3)),this.setAttribute("normal",new gt(d,3)),this.setAttribute("uv",new gt(p,2));function y(){const x=new U,C=new U;let w=0;const E=(t-e)/s;for(let T=0;T<=r;T++){const v=[],S=T/r,_=S*(t-e)+e;for(let N=0;N<=i;N++){const D=N/i,P=D*l+a,L=Math.sin(P),z=Math.cos(P);C.x=_*L,C.y=-S*s+m,C.z=_*z,h.push(C.x,C.y,C.z),x.set(L,E,z).normalize(),d.push(x.x,x.y,x.z),p.push(D,1-S),v.push(f++)}g.push(v)}for(let T=0;T<i;T++)for(let v=0;v<r;v++){const S=g[v][T],_=g[v+1][T],N=g[v+1][T+1],D=g[v][T+1];(e>0||v!==0)&&(u.push(S,_,D),w+=3),(t>0||v!==r-1)&&(u.push(_,N,D),w+=3)}c.addGroup(A,w,0),A+=w}function b(x){const C=f,w=new $e,E=new U;let T=0;const v=x===!0?e:t,S=x===!0?1:-1;for(let N=1;N<=i;N++)h.push(0,m*S,0),d.push(0,S,0),p.push(.5,.5),f++;const _=f;for(let N=0;N<=i;N++){const P=N/i*l+a,L=Math.cos(P),z=Math.sin(P);E.x=v*z,E.y=m*S,E.z=v*L,h.push(E.x,E.y,E.z),d.push(0,S,0),w.x=L*.5+.5,w.y=z*.5*S+.5,p.push(w.x,w.y),f++}for(let N=0;N<i;N++){const D=C+N,P=_+N;x===!0?u.push(P,P+1,D):u.push(P+1,P,D),T+=3}c.addGroup(A,T,x===!0?1:2),A+=T}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new tA(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class nA extends tA{constructor(e=1,t=1,s=32,i=1,r=!1,o=0,a=Math.PI*2){super(0,e,t,s,i,r,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:s,heightSegments:i,openEnded:r,thetaStart:o,thetaLength:a}}static fromJSON(e){return new nA(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class oc extends Xt{constructor(e=[],t=[],s=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:s,detail:i};const r=[],o=[];a(i),c(s),u(),this.setAttribute("position",new gt(r,3)),this.setAttribute("normal",new gt(r.slice(),3)),this.setAttribute("uv",new gt(o,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function a(y){const b=new U,x=new U,C=new U;for(let w=0;w<t.length;w+=3)p(t[w+0],b),p(t[w+1],x),p(t[w+2],C),l(b,x,C,y)}function l(y,b,x,C){const w=C+1,E=[];for(let T=0;T<=w;T++){E[T]=[];const v=y.clone().lerp(x,T/w),S=b.clone().lerp(x,T/w),_=w-T;for(let N=0;N<=_;N++)N===0&&T===w?E[T][N]=v:E[T][N]=v.clone().lerp(S,N/_)}for(let T=0;T<w;T++)for(let v=0;v<2*(w-T)-1;v++){const S=Math.floor(v/2);v%2===0?(d(E[T][S+1]),d(E[T+1][S]),d(E[T][S])):(d(E[T][S+1]),d(E[T+1][S+1]),d(E[T+1][S]))}}function c(y){const b=new U;for(let x=0;x<r.length;x+=3)b.x=r[x+0],b.y=r[x+1],b.z=r[x+2],b.normalize().multiplyScalar(y),r[x+0]=b.x,r[x+1]=b.y,r[x+2]=b.z}function u(){const y=new U;for(let b=0;b<r.length;b+=3){y.x=r[b+0],y.y=r[b+1],y.z=r[b+2];const x=m(y)/2/Math.PI+.5,C=A(y)/Math.PI+.5;o.push(x,1-C)}f(),h()}function h(){for(let y=0;y<o.length;y+=6){const b=o[y+0],x=o[y+2],C=o[y+4],w=Math.max(b,x,C),E=Math.min(b,x,C);w>.9&&E<.1&&(b<.2&&(o[y+0]+=1),x<.2&&(o[y+2]+=1),C<.2&&(o[y+4]+=1))}}function d(y){r.push(y.x,y.y,y.z)}function p(y,b){const x=y*3;b.x=e[x+0],b.y=e[x+1],b.z=e[x+2]}function f(){const y=new U,b=new U,x=new U,C=new U,w=new $e,E=new $e,T=new $e;for(let v=0,S=0;v<r.length;v+=9,S+=6){y.set(r[v+0],r[v+1],r[v+2]),b.set(r[v+3],r[v+4],r[v+5]),x.set(r[v+6],r[v+7],r[v+8]),w.set(o[S+0],o[S+1]),E.set(o[S+2],o[S+3]),T.set(o[S+4],o[S+5]),C.copy(y).add(b).add(x).divideScalar(3);const _=m(C);g(w,S+0,y,_),g(E,S+2,b,_),g(T,S+4,x,_)}}function g(y,b,x,C){C<0&&y.x===1&&(o[b]=y.x-1),x.x===0&&x.z===0&&(o[b]=C/2/Math.PI+.5)}function m(y){return Math.atan2(y.z,-y.x)}function A(y){return Math.atan2(-y.y,Math.sqrt(y.x*y.x+y.z*y.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new oc(e.vertices,e.indices,e.radius,e.details)}}class MI extends oc{constructor(e=1,t=0){const s=(1+Math.sqrt(5))/2,i=1/s,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-s,0,-i,s,0,i,-s,0,i,s,-i,-s,0,-i,s,0,i,-s,0,i,s,0,-s,0,-i,s,0,-i,-s,0,i,s,0,i],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(r,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new MI(e.radius,e.detail)}}const $x=new U,Px=new U,kv=new U,Lx=new fr;class oF extends Xt{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const i=Math.pow(10,4),r=Math.cos(uu*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],u=["a","b","c"],h=new Array(3),d={},p=[];for(let f=0;f<l;f+=3){o?(c[0]=o.getX(f),c[1]=o.getX(f+1),c[2]=o.getX(f+2)):(c[0]=f,c[1]=f+1,c[2]=f+2);const{a:g,b:m,c:A}=Lx;if(g.fromBufferAttribute(a,c[0]),m.fromBufferAttribute(a,c[1]),A.fromBufferAttribute(a,c[2]),Lx.getNormal(kv),h[0]=`${Math.round(g.x*i)},${Math.round(g.y*i)},${Math.round(g.z*i)}`,h[1]=`${Math.round(m.x*i)},${Math.round(m.y*i)},${Math.round(m.z*i)}`,h[2]=`${Math.round(A.x*i)},${Math.round(A.y*i)},${Math.round(A.z*i)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let y=0;y<3;y++){const b=(y+1)%3,x=h[y],C=h[b],w=Lx[u[y]],E=Lx[u[b]],T=`${x}_${C}`,v=`${C}_${x}`;v in d&&d[v]?(kv.dot(d[v].normal)<=r&&(p.push(w.x,w.y,w.z),p.push(E.x,E.y,E.z)),d[v]=null):T in d||(d[T]={index0:c[y],index1:c[b],normal:kv.clone()})}}for(const f in d)if(d[f]){const{index0:g,index1:m}=d[f];$x.fromBufferAttribute(a,g),Px.fromBufferAttribute(a,m),p.push($x.x,$x.y,$x.z),p.push(Px.x,Px.y,Px.z)}this.setAttribute("position",new gt(p,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class Vo{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(e,t){const s=this.getUtoTmapping(e);return this.getPoint(s,t)}getPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return t}getSpacedPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPointAt(s/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let s,i=this.getPoint(0),r=0;t.push(0);for(let o=1;o<=e;o++)s=this.getPoint(o/e),r+=s.distanceTo(i),t.push(r),i=s;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t=null){const s=this.getLengths();let i=0;const r=s.length;let o;t?o=t:o=e*s[r-1];let a=0,l=r-1,c;for(;a<=l;)if(i=Math.floor(a+(l-a)/2),c=s[i]-o,c<0)a=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,s[i]===o)return i/(r-1);const u=s[i],d=s[i+1]-u,p=(o-u)/d;return(i+p)/(r-1)}getTangent(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const o=this.getPoint(i),a=this.getPoint(r),l=t||(o.isVector2?new $e:new U);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const s=this.getUtoTmapping(e);return this.getTangent(s,t)}computeFrenetFrames(e,t=!1){const s=new U,i=[],r=[],o=[],a=new U,l=new kt;for(let p=0;p<=e;p++){const f=p/e;i[p]=this.getTangentAt(f,new U)}r[0]=new U,o[0]=new U;let c=Number.MAX_VALUE;const u=Math.abs(i[0].x),h=Math.abs(i[0].y),d=Math.abs(i[0].z);u<=c&&(c=u,s.set(1,0,0)),h<=c&&(c=h,s.set(0,1,0)),d<=c&&s.set(0,0,1),a.crossVectors(i[0],s).normalize(),r[0].crossVectors(i[0],a),o[0].crossVectors(i[0],r[0]);for(let p=1;p<=e;p++){if(r[p]=r[p-1].clone(),o[p]=o[p-1].clone(),a.crossVectors(i[p-1],i[p]),a.length()>Number.EPSILON){a.normalize();const f=Math.acos(Ot(i[p-1].dot(i[p]),-1,1));r[p].applyMatrix4(l.makeRotationAxis(a,f))}o[p].crossVectors(i[p],r[p])}if(t===!0){let p=Math.acos(Ot(r[0].dot(r[e]),-1,1));p/=e,i[0].dot(a.crossVectors(r[0],r[e]))>0&&(p=-p);for(let f=1;f<=e;f++)r[f].applyMatrix4(l.makeRotationAxis(i[f],p*f)),o[f].crossVectors(i[f],r[f])}return{tangents:i,normals:r,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class NI extends Vo{constructor(e=0,t=0,s=1,i=1,r=0,o=Math.PI*2,a=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=s,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,t=new $e){const s=t,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const o=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(o?r=0:r=i),this.aClockwise===!0&&!o&&(r===i?r=-i:r=r-i);const a=this.aStartAngle+e*r;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const u=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=l-this.aX,p=c-this.aY;l=d*u-p*h+this.aX,c=d*h+p*u+this.aY}return s.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class aF extends NI{constructor(e,t,s,i,r,o){super(e,t,s,s,i,r,o),this.isArcCurve=!0,this.type="ArcCurve"}}function WE(){let n=0,e=0,t=0,s=0;function i(r,o,a,l){n=r,e=a,t=-3*r+3*o-2*a-l,s=2*r-2*o+a+l}return{initCatmullRom:function(r,o,a,l,c){i(o,a,c*(a-r),c*(l-o))},initNonuniformCatmullRom:function(r,o,a,l,c,u,h){let d=(o-r)/c-(a-r)/(c+u)+(a-o)/u,p=(a-o)/u-(l-o)/(u+h)+(l-a)/h;d*=u,p*=u,i(o,a,d,p)},calc:function(r){const o=r*r,a=o*r;return n+e*r+t*o+s*a}}}const Ox=new U,Mv=new WE,Nv=new WE,Rv=new WE;class lF extends Vo{constructor(e=[],t=!1,s="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=s,this.tension=i}getPoint(e,t=new U){const s=t,i=this.points,r=i.length,o=(r-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/r)+1)*r:l===0&&a===r-1&&(a=r-2,l=1);let c,u;this.closed||a>0?c=i[(a-1)%r]:(Ox.subVectors(i[0],i[1]).add(i[0]),c=Ox);const h=i[a%r],d=i[(a+1)%r];if(this.closed||a+2<r?u=i[(a+2)%r]:(Ox.subVectors(i[r-1],i[r-2]).add(i[r-1]),u=Ox),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let f=Math.pow(c.distanceToSquared(h),p),g=Math.pow(h.distanceToSquared(d),p),m=Math.pow(d.distanceToSquared(u),p);g<1e-4&&(g=1),f<1e-4&&(f=g),m<1e-4&&(m=g),Mv.initNonuniformCatmullRom(c.x,h.x,d.x,u.x,f,g,m),Nv.initNonuniformCatmullRom(c.y,h.y,d.y,u.y,f,g,m),Rv.initNonuniformCatmullRom(c.z,h.z,d.z,u.z,f,g,m)}else this.curveType==="catmullrom"&&(Mv.initCatmullRom(c.x,h.x,d.x,u.x,this.tension),Nv.initCatmullRom(c.y,h.y,d.y,u.y,this.tension),Rv.initCatmullRom(c.z,h.z,d.z,u.z,this.tension));return s.set(Mv.calc(l),Nv.calc(l),Rv.calc(l)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(new U().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function lM(n,e,t,s,i){const r=(s-e)*.5,o=(i-t)*.5,a=n*n,l=n*a;return(2*t-2*s+r+o)*l+(-3*t+3*s-2*r-o)*a+r*n+t}function lH(n,e){const t=1-n;return t*t*e}function cH(n,e){return 2*(1-n)*n*e}function uH(n,e){return n*n*e}function Km(n,e,t,s){return lH(n,e)+cH(n,t)+uH(n,s)}function hH(n,e){const t=1-n;return t*t*t*e}function dH(n,e){const t=1-n;return 3*t*t*n*e}function pH(n,e){return 3*(1-n)*n*n*e}function fH(n,e){return n*n*n*e}function Jm(n,e,t,s,i){return hH(n,e)+dH(n,t)+pH(n,s)+fH(n,i)}class HE extends Vo{constructor(e=new $e,t=new $e,s=new $e,i=new $e){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=s,this.v3=i}getPoint(e,t=new $e){const s=t,i=this.v0,r=this.v1,o=this.v2,a=this.v3;return s.set(Jm(e,i.x,r.x,o.x,a.x),Jm(e,i.y,r.y,o.y,a.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class cF extends Vo{constructor(e=new U,t=new U,s=new U,i=new U){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=s,this.v3=i}getPoint(e,t=new U){const s=t,i=this.v0,r=this.v1,o=this.v2,a=this.v3;return s.set(Jm(e,i.x,r.x,o.x,a.x),Jm(e,i.y,r.y,o.y,a.y),Jm(e,i.z,r.z,o.z,a.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class qE extends Vo{constructor(e=new $e,t=new $e){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new $e){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new $e){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class uF extends Vo{constructor(e=new U,t=new U){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new U){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new U){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class YE extends Vo{constructor(e=new $e,t=new $e,s=new $e){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new $e){const s=t,i=this.v0,r=this.v1,o=this.v2;return s.set(Km(e,i.x,r.x,o.x),Km(e,i.y,r.y,o.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class XE extends Vo{constructor(e=new U,t=new U,s=new U){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new U){const s=t,i=this.v0,r=this.v1,o=this.v2;return s.set(Km(e,i.x,r.x,o.x),Km(e,i.y,r.y,o.y),Km(e,i.z,r.z,o.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class jE extends Vo{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new $e){const s=t,i=this.points,r=(i.length-1)*e,o=Math.floor(r),a=r-o,l=i[o===0?o:o-1],c=i[o],u=i[o>i.length-2?i.length-1:o+1],h=i[o>i.length-3?i.length-1:o+2];return s.set(lM(a,l.x,c.x,u.x,h.x),lM(a,l.y,c.y,u.y,h.y)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(new $e().fromArray(i))}return this}}var Bb=Object.freeze({__proto__:null,ArcCurve:aF,CatmullRomCurve3:lF,CubicBezierCurve:HE,CubicBezierCurve3:cF,EllipseCurve:NI,LineCurve:qE,LineCurve3:uF,QuadraticBezierCurve:YE,QuadraticBezierCurve3:XE,SplineCurve:jE});class hF extends Vo{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const s=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Bb[s](t,e))}return this}getPoint(e,t){const s=e*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=s){const o=i[r]-s,a=this.curves[r],l=a.getLength(),c=l===0?0:1-o/l;return a.getPointAt(c,t)}r++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let s=0,i=this.curves.length;s<i;s++)t+=this.curves[s].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let s;for(let i=0,r=this.curves;i<r.length;i++){const o=r[i],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let c=0;c<l.length;c++){const u=l[c];s&&s.equals(u)||(t.push(u),s=u)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,s=this.curves.length;t<s;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const i=e.curves[t];this.curves.push(new Bb[i.type]().fromJSON(i))}return this}}class kb extends hF{constructor(e){super(),this.type="Path",this.currentPoint=new $e,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,s=e.length;t<s;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const s=new qE(this.currentPoint.clone(),new $e(e,t));return this.curves.push(s),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,s,i){const r=new YE(this.currentPoint.clone(),new $e(e,t),new $e(s,i));return this.curves.push(r),this.currentPoint.set(s,i),this}bezierCurveTo(e,t,s,i,r,o){const a=new HE(this.currentPoint.clone(),new $e(e,t),new $e(s,i),new $e(r,o));return this.curves.push(a),this.currentPoint.set(r,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),s=new jE(t);return this.curves.push(s),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,s,i,r,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,t+l,s,i,r,o),this}absarc(e,t,s,i,r,o){return this.absellipse(e,t,s,s,i,r,o),this}ellipse(e,t,s,i,r,o,a,l){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+c,t+u,s,i,r,o,a,l),this}absellipse(e,t,s,i,r,o,a,l){const c=new NI(e,t,s,i,r,o,a,l);if(this.curves.length>0){const h=c.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(c);const u=c.getPoint(1);return this.currentPoint.copy(u),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class hu extends kb{constructor(e){super(e),this.uuid=Qr(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let s=0,i=this.holes.length;s<i;s++)t[s]=this.holes[s].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,s=this.holes.length;t<s;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const i=e.holes[t];this.holes.push(new kb().fromJSON(i))}return this}}function mH(n,e,t=2){const s=e&&e.length,i=s?e[0]*t:n.length;let r=dF(n,0,i,t,!0);const o=[];if(!r||r.next===r.prev)return o;let a,l,c;if(s&&(r=bH(n,e,r,t)),n.length>80*t){a=1/0,l=1/0;let u=-1/0,h=-1/0;for(let d=t;d<i;d+=t){const p=n[d],f=n[d+1];p<a&&(a=p),f<l&&(l=f),p>u&&(u=p),f>h&&(h=f)}c=Math.max(u-a,h-l),c=c!==0?32767/c:0}return gg(r,o,t,a,l,c,0),o}function dF(n,e,t,s,i){let r;if(i===MH(n,e,t,s)>0)for(let o=e;o<t;o+=s)r=cM(o/s|0,n[o],n[o+1],r);else for(let o=t-s;o>=e;o-=s)r=cM(o/s|0,n[o],n[o+1],r);return r&&sp(r,r.next)&&(yg(r),r=r.next),r}function Iu(n,e){if(!n)return n;e||(e=n);let t=n,s;do if(s=!1,!t.steiner&&(sp(t,t.next)||os(t.prev,t,t.next)===0)){if(yg(t),t=e=t.prev,t===t.next)break;s=!0}else t=t.next;while(s||t!==e);return e}function gg(n,e,t,s,i,r,o){if(!n)return;!o&&r&&SH(n,s,i,r);let a=n;for(;n.prev!==n.next;){const l=n.prev,c=n.next;if(r?AH(n,s,i,r):gH(n)){e.push(l.i,n.i,c.i),yg(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=yH(Iu(n),e),gg(n,e,t,s,i,r,2)):o===2&&xH(n,e,t,s,i,r):gg(Iu(n),e,t,s,i,r,1);break}}}function gH(n){const e=n.prev,t=n,s=n.next;if(os(e,t,s)>=0)return!1;const i=e.x,r=t.x,o=s.x,a=e.y,l=t.y,c=s.y,u=Math.min(i,r,o),h=Math.min(a,l,c),d=Math.max(i,r,o),p=Math.max(a,l,c);let f=s.next;for(;f!==e;){if(f.x>=u&&f.x<=d&&f.y>=h&&f.y<=p&&km(i,a,r,l,o,c,f.x,f.y)&&os(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function AH(n,e,t,s){const i=n.prev,r=n,o=n.next;if(os(i,r,o)>=0)return!1;const a=i.x,l=r.x,c=o.x,u=i.y,h=r.y,d=o.y,p=Math.min(a,l,c),f=Math.min(u,h,d),g=Math.max(a,l,c),m=Math.max(u,h,d),A=HS(p,f,e,t,s),y=HS(g,m,e,t,s);let b=n.prevZ,x=n.nextZ;for(;b&&b.z>=A&&x&&x.z<=y;){if(b.x>=p&&b.x<=g&&b.y>=f&&b.y<=m&&b!==i&&b!==o&&km(a,u,l,h,c,d,b.x,b.y)&&os(b.prev,b,b.next)>=0||(b=b.prevZ,x.x>=p&&x.x<=g&&x.y>=f&&x.y<=m&&x!==i&&x!==o&&km(a,u,l,h,c,d,x.x,x.y)&&os(x.prev,x,x.next)>=0))return!1;x=x.nextZ}for(;b&&b.z>=A;){if(b.x>=p&&b.x<=g&&b.y>=f&&b.y<=m&&b!==i&&b!==o&&km(a,u,l,h,c,d,b.x,b.y)&&os(b.prev,b,b.next)>=0)return!1;b=b.prevZ}for(;x&&x.z<=y;){if(x.x>=p&&x.x<=g&&x.y>=f&&x.y<=m&&x!==i&&x!==o&&km(a,u,l,h,c,d,x.x,x.y)&&os(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function yH(n,e){let t=n;do{const s=t.prev,i=t.next.next;!sp(s,i)&&fF(s,t,t.next,i)&&Ag(s,i)&&Ag(i,s)&&(e.push(s.i,t.i,i.i),yg(t),yg(t.next),t=n=i),t=t.next}while(t!==n);return Iu(t)}function xH(n,e,t,s,i,r){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&TH(o,a)){let l=mF(o,a);o=Iu(o,o.next),l=Iu(l,l.next),gg(o,e,t,s,i,r,0),gg(l,e,t,s,i,r,0);return}a=a.next}o=o.next}while(o!==n)}function bH(n,e,t,s){const i=[];for(let r=0,o=e.length;r<o;r++){const a=e[r]*s,l=r<o-1?e[r+1]*s:n.length,c=dF(n,a,l,s,!1);c===c.next&&(c.steiner=!0),i.push(_H(c))}i.sort(IH);for(let r=0;r<i.length;r++)t=CH(i[r],t);return t}function IH(n,e){let t=n.x-e.x;if(t===0&&(t=n.y-e.y,t===0)){const s=(n.next.y-n.y)/(n.next.x-n.x),i=(e.next.y-e.y)/(e.next.x-e.x);t=s-i}return t}function CH(n,e){const t=wH(n,e);if(!t)return e;const s=mF(t,n);return Iu(s,s.next),Iu(t,t.next)}function wH(n,e){let t=e;const s=n.x,i=n.y;let r=-1/0,o;if(sp(n,t))return t;do{if(sp(n,t.next))return t.next;if(i<=t.y&&i>=t.next.y&&t.next.y!==t.y){const h=t.x+(i-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(h<=s&&h>r&&(r=h,o=t.x<t.next.x?t:t.next,h===s))return o}t=t.next}while(t!==e);if(!o)return null;const a=o,l=o.x,c=o.y;let u=1/0;t=o;do{if(s>=t.x&&t.x>=l&&s!==t.x&&pF(i<c?s:r,i,l,c,i<c?r:s,i,t.x,t.y)){const h=Math.abs(i-t.y)/(s-t.x);Ag(t,n)&&(h<u||h===u&&(t.x>o.x||t.x===o.x&&vH(o,t)))&&(o=t,u=h)}t=t.next}while(t!==a);return o}function vH(n,e){return os(n.prev,n,e.prev)<0&&os(e.next,n,n.next)<0}function SH(n,e,t,s){let i=n;do i.z===0&&(i.z=HS(i.x,i.y,e,t,s)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==n);i.prevZ.nextZ=null,i.prevZ=null,EH(i)}function EH(n){let e,t=1;do{let s=n,i;n=null;let r=null;for(e=0;s;){e++;let o=s,a=0;for(let c=0;c<t&&(a++,o=o.nextZ,!!o);c++);let l=t;for(;a>0||l>0&&o;)a!==0&&(l===0||!o||s.z<=o.z)?(i=s,s=s.nextZ,a--):(i=o,o=o.nextZ,l--),r?r.nextZ=i:n=i,i.prevZ=r,r=i;s=o}r.nextZ=null,t*=2}while(e>1);return n}function HS(n,e,t,s,i){return n=(n-t)*i|0,e=(e-s)*i|0,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function _H(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function pF(n,e,t,s,i,r,o,a){return(i-o)*(e-a)>=(n-o)*(r-a)&&(n-o)*(s-a)>=(t-o)*(e-a)&&(t-o)*(r-a)>=(i-o)*(s-a)}function km(n,e,t,s,i,r,o,a){return!(n===o&&e===a)&&pF(n,e,t,s,i,r,o,a)}function TH(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!BH(n,e)&&(Ag(n,e)&&Ag(e,n)&&kH(n,e)&&(os(n.prev,n,e.prev)||os(n,e.prev,e))||sp(n,e)&&os(n.prev,n,n.next)>0&&os(e.prev,e,e.next)>0)}function os(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function sp(n,e){return n.x===e.x&&n.y===e.y}function fF(n,e,t,s){const i=Ux(os(n,e,t)),r=Ux(os(n,e,s)),o=Ux(os(t,s,n)),a=Ux(os(t,s,e));return!!(i!==r&&o!==a||i===0&&zx(n,t,e)||r===0&&zx(n,s,e)||o===0&&zx(t,n,s)||a===0&&zx(t,e,s))}function zx(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function Ux(n){return n>0?1:n<0?-1:0}function BH(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&fF(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function Ag(n,e){return os(n.prev,n,n.next)<0?os(n,e,n.next)>=0&&os(n,n.prev,e)>=0:os(n,e,n.prev)<0||os(n,n.next,e)<0}function kH(n,e){let t=n,s=!1;const i=(n.x+e.x)/2,r=(n.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&i<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(s=!s),t=t.next;while(t!==n);return s}function mF(n,e){const t=qS(n.i,n.x,n.y),s=qS(e.i,e.x,e.y),i=n.next,r=e.prev;return n.next=e,e.prev=n,t.next=i,i.prev=t,s.next=t,t.prev=s,r.next=s,s.prev=r,s}function cM(n,e,t,s){const i=qS(n,e,t);return s?(i.next=s.next,i.prev=s,s.next.prev=i,s.next=i):(i.prev=i,i.next=i),i}function yg(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function qS(n,e,t){return{i:n,x:e,y:t,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function MH(n,e,t,s){let i=0;for(let r=e,o=t-s;r<t;r+=s)i+=(n[o]-n[r])*(n[r+1]+n[o+1]),o=r;return i}class NH{static triangulate(e,t,s=2){return mH(e,t,s)}}class _o{static area(e){const t=e.length;let s=0;for(let i=t-1,r=0;r<t;i=r++)s+=e[i].x*e[r].y-e[r].x*e[i].y;return s*.5}static isClockWise(e){return _o.area(e)<0}static triangulateShape(e,t){const s=[],i=[],r=[];uM(e),hM(s,e);let o=e.length;t.forEach(uM);for(let l=0;l<t.length;l++)i.push(o),o+=t[l].length,hM(s,t[l]);const a=NH.triangulate(s,i);for(let l=0;l<a.length;l+=3)r.push(a.slice(l,l+3));return r}}function uM(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function hM(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class RI extends Xt{constructor(e=new hu([new $e(.5,.5),new $e(-.5,.5),new $e(-.5,-.5),new $e(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const s=this,i=[],r=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new gt(i,3)),this.setAttribute("uv",new gt(r,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1,h=t.depth!==void 0?t.depth:1;let d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,p=t.bevelThickness!==void 0?t.bevelThickness:.2,f=t.bevelSize!==void 0?t.bevelSize:p-.1,g=t.bevelOffset!==void 0?t.bevelOffset:0,m=t.bevelSegments!==void 0?t.bevelSegments:3;const A=t.extrudePath,y=t.UVGenerator!==void 0?t.UVGenerator:RH;let b,x=!1,C,w,E,T;A&&(b=A.getSpacedPoints(u),x=!0,d=!1,C=A.computeFrenetFrames(u,!1),w=new U,E=new U,T=new U),d||(m=0,p=0,f=0,g=0);const v=a.extractPoints(c);let S=v.shape;const _=v.holes;if(!_o.isClockWise(S)){S=S.reverse();for(let Ce=0,be=_.length;Ce<be;Ce++){const ge=_[Ce];_o.isClockWise(ge)&&(_[Ce]=ge.reverse())}}function D(Ce){const ge=10000000000000001e-36;let ye=Ce[0];for(let Re=1;Re<=Ce.length;Re++){const De=Re%Ce.length,Me=Ce[De],Tt=Me.x-ye.x,At=Me.y-ye.y,G=Tt*Tt+At*At,$=Math.max(Math.abs(Me.x),Math.abs(Me.y),Math.abs(ye.x),Math.abs(ye.y)),de=ge*$*$;if(G<=de){Ce.splice(De,1),Re--;continue}ye=Me}}D(S),_.forEach(D);const P=_.length,L=S;for(let Ce=0;Ce<P;Ce++){const be=_[Ce];S=S.concat(be)}function z(Ce,be,ge){return be||console.error("THREE.ExtrudeGeometry: vec does not exist"),Ce.clone().addScaledVector(be,ge)}const q=S.length;function V(Ce,be,ge){let ye,Re,De;const Me=Ce.x-be.x,Tt=Ce.y-be.y,At=ge.x-Ce.x,G=ge.y-Ce.y,$=Me*Me+Tt*Tt,de=Me*G-Tt*At;if(Math.abs(de)>Number.EPSILON){const xe=Math.sqrt($),Fe=Math.sqrt(At*At+G*G),ve=be.x-Tt/xe,ut=be.y+Me/xe,He=ge.x-G/Fe,pt=ge.y+At/Fe,yt=((He-ve)*G-(pt-ut)*At)/(Me*G-Tt*At);ye=ve+Me*yt-Ce.x,Re=ut+Tt*yt-Ce.y;const Oe=ye*ye+Re*Re;if(Oe<=2)return new $e(ye,Re);De=Math.sqrt(Oe/2)}else{let xe=!1;Me>Number.EPSILON?At>Number.EPSILON&&(xe=!0):Me<-Number.EPSILON?At<-Number.EPSILON&&(xe=!0):Math.sign(Tt)===Math.sign(G)&&(xe=!0),xe?(ye=-Tt,Re=Me,De=Math.sqrt($)):(ye=Me,Re=Tt,De=Math.sqrt($/2))}return new $e(ye/De,Re/De)}const X=[];for(let Ce=0,be=L.length,ge=be-1,ye=Ce+1;Ce<be;Ce++,ge++,ye++)ge===be&&(ge=0),ye===be&&(ye=0),X[Ce]=V(L[Ce],L[ge],L[ye]);const te=[];let se,fe=X.concat();for(let Ce=0,be=P;Ce<be;Ce++){const ge=_[Ce];se=[];for(let ye=0,Re=ge.length,De=Re-1,Me=ye+1;ye<Re;ye++,De++,Me++)De===Re&&(De=0),Me===Re&&(Me=0),se[ye]=V(ge[ye],ge[De],ge[Me]);te.push(se),fe=fe.concat(se)}let me;if(m===0)me=_o.triangulateShape(L,_);else{const Ce=[],be=[];for(let ge=0;ge<m;ge++){const ye=ge/m,Re=p*Math.cos(ye*Math.PI/2),De=f*Math.sin(ye*Math.PI/2)+g;for(let Me=0,Tt=L.length;Me<Tt;Me++){const At=z(L[Me],X[Me],De);ke(At.x,At.y,-Re),ye===0&&Ce.push(At)}for(let Me=0,Tt=P;Me<Tt;Me++){const At=_[Me];se=te[Me];const G=[];for(let $=0,de=At.length;$<de;$++){const xe=z(At[$],se[$],De);ke(xe.x,xe.y,-Re),ye===0&&G.push(xe)}ye===0&&be.push(G)}}me=_o.triangulateShape(Ce,be)}const Te=me.length,Ee=f+g;for(let Ce=0;Ce<q;Ce++){const be=d?z(S[Ce],fe[Ce],Ee):S[Ce];x?(E.copy(C.normals[0]).multiplyScalar(be.x),w.copy(C.binormals[0]).multiplyScalar(be.y),T.copy(b[0]).add(E).add(w),ke(T.x,T.y,T.z)):ke(be.x,be.y,0)}for(let Ce=1;Ce<=u;Ce++)for(let be=0;be<q;be++){const ge=d?z(S[be],fe[be],Ee):S[be];x?(E.copy(C.normals[Ce]).multiplyScalar(ge.x),w.copy(C.binormals[Ce]).multiplyScalar(ge.y),T.copy(b[Ce]).add(E).add(w),ke(T.x,T.y,T.z)):ke(ge.x,ge.y,h/u*Ce)}for(let Ce=m-1;Ce>=0;Ce--){const be=Ce/m,ge=p*Math.cos(be*Math.PI/2),ye=f*Math.sin(be*Math.PI/2)+g;for(let Re=0,De=L.length;Re<De;Re++){const Me=z(L[Re],X[Re],ye);ke(Me.x,Me.y,h+ge)}for(let Re=0,De=_.length;Re<De;Re++){const Me=_[Re];se=te[Re];for(let Tt=0,At=Me.length;Tt<At;Tt++){const G=z(Me[Tt],se[Tt],ye);x?ke(G.x,G.y+b[u-1].y,b[u-1].x+ge):ke(G.x,G.y,h+ge)}}}re(),ue();function re(){const Ce=i.length/3;if(d){let be=0,ge=q*be;for(let ye=0;ye<Te;ye++){const Re=me[ye];Ne(Re[2]+ge,Re[1]+ge,Re[0]+ge)}be=u+m*2,ge=q*be;for(let ye=0;ye<Te;ye++){const Re=me[ye];Ne(Re[0]+ge,Re[1]+ge,Re[2]+ge)}}else{for(let be=0;be<Te;be++){const ge=me[be];Ne(ge[2],ge[1],ge[0])}for(let be=0;be<Te;be++){const ge=me[be];Ne(ge[0]+q*u,ge[1]+q*u,ge[2]+q*u)}}s.addGroup(Ce,i.length/3-Ce,0)}function ue(){const Ce=i.length/3;let be=0;_e(L,be),be+=L.length;for(let ge=0,ye=_.length;ge<ye;ge++){const Re=_[ge];_e(Re,be),be+=Re.length}s.addGroup(Ce,i.length/3-Ce,1)}function _e(Ce,be){let ge=Ce.length;for(;--ge>=0;){const ye=ge;let Re=ge-1;Re<0&&(Re=Ce.length-1);for(let De=0,Me=u+m*2;De<Me;De++){const Tt=q*De,At=q*(De+1),G=be+ye+Tt,$=be+Re+Tt,de=be+Re+At,xe=be+ye+At;Ue(G,$,de,xe)}}}function ke(Ce,be,ge){l.push(Ce),l.push(be),l.push(ge)}function Ne(Ce,be,ge){ht(Ce),ht(be),ht(ge);const ye=i.length/3,Re=y.generateTopUV(s,i,ye-3,ye-2,ye-1);W(Re[0]),W(Re[1]),W(Re[2])}function Ue(Ce,be,ge,ye){ht(Ce),ht(be),ht(ye),ht(be),ht(ge),ht(ye);const Re=i.length/3,De=y.generateSideWallUV(s,i,Re-6,Re-3,Re-2,Re-1);W(De[0]),W(De[1]),W(De[3]),W(De[1]),W(De[2]),W(De[3])}function ht(Ce){i.push(l[Ce*3+0]),i.push(l[Ce*3+1]),i.push(l[Ce*3+2])}function W(Ce){r.push(Ce.x),r.push(Ce.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,s=this.parameters.options;return DH(t,s,e)}static fromJSON(e,t){const s=[];for(let r=0,o=e.shapes.length;r<o;r++){const a=t[e.shapes[r]];s.push(a)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new Bb[i.type]().fromJSON(i)),new RI(s,e.options)}}const RH={generateTopUV:function(n,e,t,s,i){const r=e[t*3],o=e[t*3+1],a=e[s*3],l=e[s*3+1],c=e[i*3],u=e[i*3+1];return[new $e(r,o),new $e(a,l),new $e(c,u)]},generateSideWallUV:function(n,e,t,s,i,r){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[s*3],u=e[s*3+1],h=e[s*3+2],d=e[i*3],p=e[i*3+1],f=e[i*3+2],g=e[r*3],m=e[r*3+1],A=e[r*3+2];return Math.abs(a-u)<Math.abs(o-c)?[new $e(o,1-l),new $e(c,1-h),new $e(d,1-f),new $e(g,1-A)]:[new $e(a,1-l),new $e(u,1-h),new $e(p,1-f),new $e(m,1-A)]}};function DH(n,e,t){if(t.shapes=[],Array.isArray(n))for(let s=0,i=n.length;s<i;s++){const r=n[s];t.shapes.push(r.uuid)}else t.shapes.push(n.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class DI extends oc{constructor(e=1,t=0){const s=(1+Math.sqrt(5))/2,i=[-1,s,0,1,s,0,-1,-s,0,1,-s,0,0,-1,s,0,1,s,0,-1,-s,0,1,-s,s,0,-1,s,0,1,-s,0,-1,-s,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,r,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new DI(e.radius,e.detail)}}class FI extends Xt{constructor(e=[new $e(0,-.5),new $e(.5,0),new $e(0,.5)],t=12,s=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:s,phiLength:i},t=Math.floor(t),i=Ot(i,0,Math.PI*2);const r=[],o=[],a=[],l=[],c=[],u=1/t,h=new U,d=new $e,p=new U,f=new U,g=new U;let m=0,A=0;for(let y=0;y<=e.length-1;y++)switch(y){case 0:m=e[y+1].x-e[y].x,A=e[y+1].y-e[y].y,p.x=A*1,p.y=-m,p.z=A*0,g.copy(p),p.normalize(),l.push(p.x,p.y,p.z);break;case e.length-1:l.push(g.x,g.y,g.z);break;default:m=e[y+1].x-e[y].x,A=e[y+1].y-e[y].y,p.x=A*1,p.y=-m,p.z=A*0,f.copy(p),p.x+=g.x,p.y+=g.y,p.z+=g.z,p.normalize(),l.push(p.x,p.y,p.z),g.copy(f)}for(let y=0;y<=t;y++){const b=s+y*u*i,x=Math.sin(b),C=Math.cos(b);for(let w=0;w<=e.length-1;w++){h.x=e[w].x*x,h.y=e[w].y,h.z=e[w].x*C,o.push(h.x,h.y,h.z),d.x=y/t,d.y=w/(e.length-1),a.push(d.x,d.y);const E=l[3*w+0]*x,T=l[3*w+1],v=l[3*w+0]*C;c.push(E,T,v)}}for(let y=0;y<t;y++)for(let b=0;b<e.length-1;b++){const x=b+y*e.length,C=x,w=x+e.length,E=x+e.length+1,T=x+1;r.push(C,w,T),r.push(E,T,w)}this.setIndex(r),this.setAttribute("position",new gt(o,3)),this.setAttribute("uv",new gt(a,2)),this.setAttribute("normal",new gt(c,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new FI(e.points,e.segments,e.phiStart,e.phiLength)}}class sA extends oc{constructor(e=1,t=0){const s=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(s,i,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new sA(e.radius,e.detail)}}class Qu extends Xt{constructor(e=1,t=1,s=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:s,heightSegments:i};const r=e/2,o=t/2,a=Math.floor(s),l=Math.floor(i),c=a+1,u=l+1,h=e/a,d=t/l,p=[],f=[],g=[],m=[];for(let A=0;A<u;A++){const y=A*d-o;for(let b=0;b<c;b++){const x=b*h-r;f.push(x,-y,0),g.push(0,0,1),m.push(b/a),m.push(1-A/l)}}for(let A=0;A<l;A++)for(let y=0;y<a;y++){const b=y+c*A,x=y+c*(A+1),C=y+1+c*(A+1),w=y+1+c*A;p.push(b,x,w),p.push(x,C,w)}this.setIndex(p),this.setAttribute("position",new gt(f,3)),this.setAttribute("normal",new gt(g,3)),this.setAttribute("uv",new gt(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Qu(e.width,e.height,e.widthSegments,e.heightSegments)}}class $I extends Xt{constructor(e=.5,t=1,s=32,i=1,r=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:s,phiSegments:i,thetaStart:r,thetaLength:o},s=Math.max(3,s),i=Math.max(1,i);const a=[],l=[],c=[],u=[];let h=e;const d=(t-e)/i,p=new U,f=new $e;for(let g=0;g<=i;g++){for(let m=0;m<=s;m++){const A=r+m/s*o;p.x=h*Math.cos(A),p.y=h*Math.sin(A),l.push(p.x,p.y,p.z),c.push(0,0,1),f.x=(p.x/t+1)/2,f.y=(p.y/t+1)/2,u.push(f.x,f.y)}h+=d}for(let g=0;g<i;g++){const m=g*(s+1);for(let A=0;A<s;A++){const y=A+m,b=y,x=y+s+1,C=y+s+2,w=y+1;a.push(b,x,w),a.push(x,C,w)}}this.setIndex(a),this.setAttribute("position",new gt(l,3)),this.setAttribute("normal",new gt(c,3)),this.setAttribute("uv",new gt(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new $I(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class PI extends Xt{constructor(e=new hu([new $e(0,.5),new $e(-.5,-.5),new $e(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const s=[],i=[],r=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(s),this.setAttribute("position",new gt(i,3)),this.setAttribute("normal",new gt(r,3)),this.setAttribute("uv",new gt(o,2));function c(u){const h=i.length/3,d=u.extractPoints(t);let p=d.shape;const f=d.holes;_o.isClockWise(p)===!1&&(p=p.reverse());for(let m=0,A=f.length;m<A;m++){const y=f[m];_o.isClockWise(y)===!0&&(f[m]=y.reverse())}const g=_o.triangulateShape(p,f);for(let m=0,A=f.length;m<A;m++){const y=f[m];p=p.concat(y)}for(let m=0,A=p.length;m<A;m++){const y=p[m];i.push(y.x,y.y,0),r.push(0,0,1),o.push(y.x,y.y)}for(let m=0,A=g.length;m<A;m++){const y=g[m],b=y[0]+h,x=y[1]+h,C=y[2]+h;s.push(b,x,C),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return FH(t,e)}static fromJSON(e,t){const s=[];for(let i=0,r=e.shapes.length;i<r;i++){const o=t[e.shapes[i]];s.push(o)}return new PI(s,e.curveSegments)}}function FH(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,s=n.length;t<s;t++){const i=n[t];e.shapes.push(i.uuid)}else e.shapes.push(n.uuid);return e}class iA extends Xt{constructor(e=1,t=32,s=16,i=0,r=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:s,phiStart:i,phiLength:r,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),s=Math.max(2,Math.floor(s));const l=Math.min(o+a,Math.PI);let c=0;const u=[],h=new U,d=new U,p=[],f=[],g=[],m=[];for(let A=0;A<=s;A++){const y=[],b=A/s;let x=0;A===0&&o===0?x=.5/t:A===s&&l===Math.PI&&(x=-.5/t);for(let C=0;C<=t;C++){const w=C/t;h.x=-e*Math.cos(i+w*r)*Math.sin(o+b*a),h.y=e*Math.cos(o+b*a),h.z=e*Math.sin(i+w*r)*Math.sin(o+b*a),f.push(h.x,h.y,h.z),d.copy(h).normalize(),g.push(d.x,d.y,d.z),m.push(w+x,1-b),y.push(c++)}u.push(y)}for(let A=0;A<s;A++)for(let y=0;y<t;y++){const b=u[A][y+1],x=u[A][y],C=u[A+1][y],w=u[A+1][y+1];(A!==0||o>0)&&p.push(b,x,w),(A!==s-1||l<Math.PI)&&p.push(x,C,w)}this.setIndex(p),this.setAttribute("position",new gt(f,3)),this.setAttribute("normal",new gt(g,3)),this.setAttribute("uv",new gt(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new iA(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class LI extends oc{constructor(e=1,t=0){const s=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(s,i,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new LI(e.radius,e.detail)}}class OI extends Xt{constructor(e=1,t=.4,s=12,i=48,r=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:s,tubularSegments:i,arc:r},s=Math.floor(s),i=Math.floor(i);const o=[],a=[],l=[],c=[],u=new U,h=new U,d=new U;for(let p=0;p<=s;p++)for(let f=0;f<=i;f++){const g=f/i*r,m=p/s*Math.PI*2;h.x=(e+t*Math.cos(m))*Math.cos(g),h.y=(e+t*Math.cos(m))*Math.sin(g),h.z=t*Math.sin(m),a.push(h.x,h.y,h.z),u.x=e*Math.cos(g),u.y=e*Math.sin(g),d.subVectors(h,u).normalize(),l.push(d.x,d.y,d.z),c.push(f/i),c.push(p/s)}for(let p=1;p<=s;p++)for(let f=1;f<=i;f++){const g=(i+1)*p+f-1,m=(i+1)*(p-1)+f-1,A=(i+1)*(p-1)+f,y=(i+1)*p+f;o.push(g,m,y),o.push(m,A,y)}this.setIndex(o),this.setAttribute("position",new gt(a,3)),this.setAttribute("normal",new gt(l,3)),this.setAttribute("uv",new gt(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new OI(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class zI extends Xt{constructor(e=1,t=.4,s=64,i=8,r=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:s,radialSegments:i,p:r,q:o},s=Math.floor(s),i=Math.floor(i);const a=[],l=[],c=[],u=[],h=new U,d=new U,p=new U,f=new U,g=new U,m=new U,A=new U;for(let b=0;b<=s;++b){const x=b/s*r*Math.PI*2;y(x,r,o,e,p),y(x+.01,r,o,e,f),m.subVectors(f,p),A.addVectors(f,p),g.crossVectors(m,A),A.crossVectors(g,m),g.normalize(),A.normalize();for(let C=0;C<=i;++C){const w=C/i*Math.PI*2,E=-t*Math.cos(w),T=t*Math.sin(w);h.x=p.x+(E*A.x+T*g.x),h.y=p.y+(E*A.y+T*g.y),h.z=p.z+(E*A.z+T*g.z),l.push(h.x,h.y,h.z),d.subVectors(h,p).normalize(),c.push(d.x,d.y,d.z),u.push(b/s),u.push(C/i)}}for(let b=1;b<=s;b++)for(let x=1;x<=i;x++){const C=(i+1)*(b-1)+(x-1),w=(i+1)*b+(x-1),E=(i+1)*b+x,T=(i+1)*(b-1)+x;a.push(C,w,T),a.push(w,E,T)}this.setIndex(a),this.setAttribute("position",new gt(l,3)),this.setAttribute("normal",new gt(c,3)),this.setAttribute("uv",new gt(u,2));function y(b,x,C,w,E){const T=Math.cos(b),v=Math.sin(b),S=C/x*b,_=Math.cos(S);E.x=w*(2+_)*.5*T,E.y=w*(2+_)*v*.5,E.z=w*Math.sin(S)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new zI(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class UI extends Xt{constructor(e=new XE(new U(-1,-1,0),new U(-1,1,0),new U(1,1,0)),t=64,s=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:s,radialSegments:i,closed:r};const o=e.computeFrenetFrames(t,r);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new U,l=new U,c=new $e;let u=new U;const h=[],d=[],p=[],f=[];g(),this.setIndex(f),this.setAttribute("position",new gt(h,3)),this.setAttribute("normal",new gt(d,3)),this.setAttribute("uv",new gt(p,2));function g(){for(let b=0;b<t;b++)m(b);m(r===!1?t:0),y(),A()}function m(b){u=e.getPointAt(b/t,u);const x=o.normals[b],C=o.binormals[b];for(let w=0;w<=i;w++){const E=w/i*Math.PI*2,T=Math.sin(E),v=-Math.cos(E);l.x=v*x.x+T*C.x,l.y=v*x.y+T*C.y,l.z=v*x.z+T*C.z,l.normalize(),d.push(l.x,l.y,l.z),a.x=u.x+s*l.x,a.y=u.y+s*l.y,a.z=u.z+s*l.z,h.push(a.x,a.y,a.z)}}function A(){for(let b=1;b<=t;b++)for(let x=1;x<=i;x++){const C=(i+1)*(b-1)+(x-1),w=(i+1)*b+(x-1),E=(i+1)*b+x,T=(i+1)*(b-1)+x;f.push(C,w,T),f.push(w,E,T)}}function y(){for(let b=0;b<=t;b++)for(let x=0;x<=i;x++)c.x=b/t,c.y=x/i,p.push(c.x,c.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new UI(new Bb[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class gF extends Xt{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],s=new Set,i=new U,r=new U;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const h=l[c],d=h.start,p=h.count;for(let f=d,g=d+p;f<g;f+=3)for(let m=0;m<3;m++){const A=a.getX(f+m),y=a.getX(f+(m+1)%3);i.fromBufferAttribute(o,A),r.fromBufferAttribute(o,y),dM(i,r,s)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const u=3*a+c,h=3*a+(c+1)%3;i.fromBufferAttribute(o,u),r.fromBufferAttribute(o,h),dM(i,r,s)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}this.setAttribute("position",new gt(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function dM(n,e,t){const s=`${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;return t.has(s)===!0||t.has(i)===!0?!1:(t.add(s),t.add(i),!0)}var pM=Object.freeze({__proto__:null,BoxGeometry:rc,CapsuleGeometry:BI,CircleGeometry:kI,ConeGeometry:nA,CylinderGeometry:tA,DodecahedronGeometry:MI,EdgesGeometry:oF,ExtrudeGeometry:RI,IcosahedronGeometry:DI,LatheGeometry:FI,OctahedronGeometry:sA,PlaneGeometry:Qu,PolyhedronGeometry:oc,RingGeometry:$I,ShapeGeometry:PI,SphereGeometry:iA,TetrahedronGeometry:LI,TorusGeometry:OI,TorusKnotGeometry:zI,TubeGeometry:UI,WireframeGeometry:gF});class AF extends Li{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new ot(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class rA extends Hr{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class xg extends Li{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new ot(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ic,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Wr,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class yF extends xg{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new $e(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ot(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new ot(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new ot(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new ot(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class xF extends Li{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new ot(16777215),this.specular=new ot(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ic,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Wr,this.combine=jg,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class bF extends Li{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ot(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ic,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class IF extends Li{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ic,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class CF extends Li{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new ot(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ic,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Wr,this.combine=jg,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class KE extends Li{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=F3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class JE extends Li{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}class wF extends Li{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ot(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ic,this.normalScale=new $e(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class vF extends ir{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function Zc(n,e){return!n||n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function SF(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function EF(n){function e(i,r){return n[i]-n[r]}const t=n.length,s=new Array(t);for(let i=0;i!==t;++i)s[i]=i;return s.sort(e),s}function YS(n,e,t){const s=n.length,i=new n.constructor(s);for(let r=0,o=0;o!==s;++r){const a=t[r]*e;for(let l=0;l!==e;++l)i[o++]=n[a+l]}return i}function ZE(n,e,t,s){let i=1,r=n[0];for(;r!==void 0&&r[s]===void 0;)r=n[i++];if(r===void 0)return;let o=r[s];if(o!==void 0)if(Array.isArray(o))do o=r[s],o!==void 0&&(e.push(r.time),t.push(...o)),r=n[i++];while(r!==void 0);else if(o.toArray!==void 0)do o=r[s],o!==void 0&&(e.push(r.time),o.toArray(t,t.length)),r=n[i++];while(r!==void 0);else do o=r[s],o!==void 0&&(e.push(r.time),t.push(o)),r=n[i++];while(r!==void 0)}function $H(n,e,t,s,i=30){const r=n.clone();r.name=e;const o=[];for(let l=0;l<r.tracks.length;++l){const c=r.tracks[l],u=c.getValueSize(),h=[],d=[];for(let p=0;p<c.times.length;++p){const f=c.times[p]*i;if(!(f<t||f>=s)){h.push(c.times[p]);for(let g=0;g<u;++g)d.push(c.values[p*u+g])}}h.length!==0&&(c.times=Zc(h,c.times.constructor),c.values=Zc(d,c.values.constructor),o.push(c))}r.tracks=o;let a=1/0;for(let l=0;l<r.tracks.length;++l)a>r.tracks[l].times[0]&&(a=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*a);return r.resetDuration(),r}function PH(n,e=0,t=n,s=30){s<=0&&(s=30);const i=t.tracks.length,r=e/s;for(let o=0;o<i;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(A){return A.name===a.name&&A.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const p=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);const f=a.times.length-1;let g;if(r<=a.times[0]){const A=u,y=h-u;g=a.values.slice(A,y)}else if(r>=a.times[f]){const A=f*h+u,y=A+h-u;g=a.values.slice(A,y)}else{const A=a.createInterpolant(),y=u,b=h-u;A.evaluate(r),g=A.resultBuffer.slice(y,b)}l==="quaternion"&&new $n().fromArray(g).normalize().conjugate().toArray(g);const m=c.times.length;for(let A=0;A<m;++A){const y=A*p+d;if(l==="quaternion")$n.multiplyQuaternionsFlat(c.values,y,g,0,c.values,y);else{const b=p-d*2;for(let x=0;x<b;++x)c.values[y+x]-=g[x]}}}return n.blendMode=TE,n}class LH{static convertArray(e,t){return Zc(e,t)}static isTypedArray(e){return SF(e)}static getKeyframeOrder(e){return EF(e)}static sortedArray(e,t,s){return YS(e,t,s)}static flattenJSON(e,t,s,i){ZE(e,t,s,i)}static subclip(e,t,s,i,r=30){return $H(e,t,s,i,r)}static makeClipAdditive(e,t=0,s=e,i=30){return PH(e,t,s,i)}}class oA{constructor(e,t,s,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(s),this.sampleValues=t,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let s=this._cachedIndex,i=t[s],r=t[s-1];e:{t:{let o;n:{s:if(!(e<i)){for(let a=s+2;;){if(i===void 0){if(e<r)break s;return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}if(s===a)break;if(r=i,i=t[++s],e<i)break t}o=t.length;break n}if(!(e>=r)){const a=t[1];e<a&&(s=2,r=a);for(let l=s-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===l)break;if(i=r,r=t[--s-1],e>=r)break t}o=s,s=0;break n}break e}for(;s<o;){const a=s+o>>>1;e<t[a]?o=a:s=a+1}if(i=t[s],r=t[s-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}this._cachedIndex=s,this.intervalChanged_(s,r,i)}return this.interpolate_(s,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,r=e*i;for(let o=0;o!==i;++o)t[o]=s[r+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class _F extends oA{constructor(e,t,s,i){super(e,t,s,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:jc,endingEnd:jc}}intervalChanged_(e,t,s){const i=this.parameterPositions;let r=e-2,o=e+1,a=i[r],l=i[o];if(a===void 0)switch(this.getSettings_().endingStart){case Kc:r=e,a=2*t-s;break;case ug:r=i.length-2,a=t+i[r]-i[r+1];break;default:r=e,a=s}if(l===void 0)switch(this.getSettings_().endingEnd){case Kc:o=e,l=2*s-t;break;case ug:o=1,l=s+i[1]-i[0];break;default:o=e-1,l=t}const c=(s-t)*.5,u=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(l-s),this._offsetPrev=r*u,this._offsetNext=o*u}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(s-t)/(i-t),g=f*f,m=g*f,A=-d*m+2*d*g-d*f,y=(1+d)*m+(-1.5-2*d)*g+(-.5+d)*f+1,b=(-1-p)*m+(1.5+p)*g+.5*f,x=p*m-p*g;for(let C=0;C!==a;++C)r[C]=A*o[u+C]+y*o[c+C]+b*o[l+C]+x*o[h+C];return r}}class e2 extends oA{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=(s-t)/(i-t),h=1-u;for(let d=0;d!==a;++d)r[d]=o[c+d]*h+o[l+d]*u;return r}}class TF extends oA{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class po{constructor(e,t,s,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Zc(t,this.TimeBufferType),this.values=Zc(s,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let s;if(t.toJSON!==this.toJSON)s=t.toJSON(e);else{s={name:e.name,times:Zc(e.times,Array),values:Zc(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(s.interpolation=i)}return s.type=e.ValueTypeName,s}InterpolantFactoryMethodDiscrete(e){return new TF(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new e2(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new _F(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case cg:t=this.InterpolantFactoryMethodDiscrete;break;case Eb:t=this.InterpolantFactoryMethodLinear;break;case y0:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return console.warn("THREE.KeyframeTrack:",s),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return cg;case this.InterpolantFactoryMethodLinear:return Eb;case this.InterpolantFactoryMethodSmooth:return y0}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]*=e}return this}trim(e,t){const s=this.times,i=s.length;let r=0,o=i-1;for(;r!==i&&s[r]<e;)++r;for(;o!==-1&&s[o]>t;)--o;if(++o,r!==0||o!==i){r>=o&&(o=Math.max(o,1),r=o-1);const a=this.getValueSize();this.times=s.slice(r,o),this.values=this.values.slice(r*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const s=this.times,i=this.values,r=s.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==r;a++){const l=s[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(i!==void 0&&SF(i))for(let a=0,l=i.length;a!==l;++a){const c=i[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),s=this.getValueSize(),i=this.getInterpolation()===y0,r=e.length-1;let o=1;for(let a=1;a<r;++a){let l=!1;const c=e[a],u=e[a+1];if(c!==u&&(a!==1||c!==e[0]))if(i)l=!0;else{const h=a*s,d=h-s,p=h+s;for(let f=0;f!==s;++f){const g=t[h+f];if(g!==t[d+f]||g!==t[p+f]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const h=a*s,d=o*s;for(let p=0;p!==s;++p)t[d+p]=t[h+p]}++o}}if(r>0){e[o]=e[r];for(let a=r*s,l=o*s,c=0;c!==s;++c)t[l+c]=t[a+c];++o}return o!==e.length?(this.times=e.slice(0,o),this.values=t.slice(0,o*s)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),s=this.constructor,i=new s(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}po.prototype.ValueTypeName="";po.prototype.TimeBufferType=Float32Array;po.prototype.ValueBufferType=Float32Array;po.prototype.DefaultInterpolation=Eb;class Vu extends po{constructor(e,t,s){super(e,t,s)}}Vu.prototype.ValueTypeName="bool";Vu.prototype.ValueBufferType=Array;Vu.prototype.DefaultInterpolation=cg;Vu.prototype.InterpolantFactoryMethodLinear=void 0;Vu.prototype.InterpolantFactoryMethodSmooth=void 0;class t2 extends po{constructor(e,t,s,i){super(e,t,s,i)}}t2.prototype.ValueTypeName="color";class bg extends po{constructor(e,t,s,i){super(e,t,s,i)}}bg.prototype.ValueTypeName="number";class BF extends oA{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(s-t)/(i-t);let c=e*a;for(let u=c+a;c!==u;c+=4)$n.slerpFlat(r,0,o,c-a,o,c,l);return r}}class aA extends po{constructor(e,t,s,i){super(e,t,s,i)}InterpolantFactoryMethodLinear(e){return new BF(this.times,this.values,this.getValueSize(),e)}}aA.prototype.ValueTypeName="quaternion";aA.prototype.InterpolantFactoryMethodSmooth=void 0;class Gu extends po{constructor(e,t,s){super(e,t,s)}}Gu.prototype.ValueTypeName="string";Gu.prototype.ValueBufferType=Array;Gu.prototype.DefaultInterpolation=cg;Gu.prototype.InterpolantFactoryMethodLinear=void 0;Gu.prototype.InterpolantFactoryMethodSmooth=void 0;class Ig extends po{constructor(e,t,s,i){super(e,t,s,i)}}Ig.prototype.ValueTypeName="vector";class Cg{constructor(e="",t=-1,s=[],i=bI){this.name=e,this.tracks=s,this.duration=t,this.blendMode=i,this.uuid=Qr(),this.userData={},this.duration<0&&this.resetDuration()}static parse(e){const t=[],s=e.tracks,i=1/(e.fps||1);for(let o=0,a=s.length;o!==a;++o)t.push(zH(s[o]).scale(i));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r.userData=JSON.parse(e.userData||"{}"),r}static toJSON(e){const t=[],s=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode,userData:JSON.stringify(e.userData)};for(let r=0,o=s.length;r!==o;++r)t.push(po.toJSON(s[r]));return i}static CreateFromMorphTargetSequence(e,t,s,i){const r=t.length,o=[];for(let a=0;a<r;a++){let l=[],c=[];l.push((a+r-1)%r,a,(a+1)%r),c.push(0,1,0);const u=EF(l);l=YS(l,1,u),c=YS(c,1,u),!i&&l[0]===0&&(l.push(r),c.push(c[0])),o.push(new bg(".morphTargetInfluences["+t[a].name+"]",l,c).scale(1/s))}return new this(e,-1,o)}static findByName(e,t){let s=e;if(!Array.isArray(e)){const i=e;s=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<s.length;i++)if(s[i].name===t)return s[i];return null}static CreateClipsFromMorphTargetSequences(e,t,s){const i={},r=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const c=e[a],u=c.name.match(r);if(u&&u.length>1){const h=u[1];let d=i[h];d||(i[h]=d=[]),d.push(c)}}const o=[];for(const a in i)o.push(this.CreateFromMorphTargetSequence(a,i[a],t,s));return o}static parseAnimation(e,t){if(console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const s=function(h,d,p,f,g){if(p.length!==0){const m=[],A=[];ZE(p,m,A,f),m.length!==0&&g.push(new h(d,m,A))}},i=[],r=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let h=0;h<c.length;h++){const d=c[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let g=0;g<d[f].morphTargets.length;g++)p[d[f].morphTargets[g]]=-1;for(const g in p){const m=[],A=[];for(let y=0;y!==d[f].morphTargets.length;++y){const b=d[f];m.push(b.time),A.push(b.morphTarget===g?1:0)}i.push(new bg(".morphTargetInfluence["+g+"]",m,A))}l=p.length*o}else{const p=".bones["+t[h].name+"]";s(Ig,p+".position",d,"pos",i),s(aA,p+".quaternion",d,"rot",i),s(Ig,p+".scale",d,"scl",i)}}return i.length===0?null:new this(r,l,i,a)}resetDuration(){const e=this.tracks;let t=0;for(let s=0,i=e.length;s!==i;++s){const r=this.tracks[s];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let s=0;s<this.tracks.length;s++)e.push(this.tracks[s].clone());const t=new this.constructor(this.name,this.duration,e,this.blendMode);return t.userData=JSON.parse(JSON.stringify(this.userData)),t}toJSON(){return this.constructor.toJSON(this)}}function OH(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return bg;case"vector":case"vector2":case"vector3":case"vector4":return Ig;case"color":return t2;case"quaternion":return aA;case"bool":case"boolean":return Vu;case"string":return Gu}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function zH(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=OH(n.type);if(n.times===void 0){const t=[],s=[];ZE(n.keys,t,s,"value"),n.times=t,n.values=s}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const ca={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class n2{constructor(e,t,s){const i=this;let r=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=s,this.abortController=new AbortController,this.itemStart=function(u){a++,r===!1&&i.onStart!==void 0&&i.onStart(u,o,a),r=!0},this.itemEnd=function(u){o++,i.onProgress!==void 0&&i.onProgress(u,o,a),o===a&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,h){return c.push(u,h),this},this.removeHandler=function(u){const h=c.indexOf(u);return h!==-1&&c.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=c.length;h<d;h+=2){const p=c[h],f=c[h+1];if(p.global&&(p.lastIndex=0),p.test(u))return f}return null},this.abort=function(){return this.abortController.abort(),this.abortController=new AbortController,this}}}const kF=new n2;class rr{constructor(e){this.manager=e!==void 0?e:kF,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const s=this;return new Promise(function(i,r){s.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}abort(){return this}}rr.DEFAULT_MATERIAL_NAME="__DEFAULT";const La={};class UH extends Error{constructor(e,t){super(e),this.response=t}}class ma extends rr{constructor(e){super(e),this.mimeType="",this.responseType="",this._abortController=new AbortController}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=ca.get(`file:${e}`);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(La[e]!==void 0){La[e].push({onLoad:t,onProgress:s,onError:i});return}La[e]=[],La[e].push({onLoad:t,onProgress:s,onError:i});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin",signal:typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal}),a=this.mimeType,l=this.responseType;fetch(o).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const u=La[e],h=c.body.getReader(),d=c.headers.get("X-File-Size")||c.headers.get("Content-Length"),p=d?parseInt(d):0,f=p!==0;let g=0;const m=new ReadableStream({start(A){y();function y(){h.read().then(({done:b,value:x})=>{if(b)A.close();else{g+=x.byteLength;const C=new ProgressEvent("progress",{lengthComputable:f,loaded:g,total:p});for(let w=0,E=u.length;w<E;w++){const T=u[w];T.onProgress&&T.onProgress(C)}A.enqueue(x),y()}},b=>{A.error(b)})}}});return new Response(m)}else throw new UH(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(u=>new DOMParser().parseFromString(u,a));case"json":return c.json();default:if(a==="")return c.text();{const h=/charset="?([^;"\s]*)"?/i.exec(a),d=h&&h[1]?h[1].toLowerCase():void 0,p=new TextDecoder(d);return c.arrayBuffer().then(f=>p.decode(f))}}}).then(c=>{ca.add(`file:${e}`,c);const u=La[e];delete La[e];for(let h=0,d=u.length;h<d;h++){const p=u[h];p.onLoad&&p.onLoad(c)}}).catch(c=>{const u=La[e];if(u===void 0)throw this.manager.itemError(e),c;delete La[e];for(let h=0,d=u.length;h<d;h++){const p=u[h];p.onError&&p.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}class QH extends rr{constructor(e){super(e)}load(e,t,s,i){const r=this,o=new ma(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(r.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},s,i)}parse(e){const t=[];for(let s=0;s<e.length;s++){const i=Cg.parse(e[s]);t.push(i)}return t}}class VH extends rr{constructor(e){super(e)}load(e,t,s,i){const r=this,o=[],a=new TI,l=new ma(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(r.withCredentials);let c=0;function u(h){l.load(e[h],function(d){const p=r.parse(d,!0);o[h]={width:p.width,height:p.height,format:p.format,mipmaps:p.mipmaps},c+=1,c===6&&(p.mipmapCount===1&&(a.minFilter=Os),a.image=o,a.format=p.format,a.needsUpdate=!0,t&&t(a))},s,i)}if(Array.isArray(e))for(let h=0,d=e.length;h<d;++h)u(h);else l.load(e,function(h){const d=r.parse(h,!0);if(d.isCubemap){const p=d.mipmaps.length/d.mipmapCount;for(let f=0;f<p;f++){o[f]={mipmaps:[]};for(let g=0;g<d.mipmapCount;g++)o[f].mipmaps.push(d.mipmaps[f*d.mipmapCount+g]),o[f].format=d.format,o[f].width=d.width,o[f].height=d.height}a.image=o}else a.image.width=d.width,a.image.height=d.height,a.mipmaps=d.mipmaps;d.mipmapCount===1&&(a.minFilter=Os),a.format=d.format,a.needsUpdate=!0,t&&t(a)},s,i);return a}}const vd=new WeakMap;class wg extends rr{constructor(e){super(e)}load(e,t,s,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=ca.get(`image:${e}`);if(o!==void 0){if(o.complete===!0)r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0);else{let h=vd.get(o);h===void 0&&(h=[],vd.set(o,h)),h.push({onLoad:t,onError:i})}return o}const a=fg("img");function l(){u(),t&&t(this);const h=vd.get(this)||[];for(let d=0;d<h.length;d++){const p=h[d];p.onLoad&&p.onLoad(this)}vd.delete(this),r.manager.itemEnd(e)}function c(h){u(),i&&i(h),ca.remove(`image:${e}`);const d=vd.get(this)||[];for(let p=0;p<d.length;p++){const f=d[p];f.onError&&f.onError(h)}vd.delete(this),r.manager.itemError(e),r.manager.itemEnd(e)}function u(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),ca.add(`image:${e}`,a),r.manager.itemStart(e),a.src=e,a}}class GH extends rr{constructor(e){super(e)}load(e,t,s,i){const r=new eA;r.colorSpace=Ei;const o=new wg(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(e[c],function(u){r.images[c]=u,a++,a===6&&(r.needsUpdate=!0,t&&t(r))},void 0,i)}for(let c=0;c<e.length;++c)l(c);return r}}class WH extends rr{constructor(e){super(e)}load(e,t,s,i){const r=this,o=new Mo,a=new ma(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(r.withCredentials),a.load(e,function(l){let c;try{c=r.parse(l)}catch(u){if(i!==void 0)i(u);else{console.error(u);return}}c.image!==void 0?o.image=c.image:c.data!==void 0&&(o.image.width=c.width,o.image.height=c.height,o.image.data=c.data),o.wrapS=c.wrapS!==void 0?c.wrapS:Pr,o.wrapT=c.wrapT!==void 0?c.wrapT:Pr,o.magFilter=c.magFilter!==void 0?c.magFilter:Os,o.minFilter=c.minFilter!==void 0?c.minFilter:Os,o.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.colorSpace!==void 0&&(o.colorSpace=c.colorSpace),c.flipY!==void 0&&(o.flipY=c.flipY),c.format!==void 0&&(o.format=c.format),c.type!==void 0&&(o.type=c.type),c.mipmaps!==void 0&&(o.mipmaps=c.mipmaps,o.minFilter=la),c.mipmapCount===1&&(o.minFilter=Os),c.generateMipmaps!==void 0&&(o.generateMipmaps=c.generateMipmaps),o.needsUpdate=!0,t&&t(o,c)},s,i),o}}class HH extends rr{constructor(e){super(e)}load(e,t,s,i){const r=new cs,o=new wg(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){r.image=a,r.needsUpdate=!0,t!==void 0&&t(r)},s,i),r}}class ac extends un{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new ot(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(t.object.target=this.target.uuid),t}}class MF extends ac{constructor(e,t,s){super(e,s),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(un.DEFAULT_UP),this.updateMatrix(),this.groundColor=new ot(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const Dv=new kt,fM=new U,mM=new U;class s2{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new $e(512,512),this.mapType=Di,this.map=null,this.mapPass=null,this.matrix=new kt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ep,this._frameExtents=new $e(1,1),this._viewportCount=1,this._viewports=[new Yt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,s=this.matrix;fM.setFromMatrixPosition(e.matrixWorld),t.position.copy(fM),mM.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(mM),t.updateMatrixWorld(),Dv.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Dv,t.coordinateSystem,t.reversedDepth),t.reversedDepth?s.set(.5,0,0,.5,0,.5,0,.5,0,0,1,0,0,0,0,1):s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(Dv)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.autoUpdate=e.autoUpdate,this.needsUpdate=e.needsUpdate,this.normalBias=e.normalBias,this.blurSamples=e.blurSamples,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class qH extends s2{constructor(){super(new Es(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(e){const t=this.camera,s=tp*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height*this.aspect,r=e.distance||t.far;(s!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=s,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class NF extends ac{constructor(e,t,s=0,i=Math.PI/3,r=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(un.DEFAULT_UP),this.updateMatrix(),this.target=new un,this.distance=s,this.angle=i,this.penumbra=r,this.decay=o,this.map=null,this.shadow=new qH}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const gM=new kt,Cm=new U,Fv=new U;class YH extends s2{constructor(){super(new Es(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new $e(4,2),this._viewportCount=6,this._viewports=[new Yt(2,1,1,1),new Yt(0,1,1,1),new Yt(3,1,1,1),new Yt(1,1,1,1),new Yt(3,0,1,1),new Yt(1,0,1,1)],this._cubeDirections=[new U(1,0,0),new U(-1,0,0),new U(0,0,1),new U(0,0,-1),new U(0,1,0),new U(0,-1,0)],this._cubeUps=[new U(0,1,0),new U(0,1,0),new U(0,1,0),new U(0,1,0),new U(0,0,1),new U(0,0,-1)]}updateMatrices(e,t=0){const s=this.camera,i=this.matrix,r=e.distance||s.far;r!==s.far&&(s.far=r,s.updateProjectionMatrix()),Cm.setFromMatrixPosition(e.matrixWorld),s.position.copy(Cm),Fv.copy(s.position),Fv.add(this._cubeDirections[t]),s.up.copy(this._cubeUps[t]),s.lookAt(Fv),s.updateMatrixWorld(),i.makeTranslation(-Cm.x,-Cm.y,-Cm.z),gM.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(gM,s.coordinateSystem,s.reversedDepth)}}class RF extends ac{constructor(e,t,s=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=i,this.shadow=new YH}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class lA extends CI{constructor(e=-1,t=1,s=1,i=-1,r=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=s,this.bottom=i,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,s,i,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=s-e,o=s+e,a=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,o=r+c*this.view.width,a-=u*this.view.offsetY,l=a-u*this.view.height}this.projectionMatrix.makeOrthographic(r,o,a,l,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}class XH extends s2{constructor(){super(new lA(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DF extends ac{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(un.DEFAULT_UP),this.updateMatrix(),this.target=new un,this.shadow=new XH}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class i2 extends ac{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class FF extends ac{constructor(e,t,s=10,i=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=s,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class $F{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new U)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const s=e.x,i=e.y,r=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*i),t.addScaledVector(o[2],.488603*r),t.addScaledVector(o[3],.488603*s),t.addScaledVector(o[4],1.092548*(s*i)),t.addScaledVector(o[5],1.092548*(i*r)),t.addScaledVector(o[6],.315392*(3*r*r-1)),t.addScaledVector(o[7],1.092548*(s*r)),t.addScaledVector(o[8],.546274*(s*s-i*i)),t}getIrradianceAt(e,t){const s=e.x,i=e.y,r=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*i),t.addScaledVector(o[2],2*.511664*r),t.addScaledVector(o[3],2*.511664*s),t.addScaledVector(o[4],2*.429043*s*i),t.addScaledVector(o[5],2*.429043*i*r),t.addScaledVector(o[6],.743125*r*r-.247708),t.addScaledVector(o[7],2*.429043*s*r),t.addScaledVector(o[8],.429043*(s*s-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let s=0;s<9;s++)this.coefficients[s].addScaledVector(e.coefficients[s],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let s=0;s<9;s++)this.coefficients[s].lerp(e.coefficients[s],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const s=this.coefficients;for(let i=0;i<9;i++)s[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const s=this.coefficients;for(let i=0;i<9;i++)s[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const s=e.x,i=e.y,r=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*r,t[3]=.488603*s,t[4]=1.092548*s*i,t[5]=1.092548*i*r,t[6]=.315392*(3*r*r-1),t[7]=1.092548*s*r,t[8]=.546274*(s*s-i*i)}}class PF extends ac{constructor(e=new $F,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class QI extends rr{constructor(e){super(e),this.textures={}}load(e,t,s,i){const r=this,o=new ma(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(a){try{t(r.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},s,i)}parse(e){const t=this.textures;function s(r){return t[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),t[r]}const i=this.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new ot().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.dispersion!==void 0&&(i.dispersion=e.dispersion),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(i.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(i.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(i.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(i.depthFunc=e.depthFunc),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(i.blendSrc=e.blendSrc),e.blendDst!==void 0&&(i.blendDst=e.blendDst),e.blendEquation!==void 0&&(i.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(i.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(i.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(i.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&i.blendColor!==void 0&&i.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(i.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==void 0&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(i.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const r in e.uniforms){const o=e.uniforms[r];switch(i.uniforms[r]={},o.type){case"t":i.uniforms[r].value=s(o.value);break;case"c":i.uniforms[r].value=new ot().setHex(o.value);break;case"v2":i.uniforms[r].value=new $e().fromArray(o.value);break;case"v3":i.uniforms[r].value=new U().fromArray(o.value);break;case"v4":i.uniforms[r].value=new Yt().fromArray(o.value);break;case"m3":i.uniforms[r].value=new Ht().fromArray(o.value);break;case"m4":i.uniforms[r].value=new kt().fromArray(o.value);break;default:i.uniforms[r].value=o.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const r in e.extensions)i.extensions[r]=e.extensions[r];if(e.lights!==void 0&&(i.lights=e.lights),e.clipping!==void 0&&(i.clipping=e.clipping),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=s(e.map)),e.matcap!==void 0&&(i.matcap=s(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=s(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=s(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=s(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let r=e.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new $e().fromArray(r)}return e.displacementMap!==void 0&&(i.displacementMap=s(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=s(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=s(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=s(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=s(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=s(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=s(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=s(e.envMap)),e.envMapRotation!==void 0&&i.envMapRotation.fromArray(e.envMapRotation),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=s(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=s(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=s(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=s(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=s(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=s(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new $e().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=s(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=s(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=s(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=s(e.thicknessMap)),e.anisotropyMap!==void 0&&(i.anisotropyMap=s(e.anisotropyMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=s(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=s(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}createMaterialFromType(e){return QI.createMaterialFromType(e)}static createMaterialFromType(e){const t={ShadowMaterial:AF,SpriteMaterial:OE,RawShaderMaterial:rA,ShaderMaterial:Hr,PointsMaterial:UE,MeshPhysicalMaterial:yF,MeshStandardMaterial:xg,MeshPhongMaterial:xF,MeshToonMaterial:bF,MeshNormalMaterial:IF,MeshLambertMaterial:CF,MeshDepthMaterial:KE,MeshDistanceMaterial:JE,MeshBasicMaterial:wa,MeshMatcapMaterial:wF,LineDashedMaterial:vF,LineBasicMaterial:ir,Material:Li};return new t[e]}}class XS{static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class r2 extends Xt{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class LF extends rr{constructor(e){super(e)}load(e,t,s,i){const r=this,o=new ma(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(a){try{t(r.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},s,i)}parse(e){const t={},s={};function i(p,f){if(t[f]!==void 0)return t[f];const m=p.interleavedBuffers[f],A=r(p,m.buffer),y=Ud(m.type,A),b=new SI(y,m.stride);return b.uuid=m.uuid,t[f]=b,b}function r(p,f){if(s[f]!==void 0)return s[f];const m=p.arrayBuffers[f],A=new Uint32Array(m).buffer;return s[f]=A,A}const o=e.isInstancedBufferGeometry?new r2:new Xt,a=e.data.index;if(a!==void 0){const p=Ud(a.type,a.array);o.setIndex(new Sn(p,1))}const l=e.data.attributes;for(const p in l){const f=l[p];let g;if(f.isInterleavedBufferAttribute){const m=i(e.data,f.data);g=new xu(m,f.itemSize,f.offset,f.normalized)}else{const m=Ud(f.type,f.array),A=f.isInstancedBufferAttribute?bu:Sn;g=new A(m,f.itemSize,f.normalized)}f.name!==void 0&&(g.name=f.name),f.usage!==void 0&&g.setUsage(f.usage),o.setAttribute(p,g)}const c=e.data.morphAttributes;if(c)for(const p in c){const f=c[p],g=[];for(let m=0,A=f.length;m<A;m++){const y=f[m];let b;if(y.isInterleavedBufferAttribute){const x=i(e.data,y.data);b=new xu(x,y.itemSize,y.offset,y.normalized)}else{const x=Ud(y.type,y.array);b=new Sn(x,y.itemSize,y.normalized)}y.name!==void 0&&(b.name=y.name),g.push(b)}o.morphAttributes[p]=g}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const h=e.data.groups||e.data.drawcalls||e.data.offsets;if(h!==void 0)for(let p=0,f=h.length;p!==f;++p){const g=h[p];o.addGroup(g.start,g.count,g.materialIndex)}const d=e.data.boundingSphere;return d!==void 0&&(o.boundingSphere=new pi().fromJSON(d)),e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class jH extends rr{constructor(e){super(e)}load(e,t,s,i){const r=this,o=this.path===""?XS.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new ma(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(h){i!==void 0&&i(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const u=c.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}r.parse(c,t)},s,i)}async loadAsync(e,t){const s=this,i=this.path===""?XS.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const r=new ma(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const o=await r.loadAsync(e,t),a=JSON.parse(o),l=a.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await s.parseAsync(a)}parse(e,t){const s=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,i),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,r,l,a,s),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),this.bindLightTargets(c),t!==void 0){let h=!1;for(const d in o)if(o[d].data instanceof HTMLImageElement){h=!0;break}h===!1&&t(c)}return c}async parseAsync(e){const t=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,s),r=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,r),a=this.parseMaterials(e.materials,o),l=this.parseObject(e.object,i,a,o,t),c=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,c),this.bindLightTargets(l),l}parseShapes(e){const t={};if(e!==void 0)for(let s=0,i=e.length;s<i;s++){const r=new hu().fromJSON(e[s]);t[r.uuid]=r}return t}parseSkeletons(e,t){const s={},i={};if(t.traverse(function(r){r.isBone&&(i[r.uuid]=r)}),e!==void 0)for(let r=0,o=e.length;r<o;r++){const a=new EI().fromJSON(e[r],i);s[a.uuid]=a}return s}parseGeometries(e,t){const s={};if(e!==void 0){const i=new LF;for(let r=0,o=e.length;r<o;r++){let a;const l=e[r];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":a=i.parse(l);break;default:l.type in pM?a=pM[l.type].fromJSON(l,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}a.uuid=l.uuid,l.name!==void 0&&(a.name=l.name),l.userData!==void 0&&(a.userData=l.userData),s[l.uuid]=a}}return s}parseMaterials(e,t){const s={},i={};if(e!==void 0){const r=new QI;r.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];s[l.uuid]===void 0&&(s[l.uuid]=r.parse(l)),i[l.uuid]=s[l.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let s=0;s<e.length;s++){const i=e[s],r=Cg.parse(i);t[r.uuid]=r}return t}parseImages(e,t){const s=this,i={};let r;function o(l){return s.manager.itemStart(l),r.load(l,function(){s.manager.itemEnd(l)},void 0,function(){s.manager.itemError(l),s.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:s.resourcePath+c;return o(u)}else return l.data?{data:Ud(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new n2(t);r=new wg(l),r.setCrossOrigin(this.crossOrigin);for(let c=0,u=e.length;c<u;c++){const h=e[c],d=h.url;if(Array.isArray(d)){const p=[];for(let f=0,g=d.length;f<g;f++){const m=d[f],A=a(m);A!==null&&(A instanceof HTMLImageElement?p.push(A):p.push(new Mo(A.data,A.width,A.height)))}i[h.uuid]=new Rl(p)}else{const p=a(h.url);i[h.uuid]=new Rl(p)}}}return i}async parseImagesAsync(e){const t=this,s={};let i;async function r(o){if(typeof o=="string"){const a=o,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:t.resourcePath+a;return await i.loadAsync(l)}else return o.data?{data:Ud(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){i=new wg(this.manager),i.setCrossOrigin(this.crossOrigin);for(let o=0,a=e.length;o<a;o++){const l=e[o],c=l.url;if(Array.isArray(c)){const u=[];for(let h=0,d=c.length;h<d;h++){const p=c[h],f=await r(p);f!==null&&(f instanceof HTMLImageElement?u.push(f):u.push(new Mo(f.data,f.width,f.height)))}s[l.uuid]=new Rl(u)}else{const u=await r(l.url);s[l.uuid]=new Rl(u)}}}return s}parseTextures(e,t){function s(r,o){return typeof r=="number"?r:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",r),o[r])}const i={};if(e!==void 0)for(let r=0,o=e.length;r<o;r++){const a=e[r];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const l=t[a.image],c=l.data;let u;Array.isArray(c)?(u=new eA,c.length===6&&(u.needsUpdate=!0)):(c&&c.data?u=new Mo:u=new cs,c&&(u.needsUpdate=!0)),u.source=l,u.uuid=a.uuid,a.name!==void 0&&(u.name=a.name),a.mapping!==void 0&&(u.mapping=s(a.mapping,KH)),a.channel!==void 0&&(u.channel=a.channel),a.offset!==void 0&&u.offset.fromArray(a.offset),a.repeat!==void 0&&u.repeat.fromArray(a.repeat),a.center!==void 0&&u.center.fromArray(a.center),a.rotation!==void 0&&(u.rotation=a.rotation),a.wrap!==void 0&&(u.wrapS=s(a.wrap[0],AM),u.wrapT=s(a.wrap[1],AM)),a.format!==void 0&&(u.format=a.format),a.internalFormat!==void 0&&(u.internalFormat=a.internalFormat),a.type!==void 0&&(u.type=a.type),a.colorSpace!==void 0&&(u.colorSpace=a.colorSpace),a.minFilter!==void 0&&(u.minFilter=s(a.minFilter,yM)),a.magFilter!==void 0&&(u.magFilter=s(a.magFilter,yM)),a.anisotropy!==void 0&&(u.anisotropy=a.anisotropy),a.flipY!==void 0&&(u.flipY=a.flipY),a.generateMipmaps!==void 0&&(u.generateMipmaps=a.generateMipmaps),a.premultiplyAlpha!==void 0&&(u.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(u.unpackAlignment=a.unpackAlignment),a.compareFunction!==void 0&&(u.compareFunction=a.compareFunction),a.userData!==void 0&&(u.userData=a.userData),i[a.uuid]=u}return i}parseObject(e,t,s,i,r){let o;function a(d){return t[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),t[d]}function l(d){if(d!==void 0){if(Array.isArray(d)){const p=[];for(let f=0,g=d.length;f<g;f++){const m=d[f];s[m]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",m),p.push(s[m])}return p}return s[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),s[d]}}function c(d){return i[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),i[d]}let u,h;switch(e.type){case"Scene":o=new LE,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new ot(e.background):o.background=c(e.background)),e.environment!==void 0&&(o.environment=c(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new vI(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new wI(e.fog.color,e.fog.density)),e.fog.name!==""&&(o.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(o.backgroundIntensity=e.backgroundIntensity),e.backgroundRotation!==void 0&&o.backgroundRotation.fromArray(e.backgroundRotation),e.environmentIntensity!==void 0&&(o.environmentIntensity=e.environmentIntensity),e.environmentRotation!==void 0&&o.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":o=new Es(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new lA(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new i2(e.color,e.intensity);break;case"DirectionalLight":o=new DF(e.color,e.intensity),o.target=e.target||"";break;case"PointLight":o=new RF(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new FF(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new NF(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),o.target=e.target||"";break;case"HemisphereLight":o=new MF(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new PF().fromJSON(e);break;case"SkinnedMesh":u=a(e.geometry),h=l(e.material),o=new tF(u,h),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":u=a(e.geometry),h=l(e.material),o=new On(u,h);break;case"InstancedMesh":u=a(e.geometry),h=l(e.material);const d=e.count,p=e.instanceMatrix,f=e.instanceColor;o=new nF(u,h,d),o.instanceMatrix=new bu(new Float32Array(p.array),16),f!==void 0&&(o.instanceColor=new bu(new Float32Array(f.array),f.itemSize));break;case"BatchedMesh":u=a(e.geometry),h=l(e.material),o=new sF(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,h),o.geometry=u,o.perObjectFrustumCulled=e.perObjectFrustumCulled,o.sortObjects=e.sortObjects,o._drawRanges=e.drawRanges,o._reservedRanges=e.reservedRanges,o._geometryInfo=e.geometryInfo.map(g=>{let m=null,A=null;return g.boundingBox!==void 0&&(m=new Us().fromJSON(g.boundingBox)),g.boundingSphere!==void 0&&(A=new pi().fromJSON(g.boundingSphere)),{...g,boundingBox:m,boundingSphere:A}}),o._instanceInfo=e.instanceInfo,o._availableInstanceIds=e._availableInstanceIds,o._availableGeometryIds=e._availableGeometryIds,o._nextIndexStart=e.nextIndexStart,o._nextVertexStart=e.nextVertexStart,o._geometryCount=e.geometryCount,o._maxInstanceCount=e.maxInstanceCount,o._maxVertexCount=e.maxVertexCount,o._maxIndexCount=e.maxIndexCount,o._geometryInitialized=e.geometryInitialized,o._matricesTexture=c(e.matricesTexture.uuid),o._indirectTexture=c(e.indirectTexture.uuid),e.colorsTexture!==void 0&&(o._colorsTexture=c(e.colorsTexture.uuid)),e.boundingSphere!==void 0&&(o.boundingSphere=new pi().fromJSON(e.boundingSphere)),e.boundingBox!==void 0&&(o.boundingBox=new Us().fromJSON(e.boundingBox));break;case"LOD":o=new eF;break;case"Line":o=new Wl(a(e.geometry),l(e.material));break;case"LineLoop":o=new iF(a(e.geometry),l(e.material));break;case"LineSegments":o=new va(a(e.geometry),l(e.material));break;case"PointCloud":case"Points":o=new rF(a(e.geometry),l(e.material));break;case"Sprite":o=new Z3(l(e.material));break;case"Group":o=new Jc;break;case"Bone":o=new zE;break;default:o=new un}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.up!==void 0&&o.up.fromArray(e.up),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.intensity!==void 0&&(o.shadow.intensity=e.shadow.intensity),e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const d=e.children;for(let p=0;p<d.length;p++)o.add(this.parseObject(d[p],t,s,i,r))}if(e.animations!==void 0){const d=e.animations;for(let p=0;p<d.length;p++){const f=d[p];o.animations.push(r[f])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const d=e.levels;for(let p=0;p<d.length;p++){const f=d[p],g=o.getObjectByProperty("uuid",f.object);g!==void 0&&o.addLevel(g,f.distance,f.hysteresis)}}return o}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(s){if(s.isSkinnedMesh===!0&&s.skeleton!==void 0){const i=t[s.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",s.skeleton):s.bind(i,s.bindMatrix)}})}bindLightTargets(e){e.traverse(function(t){if(t.isDirectionalLight||t.isSpotLight){const s=t.target,i=e.getObjectByProperty("uuid",s);i!==void 0?t.target=i:t.target=new un}})}}const KH={UVMapping:mI,CubeReflectionMapping:el,CubeRefractionMapping:Gl,EquirectangularReflectionMapping:og,EquirectangularRefractionMapping:ag,CubeUVReflectionMapping:wp},AM={RepeatWrapping:Xd,ClampToEdgeWrapping:Pr,MirroredRepeatWrapping:lg},yM={NearestFilter:bs,NearestMipmapNearestFilter:bE,NearestMipmapLinearFilter:zd,LinearFilter:Os,LinearMipmapNearestFilter:Wm,LinearMipmapLinearFilter:la},$v=new WeakMap;class JH extends rr{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"},this._abortController=new AbortController}setOptions(e){return this.options=e,this}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=ca.get(`image-bitmap:${e}`);if(o!==void 0){if(r.manager.itemStart(e),o.then){o.then(c=>{if($v.has(o)===!0)i&&i($v.get(o)),r.manager.itemError(e),r.manager.itemEnd(e);else return t&&t(c),r.manager.itemEnd(e),c});return}return setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o}const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,a.signal=typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal;const l=fetch(e,a).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(c){return ca.add(`image-bitmap:${e}`,c),t&&t(c),r.manager.itemEnd(e),c}).catch(function(c){i&&i(c),$v.set(l,c),ca.remove(`image-bitmap:${e}`),r.manager.itemError(e),r.manager.itemEnd(e)});ca.add(`image-bitmap:${e}`,l),r.manager.itemStart(e)}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}let Qx;class o2{static getContext(){return Qx===void 0&&(Qx=new(window.AudioContext||window.webkitAudioContext)),Qx}static setContext(e){Qx=e}}class ZH extends rr{constructor(e){super(e)}load(e,t,s,i){const r=this,o=new ma(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){try{const c=l.slice(0);o2.getContext().decodeAudioData(c,function(h){t(h)}).catch(a)}catch(c){a(c)}},s,i);function a(l){i?i(l):console.error(l),r.manager.itemError(e)}}}const xM=new kt,bM=new kt,Ec=new kt;class e5{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Es,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Es,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,Ec.copy(e.projectionMatrix);const i=t.eyeSep/2,r=i*t.near/t.focus,o=t.near*Math.tan(uu*t.fov*.5)/t.zoom;let a,l;bM.elements[12]=-i,xM.elements[12]=i,a=-o*t.aspect+r,l=o*t.aspect+r,Ec.elements[0]=2*t.near/(l-a),Ec.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(Ec),a=-o*t.aspect-r,l=o*t.aspect-r,Ec.elements[0]=2*t.near/(l-a),Ec.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(Ec)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(bM),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(xM)}}class OF extends Es{constructor(e=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=e}}class VI{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=performance.now();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}const _c=new U,Pv=new $n,t5=new U,Tc=new U,Bc=new U;class n5 extends un{constructor(){super(),this.type="AudioListener",this.context=o2.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new VI}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(_c,Pv,t5),Tc.set(0,0,-1).applyQuaternion(Pv),Bc.set(0,1,0).applyQuaternion(Pv),t.positionX){const s=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(_c.x,s),t.positionY.linearRampToValueAtTime(_c.y,s),t.positionZ.linearRampToValueAtTime(_c.z,s),t.forwardX.linearRampToValueAtTime(Tc.x,s),t.forwardY.linearRampToValueAtTime(Tc.y,s),t.forwardZ.linearRampToValueAtTime(Tc.z,s),t.upX.linearRampToValueAtTime(Bc.x,s),t.upY.linearRampToValueAtTime(Bc.y,s),t.upZ.linearRampToValueAtTime(Bc.z,s)}else t.setPosition(_c.x,_c.y,_c.z),t.setOrientation(Tc.x,Tc.y,Tc.z,Bc.x,Bc.y,Bc.z)}}class zF extends un{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(e=0){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+e),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}copy(e,t){return super.copy(e,t),e.sourceType!=="buffer"?(console.warn("THREE.Audio: Audio source type cannot be copied."),this):(this.autoplay=e.autoplay,this.buffer=e.buffer,this.detune=e.detune,this.loop=e.loop,this.loopStart=e.loopStart,this.loopEnd=e.loopEnd,this.offset=e.offset,this.duration=e.duration,this.playbackRate=e.playbackRate,this.hasPlaybackControl=e.hasPlaybackControl,this.sourceType=e.sourceType,this.filters=e.filters.slice(),this)}clone(e){return new this.constructor(this.listener).copy(this,e)}}const kc=new U,IM=new $n,s5=new U,Mc=new U;class i5 extends zF{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,s){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=s,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(kc,IM,s5),Mc.set(0,0,1).applyQuaternion(IM);const t=this.panner;if(t.positionX){const s=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(kc.x,s),t.positionY.linearRampToValueAtTime(kc.y,s),t.positionZ.linearRampToValueAtTime(kc.z,s),t.orientationX.linearRampToValueAtTime(Mc.x,s),t.orientationY.linearRampToValueAtTime(Mc.y,s),t.orientationZ.linearRampToValueAtTime(Mc.z,s)}else t.setPosition(kc.x,kc.y,kc.z),t.setOrientation(Mc.x,Mc.y,Mc.z)}}class r5{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let s=0;s<t.length;s++)e+=t[s];return e/t.length}}class UF{constructor(e,t,s){this.binding=e,this.valueSize=s;let i,r,o;switch(t){case"quaternion":i=this._slerp,r=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(s*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(s*5);break;default:i=this._lerp,r=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(s*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const s=this.buffer,i=this.valueSize,r=e*i+i;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==i;++a)s[r+a]=s[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(s,r,0,a,i)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,s=this.valueSize,i=s*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,s),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,s=this.buffer,i=e*t+t,r=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=t*this._origIndex;this._mixBufferRegion(s,i,l,1-r,t)}o>0&&this._mixBufferRegionAdditive(s,i,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(s[l]!==s[l+t]){a.setValue(s,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,s=this.valueSize,i=s*this._origIndex;e.getValue(t,i);for(let r=s,o=i;r!==o;++r)t[r]=t[i+r%s];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let s=e;s<t;s++)this.buffer[s]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let s=0;s<this.valueSize;s++)this.buffer[t+s]=this.buffer[e+s]}_select(e,t,s,i,r){if(i>=.5)for(let o=0;o!==r;++o)e[t+o]=e[s+o]}_slerp(e,t,s,i){$n.slerpFlat(e,t,e,t,e,s,i)}_slerpAdditive(e,t,s,i,r){const o=this._workIndex*r;$n.multiplyQuaternionsFlat(e,o,e,t,e,s),$n.slerpFlat(e,t,e,t,e,o,i)}_lerp(e,t,s,i,r){const o=1-i;for(let a=0;a!==r;++a){const l=t+a;e[l]=e[l]*o+e[s+a]*i}}_lerpAdditive(e,t,s,i,r){for(let o=0;o!==r;++o){const a=t+o;e[a]=e[a]+e[s+o]*i}}}const a2="\\[\\]\\.:\\/",o5=new RegExp("["+a2+"]","g"),l2="[^"+a2+"]",a5="[^"+a2.replace("\\.","")+"]",l5=/((?:WC+[\/:])*)/.source.replace("WC",l2),c5=/(WCOD+)?/.source.replace("WCOD",a5),u5=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",l2),h5=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",l2),d5=new RegExp("^"+l5+c5+u5+h5+"$"),p5=["material","materials","bones","map"];class f5{constructor(e,t,s){const i=s||yn.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const s=this._targetGroup.nCachedObjects_,i=this._bindings[s];i!==void 0&&i.getValue(e,t)}setValue(e,t){const s=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=s.length;i!==r;++i)s[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].unbind()}}class yn{constructor(e,t,s){this.path=t,this.parsedPath=s||yn.parseTrackName(t),this.node=yn.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,s){return e&&e.isAnimationObjectGroup?new yn.Composite(e,t,s):new yn(e,t,s)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(o5,"")}static parseTrackName(e){const t=d5.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const s={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=s.nodeName&&s.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=s.nodeName.substring(i+1);p5.indexOf(r)!==-1&&(s.nodeName=s.nodeName.substring(0,i),s.objectName=r)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return s}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const s=e.skeleton.getBoneByName(t);if(s!==void 0)return s}if(e.children){const s=function(r){for(let o=0;o<r.length;o++){const a=r[o];if(a.name===t||a.uuid===t)return a;const l=s(a.children);if(l)return l}return null},i=s(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)e[t++]=s[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,s=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=yn.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(s){let c=t.objectIndex;switch(s){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[s]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[s]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const o=e[i];if(o===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.isMaterial===!0?a=this.Versioning.NeedsUpdate:e.isObject3D===!0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=r}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}yn.Composite=f5;yn.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};yn.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};yn.prototype.GetterByBindingType=[yn.prototype._getValue_direct,yn.prototype._getValue_array,yn.prototype._getValue_arrayElement,yn.prototype._getValue_toArray];yn.prototype.SetterByBindingTypeAndVersioning=[[yn.prototype._setValue_direct,yn.prototype._setValue_direct_setNeedsUpdate,yn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[yn.prototype._setValue_array,yn.prototype._setValue_array_setNeedsUpdate,yn.prototype._setValue_array_setMatrixWorldNeedsUpdate],[yn.prototype._setValue_arrayElement,yn.prototype._setValue_arrayElement_setNeedsUpdate,yn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[yn.prototype._setValue_fromArray,yn.prototype._setValue_fromArray_setNeedsUpdate,yn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class m5{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Qr(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let s=0,i=arguments.length;s!==i;++s)e[arguments[s].uuid]=s;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,s=this._paths,i=this._parsedPaths,r=this._bindings,o=r.length;let a,l=e.length,c=this.nCachedObjects_;for(let u=0,h=arguments.length;u!==h;++u){const d=arguments[u],p=d.uuid;let f=t[p];if(f===void 0){f=l++,t[p]=f,e.push(d);for(let g=0,m=o;g!==m;++g)r[g].push(new yn(d,s[g],i[g]))}else if(f<c){a=e[f];const g=--c,m=e[g];t[m.uuid]=f,e[f]=m,t[p]=g,e[g]=d;for(let A=0,y=o;A!==y;++A){const b=r[A],x=b[g];let C=b[f];b[f]=x,C===void 0&&(C=new yn(d,s[A],i[A])),b[g]=C}}else e[f]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const e=this._objects,t=this._indicesByUUID,s=this._bindings,i=s.length;let r=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,u=t[c];if(u!==void 0&&u>=r){const h=r++,d=e[h];t[d.uuid]=u,e[u]=d,t[c]=h,e[h]=l;for(let p=0,f=i;p!==f;++p){const g=s[p],m=g[h],A=g[u];g[u]=m,g[h]=A}}}this.nCachedObjects_=r}uncache(){const e=this._objects,t=this._indicesByUUID,s=this._bindings,i=s.length;let r=this.nCachedObjects_,o=e.length;for(let a=0,l=arguments.length;a!==l;++a){const c=arguments[a],u=c.uuid,h=t[u];if(h!==void 0)if(delete t[u],h<r){const d=--r,p=e[d],f=--o,g=e[f];t[p.uuid]=h,e[h]=p,t[g.uuid]=d,e[d]=g,e.pop();for(let m=0,A=i;m!==A;++m){const y=s[m],b=y[d],x=y[f];y[h]=b,y[d]=x,y.pop()}}else{const d=--o,p=e[d];d>0&&(t[p.uuid]=h),e[h]=p,e.pop();for(let f=0,g=i;f!==g;++f){const m=s[f];m[h]=m[d],m.pop()}}}this.nCachedObjects_=r}subscribe_(e,t){const s=this._bindingsIndicesByPath;let i=s[e];const r=this._bindings;if(i!==void 0)return r[i];const o=this._paths,a=this._parsedPaths,l=this._objects,c=l.length,u=this.nCachedObjects_,h=new Array(c);i=r.length,s[e]=i,o.push(e),a.push(t),r.push(h);for(let d=u,p=l.length;d!==p;++d){const f=l[d];h[d]=new yn(f,e,t)}return h}unsubscribe_(e){const t=this._bindingsIndicesByPath,s=t[e];if(s!==void 0){const i=this._paths,r=this._parsedPaths,o=this._bindings,a=o.length-1,l=o[a],c=e[a];t[c]=s,o[s]=l,o.pop(),r[s]=r[a],r.pop(),i[s]=i[a],i.pop()}}}class QF{constructor(e,t,s=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=s,this.blendMode=i;const r=t.tracks,o=r.length,a=new Array(o),l={endingStart:jc,endingEnd:jc};for(let c=0;c!==o;++c){const u=r[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=R3,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,s=!1){if(e.fadeOut(t),this.fadeIn(t),s===!0){const i=this._clip.duration,r=e._clip.duration,o=r/i,a=i/r;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,s=!1){return e.crossFadeFrom(this,t,s)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,s){const i=this._mixer,r=i.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=r,l[1]=r+s,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,s,i){if(!this.enabled){this._updateWeight(e);return}const r=this._startTime;if(r!==null){const l=(e-r)*s;l<0||s===0?t=0:(this._startTime=null,t=s*l)}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case TE:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case bI:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulate(i,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const s=this._weightInterpolant;if(s!==null){const i=s.evaluate(e)[0];t*=i,e>s.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const s=this._timeScaleInterpolant;if(s!==null){const i=s.evaluate(e)[0];t*=i,e>s.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,s=this.loop;let i=this.time+e,r=this._loopCount;const o=s===D3;if(e===0)return r===-1?i:o&&(r&1)===1?t-i:i;if(s===N3){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),i>=t||i<0){const a=Math.floor(i/t);i-=t*a,r+=Math.abs(a);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=i;if(o&&(r&1)===1)return t-i}return i}_setEndings(e,t,s){const i=this._interpolantSettings;s?(i.endingStart=Kc,i.endingEnd=Kc):(e?i.endingStart=this.zeroSlopeAtStart?Kc:jc:i.endingStart=ug,t?i.endingEnd=this.zeroSlopeAtEnd?Kc:jc:i.endingEnd=ug)}_scheduleFading(e,t,s){const i=this._mixer,r=i.time;let o=this._weightInterpolant;o===null&&(o=i._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=r,l[0]=t,a[1]=r+e,l[1]=s,this}}const g5=new Float32Array(1);class A5 extends Ca{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const s=e._localRoot||this._root,i=e._clip.tracks,r=i.length,o=e._propertyBindings,a=e._interpolants,l=s.uuid,c=this._bindingsByRootAndName;let u=c[l];u===void 0&&(u={},c[l]=u);for(let h=0;h!==r;++h){const d=i[h],p=d.name;let f=u[p];if(f!==void 0)++f.referenceCount,o[h]=f;else{if(f=o[h],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,l,p));continue}const g=t&&t._propertyBindings[h].binding.parsedPath;f=new UF(yn.create(s,p,g),d.ValueTypeName,d.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,l,p),o[h]=f}a[h].resultBuffer=f.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const s=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,s)}const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const r=t[s];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const r=t[s];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,s){const i=this._actions,r=this._actionsByClip;let o=r[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=i.length,i.push(e),o.actionByRoot[s]=e}_removeInactiveAction(e){const t=this._actions,s=t[t.length-1],i=e._cacheIndex;s._cacheIndex=i,t[i]=s,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,o=this._actionsByClip,a=o[r],l=a.knownActions,c=l[l.length-1],u=e._byClipCacheIndex;c._byClipCacheIndex=u,l[u]=c,l.pop(),e._byClipCacheIndex=null;const h=a.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],l.length===0&&delete o[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const r=t[s];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(e){const t=this._actions,s=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_takeBackAction(e){const t=this._actions,s=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_addInactiveBinding(e,t,s){const i=this._bindingsByRootAndName,r=this._bindings;let o=i[t];o===void 0&&(o={},i[t]=o),o[s]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){const t=this._bindings,s=e.binding,i=s.rootNode.uuid,r=s.path,o=this._bindingsByRootAndName,a=o[i],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete a[r],Object.keys(a).length===0&&delete o[i]}_lendBinding(e){const t=this._bindings,s=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_takeBackBinding(e){const t=this._bindings,s=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let s=e[t];return s===void 0&&(s=new e2(new Float32Array(2),new Float32Array(2),1,g5),s.__cacheIndex=t,e[t]=s),s}_takeBackControlInterpolant(e){const t=this._controlInterpolants,s=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=s,t[s]=r}clipAction(e,t,s){const i=t||this._root,r=i.uuid;let o=typeof e=="string"?Cg.findByName(i,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let c=null;if(s===void 0&&(o!==null?s=o.blendMode:s=bI),l!==void 0){const h=l.actionByRoot[r];if(h!==void 0&&h.blendMode===s)return h;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const u=new QF(this,o,t,s);return this._bindAction(u,c),this._addInactiveAction(u,a,r),u}existingAction(e,t){const s=t||this._root,i=s.uuid,r=typeof e=="string"?Cg.findByName(s,e):e,o=r?r.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let s=t-1;s>=0;--s)e[s].stop();return this}update(e){e*=this.timeScale;const t=this._actions,s=this._nActiveActions,i=this.time+=e,r=Math.sign(e),o=this._accuIndex^=1;for(let c=0;c!==s;++c)t[c]._update(i,e,r,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,s=e.uuid,i=this._actionsByClip,r=i[s];if(r!==void 0){const o=r.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const u=c._cacheIndex,h=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,h._cacheIndex=u,t[u]=h,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[s]}}uncacheRoot(e){const t=e.uuid,s=this._actionsByClip;for(const o in s){const a=s[o].actionByRoot,l=a[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,r=i[t];if(r!==void 0)for(const o in r){const a=r[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const s=this.existingAction(e,t);s!==null&&(this._deactivateAction(s),this._removeInactiveAction(s))}}class y5 extends NE{constructor(e=1,t=1,s=1,i={}){super(e,t,i),this.isRenderTarget3D=!0,this.depth=s,this.texture=new Zg(null,e,t,s),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class c2{constructor(e){this.value=e}clone(){return new c2(this.value.clone===void 0?this.value:this.value.clone())}}let x5=0;class b5 extends Ca{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:x5++}),this.name="",this.usage=dg,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let s=0,i=t.length;s<i;s++){const r=Array.isArray(t[s])?t[s]:[t[s]];for(let o=0;o<r.length;o++)this.uniforms.push(r[o].clone())}return this}clone(){return new this.constructor().copy(this)}}class I5 extends SI{constructor(e,t,s=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class C5{constructor(e,t,s,i,r,o=!1){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=s,this.elementSize=i,this.count=r,this.normalized=o,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const CM=new kt;class w5{constructor(e,t,s=0,i=1/0){this.ray=new Sp(e,t),this.near=s,this.far=i,this.camera=null,this.layers=new II,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}setFromXRController(e){return CM.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(CM),this}intersectObject(e,t=!0,s=[]){return jS(e,this,s,t),s.sort(wM),s}intersectObjects(e,t=!0,s=[]){for(let i=0,r=e.length;i<r;i++)jS(e[i],this,s,t);return s.sort(wM),s}}function wM(n,e){return n.distance-e.distance}function jS(n,e,t,s){let i=!0;if(n.layers.test(e.layers)&&n.raycast(e,t)===!1&&(i=!1),i===!0&&s===!0){const r=n.children;for(let o=0,a=r.length;o<a;o++)jS(r[o],e,t,!0)}}class v5{constructor(){this._previousTime=0,this._currentTime=0,this._startTime=performance.now(),this._delta=0,this._elapsed=0,this._timescale=1,this._document=null,this._pageVisibilityHandler=null}connect(e){this._document=e,e.hidden!==void 0&&(this._pageVisibilityHandler=S5.bind(this),e.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disconnect(){this._pageVisibilityHandler!==null&&(this._document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this._pageVisibilityHandler=null),this._document=null}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getTimescale(){return this._timescale}setTimescale(e){return this._timescale=e,this}reset(){return this._currentTime=performance.now()-this._startTime,this}dispose(){this.disconnect()}update(e){return this._pageVisibilityHandler!==null&&this._document.hidden===!0?this._delta=0:(this._previousTime=this._currentTime,this._currentTime=(e!==void 0?e:performance.now())-this._startTime,this._delta=(this._currentTime-this._previousTime)*this._timescale,this._elapsed+=this._delta),this}}function S5(){this._document.hidden===!1&&this.reset()}class E5{constructor(e=1,t=0,s=0){this.radius=e,this.phi=t,this.theta=s}set(e,t,s){return this.radius=e,this.phi=t,this.theta=s,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Ot(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+t*t+s*s),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,s),this.phi=Math.acos(Ot(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class _5{constructor(e=1,t=0,s=0){this.radius=e,this.theta=t,this.y=s}set(e,t,s){return this.radius=e,this.theta=t,this.y=s,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+s*s),this.theta=Math.atan2(e,s),this.y=t,this}clone(){return new this.constructor().copy(this)}}class cA{constructor(e,t,s,i){cA.prototype.isMatrix2=!0,this.elements=[1,0,0,1],e!==void 0&&this.set(e,t,s,i)}identity(){return this.set(1,0,0,1),this}fromArray(e,t=0){for(let s=0;s<4;s++)this.elements[s]=e[s+t];return this}set(e,t,s,i){const r=this.elements;return r[0]=e,r[2]=t,r[1]=s,r[3]=i,this}}const vM=new $e;class T5{constructor(e=new $e(1/0,1/0),t=new $e(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=vM.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,vM).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const SM=new U,Vx=new U,Sd=new U,Ed=new U,Lv=new U,B5=new U,k5=new U;class M5{constructor(e=new U,t=new U){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){SM.subVectors(e,this.start),Vx.subVectors(this.end,this.start);const s=Vx.dot(Vx);let r=Vx.dot(SM)/s;return t&&(r=Ot(r,0,1)),r}closestPointToPoint(e,t,s){const i=this.closestPointToPointParameter(e,t);return this.delta(s).multiplyScalar(i).add(this.start)}distanceSqToLine3(e,t=B5,s=k5){const i=10000000000000001e-32;let r,o;const a=this.start,l=e.start,c=this.end,u=e.end;Sd.subVectors(c,a),Ed.subVectors(u,l),Lv.subVectors(a,l);const h=Sd.dot(Sd),d=Ed.dot(Ed),p=Ed.dot(Lv);if(h<=i&&d<=i)return t.copy(a),s.copy(l),t.sub(s),t.dot(t);if(h<=i)r=0,o=p/d,o=Ot(o,0,1);else{const f=Sd.dot(Lv);if(d<=i)o=0,r=Ot(-f/h,0,1);else{const g=Sd.dot(Ed),m=h*d-g*g;m!==0?r=Ot((g*p-f*d)/m,0,1):r=0,o=(g*r+p)/d,o<0?(o=0,r=Ot(-f/h,0,1)):o>1&&(o=1,r=Ot((g-f)/h,0,1))}}return t.copy(a).add(Sd.multiplyScalar(r)),s.copy(l).add(Ed.multiplyScalar(o)),t.sub(s),t.dot(t)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const EM=new U;class N5 extends un{constructor(e,t){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const s=new Xt,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,u=a/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}s.setAttribute("position",new gt(i,3));const r=new ir({fog:!1,toneMapped:!1});this.cone=new va(s,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),EM.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(EM),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const El=new U,Gx=new kt,Ov=new kt;class R5 extends va{constructor(e){const t=VF(e),s=new Xt,i=[],r=[];for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(0,0,0),r.push(0,0,0))}s.setAttribute("position",new gt(i,3)),s.setAttribute("color",new gt(r,3));const o=new ir({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(s,o),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1;const a=new ot(255),l=new ot(65280);this.setColors(a,l)}updateMatrixWorld(e){const t=this.bones,s=this.geometry,i=s.getAttribute("position");Ov.copy(this.root.matrixWorld).invert();for(let r=0,o=0;r<t.length;r++){const a=t[r];a.parent&&a.parent.isBone&&(Gx.multiplyMatrices(Ov,a.matrixWorld),El.setFromMatrixPosition(Gx),i.setXYZ(o,El.x,El.y,El.z),Gx.multiplyMatrices(Ov,a.parent.matrixWorld),El.setFromMatrixPosition(Gx),i.setXYZ(o+1,El.x,El.y,El.z),o+=2)}s.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}setColors(e,t){const i=this.geometry.getAttribute("color");for(let r=0;r<i.count;r+=2)i.setXYZ(r,e.r,e.g,e.b),i.setXYZ(r+1,t.r,t.g,t.b);return i.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}function VF(n){const e=[];n.isBone===!0&&e.push(n);for(let t=0;t<n.children.length;t++)e.push(...VF(n.children[t]));return e}class D5 extends On{constructor(e,t,s){const i=new iA(t,4,2),r=new wa({wireframe:!0,fog:!1,toneMapped:!1});super(i,r),this.light=e,this.color=s,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const F5=new U,_M=new ot,TM=new ot;class $5 extends un{constructor(e,t,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="HemisphereLightHelper";const i=new sA(t);i.rotateY(Math.PI*.5),this.material=new wa({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),o=new Float32Array(r.count*3);i.setAttribute("color",new Sn(o,3)),this.add(new On(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");_M.copy(this.light.color),TM.copy(this.light.groundColor);for(let s=0,i=t.count;s<i;s++){const r=s<i/2?_M:TM;t.setXYZ(s,r.r,r.g,r.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(F5.setFromMatrixPosition(this.light.matrixWorld).negate())}}class P5 extends va{constructor(e=10,t=10,s=4473924,i=8947848){s=new ot(s),i=new ot(i);const r=t/2,o=e/t,a=e/2,l=[],c=[];for(let d=0,p=0,f=-a;d<=t;d++,f+=o){l.push(-a,0,f,a,0,f),l.push(f,0,-a,f,0,a);const g=d===r?s:i;g.toArray(c,p),p+=3,g.toArray(c,p),p+=3,g.toArray(c,p),p+=3,g.toArray(c,p),p+=3}const u=new Xt;u.setAttribute("position",new gt(l,3)),u.setAttribute("color",new gt(c,3));const h=new ir({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class L5 extends va{constructor(e=10,t=16,s=8,i=64,r=4473924,o=8947848){r=new ot(r),o=new ot(o);const a=[],l=[];if(t>1)for(let h=0;h<t;h++){const d=h/t*(Math.PI*2),p=Math.sin(d)*e,f=Math.cos(d)*e;a.push(0,0,0),a.push(p,0,f);const g=h&1?r:o;l.push(g.r,g.g,g.b),l.push(g.r,g.g,g.b)}for(let h=0;h<s;h++){const d=h&1?r:o,p=e-e/s*h;for(let f=0;f<i;f++){let g=f/i*(Math.PI*2),m=Math.sin(g)*p,A=Math.cos(g)*p;a.push(m,0,A),l.push(d.r,d.g,d.b),g=(f+1)/i*(Math.PI*2),m=Math.sin(g)*p,A=Math.cos(g)*p,a.push(m,0,A),l.push(d.r,d.g,d.b)}}const c=new Xt;c.setAttribute("position",new gt(a,3)),c.setAttribute("color",new gt(l,3));const u=new ir({vertexColors:!0,toneMapped:!1});super(c,u),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const BM=new U,Wx=new U,kM=new U;class O5 extends un{constructor(e,t,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="DirectionalLightHelper",t===void 0&&(t=1);let i=new Xt;i.setAttribute("position",new gt([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const r=new ir({fog:!1,toneMapped:!1});this.lightPlane=new Wl(i,r),this.add(this.lightPlane),i=new Xt,i.setAttribute("position",new gt([0,0,0,0,0,1],3)),this.targetLine=new Wl(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),BM.setFromMatrixPosition(this.light.matrixWorld),Wx.setFromMatrixPosition(this.light.target.matrixWorld),kM.subVectors(Wx,BM),this.lightPlane.lookAt(Wx),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Wx),this.targetLine.scale.z=kM.length()}}const Hx=new U,hs=new CI;class z5 extends va{constructor(e){const t=new Xt,s=new ir({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(f,g){l(f),l(g)}function l(f){i.push(0,0,0),r.push(0,0,0),o[f]===void 0&&(o[f]=[]),o[f].push(i.length/3-1)}t.setAttribute("position",new gt(i,3)),t.setAttribute("color",new gt(r,3)),super(t,s),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const c=new ot(16755200),u=new ot(16711680),h=new ot(43775),d=new ot(16777215),p=new ot(3355443);this.setColors(c,u,h,d,p)}setColors(e,t,s,i,r){const a=this.geometry.getAttribute("color");return a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,t.r,t.g,t.b),a.setXYZ(25,t.r,t.g,t.b),a.setXYZ(26,t.r,t.g,t.b),a.setXYZ(27,t.r,t.g,t.b),a.setXYZ(28,t.r,t.g,t.b),a.setXYZ(29,t.r,t.g,t.b),a.setXYZ(30,t.r,t.g,t.b),a.setXYZ(31,t.r,t.g,t.b),a.setXYZ(32,s.r,s.g,s.b),a.setXYZ(33,s.r,s.g,s.b),a.setXYZ(34,s.r,s.g,s.b),a.setXYZ(35,s.r,s.g,s.b),a.setXYZ(36,s.r,s.g,s.b),a.setXYZ(37,s.r,s.g,s.b),a.setXYZ(38,i.r,i.g,i.b),a.setXYZ(39,i.r,i.g,i.b),a.setXYZ(40,r.r,r.g,r.b),a.setXYZ(41,r.r,r.g,r.b),a.setXYZ(42,r.r,r.g,r.b),a.setXYZ(43,r.r,r.g,r.b),a.setXYZ(44,r.r,r.g,r.b),a.setXYZ(45,r.r,r.g,r.b),a.setXYZ(46,r.r,r.g,r.b),a.setXYZ(47,r.r,r.g,r.b),a.setXYZ(48,r.r,r.g,r.b),a.setXYZ(49,r.r,r.g,r.b),a.needsUpdate=!0,this}update(){const e=this.geometry,t=this.pointMap,s=1,i=1;let r,o;if(hs.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),this.camera.reversedDepth===!0)r=1,o=0;else if(this.camera.coordinateSystem===Lr)r=-1,o=1;else if(this.camera.coordinateSystem===ep)r=0,o=1;else throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: "+this.camera.coordinateSystem);gs("c",t,e,hs,0,0,r),gs("t",t,e,hs,0,0,o),gs("n1",t,e,hs,-s,-i,r),gs("n2",t,e,hs,s,-i,r),gs("n3",t,e,hs,-s,i,r),gs("n4",t,e,hs,s,i,r),gs("f1",t,e,hs,-s,-i,o),gs("f2",t,e,hs,s,-i,o),gs("f3",t,e,hs,-s,i,o),gs("f4",t,e,hs,s,i,o),gs("u1",t,e,hs,s*.7,i*1.1,r),gs("u2",t,e,hs,-s*.7,i*1.1,r),gs("u3",t,e,hs,0,i*2,r),gs("cf1",t,e,hs,-s,0,o),gs("cf2",t,e,hs,s,0,o),gs("cf3",t,e,hs,0,-i,o),gs("cf4",t,e,hs,0,i,o),gs("cn1",t,e,hs,-s,0,r),gs("cn2",t,e,hs,s,0,r),gs("cn3",t,e,hs,0,-i,r),gs("cn4",t,e,hs,0,i,r),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function gs(n,e,t,s,i,r,o){Hx.set(i,r,o).unproject(s);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,u=a.length;c<u;c++)l.setXYZ(a[c],Hx.x,Hx.y,Hx.z)}}const qx=new Us;class U5 extends va{constructor(e,t=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new Xt;r.setIndex(new Sn(s,1)),r.setAttribute("position",new Sn(i,3)),super(r,new ir({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(this.object!==void 0&&qx.setFromObject(this.object),qx.isEmpty())return;const e=qx.min,t=qx.max,s=this.geometry.attributes.position,i=s.array;i[0]=t.x,i[1]=t.y,i[2]=t.z,i[3]=e.x,i[4]=t.y,i[5]=t.z,i[6]=e.x,i[7]=e.y,i[8]=t.z,i[9]=t.x,i[10]=e.y,i[11]=t.z,i[12]=t.x,i[13]=t.y,i[14]=e.z,i[15]=e.x,i[16]=t.y,i[17]=e.z,i[18]=e.x,i[19]=e.y,i[20]=e.z,i[21]=t.x,i[22]=e.y,i[23]=e.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Q5 extends va{constructor(e,t=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new Xt;r.setIndex(new Sn(s,1)),r.setAttribute("position",new gt(i,3)),super(r,new ir({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class V5 extends Wl{constructor(e,t=1,s=16776960){const i=s,r=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new Xt;o.setAttribute("position",new gt(r,3)),o.computeBoundingSphere(),super(o,new ir({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new Xt;l.setAttribute("position",new gt(a,3)),l.computeBoundingSphere(),this.add(new On(l,new wa({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const MM=new U;let Yx,zv;class G5 extends un{constructor(e=new U(0,0,1),t=new U(0,0,0),s=1,i=16776960,r=s*.2,o=r*.2){super(),this.type="ArrowHelper",Yx===void 0&&(Yx=new Xt,Yx.setAttribute("position",new gt([0,0,0,0,1,0],3)),zv=new nA(.5,1,5,1),zv.translate(0,-.5,0)),this.position.copy(t),this.line=new Wl(Yx,new ir({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new On(zv,new wa({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(s,r,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{MM.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(MM,t)}}setLength(e,t=e*.2,s=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(s,t,s),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class W5 extends va{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],s=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Xt;i.setAttribute("position",new gt(t,3)),i.setAttribute("color",new gt(s,3));const r=new ir({vertexColors:!0,toneMapped:!1});super(i,r),this.type="AxesHelper"}setColors(e,t,s){const i=new ot,r=this.geometry.attributes.color.array;return i.set(e),i.toArray(r,0),i.toArray(r,3),i.set(t),i.toArray(r,6),i.toArray(r,9),i.set(s),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class H5{constructor(){this.type="ShapePath",this.color=new ot,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new kb,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,s,i){return this.currentPath.quadraticCurveTo(e,t,s,i),this}bezierCurveTo(e,t,s,i,r,o){return this.currentPath.bezierCurveTo(e,t,s,i,r,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(A){const y=[];for(let b=0,x=A.length;b<x;b++){const C=A[b],w=new hu;w.curves=C.curves,y.push(w)}return y}function s(A,y){const b=y.length;let x=!1;for(let C=b-1,w=0;w<b;C=w++){let E=y[C],T=y[w],v=T.x-E.x,S=T.y-E.y;if(Math.abs(S)>Number.EPSILON){if(S<0&&(E=y[w],v=-v,T=y[C],S=-S),A.y<E.y||A.y>T.y)continue;if(A.y===E.y){if(A.x===E.x)return!0}else{const _=S*(A.x-E.x)-v*(A.y-E.y);if(_===0)return!0;if(_<0)continue;x=!x}}else{if(A.y!==E.y)continue;if(T.x<=A.x&&A.x<=E.x||E.x<=A.x&&A.x<=T.x)return!0}}return x}const i=_o.isClockWise,r=this.subPaths;if(r.length===0)return[];let o,a,l;const c=[];if(r.length===1)return a=r[0],l=new hu,l.curves=a.curves,c.push(l),c;let u=!i(r[0].getPoints());u=e?!u:u;const h=[],d=[];let p=[],f=0,g;d[f]=void 0,p[f]=[];for(let A=0,y=r.length;A<y;A++)a=r[A],g=a.getPoints(),o=i(g),o=e?!o:o,o?(!u&&d[f]&&f++,d[f]={s:new hu,p:g},d[f].s.curves=a.curves,u&&f++,p[f]=[]):p[f].push({h:a,p:g[0]});if(!d[0])return t(r);if(d.length>1){let A=!1,y=0;for(let b=0,x=d.length;b<x;b++)h[b]=[];for(let b=0,x=d.length;b<x;b++){const C=p[b];for(let w=0;w<C.length;w++){const E=C[w];let T=!0;for(let v=0;v<d.length;v++)s(E.p,d[v].p)&&(b!==v&&y++,T?(T=!1,h[v].push(E)):A=!0);T&&h[b].push(E)}}y>0&&A===!1&&(p=h)}let m;for(let A=0,y=d.length;A<y;A++){l=d[A].s,c.push(l),m=p[A];for(let b=0,x=m.length;b<x;b++)l.holes.push(m[b].h)}return c}}class q5 extends Ca{constructor(e,t=null){super(),this.object=e,this.domElement=t,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(e){if(e===void 0){console.warn("THREE.Controls: connect() now requires an element.");return}this.domElement!==null&&this.disconnect(),this.domElement=e}disconnect(){}dispose(){}update(){}}function Y5(n,e){const t=n.image&&n.image.width?n.image.width/n.image.height:1;return t>e?(n.repeat.x=1,n.repeat.y=t/e,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2):(n.repeat.x=e/t,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0),n}function X5(n,e){const t=n.image&&n.image.width?n.image.width/n.image.height:1;return t>e?(n.repeat.x=e/t,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0):(n.repeat.x=1,n.repeat.y=t/e,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2),n}function j5(n){return n.repeat.x=1,n.repeat.y=1,n.offset.x=0,n.offset.y=0,n}function KS(n,e,t,s){const i=K5(s);switch(t){case SE:return n*e;case xI:return n*e/i.components*i.byteLength;case Kg:return n*e/i.components*i.byteLength;case _E:return n*e*2/i.components*i.byteLength;case Jg:return n*e*2/i.components*i.byteLength;case EE:return n*e*3/i.components*i.byteLength;case ys:return n*e*4/i.components*i.byteLength;case ha:return n*e*4/i.components*i.byteLength;case Hm:case qm:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case Ym:case Xm:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case Z0:case tb:return Math.max(n,16)*Math.max(e,8)/4;case J0:case eb:return Math.max(n,8)*Math.max(e,8)/2;case nb:case sb:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case ib:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case rb:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case ob:return Math.floor((n+4)/5)*Math.floor((e+3)/4)*16;case ab:return Math.floor((n+4)/5)*Math.floor((e+4)/5)*16;case lb:return Math.floor((n+5)/6)*Math.floor((e+4)/5)*16;case cb:return Math.floor((n+5)/6)*Math.floor((e+5)/6)*16;case ub:return Math.floor((n+7)/8)*Math.floor((e+4)/5)*16;case hb:return Math.floor((n+7)/8)*Math.floor((e+5)/6)*16;case db:return Math.floor((n+7)/8)*Math.floor((e+7)/8)*16;case pb:return Math.floor((n+9)/10)*Math.floor((e+4)/5)*16;case fb:return Math.floor((n+9)/10)*Math.floor((e+5)/6)*16;case mb:return Math.floor((n+9)/10)*Math.floor((e+7)/8)*16;case gb:return Math.floor((n+9)/10)*Math.floor((e+9)/10)*16;case Ab:return Math.floor((n+11)/12)*Math.floor((e+9)/10)*16;case yb:return Math.floor((n+11)/12)*Math.floor((e+11)/12)*16;case xb:case bb:case Ib:return Math.ceil(n/4)*Math.ceil(e/4)*16;case Cb:case wb:return Math.ceil(n/4)*Math.ceil(e/4)*8;case vb:case Sb:return Math.ceil(n/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${t} format.`)}function K5(n){switch(n){case Di:case IE:return{byteLength:1,components:1};case jd:case CE:case vp:return{byteLength:2,components:1};case AI:case yI:return{byteLength:2,components:4};case Ri:case gI:case gr:return{byteLength:4,components:1};case wE:case vE:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${n}.`)}class J5{static contain(e,t){return Y5(e,t)}static cover(e,t){return X5(e,t)}static fill(e){return j5(e)}static getByteLength(e,t,s,i){return KS(e,t,s,i)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:fI}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=fI);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function GF(){let n=null,e=!1,t=null,s=null;function i(r,o){t(r,o),s=n.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(s=n.requestAnimationFrame(i),e=!0)},stop:function(){n.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){n=r}}}function Z5(n){const e=new WeakMap;function t(a,l){const c=a.array,u=a.usage,h=c.byteLength,d=n.createBuffer();n.bindBuffer(l,d),n.bufferData(l,c,u),a.onUploadCallback();let p;if(c instanceof Float32Array)p=n.FLOAT;else if(typeof Float16Array<"u"&&c instanceof Float16Array)p=n.HALF_FLOAT;else if(c instanceof Uint16Array)a.isFloat16BufferAttribute?p=n.HALF_FLOAT:p=n.UNSIGNED_SHORT;else if(c instanceof Int16Array)p=n.SHORT;else if(c instanceof Uint32Array)p=n.UNSIGNED_INT;else if(c instanceof Int32Array)p=n.INT;else if(c instanceof Int8Array)p=n.BYTE;else if(c instanceof Uint8Array)p=n.UNSIGNED_BYTE;else if(c instanceof Uint8ClampedArray)p=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+c);return{buffer:d,type:p,bytesPerElement:c.BYTES_PER_ELEMENT,version:a.version,size:h}}function s(a,l,c){const u=l.array,h=l.updateRanges;if(n.bindBuffer(c,a),h.length===0)n.bufferSubData(c,0,u);else{h.sort((p,f)=>p.start-f.start);let d=0;for(let p=1;p<h.length;p++){const f=h[d],g=h[p];g.start<=f.start+f.count+1?f.count=Math.max(f.count,g.start+g.count-f.start):(++d,h[d]=g)}h.length=d+1;for(let p=0,f=h.length;p<f;p++){const g=h[p];n.bufferSubData(c,g.start*u.BYTES_PER_ELEMENT,u,g.start,g.count)}l.clearUpdateRanges()}l.onUploadCallback()}function i(a){return a.isInterleavedBufferAttribute&&(a=a.data),e.get(a)}function r(a){a.isInterleavedBufferAttribute&&(a=a.data);const l=e.get(a);l&&(n.deleteBuffer(l.buffer),e.delete(a))}function o(a,l){if(a.isInterleavedBufferAttribute&&(a=a.data),a.isGLBufferAttribute){const u=e.get(a);(!u||u.version<a.version)&&e.set(a,{buffer:a.buffer,type:a.type,bytesPerElement:a.elementSize,version:a.version});return}const c=e.get(a);if(c===void 0)e.set(a,t(a,l));else if(c.version<a.version){if(c.size!==a.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");s(c.buffer,a,l),c.version=a.version}}return{get:i,remove:r,update:o}}var eq=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,tq=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,nq=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,sq=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,iq=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,rq=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,oq=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aq=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,lq=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,cq=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,uq=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,hq=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,dq=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,pq=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,fq=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,mq=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,gq=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Aq=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,yq=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,xq=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,bq=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Iq=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,Cq=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,wq=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,vq=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Sq=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Eq=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,_q=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,Tq=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Bq=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,kq="gl_FragColor = linearToOutputTexel( gl_FragColor );",Mq=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,Nq=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Rq=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Dq=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Fq=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,$q=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Pq=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Lq=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Oq=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,zq=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Uq=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,Qq=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Vq=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Gq=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,Wq=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Hq=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,qq=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Yq=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,Xq=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,jq=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,Kq=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,Jq=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Zq=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,e8=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,t8=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,n8=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,s8=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,i8=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,r8=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,o8=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,a8=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,l8=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,c8=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,u8=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,h8=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,d8=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,p8=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,f8=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,m8=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,g8=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,A8=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,y8=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,x8=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,b8=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,I8=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,C8=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,w8=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,v8=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,S8=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,E8=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,_8=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,T8=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,B8=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,k8=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,M8=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,N8=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,R8=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,D8=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,F8=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,$8=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,P8=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,L8=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,O8=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,z8=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,U8=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Q8=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,V8=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,G8=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,W8=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,H8=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,q8=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,Y8=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,X8=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,j8=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,K8=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,J8=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Z8=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,e6=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,t6=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,n6=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,s6=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,i6=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,r6=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,o6=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,a6=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,l6=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,c6=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,u6=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,h6=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,d6=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,p6=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,f6=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,m6=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,g6=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,A6=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,y6=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,x6=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,b6=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,I6=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,C6=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,w6=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,v6=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,S6=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,E6=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_6=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,T6=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,B6=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,k6=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,M6=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,N6=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Kt={alphahash_fragment:eq,alphahash_pars_fragment:tq,alphamap_fragment:nq,alphamap_pars_fragment:sq,alphatest_fragment:iq,alphatest_pars_fragment:rq,aomap_fragment:oq,aomap_pars_fragment:aq,batching_pars_vertex:lq,batching_vertex:cq,begin_vertex:uq,beginnormal_vertex:hq,bsdfs:dq,iridescence_fragment:pq,bumpmap_pars_fragment:fq,clipping_planes_fragment:mq,clipping_planes_pars_fragment:gq,clipping_planes_pars_vertex:Aq,clipping_planes_vertex:yq,color_fragment:xq,color_pars_fragment:bq,color_pars_vertex:Iq,color_vertex:Cq,common:wq,cube_uv_reflection_fragment:vq,defaultnormal_vertex:Sq,displacementmap_pars_vertex:Eq,displacementmap_vertex:_q,emissivemap_fragment:Tq,emissivemap_pars_fragment:Bq,colorspace_fragment:kq,colorspace_pars_fragment:Mq,envmap_fragment:Nq,envmap_common_pars_fragment:Rq,envmap_pars_fragment:Dq,envmap_pars_vertex:Fq,envmap_physical_pars_fragment:Hq,envmap_vertex:$q,fog_vertex:Pq,fog_pars_vertex:Lq,fog_fragment:Oq,fog_pars_fragment:zq,gradientmap_pars_fragment:Uq,lightmap_pars_fragment:Qq,lights_lambert_fragment:Vq,lights_lambert_pars_fragment:Gq,lights_pars_begin:Wq,lights_toon_fragment:qq,lights_toon_pars_fragment:Yq,lights_phong_fragment:Xq,lights_phong_pars_fragment:jq,lights_physical_fragment:Kq,lights_physical_pars_fragment:Jq,lights_fragment_begin:Zq,lights_fragment_maps:e8,lights_fragment_end:t8,logdepthbuf_fragment:n8,logdepthbuf_pars_fragment:s8,logdepthbuf_pars_vertex:i8,logdepthbuf_vertex:r8,map_fragment:o8,map_pars_fragment:a8,map_particle_fragment:l8,map_particle_pars_fragment:c8,metalnessmap_fragment:u8,metalnessmap_pars_fragment:h8,morphinstance_vertex:d8,morphcolor_vertex:p8,morphnormal_vertex:f8,morphtarget_pars_vertex:m8,morphtarget_vertex:g8,normal_fragment_begin:A8,normal_fragment_maps:y8,normal_pars_fragment:x8,normal_pars_vertex:b8,normal_vertex:I8,normalmap_pars_fragment:C8,clearcoat_normal_fragment_begin:w8,clearcoat_normal_fragment_maps:v8,clearcoat_pars_fragment:S8,iridescence_pars_fragment:E8,opaque_fragment:_8,packing:T8,premultiplied_alpha_fragment:B8,project_vertex:k8,dithering_fragment:M8,dithering_pars_fragment:N8,roughnessmap_fragment:R8,roughnessmap_pars_fragment:D8,shadowmap_pars_fragment:F8,shadowmap_pars_vertex:$8,shadowmap_vertex:P8,shadowmask_pars_fragment:L8,skinbase_vertex:O8,skinning_pars_vertex:z8,skinning_vertex:U8,skinnormal_vertex:Q8,specularmap_fragment:V8,specularmap_pars_fragment:G8,tonemapping_fragment:W8,tonemapping_pars_fragment:H8,transmission_fragment:q8,transmission_pars_fragment:Y8,uv_pars_fragment:X8,uv_pars_vertex:j8,uv_vertex:K8,worldpos_vertex:J8,background_vert:Z8,background_frag:e6,backgroundCube_vert:t6,backgroundCube_frag:n6,cube_vert:s6,cube_frag:i6,depth_vert:r6,depth_frag:o6,distanceRGBA_vert:a6,distanceRGBA_frag:l6,equirect_vert:c6,equirect_frag:u6,linedashed_vert:h6,linedashed_frag:d6,meshbasic_vert:p6,meshbasic_frag:f6,meshlambert_vert:m6,meshlambert_frag:g6,meshmatcap_vert:A6,meshmatcap_frag:y6,meshnormal_vert:x6,meshnormal_frag:b6,meshphong_vert:I6,meshphong_frag:C6,meshphysical_vert:w6,meshphysical_frag:v6,meshtoon_vert:S6,meshtoon_frag:E6,points_vert:_6,points_frag:T6,shadow_vert:B6,shadow_frag:k6,sprite_vert:M6,sprite_frag:N6},rt={common:{diffuse:{value:new ot(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Ht},alphaMap:{value:null},alphaMapTransform:{value:new Ht},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Ht}},envmap:{envMap:{value:null},envMapRotation:{value:new Ht},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Ht}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Ht}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Ht},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Ht},normalScale:{value:new $e(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Ht},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Ht}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Ht}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Ht}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ot(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ot(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Ht},alphaTest:{value:0},uvTransform:{value:new Ht}},sprite:{diffuse:{value:new ot(16777215)},opacity:{value:1},center:{value:new $e(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Ht},alphaMap:{value:null},alphaMapTransform:{value:new Ht},alphaTest:{value:0}}},wo={basic:{uniforms:Wi([rt.common,rt.specularmap,rt.envmap,rt.aomap,rt.lightmap,rt.fog]),vertexShader:Kt.meshbasic_vert,fragmentShader:Kt.meshbasic_frag},lambert:{uniforms:Wi([rt.common,rt.specularmap,rt.envmap,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.fog,rt.lights,{emissive:{value:new ot(0)}}]),vertexShader:Kt.meshlambert_vert,fragmentShader:Kt.meshlambert_frag},phong:{uniforms:Wi([rt.common,rt.specularmap,rt.envmap,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.fog,rt.lights,{emissive:{value:new ot(0)},specular:{value:new ot(1118481)},shininess:{value:30}}]),vertexShader:Kt.meshphong_vert,fragmentShader:Kt.meshphong_frag},standard:{uniforms:Wi([rt.common,rt.envmap,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.roughnessmap,rt.metalnessmap,rt.fog,rt.lights,{emissive:{value:new ot(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Kt.meshphysical_vert,fragmentShader:Kt.meshphysical_frag},toon:{uniforms:Wi([rt.common,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.gradientmap,rt.fog,rt.lights,{emissive:{value:new ot(0)}}]),vertexShader:Kt.meshtoon_vert,fragmentShader:Kt.meshtoon_frag},matcap:{uniforms:Wi([rt.common,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.fog,{matcap:{value:null}}]),vertexShader:Kt.meshmatcap_vert,fragmentShader:Kt.meshmatcap_frag},points:{uniforms:Wi([rt.points,rt.fog]),vertexShader:Kt.points_vert,fragmentShader:Kt.points_frag},dashed:{uniforms:Wi([rt.common,rt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Kt.linedashed_vert,fragmentShader:Kt.linedashed_frag},depth:{uniforms:Wi([rt.common,rt.displacementmap]),vertexShader:Kt.depth_vert,fragmentShader:Kt.depth_frag},normal:{uniforms:Wi([rt.common,rt.bumpmap,rt.normalmap,rt.displacementmap,{opacity:{value:1}}]),vertexShader:Kt.meshnormal_vert,fragmentShader:Kt.meshnormal_frag},sprite:{uniforms:Wi([rt.sprite,rt.fog]),vertexShader:Kt.sprite_vert,fragmentShader:Kt.sprite_frag},background:{uniforms:{uvTransform:{value:new Ht},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Kt.background_vert,fragmentShader:Kt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Ht}},vertexShader:Kt.backgroundCube_vert,fragmentShader:Kt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Kt.cube_vert,fragmentShader:Kt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Kt.equirect_vert,fragmentShader:Kt.equirect_frag},distanceRGBA:{uniforms:Wi([rt.common,rt.displacementmap,{referencePosition:{value:new U},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Kt.distanceRGBA_vert,fragmentShader:Kt.distanceRGBA_frag},shadow:{uniforms:Wi([rt.lights,rt.fog,{color:{value:new ot(0)},opacity:{value:1}}]),vertexShader:Kt.shadow_vert,fragmentShader:Kt.shadow_frag}};wo.physical={uniforms:Wi([wo.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Ht},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Ht},clearcoatNormalScale:{value:new $e(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Ht},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Ht},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Ht},sheen:{value:0},sheenColor:{value:new ot(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Ht},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Ht},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Ht},transmissionSamplerSize:{value:new $e},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Ht},attenuationDistance:{value:0},attenuationColor:{value:new ot(0)},specularColor:{value:new ot(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Ht},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Ht},anisotropyVector:{value:new $e},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Ht}}]),vertexShader:Kt.meshphysical_vert,fragmentShader:Kt.meshphysical_frag};const Xx={r:0,b:0,g:0},Nc=new Wr,R6=new kt;function D6(n,e,t,s,i,r,o){const a=new ot(0);let l=r===!0?0:1,c,u,h=null,d=0,p=null;function f(b){let x=b.isScene===!0?b.background:null;return x&&x.isTexture&&(x=(b.backgroundBlurriness>0?t:e).get(x)),x}function g(b){let x=!1;const C=f(b);C===null?A(a,l):C&&C.isColor&&(A(C,1),x=!0);const w=n.xr.getEnvironmentBlendMode();w==="additive"?s.buffers.color.setClear(0,0,0,1,o):w==="alpha-blend"&&s.buffers.color.setClear(0,0,0,0,o),(n.autoClear||x)&&(s.buffers.depth.setTest(!0),s.buffers.depth.setMask(!0),s.buffers.color.setMask(!0),n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil))}function m(b,x){const C=f(x);C&&(C.isCubeTexture||C.mapping===wp)?(u===void 0&&(u=new On(new rc(1,1,1),new Hr({name:"BackgroundCubeMaterial",uniforms:np(wo.backgroundCube.uniforms),vertexShader:wo.backgroundCube.vertexShader,fragmentShader:wo.backgroundCube.fragmentShader,side:ji,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(w,E,T){this.matrixWorld.copyPosition(T.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(u)),Nc.copy(x.backgroundRotation),Nc.x*=-1,Nc.y*=-1,Nc.z*=-1,C.isCubeTexture&&C.isRenderTargetTexture===!1&&(Nc.y*=-1,Nc.z*=-1),u.material.uniforms.envMap.value=C,u.material.uniforms.flipEnvMap.value=C.isCubeTexture&&C.isRenderTargetTexture===!1?-1:1,u.material.uniforms.backgroundBlurriness.value=x.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,u.material.uniforms.backgroundRotation.value.setFromMatrix4(R6.makeRotationFromEuler(Nc)),u.material.toneMapped=gn.getTransfer(C.colorSpace)!==kn,(h!==C||d!==C.version||p!==n.toneMapping)&&(u.material.needsUpdate=!0,h=C,d=C.version,p=n.toneMapping),u.layers.enableAll(),b.unshift(u,u.geometry,u.material,0,0,null)):C&&C.isTexture&&(c===void 0&&(c=new On(new Qu(2,2),new Hr({name:"BackgroundMaterial",uniforms:np(wo.background.uniforms),vertexShader:wo.background.vertexShader,fragmentShader:wo.background.fragmentShader,side:Za,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(c)),c.material.uniforms.t2D.value=C,c.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,c.material.toneMapped=gn.getTransfer(C.colorSpace)!==kn,C.matrixAutoUpdate===!0&&C.updateMatrix(),c.material.uniforms.uvTransform.value.copy(C.matrix),(h!==C||d!==C.version||p!==n.toneMapping)&&(c.material.needsUpdate=!0,h=C,d=C.version,p=n.toneMapping),c.layers.enableAll(),b.unshift(c,c.geometry,c.material,0,0,null))}function A(b,x){b.getRGB(Xx,j3(n)),s.buffers.color.setClear(Xx.r,Xx.g,Xx.b,x,o)}function y(){u!==void 0&&(u.geometry.dispose(),u.material.dispose(),u=void 0),c!==void 0&&(c.geometry.dispose(),c.material.dispose(),c=void 0)}return{getClearColor:function(){return a},setClearColor:function(b,x=1){a.set(b),l=x,A(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(b){l=b,A(a,l)},render:g,addToRenderList:m,dispose:y}}function F6(n,e){const t=n.getParameter(n.MAX_VERTEX_ATTRIBS),s={},i=d(null);let r=i,o=!1;function a(S,_,N,D,P){let L=!1;const z=h(D,N,_);r!==z&&(r=z,c(r.object)),L=p(S,D,N,P),L&&f(S,D,N,P),P!==null&&e.update(P,n.ELEMENT_ARRAY_BUFFER),(L||o)&&(o=!1,x(S,_,N,D),P!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e.get(P).buffer))}function l(){return n.createVertexArray()}function c(S){return n.bindVertexArray(S)}function u(S){return n.deleteVertexArray(S)}function h(S,_,N){const D=N.wireframe===!0;let P=s[S.id];P===void 0&&(P={},s[S.id]=P);let L=P[_.id];L===void 0&&(L={},P[_.id]=L);let z=L[D];return z===void 0&&(z=d(l()),L[D]=z),z}function d(S){const _=[],N=[],D=[];for(let P=0;P<t;P++)_[P]=0,N[P]=0,D[P]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:_,enabledAttributes:N,attributeDivisors:D,object:S,attributes:{},index:null}}function p(S,_,N,D){const P=r.attributes,L=_.attributes;let z=0;const q=N.getAttributes();for(const V in q)if(q[V].location>=0){const te=P[V];let se=L[V];if(se===void 0&&(V==="instanceMatrix"&&S.instanceMatrix&&(se=S.instanceMatrix),V==="instanceColor"&&S.instanceColor&&(se=S.instanceColor)),te===void 0||te.attribute!==se||se&&te.data!==se.data)return!0;z++}return r.attributesNum!==z||r.index!==D}function f(S,_,N,D){const P={},L=_.attributes;let z=0;const q=N.getAttributes();for(const V in q)if(q[V].location>=0){let te=L[V];te===void 0&&(V==="instanceMatrix"&&S.instanceMatrix&&(te=S.instanceMatrix),V==="instanceColor"&&S.instanceColor&&(te=S.instanceColor));const se={};se.attribute=te,te&&te.data&&(se.data=te.data),P[V]=se,z++}r.attributes=P,r.attributesNum=z,r.index=D}function g(){const S=r.newAttributes;for(let _=0,N=S.length;_<N;_++)S[_]=0}function m(S){A(S,0)}function A(S,_){const N=r.newAttributes,D=r.enabledAttributes,P=r.attributeDivisors;N[S]=1,D[S]===0&&(n.enableVertexAttribArray(S),D[S]=1),P[S]!==_&&(n.vertexAttribDivisor(S,_),P[S]=_)}function y(){const S=r.newAttributes,_=r.enabledAttributes;for(let N=0,D=_.length;N<D;N++)_[N]!==S[N]&&(n.disableVertexAttribArray(N),_[N]=0)}function b(S,_,N,D,P,L,z){z===!0?n.vertexAttribIPointer(S,_,N,P,L):n.vertexAttribPointer(S,_,N,D,P,L)}function x(S,_,N,D){g();const P=D.attributes,L=N.getAttributes(),z=_.defaultAttributeValues;for(const q in L){const V=L[q];if(V.location>=0){let X=P[q];if(X===void 0&&(q==="instanceMatrix"&&S.instanceMatrix&&(X=S.instanceMatrix),q==="instanceColor"&&S.instanceColor&&(X=S.instanceColor)),X!==void 0){const te=X.normalized,se=X.itemSize,fe=e.get(X);if(fe===void 0)continue;const me=fe.buffer,Te=fe.type,Ee=fe.bytesPerElement,re=Te===n.INT||Te===n.UNSIGNED_INT||X.gpuType===gI;if(X.isInterleavedBufferAttribute){const ue=X.data,_e=ue.stride,ke=X.offset;if(ue.isInstancedInterleavedBuffer){for(let Ne=0;Ne<V.locationSize;Ne++)A(V.location+Ne,ue.meshPerAttribute);S.isInstancedMesh!==!0&&D._maxInstanceCount===void 0&&(D._maxInstanceCount=ue.meshPerAttribute*ue.count)}else for(let Ne=0;Ne<V.locationSize;Ne++)m(V.location+Ne);n.bindBuffer(n.ARRAY_BUFFER,me);for(let Ne=0;Ne<V.locationSize;Ne++)b(V.location+Ne,se/V.locationSize,Te,te,_e*Ee,(ke+se/V.locationSize*Ne)*Ee,re)}else{if(X.isInstancedBufferAttribute){for(let ue=0;ue<V.locationSize;ue++)A(V.location+ue,X.meshPerAttribute);S.isInstancedMesh!==!0&&D._maxInstanceCount===void 0&&(D._maxInstanceCount=X.meshPerAttribute*X.count)}else for(let ue=0;ue<V.locationSize;ue++)m(V.location+ue);n.bindBuffer(n.ARRAY_BUFFER,me);for(let ue=0;ue<V.locationSize;ue++)b(V.location+ue,se/V.locationSize,Te,te,se*Ee,se/V.locationSize*ue*Ee,re)}}else if(z!==void 0){const te=z[q];if(te!==void 0)switch(te.length){case 2:n.vertexAttrib2fv(V.location,te);break;case 3:n.vertexAttrib3fv(V.location,te);break;case 4:n.vertexAttrib4fv(V.location,te);break;default:n.vertexAttrib1fv(V.location,te)}}}}y()}function C(){T();for(const S in s){const _=s[S];for(const N in _){const D=_[N];for(const P in D)u(D[P].object),delete D[P];delete _[N]}delete s[S]}}function w(S){if(s[S.id]===void 0)return;const _=s[S.id];for(const N in _){const D=_[N];for(const P in D)u(D[P].object),delete D[P];delete _[N]}delete s[S.id]}function E(S){for(const _ in s){const N=s[_];if(N[S.id]===void 0)continue;const D=N[S.id];for(const P in D)u(D[P].object),delete D[P];delete N[S.id]}}function T(){v(),o=!0,r!==i&&(r=i,c(r.object))}function v(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:a,reset:T,resetDefaultState:v,dispose:C,releaseStatesOfGeometry:w,releaseStatesOfProgram:E,initAttributes:g,enableAttribute:m,disableUnusedAttributes:y}}function $6(n,e,t){let s;function i(c){s=c}function r(c,u){n.drawArrays(s,c,u),t.update(u,s,1)}function o(c,u,h){h!==0&&(n.drawArraysInstanced(s,c,u,h),t.update(u,s,h))}function a(c,u,h){if(h===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(s,c,0,u,0,h);let p=0;for(let f=0;f<h;f++)p+=u[f];t.update(p,s,1)}function l(c,u,h,d){if(h===0)return;const p=e.get("WEBGL_multi_draw");if(p===null)for(let f=0;f<c.length;f++)o(c[f],u[f],d[f]);else{p.multiDrawArraysInstancedWEBGL(s,c,0,u,0,d,0,h);let f=0;for(let g=0;g<h;g++)f+=u[g]*d[g];t.update(f,s,1)}}this.setMode=i,this.render=r,this.renderInstances=o,this.renderMultiDraw=a,this.renderMultiDrawInstances=l}function P6(n,e,t,s){let i;function r(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const E=e.get("EXT_texture_filter_anisotropic");i=n.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function o(E){return!(E!==ys&&s.convert(E)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))}function a(E){const T=E===vp&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(E!==Di&&s.convert(E)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE)&&E!==gr&&!T)}function l(E){if(E==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";E="mediump"}return E==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let c=t.precision!==void 0?t.precision:"highp";const u=l(c);u!==c&&(console.warn("THREE.WebGLRenderer:",c,"not supported, using",u,"instead."),c=u);const h=t.logarithmicDepthBuffer===!0,d=t.reversedDepthBuffer===!0&&e.has("EXT_clip_control"),p=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),f=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),g=n.getParameter(n.MAX_TEXTURE_SIZE),m=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),A=n.getParameter(n.MAX_VERTEX_ATTRIBS),y=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),b=n.getParameter(n.MAX_VARYING_VECTORS),x=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),C=f>0,w=n.getParameter(n.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:r,getMaxPrecision:l,textureFormatReadable:o,textureTypeReadable:a,precision:c,logarithmicDepthBuffer:h,reversedDepthBuffer:d,maxTextures:p,maxVertexTextures:f,maxTextureSize:g,maxCubemapSize:m,maxAttributes:A,maxVertexUniforms:y,maxVaryings:b,maxFragmentUniforms:x,vertexTextures:C,maxSamples:w}}function L6(n){const e=this;let t=null,s=0,i=!1,r=!1;const o=new kl,a=new Ht,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d){const p=h.length!==0||d||s!==0||i;return i=d,s=h.length,p},this.beginShadows=function(){r=!0,u(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(h,d){t=u(h,d,0)},this.setState=function(h,d,p){const f=h.clippingPlanes,g=h.clipIntersection,m=h.clipShadows,A=n.get(h);if(!i||f===null||f.length===0||r&&!m)r?u(null):c();else{const y=r?0:s,b=y*4;let x=A.clippingState||null;l.value=x,x=u(f,d,b,p);for(let C=0;C!==b;++C)x[C]=t[C];A.clippingState=x,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=y}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function u(h,d,p,f){const g=h!==null?h.length:0;let m=null;if(g!==0){if(m=l.value,f!==!0||m===null){const A=p+g*4,y=d.matrixWorldInverse;a.getNormalMatrix(y),(m===null||m.length<A)&&(m=new Float32Array(A));for(let b=0,x=p;b!==g;++b,x+=4)o.copy(h[b]).applyMatrix4(y,a),o.normal.toArray(m,x),m[x+3]=o.constant}l.value=m,l.needsUpdate=!0}return e.numPlanes=g,e.numIntersection=0,m}}function O6(n){let e=new WeakMap;function t(o,a){return a===og?o.mapping=el:a===ag&&(o.mapping=Gl),o}function s(o){if(o&&o.isTexture){const a=o.mapping;if(a===og||a===ag)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new PE(l.height);return c.fromEquirectangularTexture(n,o),e.set(o,c),o.addEventListener("dispose",i),t(c.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function r(){e=new WeakMap}return{get:s,dispose:r}}const Qd=4,NM=[.125,.215,.35,.446,.526,.582],Qc=20,Uv=new lA,RM=new ot;let Qv=null,Vv=0,Gv=0,Wv=!1;const Pc=(1+Math.sqrt(5))/2,_d=1/Pc,DM=[new U(-Pc,_d,0),new U(Pc,_d,0),new U(-_d,0,Pc),new U(_d,0,Pc),new U(0,Pc,-_d),new U(0,Pc,_d),new U(-1,1,-1),new U(1,1,-1),new U(-1,1,1),new U(1,1,1)],z6=new U;class Mb{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,s=.1,i=100,r={}){const{size:o=256,position:a=z6}=r;Qv=this._renderer.getRenderTarget(),Vv=this._renderer.getActiveCubeFace(),Gv=this._renderer.getActiveMipmapLevel(),Wv=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(o);const l=this._allocateTargets();return l.depthBuffer=!0,this._sceneToCubeUV(e,s,i,l,a),t>0&&this._blur(l,0,0,t),this._applyPMREM(l),this._cleanup(l),l}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=PM(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=$M(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Qv,Vv,Gv),this._renderer.xr.enabled=Wv,e.scissorTest=!1,jx(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===el||e.mapping===Gl?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Qv=this._renderer.getRenderTarget(),Vv=this._renderer.getActiveCubeFace(),Gv=this._renderer.getActiveMipmapLevel(),Wv=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const s=t||this._allocateTargets();return this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,s={magFilter:Os,minFilter:Os,generateMipmaps:!1,type:vp,format:ys,colorSpace:yu,depthBuffer:!1},i=FM(e,t,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=FM(e,t,s);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=U6(r)),this._blurMaterial=Q6(r,e,t)}return i}_compileMaterial(e){const t=new On(this._lodPlanes[0],e);this._renderer.compile(t,Uv)}_sceneToCubeUV(e,t,s,i,r){const l=new Es(90,1,t,s),c=[1,-1,1,1,1,1],u=[1,1,1,-1,-1,-1],h=this._renderer,d=h.autoClear,p=h.toneMapping;h.getClearColor(RM),h.toneMapping=Ya,h.autoClear=!1,h.state.buffers.depth.getReversed()&&(h.setRenderTarget(i),h.clearDepth(),h.setRenderTarget(null));const g=new wa({name:"PMREM.Background",side:ji,depthWrite:!1,depthTest:!1}),m=new On(new rc,g);let A=!1;const y=e.background;y?y.isColor&&(g.color.copy(y),e.background=null,A=!0):(g.color.copy(RM),A=!0);for(let b=0;b<6;b++){const x=b%3;x===0?(l.up.set(0,c[b],0),l.position.set(r.x,r.y,r.z),l.lookAt(r.x+u[b],r.y,r.z)):x===1?(l.up.set(0,0,c[b]),l.position.set(r.x,r.y,r.z),l.lookAt(r.x,r.y+u[b],r.z)):(l.up.set(0,c[b],0),l.position.set(r.x,r.y,r.z),l.lookAt(r.x,r.y,r.z+u[b]));const C=this._cubeSize;jx(i,x*C,b>2?C:0,C,C),h.setRenderTarget(i),A&&h.render(m,l),h.render(e,l)}m.geometry.dispose(),m.material.dispose(),h.toneMapping=p,h.autoClear=d,e.background=y}_textureToCubeUV(e,t){const s=this._renderer,i=e.mapping===el||e.mapping===Gl;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=PM()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=$M());const r=i?this._cubemapMaterial:this._equirectMaterial,o=new On(this._lodPlanes[0],r),a=r.uniforms;a.envMap.value=e;const l=this._cubeSize;jx(t,0,0,3*l,2*l),s.setRenderTarget(t),s.render(o,Uv)}_applyPMREM(e){const t=this._renderer,s=t.autoClear;t.autoClear=!1;const i=this._lodPlanes.length;for(let r=1;r<i;r++){const o=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),a=DM[(i-r-1)%DM.length];this._blur(e,r-1,r,o,a)}t.autoClear=s}_blur(e,t,s,i,r){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,s,i,"latitudinal",r),this._halfBlur(o,e,s,s,i,"longitudinal",r)}_halfBlur(e,t,s,i,r,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new On(this._lodPlanes[i],c),d=c.uniforms,p=this._sizeLods[s]-1,f=isFinite(r)?Math.PI/(2*p):2*Math.PI/(2*Qc-1),g=r/f,m=isFinite(r)?1+Math.floor(u*g):Qc;m>Qc&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Qc}`);const A=[];let y=0;for(let E=0;E<Qc;++E){const T=E/g,v=Math.exp(-T*T/2);A.push(v),E===0?y+=v:E<m&&(y+=2*v)}for(let E=0;E<A.length;E++)A[E]=A[E]/y;d.envMap.value=e.texture,d.samples.value=m,d.weights.value=A,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:b}=this;d.dTheta.value=f,d.mipInt.value=b-s;const x=this._sizeLods[i],C=3*x*(i>b-Qd?i-b+Qd:0),w=4*(this._cubeSize-x);jx(t,C,w,3*x,2*x),l.setRenderTarget(t),l.render(h,Uv)}}function U6(n){const e=[],t=[],s=[];let i=n;const r=n-Qd+1+NM.length;for(let o=0;o<r;o++){const a=Math.pow(2,i);t.push(a);let l=1/a;o>n-Qd?l=NM[o-n+Qd-1]:o===0&&(l=0),s.push(l);const c=1/(a-2),u=-c,h=1+c,d=[u,u,h,u,h,h,u,u,h,h,u,h],p=6,f=6,g=3,m=2,A=1,y=new Float32Array(g*f*p),b=new Float32Array(m*f*p),x=new Float32Array(A*f*p);for(let w=0;w<p;w++){const E=w%3*2/3-1,T=w>2?0:-1,v=[E,T,0,E+2/3,T,0,E+2/3,T+1,0,E,T,0,E+2/3,T+1,0,E,T+1,0];y.set(v,g*f*w),b.set(d,m*f*w);const S=[w,w,w,w,w,w];x.set(S,A*f*w)}const C=new Xt;C.setAttribute("position",new Sn(y,g)),C.setAttribute("uv",new Sn(b,m)),C.setAttribute("faceIndex",new Sn(x,A)),e.push(C),i>Qd&&i--}return{lodPlanes:e,sizeLods:t,sigmas:s}}function FM(n,e,t){const s=new ao(n,e,t);return s.texture.mapping=wp,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function jx(n,e,t,s,i){n.viewport.set(e,t,s,i),n.scissor.set(e,t,s,i)}function Q6(n,e,t){const s=new Float32Array(Qc),i=new U(0,1,0);return new Hr({name:"SphericalGaussianBlur",defines:{n:Qc,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:u2(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:qa,depthTest:!1,depthWrite:!1})}function $M(){return new Hr({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:u2(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:qa,depthTest:!1,depthWrite:!1})}function PM(){return new Hr({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:u2(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:qa,depthTest:!1,depthWrite:!1})}function u2(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function V6(n){let e=new WeakMap,t=null;function s(a){if(a&&a.isTexture){const l=a.mapping,c=l===og||l===ag,u=l===el||l===Gl;if(c||u){let h=e.get(a);const d=h!==void 0?h.texture.pmremVersion:0;if(a.isRenderTargetTexture&&a.pmremVersion!==d)return t===null&&(t=new Mb(n)),h=c?t.fromEquirectangular(a,h):t.fromCubemap(a,h),h.texture.pmremVersion=a.pmremVersion,e.set(a,h),h.texture;if(h!==void 0)return h.texture;{const p=a.image;return c&&p&&p.height>0||u&&p&&i(p)?(t===null&&(t=new Mb(n)),h=c?t.fromEquirectangular(a):t.fromCubemap(a),h.texture.pmremVersion=a.pmremVersion,e.set(a,h),a.addEventListener("dispose",r),h.texture):null}}}return a}function i(a){let l=0;const c=6;for(let u=0;u<c;u++)a[u]!==void 0&&l++;return l===c}function r(a){const l=a.target;l.removeEventListener("dispose",r);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:s,dispose:o}}function G6(n){const e={};function t(s){if(e[s]!==void 0)return e[s];let i;switch(s){case"WEBGL_depth_texture":i=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=n.getExtension(s)}return e[s]=i,i}return{has:function(s){return t(s)!==null},init:function(){t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance"),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture"),t("WEBGL_render_shared_exponent")},get:function(s){const i=t(s);return i===null&&mg("THREE.WebGLRenderer: "+s+" extension not supported."),i}}}function W6(n,e,t,s){const i={},r=new WeakMap;function o(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const f in d.attributes)e.remove(d.attributes[f]);d.removeEventListener("dispose",o),delete i[d.id];const p=r.get(d);p&&(e.remove(p),r.delete(d)),s.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(h,d){return i[d.id]===!0||(d.addEventListener("dispose",o),i[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const p in d)e.update(d[p],n.ARRAY_BUFFER)}function c(h){const d=[],p=h.index,f=h.attributes.position;let g=0;if(p!==null){const y=p.array;g=p.version;for(let b=0,x=y.length;b<x;b+=3){const C=y[b+0],w=y[b+1],E=y[b+2];d.push(C,w,w,E,E,C)}}else if(f!==void 0){const y=f.array;g=f.version;for(let b=0,x=y.length/3-1;b<x;b+=3){const C=b+0,w=b+1,E=b+2;d.push(C,w,w,E,E,C)}}else return;const m=new(H3(d)?FE:DE)(d,1);m.version=g;const A=r.get(h);A&&e.remove(A),r.set(h,m)}function u(h){const d=r.get(h);if(d){const p=h.index;p!==null&&d.version<p.version&&c(h)}else c(h);return r.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function H6(n,e,t){let s;function i(d){s=d}let r,o;function a(d){r=d.type,o=d.bytesPerElement}function l(d,p){n.drawElements(s,p,r,d*o),t.update(p,s,1)}function c(d,p,f){f!==0&&(n.drawElementsInstanced(s,p,r,d*o,f),t.update(p,s,f))}function u(d,p,f){if(f===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(s,p,0,r,d,0,f);let m=0;for(let A=0;A<f;A++)m+=p[A];t.update(m,s,1)}function h(d,p,f,g){if(f===0)return;const m=e.get("WEBGL_multi_draw");if(m===null)for(let A=0;A<d.length;A++)c(d[A]/o,p[A],g[A]);else{m.multiDrawElementsInstancedWEBGL(s,p,0,r,d,0,g,0,f);let A=0;for(let y=0;y<f;y++)A+=p[y]*g[y];t.update(A,s,1)}}this.setMode=i,this.setIndex=a,this.render=l,this.renderInstances=c,this.renderMultiDraw=u,this.renderMultiDrawInstances=h}function q6(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function s(r,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(r/3);break;case n.LINES:t.lines+=a*(r/2);break;case n.LINE_STRIP:t.lines+=a*(r-1);break;case n.LINE_LOOP:t.lines+=a*r;break;case n.POINTS:t.points+=a*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:s}}function Y6(n,e,t){const s=new WeakMap,i=new Yt;function r(o,a,l){const c=o.morphTargetInfluences,u=a.morphAttributes.position||a.morphAttributes.normal||a.morphAttributes.color,h=u!==void 0?u.length:0;let d=s.get(a);if(d===void 0||d.count!==h){let v=function(){E.dispose(),s.delete(a),a.removeEventListener("dispose",v)};d!==void 0&&d.texture.dispose();const p=a.morphAttributes.position!==void 0,f=a.morphAttributes.normal!==void 0,g=a.morphAttributes.color!==void 0,m=a.morphAttributes.position||[],A=a.morphAttributes.normal||[],y=a.morphAttributes.color||[];let b=0;p===!0&&(b=1),f===!0&&(b=2),g===!0&&(b=3);let x=a.attributes.position.count*b,C=1;x>e.maxTextureSize&&(C=Math.ceil(x/e.maxTextureSize),x=e.maxTextureSize);const w=new Float32Array(x*C*4*h),E=new ko(w,x,C,h);E.type=gr,E.needsUpdate=!0;const T=b*4;for(let S=0;S<h;S++){const _=m[S],N=A[S],D=y[S],P=x*C*4*S;for(let L=0;L<_.count;L++){const z=L*T;p===!0&&(i.fromBufferAttribute(_,L),w[P+z+0]=i.x,w[P+z+1]=i.y,w[P+z+2]=i.z,w[P+z+3]=0),f===!0&&(i.fromBufferAttribute(N,L),w[P+z+4]=i.x,w[P+z+5]=i.y,w[P+z+6]=i.z,w[P+z+7]=0),g===!0&&(i.fromBufferAttribute(D,L),w[P+z+8]=i.x,w[P+z+9]=i.y,w[P+z+10]=i.z,w[P+z+11]=D.itemSize===4?i.w:1)}}d={count:h,texture:E,size:new $e(x,C)},s.set(a,d),a.addEventListener("dispose",v)}if(o.isInstancedMesh===!0&&o.morphTexture!==null)l.getUniforms().setValue(n,"morphTexture",o.morphTexture,t);else{let p=0;for(let g=0;g<c.length;g++)p+=c[g];const f=a.morphTargetsRelative?1:1-p;l.getUniforms().setValue(n,"morphTargetBaseInfluence",f),l.getUniforms().setValue(n,"morphTargetInfluences",c)}l.getUniforms().setValue(n,"morphTargetsTexture",d.texture,t),l.getUniforms().setValue(n,"morphTargetsTextureSize",d.size)}return{update:r}}function X6(n,e,t,s){let i=new WeakMap;function r(l){const c=s.render.frame,u=l.geometry,h=e.get(l,u);if(i.get(h)!==c&&(e.update(h),i.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),i.get(l)!==c&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),i.set(l,c))),l.isSkinnedMesh){const d=l.skeleton;i.get(d)!==c&&(d.update(),i.set(d,c))}return h}function o(){i=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:r,dispose:o}}const WF=new cs,LM=new VE(1,1),HF=new ko,qF=new Zg,YF=new eA,OM=[],zM=[],UM=new Float32Array(16),QM=new Float32Array(9),VM=new Float32Array(4);function _p(n,e,t){const s=n[0];if(s<=0||s>0)return n;const i=e*t;let r=OM[i];if(r===void 0&&(r=new Float32Array(i),OM[i]=r),e!==0){s.toArray(r,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(r,a)}return r}function Vs(n,e){if(n.length!==e.length)return!1;for(let t=0,s=n.length;t<s;t++)if(n[t]!==e[t])return!1;return!0}function Gs(n,e){for(let t=0,s=e.length;t<s;t++)n[t]=e[t]}function GI(n,e){let t=zM[e];t===void 0&&(t=new Int32Array(e),zM[e]=t);for(let s=0;s!==e;++s)t[s]=n.allocateTextureUnit();return t}function j6(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function K6(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Vs(t,e))return;n.uniform2fv(this.addr,e),Gs(t,e)}}function J6(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Vs(t,e))return;n.uniform3fv(this.addr,e),Gs(t,e)}}function Z6(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Vs(t,e))return;n.uniform4fv(this.addr,e),Gs(t,e)}}function eY(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Vs(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Gs(t,e)}else{if(Vs(t,s))return;VM.set(s),n.uniformMatrix2fv(this.addr,!1,VM),Gs(t,s)}}function tY(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Vs(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Gs(t,e)}else{if(Vs(t,s))return;QM.set(s),n.uniformMatrix3fv(this.addr,!1,QM),Gs(t,s)}}function nY(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Vs(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Gs(t,e)}else{if(Vs(t,s))return;UM.set(s),n.uniformMatrix4fv(this.addr,!1,UM),Gs(t,s)}}function sY(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function iY(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Vs(t,e))return;n.uniform2iv(this.addr,e),Gs(t,e)}}function rY(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Vs(t,e))return;n.uniform3iv(this.addr,e),Gs(t,e)}}function oY(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Vs(t,e))return;n.uniform4iv(this.addr,e),Gs(t,e)}}function aY(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function lY(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Vs(t,e))return;n.uniform2uiv(this.addr,e),Gs(t,e)}}function cY(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Vs(t,e))return;n.uniform3uiv(this.addr,e),Gs(t,e)}}function uY(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Vs(t,e))return;n.uniform4uiv(this.addr,e),Gs(t,e)}}function hY(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i);let r;this.type===n.SAMPLER_2D_SHADOW?(LM.compareFunction=BE,r=LM):r=WF,t.setTexture2D(e||r,i)}function dY(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture3D(e||qF,i)}function pY(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTextureCube(e||YF,i)}function fY(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture2DArray(e||HF,i)}function mY(n){switch(n){case 5126:return j6;case 35664:return K6;case 35665:return J6;case 35666:return Z6;case 35674:return eY;case 35675:return tY;case 35676:return nY;case 5124:case 35670:return sY;case 35667:case 35671:return iY;case 35668:case 35672:return rY;case 35669:case 35673:return oY;case 5125:return aY;case 36294:return lY;case 36295:return cY;case 36296:return uY;case 35678:case 36198:case 36298:case 36306:case 35682:return hY;case 35679:case 36299:case 36307:return dY;case 35680:case 36300:case 36308:case 36293:return pY;case 36289:case 36303:case 36311:case 36292:return fY}}function gY(n,e){n.uniform1fv(this.addr,e)}function AY(n,e){const t=_p(e,this.size,2);n.uniform2fv(this.addr,t)}function yY(n,e){const t=_p(e,this.size,3);n.uniform3fv(this.addr,t)}function xY(n,e){const t=_p(e,this.size,4);n.uniform4fv(this.addr,t)}function bY(n,e){const t=_p(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function IY(n,e){const t=_p(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function CY(n,e){const t=_p(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function wY(n,e){n.uniform1iv(this.addr,e)}function vY(n,e){n.uniform2iv(this.addr,e)}function SY(n,e){n.uniform3iv(this.addr,e)}function EY(n,e){n.uniform4iv(this.addr,e)}function _Y(n,e){n.uniform1uiv(this.addr,e)}function TY(n,e){n.uniform2uiv(this.addr,e)}function BY(n,e){n.uniform3uiv(this.addr,e)}function kY(n,e){n.uniform4uiv(this.addr,e)}function MY(n,e,t){const s=this.cache,i=e.length,r=GI(t,i);Vs(s,r)||(n.uniform1iv(this.addr,r),Gs(s,r));for(let o=0;o!==i;++o)t.setTexture2D(e[o]||WF,r[o])}function NY(n,e,t){const s=this.cache,i=e.length,r=GI(t,i);Vs(s,r)||(n.uniform1iv(this.addr,r),Gs(s,r));for(let o=0;o!==i;++o)t.setTexture3D(e[o]||qF,r[o])}function RY(n,e,t){const s=this.cache,i=e.length,r=GI(t,i);Vs(s,r)||(n.uniform1iv(this.addr,r),Gs(s,r));for(let o=0;o!==i;++o)t.setTextureCube(e[o]||YF,r[o])}function DY(n,e,t){const s=this.cache,i=e.length,r=GI(t,i);Vs(s,r)||(n.uniform1iv(this.addr,r),Gs(s,r));for(let o=0;o!==i;++o)t.setTexture2DArray(e[o]||HF,r[o])}function FY(n){switch(n){case 5126:return gY;case 35664:return AY;case 35665:return yY;case 35666:return xY;case 35674:return bY;case 35675:return IY;case 35676:return CY;case 5124:case 35670:return wY;case 35667:case 35671:return vY;case 35668:case 35672:return SY;case 35669:case 35673:return EY;case 5125:return _Y;case 36294:return TY;case 36295:return BY;case 36296:return kY;case 35678:case 36198:case 36298:case 36306:case 35682:return MY;case 35679:case 36299:case 36307:return NY;case 35680:case 36300:case 36308:case 36293:return RY;case 36289:case 36303:case 36311:case 36292:return DY}}class $Y{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.type=t.type,this.setValue=mY(t.type)}}class PY{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=FY(t.type)}}class LY{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,s){const i=this.seq;for(let r=0,o=i.length;r!==o;++r){const a=i[r];a.setValue(e,t[a.id],s)}}}const Hv=/(\w+)(\])?(\[|\.)?/g;function GM(n,e){n.seq.push(e),n.map[e.id]=e}function OY(n,e,t){const s=n.name,i=s.length;for(Hv.lastIndex=0;;){const r=Hv.exec(s),o=Hv.lastIndex;let a=r[1];const l=r[2]==="]",c=r[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===i){GM(t,c===void 0?new $Y(a,n,e):new PY(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new LY(a),GM(t,h)),t=h}}}class b0{constructor(e,t){this.seq=[],this.map={};const s=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<s;++i){const r=e.getActiveUniform(t,i),o=e.getUniformLocation(t,r.name);OY(r,o,this)}}setValue(e,t,s,i){const r=this.map[t];r!==void 0&&r.setValue(e,s,i)}setOptional(e,t,s){const i=t[s];i!==void 0&&this.setValue(e,s,i)}static upload(e,t,s,i){for(let r=0,o=t.length;r!==o;++r){const a=t[r],l=s[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,i)}}static seqWithValue(e,t){const s=[];for(let i=0,r=e.length;i!==r;++i){const o=e[i];o.id in t&&s.push(o)}return s}}function WM(n,e,t){const s=n.createShader(e);return n.shaderSource(s,t),n.compileShader(s),s}const zY=37297;let UY=0;function QY(n,e){const t=n.split(`
`),s=[],i=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let o=i;o<r;o++){const a=o+1;s.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return s.join(`
`)}const HM=new Ht;function VY(n){gn._getMatrix(HM,gn.workingColorSpace,n);const e=`mat3( ${HM.elements.map(t=>t.toFixed(4))} )`;switch(gn.getTransfer(n)){case hg:return[e,"LinearTransferOETF"];case kn:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",n),[e,"LinearTransferOETF"]}}function qM(n,e,t){const s=n.getShaderParameter(e,n.COMPILE_STATUS),r=(n.getShaderInfoLog(e)||"").trim();if(s&&r==="")return"";const o=/ERROR: 0:(\d+)/.exec(r);if(o){const a=parseInt(o[1]);return t.toUpperCase()+`

`+r+`

`+QY(n.getShaderSource(e),a)}else return r}function GY(n,e){const t=VY(e);return[`vec4 ${n}( vec4 value ) {`,`	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,"}"].join(`
`)}function WY(n,e){let t;switch(e){case w3:t="Linear";break;case v3:t="Reinhard";break;case S3:t="Cineon";break;case E3:t="ACESFilmic";break;case T3:t="AgX";break;case B3:t="Neutral";break;case _3:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}const Kx=new U;function HY(){gn.getLuminanceCoefficients(Kx);const n=Kx.x.toFixed(4),e=Kx.y.toFixed(4),t=Kx.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,"	return dot( weights, rgb );","}"].join(`
`)}function qY(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",n.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Mm).join(`
`)}function YY(n){const e=[];for(const t in n){const s=n[t];s!==!1&&e.push("#define "+t+" "+s)}return e.join(`
`)}function XY(n,e){const t={},s=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let i=0;i<s;i++){const r=n.getActiveAttrib(e,i),o=r.name;let a=1;r.type===n.FLOAT_MAT2&&(a=2),r.type===n.FLOAT_MAT3&&(a=3),r.type===n.FLOAT_MAT4&&(a=4),t[o]={type:r.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function Mm(n){return n!==""}function YM(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function XM(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const jY=/^[ \t]*#include +<([\w\d./]+)>/gm;function JS(n){return n.replace(jY,JY)}const KY=new Map;function JY(n,e){let t=Kt[e];if(t===void 0){const s=KY.get(e);if(s!==void 0)t=Kt[s],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,s);else throw new Error("Can not resolve #include <"+e+">")}return JS(t)}const ZY=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function jM(n){return n.replace(ZY,eX)}function eX(n,e,t,s){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=s.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function KM(n){let e=`precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function tX(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===xE?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===n3?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===ta&&(e="SHADOWMAP_TYPE_VSM"),e}function nX(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case el:case Gl:e="ENVMAP_TYPE_CUBE";break;case wp:e="ENVMAP_TYPE_CUBE_UV";break}return e}function sX(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case Gl:e="ENVMAP_MODE_REFRACTION";break}return e}function iX(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case jg:e="ENVMAP_BLENDING_MULTIPLY";break;case I3:e="ENVMAP_BLENDING_MIX";break;case C3:e="ENVMAP_BLENDING_ADD";break}return e}function rX(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,s=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:s,maxMip:t}}function oX(n,e,t,s){const i=n.getContext(),r=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=tX(t),c=nX(t),u=sX(t),h=iX(t),d=rX(t),p=qY(t),f=YY(r),g=i.createProgram();let m,A,y=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(m=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f].filter(Mm).join(`
`),m.length>0&&(m+=`
`),A=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f].filter(Mm).join(`
`),A.length>0&&(A+=`
`)):(m=[KM(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.batchingColor?"#define USE_BATCHING_COLOR":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.instancingMorph?"#define USE_INSTANCING_MORPH":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",t.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Mm).join(`
`),A=[KM(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.dispersion?"#define USE_DISPERSION":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor||t.batchingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",t.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",t.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ya?"#define TONE_MAPPING":"",t.toneMapping!==Ya?Kt.tonemapping_pars_fragment:"",t.toneMapping!==Ya?WY("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",Kt.colorspace_pars_fragment,GY("linearToOutputTexel",t.outputColorSpace),HY(),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Mm).join(`
`)),o=JS(o),o=YM(o,t),o=XM(o,t),a=JS(a),a=YM(a,t),a=XM(a,t),o=jM(o),a=jM(a),t.isRawShaderMaterial!==!0&&(y=`#version 300 es
`,m=[p,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,A=["#define varying in",t.glslVersion===pg?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===pg?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+A);const b=y+m+o,x=y+A+a,C=WM(i,i.VERTEX_SHADER,b),w=WM(i,i.FRAGMENT_SHADER,x);i.attachShader(g,C),i.attachShader(g,w),t.index0AttributeName!==void 0?i.bindAttribLocation(g,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(g,0,"position"),i.linkProgram(g);function E(_){if(n.debug.checkShaderErrors){const N=i.getProgramInfoLog(g)||"",D=i.getShaderInfoLog(C)||"",P=i.getShaderInfoLog(w)||"",L=N.trim(),z=D.trim(),q=P.trim();let V=!0,X=!0;if(i.getProgramParameter(g,i.LINK_STATUS)===!1)if(V=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(i,g,C,w);else{const te=qM(i,C,"vertex"),se=qM(i,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(g,i.VALIDATE_STATUS)+`

Material Name: `+_.name+`
Material Type: `+_.type+`

Program Info Log: `+L+`
`+te+`
`+se)}else L!==""?console.warn("THREE.WebGLProgram: Program Info Log:",L):(z===""||q==="")&&(X=!1);X&&(_.diagnostics={runnable:V,programLog:L,vertexShader:{log:z,prefix:m},fragmentShader:{log:q,prefix:A}})}i.deleteShader(C),i.deleteShader(w),T=new b0(i,g),v=XY(i,g)}let T;this.getUniforms=function(){return T===void 0&&E(this),T};let v;this.getAttributes=function(){return v===void 0&&E(this),v};let S=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return S===!1&&(S=i.getProgramParameter(g,zY)),S},this.destroy=function(){s.releaseStatesOfProgram(this),i.deleteProgram(g),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=UY++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=C,this.fragmentShader=w,this}let aX=0;class lX{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,s=e.fragmentShader,i=this._getShaderStage(t),r=this._getShaderStage(s),o=this._getShaderCacheForMaterial(e);return o.has(i)===!1&&(o.add(i),i.usedTimes++),o.has(r)===!1&&(o.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const s of t)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let s=t.get(e);return s===void 0&&(s=new Set,t.set(e,s)),s}_getShaderStage(e){const t=this.shaderCache;let s=t.get(e);return s===void 0&&(s=new cX(e),t.set(e,s)),s}}class cX{constructor(e){this.id=aX++,this.code=e,this.usedTimes=0}}function uX(n,e,t,s,i,r,o){const a=new II,l=new lX,c=new Set,u=[],h=i.logarithmicDepthBuffer,d=i.vertexTextures;let p=i.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function g(v){return c.add(v),v===0?"uv":`uv${v}`}function m(v,S,_,N,D){const P=N.fog,L=D.geometry,z=v.isMeshStandardMaterial?N.environment:null,q=(v.isMeshStandardMaterial?t:e).get(v.envMap||z),V=q&&q.mapping===wp?q.image.height:null,X=f[v.type];v.precision!==null&&(p=i.getMaxPrecision(v.precision),p!==v.precision&&console.warn("THREE.WebGLProgram.getParameters:",v.precision,"not supported, using",p,"instead."));const te=L.morphAttributes.position||L.morphAttributes.normal||L.morphAttributes.color,se=te!==void 0?te.length:0;let fe=0;L.morphAttributes.position!==void 0&&(fe=1),L.morphAttributes.normal!==void 0&&(fe=2),L.morphAttributes.color!==void 0&&(fe=3);let me,Te,Ee,re;if(X){const hn=wo[X];me=hn.vertexShader,Te=hn.fragmentShader}else me=v.vertexShader,Te=v.fragmentShader,l.update(v),Ee=l.getVertexShaderID(v),re=l.getFragmentShaderID(v);const ue=n.getRenderTarget(),_e=n.state.buffers.depth.getReversed(),ke=D.isInstancedMesh===!0,Ne=D.isBatchedMesh===!0,Ue=!!v.map,ht=!!v.matcap,W=!!q,Ce=!!v.aoMap,be=!!v.lightMap,ge=!!v.bumpMap,ye=!!v.normalMap,Re=!!v.displacementMap,De=!!v.emissiveMap,Me=!!v.metalnessMap,Tt=!!v.roughnessMap,At=v.anisotropy>0,G=v.clearcoat>0,$=v.dispersion>0,de=v.iridescence>0,xe=v.sheen>0,Fe=v.transmission>0,ve=At&&!!v.anisotropyMap,ut=G&&!!v.clearcoatMap,He=G&&!!v.clearcoatNormalMap,pt=G&&!!v.clearcoatRoughnessMap,yt=de&&!!v.iridescenceMap,Oe=de&&!!v.iridescenceThicknessMap,tt=xe&&!!v.sheenColorMap,Nt=xe&&!!v.sheenRoughnessMap,_t=!!v.specularMap,st=!!v.specularColorMap,Wt=!!v.specularIntensityMap,ie=Fe&&!!v.transmissionMap,Ve=Fe&&!!v.thicknessMap,je=!!v.gradientMap,mt=!!v.alphaMap,Qe=v.alphaTest>0,Pe=!!v.alphaHash,dt=!!v.extensions;let Gt=Ya;v.toneMapped&&(ue===null||ue.isXRRenderTarget===!0)&&(Gt=n.toneMapping);const _n={shaderID:X,shaderType:v.type,shaderName:v.name,vertexShader:me,fragmentShader:Te,defines:v.defines,customVertexShaderID:Ee,customFragmentShaderID:re,isRawShaderMaterial:v.isRawShaderMaterial===!0,glslVersion:v.glslVersion,precision:p,batching:Ne,batchingColor:Ne&&D._colorsTexture!==null,instancing:ke,instancingColor:ke&&D.instanceColor!==null,instancingMorph:ke&&D.morphTexture!==null,supportsVertexTextures:d,outputColorSpace:ue===null?n.outputColorSpace:ue.isXRRenderTarget===!0?ue.texture.colorSpace:yu,alphaToCoverage:!!v.alphaToCoverage,map:Ue,matcap:ht,envMap:W,envMapMode:W&&q.mapping,envMapCubeUVHeight:V,aoMap:Ce,lightMap:be,bumpMap:ge,normalMap:ye,displacementMap:d&&Re,emissiveMap:De,normalMapObjectSpace:ye&&v.normalMapType===P3,normalMapTangentSpace:ye&&v.normalMapType===ic,metalnessMap:Me,roughnessMap:Tt,anisotropy:At,anisotropyMap:ve,clearcoat:G,clearcoatMap:ut,clearcoatNormalMap:He,clearcoatRoughnessMap:pt,dispersion:$,iridescence:de,iridescenceMap:yt,iridescenceThicknessMap:Oe,sheen:xe,sheenColorMap:tt,sheenRoughnessMap:Nt,specularMap:_t,specularColorMap:st,specularIntensityMap:Wt,transmission:Fe,transmissionMap:ie,thicknessMap:Ve,gradientMap:je,opaque:v.transparent===!1&&v.blending===cu&&v.alphaToCoverage===!1,alphaMap:mt,alphaTest:Qe,alphaHash:Pe,combine:v.combine,mapUv:Ue&&g(v.map.channel),aoMapUv:Ce&&g(v.aoMap.channel),lightMapUv:be&&g(v.lightMap.channel),bumpMapUv:ge&&g(v.bumpMap.channel),normalMapUv:ye&&g(v.normalMap.channel),displacementMapUv:Re&&g(v.displacementMap.channel),emissiveMapUv:De&&g(v.emissiveMap.channel),metalnessMapUv:Me&&g(v.metalnessMap.channel),roughnessMapUv:Tt&&g(v.roughnessMap.channel),anisotropyMapUv:ve&&g(v.anisotropyMap.channel),clearcoatMapUv:ut&&g(v.clearcoatMap.channel),clearcoatNormalMapUv:He&&g(v.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:pt&&g(v.clearcoatRoughnessMap.channel),iridescenceMapUv:yt&&g(v.iridescenceMap.channel),iridescenceThicknessMapUv:Oe&&g(v.iridescenceThicknessMap.channel),sheenColorMapUv:tt&&g(v.sheenColorMap.channel),sheenRoughnessMapUv:Nt&&g(v.sheenRoughnessMap.channel),specularMapUv:_t&&g(v.specularMap.channel),specularColorMapUv:st&&g(v.specularColorMap.channel),specularIntensityMapUv:Wt&&g(v.specularIntensityMap.channel),transmissionMapUv:ie&&g(v.transmissionMap.channel),thicknessMapUv:Ve&&g(v.thicknessMap.channel),alphaMapUv:mt&&g(v.alphaMap.channel),vertexTangents:!!L.attributes.tangent&&(ye||At),vertexColors:v.vertexColors,vertexAlphas:v.vertexColors===!0&&!!L.attributes.color&&L.attributes.color.itemSize===4,pointsUvs:D.isPoints===!0&&!!L.attributes.uv&&(Ue||mt),fog:!!P,useFog:v.fog===!0,fogExp2:!!P&&P.isFogExp2,flatShading:v.flatShading===!0&&v.wireframe===!1,sizeAttenuation:v.sizeAttenuation===!0,logarithmicDepthBuffer:h,reversedDepthBuffer:_e,skinning:D.isSkinnedMesh===!0,morphTargets:L.morphAttributes.position!==void 0,morphNormals:L.morphAttributes.normal!==void 0,morphColors:L.morphAttributes.color!==void 0,morphTargetsCount:se,morphTextureStride:fe,numDirLights:S.directional.length,numPointLights:S.point.length,numSpotLights:S.spot.length,numSpotLightMaps:S.spotLightMap.length,numRectAreaLights:S.rectArea.length,numHemiLights:S.hemi.length,numDirLightShadows:S.directionalShadowMap.length,numPointLightShadows:S.pointShadowMap.length,numSpotLightShadows:S.spotShadowMap.length,numSpotLightShadowsWithMaps:S.numSpotLightShadowsWithMaps,numLightProbes:S.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:v.dithering,shadowMapEnabled:n.shadowMap.enabled&&_.length>0,shadowMapType:n.shadowMap.type,toneMapping:Gt,decodeVideoTexture:Ue&&v.map.isVideoTexture===!0&&gn.getTransfer(v.map.colorSpace)===kn,decodeVideoTextureEmissive:De&&v.emissiveMap.isVideoTexture===!0&&gn.getTransfer(v.emissiveMap.colorSpace)===kn,premultipliedAlpha:v.premultipliedAlpha,doubleSided:v.side===io,flipSided:v.side===ji,useDepthPacking:v.depthPacking>=0,depthPacking:v.depthPacking||0,index0AttributeName:v.index0AttributeName,extensionClipCullDistance:dt&&v.extensions.clipCullDistance===!0&&s.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(dt&&v.extensions.multiDraw===!0||Ne)&&s.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:s.has("KHR_parallel_shader_compile"),customProgramCacheKey:v.customProgramCacheKey()};return _n.vertexUv1s=c.has(1),_n.vertexUv2s=c.has(2),_n.vertexUv3s=c.has(3),c.clear(),_n}function A(v){const S=[];if(v.shaderID?S.push(v.shaderID):(S.push(v.customVertexShaderID),S.push(v.customFragmentShaderID)),v.defines!==void 0)for(const _ in v.defines)S.push(_),S.push(v.defines[_]);return v.isRawShaderMaterial===!1&&(y(S,v),b(S,v),S.push(n.outputColorSpace)),S.push(v.customProgramCacheKey),S.join()}function y(v,S){v.push(S.precision),v.push(S.outputColorSpace),v.push(S.envMapMode),v.push(S.envMapCubeUVHeight),v.push(S.mapUv),v.push(S.alphaMapUv),v.push(S.lightMapUv),v.push(S.aoMapUv),v.push(S.bumpMapUv),v.push(S.normalMapUv),v.push(S.displacementMapUv),v.push(S.emissiveMapUv),v.push(S.metalnessMapUv),v.push(S.roughnessMapUv),v.push(S.anisotropyMapUv),v.push(S.clearcoatMapUv),v.push(S.clearcoatNormalMapUv),v.push(S.clearcoatRoughnessMapUv),v.push(S.iridescenceMapUv),v.push(S.iridescenceThicknessMapUv),v.push(S.sheenColorMapUv),v.push(S.sheenRoughnessMapUv),v.push(S.specularMapUv),v.push(S.specularColorMapUv),v.push(S.specularIntensityMapUv),v.push(S.transmissionMapUv),v.push(S.thicknessMapUv),v.push(S.combine),v.push(S.fogExp2),v.push(S.sizeAttenuation),v.push(S.morphTargetsCount),v.push(S.morphAttributeCount),v.push(S.numDirLights),v.push(S.numPointLights),v.push(S.numSpotLights),v.push(S.numSpotLightMaps),v.push(S.numHemiLights),v.push(S.numRectAreaLights),v.push(S.numDirLightShadows),v.push(S.numPointLightShadows),v.push(S.numSpotLightShadows),v.push(S.numSpotLightShadowsWithMaps),v.push(S.numLightProbes),v.push(S.shadowMapType),v.push(S.toneMapping),v.push(S.numClippingPlanes),v.push(S.numClipIntersection),v.push(S.depthPacking)}function b(v,S){a.disableAll(),S.supportsVertexTextures&&a.enable(0),S.instancing&&a.enable(1),S.instancingColor&&a.enable(2),S.instancingMorph&&a.enable(3),S.matcap&&a.enable(4),S.envMap&&a.enable(5),S.normalMapObjectSpace&&a.enable(6),S.normalMapTangentSpace&&a.enable(7),S.clearcoat&&a.enable(8),S.iridescence&&a.enable(9),S.alphaTest&&a.enable(10),S.vertexColors&&a.enable(11),S.vertexAlphas&&a.enable(12),S.vertexUv1s&&a.enable(13),S.vertexUv2s&&a.enable(14),S.vertexUv3s&&a.enable(15),S.vertexTangents&&a.enable(16),S.anisotropy&&a.enable(17),S.alphaHash&&a.enable(18),S.batching&&a.enable(19),S.dispersion&&a.enable(20),S.batchingColor&&a.enable(21),S.gradientMap&&a.enable(22),v.push(a.mask),a.disableAll(),S.fog&&a.enable(0),S.useFog&&a.enable(1),S.flatShading&&a.enable(2),S.logarithmicDepthBuffer&&a.enable(3),S.reversedDepthBuffer&&a.enable(4),S.skinning&&a.enable(5),S.morphTargets&&a.enable(6),S.morphNormals&&a.enable(7),S.morphColors&&a.enable(8),S.premultipliedAlpha&&a.enable(9),S.shadowMapEnabled&&a.enable(10),S.doubleSided&&a.enable(11),S.flipSided&&a.enable(12),S.useDepthPacking&&a.enable(13),S.dithering&&a.enable(14),S.transmission&&a.enable(15),S.sheen&&a.enable(16),S.opaque&&a.enable(17),S.pointsUvs&&a.enable(18),S.decodeVideoTexture&&a.enable(19),S.decodeVideoTextureEmissive&&a.enable(20),S.alphaToCoverage&&a.enable(21),v.push(a.mask)}function x(v){const S=f[v.type];let _;if(S){const N=wo[S];_=K3.clone(N.uniforms)}else _=v.uniforms;return _}function C(v,S){let _;for(let N=0,D=u.length;N<D;N++){const P=u[N];if(P.cacheKey===S){_=P,++_.usedTimes;break}}return _===void 0&&(_=new oX(n,S,v,r),u.push(_)),_}function w(v){if(--v.usedTimes===0){const S=u.indexOf(v);u[S]=u[u.length-1],u.pop(),v.destroy()}}function E(v){l.remove(v)}function T(){l.dispose()}return{getParameters:m,getProgramCacheKey:A,getUniforms:x,acquireProgram:C,releaseProgram:w,releaseShaderCache:E,programs:u,dispose:T}}function hX(){let n=new WeakMap;function e(o){return n.has(o)}function t(o){let a=n.get(o);return a===void 0&&(a={},n.set(o,a)),a}function s(o){n.delete(o)}function i(o,a,l){n.get(o)[a]=l}function r(){n=new WeakMap}return{has:e,get:t,remove:s,update:i,dispose:r}}function dX(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function JM(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function ZM(){const n=[];let e=0;const t=[],s=[],i=[];function r(){e=0,t.length=0,s.length=0,i.length=0}function o(h,d,p,f,g,m){let A=n[e];return A===void 0?(A={id:h.id,object:h,geometry:d,material:p,groupOrder:f,renderOrder:h.renderOrder,z:g,group:m},n[e]=A):(A.id=h.id,A.object=h,A.geometry=d,A.material=p,A.groupOrder=f,A.renderOrder=h.renderOrder,A.z=g,A.group=m),e++,A}function a(h,d,p,f,g,m){const A=o(h,d,p,f,g,m);p.transmission>0?s.push(A):p.transparent===!0?i.push(A):t.push(A)}function l(h,d,p,f,g,m){const A=o(h,d,p,f,g,m);p.transmission>0?s.unshift(A):p.transparent===!0?i.unshift(A):t.unshift(A)}function c(h,d){t.length>1&&t.sort(h||dX),s.length>1&&s.sort(d||JM),i.length>1&&i.sort(d||JM)}function u(){for(let h=e,d=n.length;h<d;h++){const p=n[h];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:t,transmissive:s,transparent:i,init:r,push:a,unshift:l,finish:u,sort:c}}function pX(){let n=new WeakMap;function e(s,i){const r=n.get(s);let o;return r===void 0?(o=new ZM,n.set(s,[o])):i>=r.length?(o=new ZM,r.push(o)):o=r[i],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function fX(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new U,color:new ot};break;case"SpotLight":t={position:new U,direction:new U,color:new ot,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new U,color:new ot,distance:0,decay:0};break;case"HemisphereLight":t={direction:new U,skyColor:new ot,groundColor:new ot};break;case"RectAreaLight":t={color:new ot,position:new U,halfWidth:new U,halfHeight:new U};break}return n[e.id]=t,t}}}function mX(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new $e};break;case"SpotLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new $e};break;case"PointLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new $e,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let gX=0;function AX(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function yX(n){const e=new fX,t=mX(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)s.probe.push(new U);const i=new U,r=new kt,o=new kt;function a(c){let u=0,h=0,d=0;for(let v=0;v<9;v++)s.probe[v].set(0,0,0);let p=0,f=0,g=0,m=0,A=0,y=0,b=0,x=0,C=0,w=0,E=0;c.sort(AX);for(let v=0,S=c.length;v<S;v++){const _=c[v],N=_.color,D=_.intensity,P=_.distance,L=_.shadow&&_.shadow.map?_.shadow.map.texture:null;if(_.isAmbientLight)u+=N.r*D,h+=N.g*D,d+=N.b*D;else if(_.isLightProbe){for(let z=0;z<9;z++)s.probe[z].addScaledVector(_.sh.coefficients[z],D);E++}else if(_.isDirectionalLight){const z=e.get(_);if(z.color.copy(_.color).multiplyScalar(_.intensity),_.castShadow){const q=_.shadow,V=t.get(_);V.shadowIntensity=q.intensity,V.shadowBias=q.bias,V.shadowNormalBias=q.normalBias,V.shadowRadius=q.radius,V.shadowMapSize=q.mapSize,s.directionalShadow[p]=V,s.directionalShadowMap[p]=L,s.directionalShadowMatrix[p]=_.shadow.matrix,y++}s.directional[p]=z,p++}else if(_.isSpotLight){const z=e.get(_);z.position.setFromMatrixPosition(_.matrixWorld),z.color.copy(N).multiplyScalar(D),z.distance=P,z.coneCos=Math.cos(_.angle),z.penumbraCos=Math.cos(_.angle*(1-_.penumbra)),z.decay=_.decay,s.spot[g]=z;const q=_.shadow;if(_.map&&(s.spotLightMap[C]=_.map,C++,q.updateMatrices(_),_.castShadow&&w++),s.spotLightMatrix[g]=q.matrix,_.castShadow){const V=t.get(_);V.shadowIntensity=q.intensity,V.shadowBias=q.bias,V.shadowNormalBias=q.normalBias,V.shadowRadius=q.radius,V.shadowMapSize=q.mapSize,s.spotShadow[g]=V,s.spotShadowMap[g]=L,x++}g++}else if(_.isRectAreaLight){const z=e.get(_);z.color.copy(N).multiplyScalar(D),z.halfWidth.set(_.width*.5,0,0),z.halfHeight.set(0,_.height*.5,0),s.rectArea[m]=z,m++}else if(_.isPointLight){const z=e.get(_);if(z.color.copy(_.color).multiplyScalar(_.intensity),z.distance=_.distance,z.decay=_.decay,_.castShadow){const q=_.shadow,V=t.get(_);V.shadowIntensity=q.intensity,V.shadowBias=q.bias,V.shadowNormalBias=q.normalBias,V.shadowRadius=q.radius,V.shadowMapSize=q.mapSize,V.shadowCameraNear=q.camera.near,V.shadowCameraFar=q.camera.far,s.pointShadow[f]=V,s.pointShadowMap[f]=L,s.pointShadowMatrix[f]=_.shadow.matrix,b++}s.point[f]=z,f++}else if(_.isHemisphereLight){const z=e.get(_);z.skyColor.copy(_.color).multiplyScalar(D),z.groundColor.copy(_.groundColor).multiplyScalar(D),s.hemi[A]=z,A++}}m>0&&(n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=rt.LTC_FLOAT_1,s.rectAreaLTC2=rt.LTC_FLOAT_2):(s.rectAreaLTC1=rt.LTC_HALF_1,s.rectAreaLTC2=rt.LTC_HALF_2)),s.ambient[0]=u,s.ambient[1]=h,s.ambient[2]=d;const T=s.hash;(T.directionalLength!==p||T.pointLength!==f||T.spotLength!==g||T.rectAreaLength!==m||T.hemiLength!==A||T.numDirectionalShadows!==y||T.numPointShadows!==b||T.numSpotShadows!==x||T.numSpotMaps!==C||T.numLightProbes!==E)&&(s.directional.length=p,s.spot.length=g,s.rectArea.length=m,s.point.length=f,s.hemi.length=A,s.directionalShadow.length=y,s.directionalShadowMap.length=y,s.pointShadow.length=b,s.pointShadowMap.length=b,s.spotShadow.length=x,s.spotShadowMap.length=x,s.directionalShadowMatrix.length=y,s.pointShadowMatrix.length=b,s.spotLightMatrix.length=x+C-w,s.spotLightMap.length=C,s.numSpotLightShadowsWithMaps=w,s.numLightProbes=E,T.directionalLength=p,T.pointLength=f,T.spotLength=g,T.rectAreaLength=m,T.hemiLength=A,T.numDirectionalShadows=y,T.numPointShadows=b,T.numSpotShadows=x,T.numSpotMaps=C,T.numLightProbes=E,s.version=gX++)}function l(c,u){let h=0,d=0,p=0,f=0,g=0;const m=u.matrixWorldInverse;for(let A=0,y=c.length;A<y;A++){const b=c[A];if(b.isDirectionalLight){const x=s.directional[h];x.direction.setFromMatrixPosition(b.matrixWorld),i.setFromMatrixPosition(b.target.matrixWorld),x.direction.sub(i),x.direction.transformDirection(m),h++}else if(b.isSpotLight){const x=s.spot[p];x.position.setFromMatrixPosition(b.matrixWorld),x.position.applyMatrix4(m),x.direction.setFromMatrixPosition(b.matrixWorld),i.setFromMatrixPosition(b.target.matrixWorld),x.direction.sub(i),x.direction.transformDirection(m),p++}else if(b.isRectAreaLight){const x=s.rectArea[f];x.position.setFromMatrixPosition(b.matrixWorld),x.position.applyMatrix4(m),o.identity(),r.copy(b.matrixWorld),r.premultiply(m),o.extractRotation(r),x.halfWidth.set(b.width*.5,0,0),x.halfHeight.set(0,b.height*.5,0),x.halfWidth.applyMatrix4(o),x.halfHeight.applyMatrix4(o),f++}else if(b.isPointLight){const x=s.point[d];x.position.setFromMatrixPosition(b.matrixWorld),x.position.applyMatrix4(m),d++}else if(b.isHemisphereLight){const x=s.hemi[g];x.direction.setFromMatrixPosition(b.matrixWorld),x.direction.transformDirection(m),g++}}}return{setup:a,setupView:l,state:s}}function eN(n){const e=new yX(n),t=[],s=[];function i(u){c.camera=u,t.length=0,s.length=0}function r(u){t.push(u)}function o(u){s.push(u)}function a(){e.setup(t)}function l(u){e.setupView(t,u)}const c={lightsArray:t,shadowsArray:s,camera:null,lights:e,transmissionRenderTarget:{}};return{init:i,state:c,setupLights:a,setupLightsView:l,pushLight:r,pushShadow:o}}function xX(n){let e=new WeakMap;function t(i,r=0){const o=e.get(i);let a;return o===void 0?(a=new eN(n),e.set(i,[a])):r>=o.length?(a=new eN(n),o.push(a)):a=o[r],a}function s(){e=new WeakMap}return{get:t,dispose:s}}const bX=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,IX=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function CX(n,e,t){let s=new Ep;const i=new $e,r=new $e,o=new Yt,a=new KE({depthPacking:$3}),l=new JE,c={},u=t.maxTextureSize,h={[Za]:ji,[ji]:Za,[io]:io},d=new Hr({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new $e},radius:{value:4}},vertexShader:bX,fragmentShader:IX}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new Xt;f.setAttribute("position",new Sn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new On(f,d),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=xE;let A=this.type;this.render=function(w,E,T){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||w.length===0)return;const v=n.getRenderTarget(),S=n.getActiveCubeFace(),_=n.getActiveMipmapLevel(),N=n.state;N.setBlending(qa),N.buffers.depth.getReversed()===!0?N.buffers.color.setClear(0,0,0,0):N.buffers.color.setClear(1,1,1,1),N.buffers.depth.setTest(!0),N.setScissorTest(!1);const D=A!==ta&&this.type===ta,P=A===ta&&this.type!==ta;for(let L=0,z=w.length;L<z;L++){const q=w[L],V=q.shadow;if(V===void 0){console.warn("THREE.WebGLShadowMap:",q,"has no shadow.");continue}if(V.autoUpdate===!1&&V.needsUpdate===!1)continue;i.copy(V.mapSize);const X=V.getFrameExtents();if(i.multiply(X),r.copy(V.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(r.x=Math.floor(u/X.x),i.x=r.x*X.x,V.mapSize.x=r.x),i.y>u&&(r.y=Math.floor(u/X.y),i.y=r.y*X.y,V.mapSize.y=r.y)),V.map===null||D===!0||P===!0){const se=this.type!==ta?{minFilter:bs,magFilter:bs}:{};V.map!==null&&V.map.dispose(),V.map=new ao(i.x,i.y,se),V.map.texture.name=q.name+".shadowMap",V.camera.updateProjectionMatrix()}n.setRenderTarget(V.map),n.clear();const te=V.getViewportCount();for(let se=0;se<te;se++){const fe=V.getViewport(se);o.set(r.x*fe.x,r.y*fe.y,r.x*fe.z,r.y*fe.w),N.viewport(o),V.updateMatrices(q,se),s=V.getFrustum(),x(E,T,V.camera,q,this.type)}V.isPointLightShadow!==!0&&this.type===ta&&y(V,T),V.needsUpdate=!1}A=this.type,m.needsUpdate=!1,n.setRenderTarget(v,S,_)};function y(w,E){const T=e.update(g);d.defines.VSM_SAMPLES!==w.blurSamples&&(d.defines.VSM_SAMPLES=w.blurSamples,p.defines.VSM_SAMPLES=w.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),w.mapPass===null&&(w.mapPass=new ao(i.x,i.y)),d.uniforms.shadow_pass.value=w.map.texture,d.uniforms.resolution.value=w.mapSize,d.uniforms.radius.value=w.radius,n.setRenderTarget(w.mapPass),n.clear(),n.renderBufferDirect(E,null,T,d,g,null),p.uniforms.shadow_pass.value=w.mapPass.texture,p.uniforms.resolution.value=w.mapSize,p.uniforms.radius.value=w.radius,n.setRenderTarget(w.map),n.clear(),n.renderBufferDirect(E,null,T,p,g,null)}function b(w,E,T,v){let S=null;const _=T.isPointLight===!0?w.customDistanceMaterial:w.customDepthMaterial;if(_!==void 0)S=_;else if(S=T.isPointLight===!0?l:a,n.localClippingEnabled&&E.clipShadows===!0&&Array.isArray(E.clippingPlanes)&&E.clippingPlanes.length!==0||E.displacementMap&&E.displacementScale!==0||E.alphaMap&&E.alphaTest>0||E.map&&E.alphaTest>0||E.alphaToCoverage===!0){const N=S.uuid,D=E.uuid;let P=c[N];P===void 0&&(P={},c[N]=P);let L=P[D];L===void 0&&(L=S.clone(),P[D]=L,E.addEventListener("dispose",C)),S=L}if(S.visible=E.visible,S.wireframe=E.wireframe,v===ta?S.side=E.shadowSide!==null?E.shadowSide:E.side:S.side=E.shadowSide!==null?E.shadowSide:h[E.side],S.alphaMap=E.alphaMap,S.alphaTest=E.alphaToCoverage===!0?.5:E.alphaTest,S.map=E.map,S.clipShadows=E.clipShadows,S.clippingPlanes=E.clippingPlanes,S.clipIntersection=E.clipIntersection,S.displacementMap=E.displacementMap,S.displacementScale=E.displacementScale,S.displacementBias=E.displacementBias,S.wireframeLinewidth=E.wireframeLinewidth,S.linewidth=E.linewidth,T.isPointLight===!0&&S.isMeshDistanceMaterial===!0){const N=n.properties.get(S);N.light=T}return S}function x(w,E,T,v,S){if(w.visible===!1)return;if(w.layers.test(E.layers)&&(w.isMesh||w.isLine||w.isPoints)&&(w.castShadow||w.receiveShadow&&S===ta)&&(!w.frustumCulled||s.intersectsObject(w))){w.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse,w.matrixWorld);const D=e.update(w),P=w.material;if(Array.isArray(P)){const L=D.groups;for(let z=0,q=L.length;z<q;z++){const V=L[z],X=P[V.materialIndex];if(X&&X.visible){const te=b(w,X,v,S);w.onBeforeShadow(n,w,E,T,D,te,V),n.renderBufferDirect(T,null,D,te,w,V),w.onAfterShadow(n,w,E,T,D,te,V)}}}else if(P.visible){const L=b(w,P,v,S);w.onBeforeShadow(n,w,E,T,D,L,null),n.renderBufferDirect(T,null,D,L,w,null),w.onAfterShadow(n,w,E,T,D,L,null)}}const N=w.children;for(let D=0,P=N.length;D<P;D++)x(N[D],E,T,v,S)}function C(w){w.target.removeEventListener("dispose",C);for(const T in c){const v=c[T],S=w.target.uuid;S in v&&(v[S].dispose(),delete v[S])}}}const wX={[W0]:H0,[q0]:j0,[Y0]:K0,[Au]:X0,[H0]:W0,[j0]:q0,[K0]:Y0,[X0]:Au};function vX(n,e){function t(){let ie=!1;const Ve=new Yt;let je=null;const mt=new Yt(0,0,0,0);return{setMask:function(Qe){je!==Qe&&!ie&&(n.colorMask(Qe,Qe,Qe,Qe),je=Qe)},setLocked:function(Qe){ie=Qe},setClear:function(Qe,Pe,dt,Gt,_n){_n===!0&&(Qe*=Gt,Pe*=Gt,dt*=Gt),Ve.set(Qe,Pe,dt,Gt),mt.equals(Ve)===!1&&(n.clearColor(Qe,Pe,dt,Gt),mt.copy(Ve))},reset:function(){ie=!1,je=null,mt.set(-1,0,0,0)}}}function s(){let ie=!1,Ve=!1,je=null,mt=null,Qe=null;return{setReversed:function(Pe){if(Ve!==Pe){const dt=e.get("EXT_clip_control");Pe?dt.clipControlEXT(dt.LOWER_LEFT_EXT,dt.ZERO_TO_ONE_EXT):dt.clipControlEXT(dt.LOWER_LEFT_EXT,dt.NEGATIVE_ONE_TO_ONE_EXT),Ve=Pe;const Gt=Qe;Qe=null,this.setClear(Gt)}},getReversed:function(){return Ve},setTest:function(Pe){Pe?ue(n.DEPTH_TEST):_e(n.DEPTH_TEST)},setMask:function(Pe){je!==Pe&&!ie&&(n.depthMask(Pe),je=Pe)},setFunc:function(Pe){if(Ve&&(Pe=wX[Pe]),mt!==Pe){switch(Pe){case W0:n.depthFunc(n.NEVER);break;case H0:n.depthFunc(n.ALWAYS);break;case q0:n.depthFunc(n.LESS);break;case Au:n.depthFunc(n.LEQUAL);break;case Y0:n.depthFunc(n.EQUAL);break;case X0:n.depthFunc(n.GEQUAL);break;case j0:n.depthFunc(n.GREATER);break;case K0:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}mt=Pe}},setLocked:function(Pe){ie=Pe},setClear:function(Pe){Qe!==Pe&&(Ve&&(Pe=1-Pe),n.clearDepth(Pe),Qe=Pe)},reset:function(){ie=!1,je=null,mt=null,Qe=null,Ve=!1}}}function i(){let ie=!1,Ve=null,je=null,mt=null,Qe=null,Pe=null,dt=null,Gt=null,_n=null;return{setTest:function(hn){ie||(hn?ue(n.STENCIL_TEST):_e(n.STENCIL_TEST))},setMask:function(hn){Ve!==hn&&!ie&&(n.stencilMask(hn),Ve=hn)},setFunc:function(hn,or,Jr){(je!==hn||mt!==or||Qe!==Jr)&&(n.stencilFunc(hn,or,Jr),je=hn,mt=or,Qe=Jr)},setOp:function(hn,or,Jr){(Pe!==hn||dt!==or||Gt!==Jr)&&(n.stencilOp(hn,or,Jr),Pe=hn,dt=or,Gt=Jr)},setLocked:function(hn){ie=hn},setClear:function(hn){_n!==hn&&(n.clearStencil(hn),_n=hn)},reset:function(){ie=!1,Ve=null,je=null,mt=null,Qe=null,Pe=null,dt=null,Gt=null,_n=null}}}const r=new t,o=new s,a=new i,l=new WeakMap,c=new WeakMap;let u={},h={},d=new WeakMap,p=[],f=null,g=!1,m=null,A=null,y=null,b=null,x=null,C=null,w=null,E=new ot(0,0,0),T=0,v=!1,S=null,_=null,N=null,D=null,P=null;const L=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let z=!1,q=0;const V=n.getParameter(n.VERSION);V.indexOf("WebGL")!==-1?(q=parseFloat(/^WebGL (\d)/.exec(V)[1]),z=q>=1):V.indexOf("OpenGL ES")!==-1&&(q=parseFloat(/^OpenGL ES (\d)/.exec(V)[1]),z=q>=2);let X=null,te={};const se=n.getParameter(n.SCISSOR_BOX),fe=n.getParameter(n.VIEWPORT),me=new Yt().fromArray(se),Te=new Yt().fromArray(fe);function Ee(ie,Ve,je,mt){const Qe=new Uint8Array(4),Pe=n.createTexture();n.bindTexture(ie,Pe),n.texParameteri(ie,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(ie,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let dt=0;dt<je;dt++)ie===n.TEXTURE_3D||ie===n.TEXTURE_2D_ARRAY?n.texImage3D(Ve,0,n.RGBA,1,1,mt,0,n.RGBA,n.UNSIGNED_BYTE,Qe):n.texImage2D(Ve+dt,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,Qe);return Pe}const re={};re[n.TEXTURE_2D]=Ee(n.TEXTURE_2D,n.TEXTURE_2D,1),re[n.TEXTURE_CUBE_MAP]=Ee(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),re[n.TEXTURE_2D_ARRAY]=Ee(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),re[n.TEXTURE_3D]=Ee(n.TEXTURE_3D,n.TEXTURE_3D,1,1),r.setClear(0,0,0,1),o.setClear(1),a.setClear(0),ue(n.DEPTH_TEST),o.setFunc(Au),ge(!1),ye(OS),ue(n.CULL_FACE),Ce(qa);function ue(ie){u[ie]!==!0&&(n.enable(ie),u[ie]=!0)}function _e(ie){u[ie]!==!1&&(n.disable(ie),u[ie]=!1)}function ke(ie,Ve){return h[ie]!==Ve?(n.bindFramebuffer(ie,Ve),h[ie]=Ve,ie===n.DRAW_FRAMEBUFFER&&(h[n.FRAMEBUFFER]=Ve),ie===n.FRAMEBUFFER&&(h[n.DRAW_FRAMEBUFFER]=Ve),!0):!1}function Ne(ie,Ve){let je=p,mt=!1;if(ie){je=d.get(Ve),je===void 0&&(je=[],d.set(Ve,je));const Qe=ie.textures;if(je.length!==Qe.length||je[0]!==n.COLOR_ATTACHMENT0){for(let Pe=0,dt=Qe.length;Pe<dt;Pe++)je[Pe]=n.COLOR_ATTACHMENT0+Pe;je.length=Qe.length,mt=!0}}else je[0]!==n.BACK&&(je[0]=n.BACK,mt=!0);mt&&n.drawBuffers(je)}function Ue(ie){return f!==ie?(n.useProgram(ie),f=ie,!0):!1}const ht={[Nl]:n.FUNC_ADD,[i3]:n.FUNC_SUBTRACT,[r3]:n.FUNC_REVERSE_SUBTRACT};ht[o3]=n.MIN,ht[a3]=n.MAX;const W={[l3]:n.ZERO,[c3]:n.ONE,[u3]:n.SRC_COLOR,[V0]:n.SRC_ALPHA,[g3]:n.SRC_ALPHA_SATURATE,[f3]:n.DST_COLOR,[d3]:n.DST_ALPHA,[h3]:n.ONE_MINUS_SRC_COLOR,[G0]:n.ONE_MINUS_SRC_ALPHA,[m3]:n.ONE_MINUS_DST_COLOR,[p3]:n.ONE_MINUS_DST_ALPHA,[A3]:n.CONSTANT_COLOR,[y3]:n.ONE_MINUS_CONSTANT_COLOR,[x3]:n.CONSTANT_ALPHA,[b3]:n.ONE_MINUS_CONSTANT_ALPHA};function Ce(ie,Ve,je,mt,Qe,Pe,dt,Gt,_n,hn){if(ie===qa){g===!0&&(_e(n.BLEND),g=!1);return}if(g===!1&&(ue(n.BLEND),g=!0),ie!==s3){if(ie!==m||hn!==v){if((A!==Nl||x!==Nl)&&(n.blendEquation(n.FUNC_ADD),A=Nl,x=Nl),hn)switch(ie){case cu:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case zS:n.blendFunc(n.ONE,n.ONE);break;case US:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case QS:n.blendFuncSeparate(n.DST_COLOR,n.ONE_MINUS_SRC_ALPHA,n.ZERO,n.ONE);break;default:console.error("THREE.WebGLState: Invalid blending: ",ie);break}else switch(ie){case cu:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case zS:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE,n.ONE,n.ONE);break;case US:console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case QS:console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:console.error("THREE.WebGLState: Invalid blending: ",ie);break}y=null,b=null,C=null,w=null,E.set(0,0,0),T=0,m=ie,v=hn}return}Qe=Qe||Ve,Pe=Pe||je,dt=dt||mt,(Ve!==A||Qe!==x)&&(n.blendEquationSeparate(ht[Ve],ht[Qe]),A=Ve,x=Qe),(je!==y||mt!==b||Pe!==C||dt!==w)&&(n.blendFuncSeparate(W[je],W[mt],W[Pe],W[dt]),y=je,b=mt,C=Pe,w=dt),(Gt.equals(E)===!1||_n!==T)&&(n.blendColor(Gt.r,Gt.g,Gt.b,_n),E.copy(Gt),T=_n),m=ie,v=!1}function be(ie,Ve){ie.side===io?_e(n.CULL_FACE):ue(n.CULL_FACE);let je=ie.side===ji;Ve&&(je=!je),ge(je),ie.blending===cu&&ie.transparent===!1?Ce(qa):Ce(ie.blending,ie.blendEquation,ie.blendSrc,ie.blendDst,ie.blendEquationAlpha,ie.blendSrcAlpha,ie.blendDstAlpha,ie.blendColor,ie.blendAlpha,ie.premultipliedAlpha),o.setFunc(ie.depthFunc),o.setTest(ie.depthTest),o.setMask(ie.depthWrite),r.setMask(ie.colorWrite);const mt=ie.stencilWrite;a.setTest(mt),mt&&(a.setMask(ie.stencilWriteMask),a.setFunc(ie.stencilFunc,ie.stencilRef,ie.stencilFuncMask),a.setOp(ie.stencilFail,ie.stencilZFail,ie.stencilZPass)),De(ie.polygonOffset,ie.polygonOffsetFactor,ie.polygonOffsetUnits),ie.alphaToCoverage===!0?ue(n.SAMPLE_ALPHA_TO_COVERAGE):_e(n.SAMPLE_ALPHA_TO_COVERAGE)}function ge(ie){S!==ie&&(ie?n.frontFace(n.CW):n.frontFace(n.CCW),S=ie)}function ye(ie){ie!==e3?(ue(n.CULL_FACE),ie!==_&&(ie===OS?n.cullFace(n.BACK):ie===t3?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):_e(n.CULL_FACE),_=ie}function Re(ie){ie!==N&&(z&&n.lineWidth(ie),N=ie)}function De(ie,Ve,je){ie?(ue(n.POLYGON_OFFSET_FILL),(D!==Ve||P!==je)&&(n.polygonOffset(Ve,je),D=Ve,P=je)):_e(n.POLYGON_OFFSET_FILL)}function Me(ie){ie?ue(n.SCISSOR_TEST):_e(n.SCISSOR_TEST)}function Tt(ie){ie===void 0&&(ie=n.TEXTURE0+L-1),X!==ie&&(n.activeTexture(ie),X=ie)}function At(ie,Ve,je){je===void 0&&(X===null?je=n.TEXTURE0+L-1:je=X);let mt=te[je];mt===void 0&&(mt={type:void 0,texture:void 0},te[je]=mt),(mt.type!==ie||mt.texture!==Ve)&&(X!==je&&(n.activeTexture(je),X=je),n.bindTexture(ie,Ve||re[ie]),mt.type=ie,mt.texture=Ve)}function G(){const ie=te[X];ie!==void 0&&ie.type!==void 0&&(n.bindTexture(ie.type,null),ie.type=void 0,ie.texture=void 0)}function $(){try{n.compressedTexImage2D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function de(){try{n.compressedTexImage3D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function xe(){try{n.texSubImage2D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function Fe(){try{n.texSubImage3D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function ve(){try{n.compressedTexSubImage2D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function ut(){try{n.compressedTexSubImage3D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function He(){try{n.texStorage2D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function pt(){try{n.texStorage3D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function yt(){try{n.texImage2D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function Oe(){try{n.texImage3D(...arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function tt(ie){me.equals(ie)===!1&&(n.scissor(ie.x,ie.y,ie.z,ie.w),me.copy(ie))}function Nt(ie){Te.equals(ie)===!1&&(n.viewport(ie.x,ie.y,ie.z,ie.w),Te.copy(ie))}function _t(ie,Ve){let je=c.get(Ve);je===void 0&&(je=new WeakMap,c.set(Ve,je));let mt=je.get(ie);mt===void 0&&(mt=n.getUniformBlockIndex(Ve,ie.name),je.set(ie,mt))}function st(ie,Ve){const mt=c.get(Ve).get(ie);l.get(Ve)!==mt&&(n.uniformBlockBinding(Ve,mt,ie.__bindingPointIndex),l.set(Ve,mt))}function Wt(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),o.setReversed(!1),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),u={},X=null,te={},h={},d=new WeakMap,p=[],f=null,g=!1,m=null,A=null,y=null,b=null,x=null,C=null,w=null,E=new ot(0,0,0),T=0,v=!1,S=null,_=null,N=null,D=null,P=null,me.set(0,0,n.canvas.width,n.canvas.height),Te.set(0,0,n.canvas.width,n.canvas.height),r.reset(),o.reset(),a.reset()}return{buffers:{color:r,depth:o,stencil:a},enable:ue,disable:_e,bindFramebuffer:ke,drawBuffers:Ne,useProgram:Ue,setBlending:Ce,setMaterial:be,setFlipSided:ge,setCullFace:ye,setLineWidth:Re,setPolygonOffset:De,setScissorTest:Me,activeTexture:Tt,bindTexture:At,unbindTexture:G,compressedTexImage2D:$,compressedTexImage3D:de,texImage2D:yt,texImage3D:Oe,updateUBOMapping:_t,uniformBlockBinding:st,texStorage2D:He,texStorage3D:pt,texSubImage2D:xe,texSubImage3D:Fe,compressedTexSubImage2D:ve,compressedTexSubImage3D:ut,scissor:tt,viewport:Nt,reset:Wt}}function SX(n,e,t,s,i,r,o){const a=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new $e,u=new WeakMap;let h;const d=new WeakMap;let p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function f(G,$){return p?new OffscreenCanvas(G,$):fg("canvas")}function g(G,$,de){let xe=1;const Fe=At(G);if((Fe.width>de||Fe.height>de)&&(xe=de/Math.max(Fe.width,Fe.height)),xe<1)if(typeof HTMLImageElement<"u"&&G instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&G instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&G instanceof ImageBitmap||typeof VideoFrame<"u"&&G instanceof VideoFrame){const ve=Math.floor(xe*Fe.width),ut=Math.floor(xe*Fe.height);h===void 0&&(h=f(ve,ut));const He=$?f(ve,ut):h;return He.width=ve,He.height=ut,He.getContext("2d").drawImage(G,0,0,ve,ut),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+Fe.width+"x"+Fe.height+") to ("+ve+"x"+ut+")."),He}else return"data"in G&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+Fe.width+"x"+Fe.height+")."),G;return G}function m(G){return G.generateMipmaps}function A(G){n.generateMipmap(G)}function y(G){return G.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:G.isWebGL3DRenderTarget?n.TEXTURE_3D:G.isWebGLArrayRenderTarget||G.isCompressedArrayTexture?n.TEXTURE_2D_ARRAY:n.TEXTURE_2D}function b(G,$,de,xe,Fe=!1){if(G!==null){if(n[G]!==void 0)return n[G];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+G+"'")}let ve=$;if($===n.RED&&(de===n.FLOAT&&(ve=n.R32F),de===n.HALF_FLOAT&&(ve=n.R16F),de===n.UNSIGNED_BYTE&&(ve=n.R8)),$===n.RED_INTEGER&&(de===n.UNSIGNED_BYTE&&(ve=n.R8UI),de===n.UNSIGNED_SHORT&&(ve=n.R16UI),de===n.UNSIGNED_INT&&(ve=n.R32UI),de===n.BYTE&&(ve=n.R8I),de===n.SHORT&&(ve=n.R16I),de===n.INT&&(ve=n.R32I)),$===n.RG&&(de===n.FLOAT&&(ve=n.RG32F),de===n.HALF_FLOAT&&(ve=n.RG16F),de===n.UNSIGNED_BYTE&&(ve=n.RG8)),$===n.RG_INTEGER&&(de===n.UNSIGNED_BYTE&&(ve=n.RG8UI),de===n.UNSIGNED_SHORT&&(ve=n.RG16UI),de===n.UNSIGNED_INT&&(ve=n.RG32UI),de===n.BYTE&&(ve=n.RG8I),de===n.SHORT&&(ve=n.RG16I),de===n.INT&&(ve=n.RG32I)),$===n.RGB_INTEGER&&(de===n.UNSIGNED_BYTE&&(ve=n.RGB8UI),de===n.UNSIGNED_SHORT&&(ve=n.RGB16UI),de===n.UNSIGNED_INT&&(ve=n.RGB32UI),de===n.BYTE&&(ve=n.RGB8I),de===n.SHORT&&(ve=n.RGB16I),de===n.INT&&(ve=n.RGB32I)),$===n.RGBA_INTEGER&&(de===n.UNSIGNED_BYTE&&(ve=n.RGBA8UI),de===n.UNSIGNED_SHORT&&(ve=n.RGBA16UI),de===n.UNSIGNED_INT&&(ve=n.RGBA32UI),de===n.BYTE&&(ve=n.RGBA8I),de===n.SHORT&&(ve=n.RGBA16I),de===n.INT&&(ve=n.RGBA32I)),$===n.RGB&&(de===n.UNSIGNED_INT_5_9_9_9_REV&&(ve=n.RGB9_E5),de===n.UNSIGNED_INT_10F_11F_11F_REV&&(ve=n.R11F_G11F_B10F)),$===n.RGBA){const ut=Fe?hg:gn.getTransfer(xe);de===n.FLOAT&&(ve=n.RGBA32F),de===n.HALF_FLOAT&&(ve=n.RGBA16F),de===n.UNSIGNED_BYTE&&(ve=ut===kn?n.SRGB8_ALPHA8:n.RGBA8),de===n.UNSIGNED_SHORT_4_4_4_4&&(ve=n.RGBA4),de===n.UNSIGNED_SHORT_5_5_5_1&&(ve=n.RGB5_A1)}return(ve===n.R16F||ve===n.R32F||ve===n.RG16F||ve===n.RG32F||ve===n.RGBA16F||ve===n.RGBA32F)&&e.get("EXT_color_buffer_float"),ve}function x(G,$){let de;return G?$===null||$===Ri||$===Kd?de=n.DEPTH24_STENCIL8:$===gr?de=n.DEPTH32F_STENCIL8:$===jd&&(de=n.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):$===null||$===Ri||$===Kd?de=n.DEPTH_COMPONENT24:$===gr?de=n.DEPTH_COMPONENT32F:$===jd&&(de=n.DEPTH_COMPONENT16),de}function C(G,$){return m(G)===!0||G.isFramebufferTexture&&G.minFilter!==bs&&G.minFilter!==Os?Math.log2(Math.max($.width,$.height))+1:G.mipmaps!==void 0&&G.mipmaps.length>0?G.mipmaps.length:G.isCompressedTexture&&Array.isArray(G.image)?$.mipmaps.length:1}function w(G){const $=G.target;$.removeEventListener("dispose",w),T($),$.isVideoTexture&&u.delete($)}function E(G){const $=G.target;$.removeEventListener("dispose",E),S($)}function T(G){const $=s.get(G);if($.__webglInit===void 0)return;const de=G.source,xe=d.get(de);if(xe){const Fe=xe[$.__cacheKey];Fe.usedTimes--,Fe.usedTimes===0&&v(G),Object.keys(xe).length===0&&d.delete(de)}s.remove(G)}function v(G){const $=s.get(G);n.deleteTexture($.__webglTexture);const de=G.source,xe=d.get(de);delete xe[$.__cacheKey],o.memory.textures--}function S(G){const $=s.get(G);if(G.depthTexture&&(G.depthTexture.dispose(),s.remove(G.depthTexture)),G.isWebGLCubeRenderTarget)for(let xe=0;xe<6;xe++){if(Array.isArray($.__webglFramebuffer[xe]))for(let Fe=0;Fe<$.__webglFramebuffer[xe].length;Fe++)n.deleteFramebuffer($.__webglFramebuffer[xe][Fe]);else n.deleteFramebuffer($.__webglFramebuffer[xe]);$.__webglDepthbuffer&&n.deleteRenderbuffer($.__webglDepthbuffer[xe])}else{if(Array.isArray($.__webglFramebuffer))for(let xe=0;xe<$.__webglFramebuffer.length;xe++)n.deleteFramebuffer($.__webglFramebuffer[xe]);else n.deleteFramebuffer($.__webglFramebuffer);if($.__webglDepthbuffer&&n.deleteRenderbuffer($.__webglDepthbuffer),$.__webglMultisampledFramebuffer&&n.deleteFramebuffer($.__webglMultisampledFramebuffer),$.__webglColorRenderbuffer)for(let xe=0;xe<$.__webglColorRenderbuffer.length;xe++)$.__webglColorRenderbuffer[xe]&&n.deleteRenderbuffer($.__webglColorRenderbuffer[xe]);$.__webglDepthRenderbuffer&&n.deleteRenderbuffer($.__webglDepthRenderbuffer)}const de=G.textures;for(let xe=0,Fe=de.length;xe<Fe;xe++){const ve=s.get(de[xe]);ve.__webglTexture&&(n.deleteTexture(ve.__webglTexture),o.memory.textures--),s.remove(de[xe])}s.remove(G)}let _=0;function N(){_=0}function D(){const G=_;return G>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+G+" texture units while this GPU supports only "+i.maxTextures),_+=1,G}function P(G){const $=[];return $.push(G.wrapS),$.push(G.wrapT),$.push(G.wrapR||0),$.push(G.magFilter),$.push(G.minFilter),$.push(G.anisotropy),$.push(G.internalFormat),$.push(G.format),$.push(G.type),$.push(G.generateMipmaps),$.push(G.premultiplyAlpha),$.push(G.flipY),$.push(G.unpackAlignment),$.push(G.colorSpace),$.join()}function L(G,$){const de=s.get(G);if(G.isVideoTexture&&Me(G),G.isRenderTargetTexture===!1&&G.isExternalTexture!==!0&&G.version>0&&de.__version!==G.version){const xe=G.image;if(xe===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(xe.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{re(de,G,$);return}}else G.isExternalTexture&&(de.__webglTexture=G.sourceTexture?G.sourceTexture:null);t.bindTexture(n.TEXTURE_2D,de.__webglTexture,n.TEXTURE0+$)}function z(G,$){const de=s.get(G);if(G.isRenderTargetTexture===!1&&G.version>0&&de.__version!==G.version){re(de,G,$);return}t.bindTexture(n.TEXTURE_2D_ARRAY,de.__webglTexture,n.TEXTURE0+$)}function q(G,$){const de=s.get(G);if(G.isRenderTargetTexture===!1&&G.version>0&&de.__version!==G.version){re(de,G,$);return}t.bindTexture(n.TEXTURE_3D,de.__webglTexture,n.TEXTURE0+$)}function V(G,$){const de=s.get(G);if(G.version>0&&de.__version!==G.version){ue(de,G,$);return}t.bindTexture(n.TEXTURE_CUBE_MAP,de.__webglTexture,n.TEXTURE0+$)}const X={[Xd]:n.REPEAT,[Pr]:n.CLAMP_TO_EDGE,[lg]:n.MIRRORED_REPEAT},te={[bs]:n.NEAREST,[bE]:n.NEAREST_MIPMAP_NEAREST,[zd]:n.NEAREST_MIPMAP_LINEAR,[Os]:n.LINEAR,[Wm]:n.LINEAR_MIPMAP_NEAREST,[la]:n.LINEAR_MIPMAP_LINEAR},se={[L3]:n.NEVER,[G3]:n.ALWAYS,[O3]:n.LESS,[BE]:n.LEQUAL,[z3]:n.EQUAL,[V3]:n.GEQUAL,[U3]:n.GREATER,[Q3]:n.NOTEQUAL};function fe(G,$){if($.type===gr&&e.has("OES_texture_float_linear")===!1&&($.magFilter===Os||$.magFilter===Wm||$.magFilter===zd||$.magFilter===la||$.minFilter===Os||$.minFilter===Wm||$.minFilter===zd||$.minFilter===la)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),n.texParameteri(G,n.TEXTURE_WRAP_S,X[$.wrapS]),n.texParameteri(G,n.TEXTURE_WRAP_T,X[$.wrapT]),(G===n.TEXTURE_3D||G===n.TEXTURE_2D_ARRAY)&&n.texParameteri(G,n.TEXTURE_WRAP_R,X[$.wrapR]),n.texParameteri(G,n.TEXTURE_MAG_FILTER,te[$.magFilter]),n.texParameteri(G,n.TEXTURE_MIN_FILTER,te[$.minFilter]),$.compareFunction&&(n.texParameteri(G,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(G,n.TEXTURE_COMPARE_FUNC,se[$.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if($.magFilter===bs||$.minFilter!==zd&&$.minFilter!==la||$.type===gr&&e.has("OES_texture_float_linear")===!1)return;if($.anisotropy>1||s.get($).__currentAnisotropy){const de=e.get("EXT_texture_filter_anisotropic");n.texParameterf(G,de.TEXTURE_MAX_ANISOTROPY_EXT,Math.min($.anisotropy,i.getMaxAnisotropy())),s.get($).__currentAnisotropy=$.anisotropy}}}function me(G,$){let de=!1;G.__webglInit===void 0&&(G.__webglInit=!0,$.addEventListener("dispose",w));const xe=$.source;let Fe=d.get(xe);Fe===void 0&&(Fe={},d.set(xe,Fe));const ve=P($);if(ve!==G.__cacheKey){Fe[ve]===void 0&&(Fe[ve]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,de=!0),Fe[ve].usedTimes++;const ut=Fe[G.__cacheKey];ut!==void 0&&(Fe[G.__cacheKey].usedTimes--,ut.usedTimes===0&&v($)),G.__cacheKey=ve,G.__webglTexture=Fe[ve].texture}return de}function Te(G,$,de){return Math.floor(Math.floor(G/de)/$)}function Ee(G,$,de,xe){const ve=G.updateRanges;if(ve.length===0)t.texSubImage2D(n.TEXTURE_2D,0,0,0,$.width,$.height,de,xe,$.data);else{ve.sort((Oe,tt)=>Oe.start-tt.start);let ut=0;for(let Oe=1;Oe<ve.length;Oe++){const tt=ve[ut],Nt=ve[Oe],_t=tt.start+tt.count,st=Te(Nt.start,$.width,4),Wt=Te(tt.start,$.width,4);Nt.start<=_t+1&&st===Wt&&Te(Nt.start+Nt.count-1,$.width,4)===st?tt.count=Math.max(tt.count,Nt.start+Nt.count-tt.start):(++ut,ve[ut]=Nt)}ve.length=ut+1;const He=n.getParameter(n.UNPACK_ROW_LENGTH),pt=n.getParameter(n.UNPACK_SKIP_PIXELS),yt=n.getParameter(n.UNPACK_SKIP_ROWS);n.pixelStorei(n.UNPACK_ROW_LENGTH,$.width);for(let Oe=0,tt=ve.length;Oe<tt;Oe++){const Nt=ve[Oe],_t=Math.floor(Nt.start/4),st=Math.ceil(Nt.count/4),Wt=_t%$.width,ie=Math.floor(_t/$.width),Ve=st,je=1;n.pixelStorei(n.UNPACK_SKIP_PIXELS,Wt),n.pixelStorei(n.UNPACK_SKIP_ROWS,ie),t.texSubImage2D(n.TEXTURE_2D,0,Wt,ie,Ve,je,de,xe,$.data)}G.clearUpdateRanges(),n.pixelStorei(n.UNPACK_ROW_LENGTH,He),n.pixelStorei(n.UNPACK_SKIP_PIXELS,pt),n.pixelStorei(n.UNPACK_SKIP_ROWS,yt)}}function re(G,$,de){let xe=n.TEXTURE_2D;($.isDataArrayTexture||$.isCompressedArrayTexture)&&(xe=n.TEXTURE_2D_ARRAY),$.isData3DTexture&&(xe=n.TEXTURE_3D);const Fe=me(G,$),ve=$.source;t.bindTexture(xe,G.__webglTexture,n.TEXTURE0+de);const ut=s.get(ve);if(ve.version!==ut.__version||Fe===!0){t.activeTexture(n.TEXTURE0+de);const He=gn.getPrimaries(gn.workingColorSpace),pt=$.colorSpace===Qa?null:gn.getPrimaries($.colorSpace),yt=$.colorSpace===Qa||He===pt?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,$.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,$.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,$.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,yt);let Oe=g($.image,!1,i.maxTextureSize);Oe=Tt($,Oe);const tt=r.convert($.format,$.colorSpace),Nt=r.convert($.type);let _t=b($.internalFormat,tt,Nt,$.colorSpace,$.isVideoTexture);fe(xe,$);let st;const Wt=$.mipmaps,ie=$.isVideoTexture!==!0,Ve=ut.__version===void 0||Fe===!0,je=ve.dataReady,mt=C($,Oe);if($.isDepthTexture)_t=x($.format===Zd,$.type),Ve&&(ie?t.texStorage2D(n.TEXTURE_2D,1,_t,Oe.width,Oe.height):t.texImage2D(n.TEXTURE_2D,0,_t,Oe.width,Oe.height,0,tt,Nt,null));else if($.isDataTexture)if(Wt.length>0){ie&&Ve&&t.texStorage2D(n.TEXTURE_2D,mt,_t,Wt[0].width,Wt[0].height);for(let Qe=0,Pe=Wt.length;Qe<Pe;Qe++)st=Wt[Qe],ie?je&&t.texSubImage2D(n.TEXTURE_2D,Qe,0,0,st.width,st.height,tt,Nt,st.data):t.texImage2D(n.TEXTURE_2D,Qe,_t,st.width,st.height,0,tt,Nt,st.data);$.generateMipmaps=!1}else ie?(Ve&&t.texStorage2D(n.TEXTURE_2D,mt,_t,Oe.width,Oe.height),je&&Ee($,Oe,tt,Nt)):t.texImage2D(n.TEXTURE_2D,0,_t,Oe.width,Oe.height,0,tt,Nt,Oe.data);else if($.isCompressedTexture)if($.isCompressedArrayTexture){ie&&Ve&&t.texStorage3D(n.TEXTURE_2D_ARRAY,mt,_t,Wt[0].width,Wt[0].height,Oe.depth);for(let Qe=0,Pe=Wt.length;Qe<Pe;Qe++)if(st=Wt[Qe],$.format!==ys)if(tt!==null)if(ie){if(je)if($.layerUpdates.size>0){const dt=KS(st.width,st.height,$.format,$.type);for(const Gt of $.layerUpdates){const _n=st.data.subarray(Gt*dt/st.data.BYTES_PER_ELEMENT,(Gt+1)*dt/st.data.BYTES_PER_ELEMENT);t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,Qe,0,0,Gt,st.width,st.height,1,tt,_n)}$.clearLayerUpdates()}else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,Qe,0,0,0,st.width,st.height,Oe.depth,tt,st.data)}else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,Qe,_t,st.width,st.height,Oe.depth,0,st.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else ie?je&&t.texSubImage3D(n.TEXTURE_2D_ARRAY,Qe,0,0,0,st.width,st.height,Oe.depth,tt,Nt,st.data):t.texImage3D(n.TEXTURE_2D_ARRAY,Qe,_t,st.width,st.height,Oe.depth,0,tt,Nt,st.data)}else{ie&&Ve&&t.texStorage2D(n.TEXTURE_2D,mt,_t,Wt[0].width,Wt[0].height);for(let Qe=0,Pe=Wt.length;Qe<Pe;Qe++)st=Wt[Qe],$.format!==ys?tt!==null?ie?je&&t.compressedTexSubImage2D(n.TEXTURE_2D,Qe,0,0,st.width,st.height,tt,st.data):t.compressedTexImage2D(n.TEXTURE_2D,Qe,_t,st.width,st.height,0,st.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):ie?je&&t.texSubImage2D(n.TEXTURE_2D,Qe,0,0,st.width,st.height,tt,Nt,st.data):t.texImage2D(n.TEXTURE_2D,Qe,_t,st.width,st.height,0,tt,Nt,st.data)}else if($.isDataArrayTexture)if(ie){if(Ve&&t.texStorage3D(n.TEXTURE_2D_ARRAY,mt,_t,Oe.width,Oe.height,Oe.depth),je)if($.layerUpdates.size>0){const Qe=KS(Oe.width,Oe.height,$.format,$.type);for(const Pe of $.layerUpdates){const dt=Oe.data.subarray(Pe*Qe/Oe.data.BYTES_PER_ELEMENT,(Pe+1)*Qe/Oe.data.BYTES_PER_ELEMENT);t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,Pe,Oe.width,Oe.height,1,tt,Nt,dt)}$.clearLayerUpdates()}else t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,Oe.width,Oe.height,Oe.depth,tt,Nt,Oe.data)}else t.texImage3D(n.TEXTURE_2D_ARRAY,0,_t,Oe.width,Oe.height,Oe.depth,0,tt,Nt,Oe.data);else if($.isData3DTexture)ie?(Ve&&t.texStorage3D(n.TEXTURE_3D,mt,_t,Oe.width,Oe.height,Oe.depth),je&&t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,Oe.width,Oe.height,Oe.depth,tt,Nt,Oe.data)):t.texImage3D(n.TEXTURE_3D,0,_t,Oe.width,Oe.height,Oe.depth,0,tt,Nt,Oe.data);else if($.isFramebufferTexture){if(Ve)if(ie)t.texStorage2D(n.TEXTURE_2D,mt,_t,Oe.width,Oe.height);else{let Qe=Oe.width,Pe=Oe.height;for(let dt=0;dt<mt;dt++)t.texImage2D(n.TEXTURE_2D,dt,_t,Qe,Pe,0,tt,Nt,null),Qe>>=1,Pe>>=1}}else if(Wt.length>0){if(ie&&Ve){const Qe=At(Wt[0]);t.texStorage2D(n.TEXTURE_2D,mt,_t,Qe.width,Qe.height)}for(let Qe=0,Pe=Wt.length;Qe<Pe;Qe++)st=Wt[Qe],ie?je&&t.texSubImage2D(n.TEXTURE_2D,Qe,0,0,tt,Nt,st):t.texImage2D(n.TEXTURE_2D,Qe,_t,tt,Nt,st);$.generateMipmaps=!1}else if(ie){if(Ve){const Qe=At(Oe);t.texStorage2D(n.TEXTURE_2D,mt,_t,Qe.width,Qe.height)}je&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,tt,Nt,Oe)}else t.texImage2D(n.TEXTURE_2D,0,_t,tt,Nt,Oe);m($)&&A(xe),ut.__version=ve.version,$.onUpdate&&$.onUpdate($)}G.__version=$.version}function ue(G,$,de){if($.image.length!==6)return;const xe=me(G,$),Fe=$.source;t.bindTexture(n.TEXTURE_CUBE_MAP,G.__webglTexture,n.TEXTURE0+de);const ve=s.get(Fe);if(Fe.version!==ve.__version||xe===!0){t.activeTexture(n.TEXTURE0+de);const ut=gn.getPrimaries(gn.workingColorSpace),He=$.colorSpace===Qa?null:gn.getPrimaries($.colorSpace),pt=$.colorSpace===Qa||ut===He?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,$.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,$.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,$.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,pt);const yt=$.isCompressedTexture||$.image[0].isCompressedTexture,Oe=$.image[0]&&$.image[0].isDataTexture,tt=[];for(let Pe=0;Pe<6;Pe++)!yt&&!Oe?tt[Pe]=g($.image[Pe],!0,i.maxCubemapSize):tt[Pe]=Oe?$.image[Pe].image:$.image[Pe],tt[Pe]=Tt($,tt[Pe]);const Nt=tt[0],_t=r.convert($.format,$.colorSpace),st=r.convert($.type),Wt=b($.internalFormat,_t,st,$.colorSpace),ie=$.isVideoTexture!==!0,Ve=ve.__version===void 0||xe===!0,je=Fe.dataReady;let mt=C($,Nt);fe(n.TEXTURE_CUBE_MAP,$);let Qe;if(yt){ie&&Ve&&t.texStorage2D(n.TEXTURE_CUBE_MAP,mt,Wt,Nt.width,Nt.height);for(let Pe=0;Pe<6;Pe++){Qe=tt[Pe].mipmaps;for(let dt=0;dt<Qe.length;dt++){const Gt=Qe[dt];$.format!==ys?_t!==null?ie?je&&t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,dt,0,0,Gt.width,Gt.height,_t,Gt.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,dt,Wt,Gt.width,Gt.height,0,Gt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):ie?je&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,dt,0,0,Gt.width,Gt.height,_t,st,Gt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,dt,Wt,Gt.width,Gt.height,0,_t,st,Gt.data)}}}else{if(Qe=$.mipmaps,ie&&Ve){Qe.length>0&&mt++;const Pe=At(tt[0]);t.texStorage2D(n.TEXTURE_CUBE_MAP,mt,Wt,Pe.width,Pe.height)}for(let Pe=0;Pe<6;Pe++)if(Oe){ie?je&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,0,0,0,tt[Pe].width,tt[Pe].height,_t,st,tt[Pe].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,0,Wt,tt[Pe].width,tt[Pe].height,0,_t,st,tt[Pe].data);for(let dt=0;dt<Qe.length;dt++){const _n=Qe[dt].image[Pe].image;ie?je&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,dt+1,0,0,_n.width,_n.height,_t,st,_n.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,dt+1,Wt,_n.width,_n.height,0,_t,st,_n.data)}}else{ie?je&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,0,0,0,_t,st,tt[Pe]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,0,Wt,_t,st,tt[Pe]);for(let dt=0;dt<Qe.length;dt++){const Gt=Qe[dt];ie?je&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,dt+1,0,0,_t,st,Gt.image[Pe]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Pe,dt+1,Wt,_t,st,Gt.image[Pe])}}}m($)&&A(n.TEXTURE_CUBE_MAP),ve.__version=Fe.version,$.onUpdate&&$.onUpdate($)}G.__version=$.version}function _e(G,$,de,xe,Fe,ve){const ut=r.convert(de.format,de.colorSpace),He=r.convert(de.type),pt=b(de.internalFormat,ut,He,de.colorSpace),yt=s.get($),Oe=s.get(de);if(Oe.__renderTarget=$,!yt.__hasExternalTextures){const tt=Math.max(1,$.width>>ve),Nt=Math.max(1,$.height>>ve);Fe===n.TEXTURE_3D||Fe===n.TEXTURE_2D_ARRAY?t.texImage3D(Fe,ve,pt,tt,Nt,$.depth,0,ut,He,null):t.texImage2D(Fe,ve,pt,tt,Nt,0,ut,He,null)}t.bindFramebuffer(n.FRAMEBUFFER,G),De($)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,xe,Fe,Oe.__webglTexture,0,Re($)):(Fe===n.TEXTURE_2D||Fe>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&Fe<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,xe,Fe,Oe.__webglTexture,ve),t.bindFramebuffer(n.FRAMEBUFFER,null)}function ke(G,$,de){if(n.bindRenderbuffer(n.RENDERBUFFER,G),$.depthBuffer){const xe=$.depthTexture,Fe=xe&&xe.isDepthTexture?xe.type:null,ve=x($.stencilBuffer,Fe),ut=$.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,He=Re($);De($)?a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,He,ve,$.width,$.height):de?n.renderbufferStorageMultisample(n.RENDERBUFFER,He,ve,$.width,$.height):n.renderbufferStorage(n.RENDERBUFFER,ve,$.width,$.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,ut,n.RENDERBUFFER,G)}else{const xe=$.textures;for(let Fe=0;Fe<xe.length;Fe++){const ve=xe[Fe],ut=r.convert(ve.format,ve.colorSpace),He=r.convert(ve.type),pt=b(ve.internalFormat,ut,He,ve.colorSpace),yt=Re($);de&&De($)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,yt,pt,$.width,$.height):De($)?a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,yt,pt,$.width,$.height):n.renderbufferStorage(n.RENDERBUFFER,pt,$.width,$.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function Ne(G,$){if($&&$.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,G),!($.depthTexture&&$.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const xe=s.get($.depthTexture);xe.__renderTarget=$,(!xe.__webglTexture||$.depthTexture.image.width!==$.width||$.depthTexture.image.height!==$.height)&&($.depthTexture.image.width=$.width,$.depthTexture.image.height=$.height,$.depthTexture.needsUpdate=!0),L($.depthTexture,0);const Fe=xe.__webglTexture,ve=Re($);if($.depthTexture.format===Jd)De($)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,Fe,0,ve):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,Fe,0);else if($.depthTexture.format===Zd)De($)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,Fe,0,ve):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,Fe,0);else throw new Error("Unknown depthTexture format")}function Ue(G){const $=s.get(G),de=G.isWebGLCubeRenderTarget===!0;if($.__boundDepthTexture!==G.depthTexture){const xe=G.depthTexture;if($.__depthDisposeCallback&&$.__depthDisposeCallback(),xe){const Fe=()=>{delete $.__boundDepthTexture,delete $.__depthDisposeCallback,xe.removeEventListener("dispose",Fe)};xe.addEventListener("dispose",Fe),$.__depthDisposeCallback=Fe}$.__boundDepthTexture=xe}if(G.depthTexture&&!$.__autoAllocateDepthBuffer){if(de)throw new Error("target.depthTexture not supported in Cube render targets");const xe=G.texture.mipmaps;xe&&xe.length>0?Ne($.__webglFramebuffer[0],G):Ne($.__webglFramebuffer,G)}else if(de){$.__webglDepthbuffer=[];for(let xe=0;xe<6;xe++)if(t.bindFramebuffer(n.FRAMEBUFFER,$.__webglFramebuffer[xe]),$.__webglDepthbuffer[xe]===void 0)$.__webglDepthbuffer[xe]=n.createRenderbuffer(),ke($.__webglDepthbuffer[xe],G,!1);else{const Fe=G.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,ve=$.__webglDepthbuffer[xe];n.bindRenderbuffer(n.RENDERBUFFER,ve),n.framebufferRenderbuffer(n.FRAMEBUFFER,Fe,n.RENDERBUFFER,ve)}}else{const xe=G.texture.mipmaps;if(xe&&xe.length>0?t.bindFramebuffer(n.FRAMEBUFFER,$.__webglFramebuffer[0]):t.bindFramebuffer(n.FRAMEBUFFER,$.__webglFramebuffer),$.__webglDepthbuffer===void 0)$.__webglDepthbuffer=n.createRenderbuffer(),ke($.__webglDepthbuffer,G,!1);else{const Fe=G.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,ve=$.__webglDepthbuffer;n.bindRenderbuffer(n.RENDERBUFFER,ve),n.framebufferRenderbuffer(n.FRAMEBUFFER,Fe,n.RENDERBUFFER,ve)}}t.bindFramebuffer(n.FRAMEBUFFER,null)}function ht(G,$,de){const xe=s.get(G);$!==void 0&&_e(xe.__webglFramebuffer,G,G.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),de!==void 0&&Ue(G)}function W(G){const $=G.texture,de=s.get(G),xe=s.get($);G.addEventListener("dispose",E);const Fe=G.textures,ve=G.isWebGLCubeRenderTarget===!0,ut=Fe.length>1;if(ut||(xe.__webglTexture===void 0&&(xe.__webglTexture=n.createTexture()),xe.__version=$.version,o.memory.textures++),ve){de.__webglFramebuffer=[];for(let He=0;He<6;He++)if($.mipmaps&&$.mipmaps.length>0){de.__webglFramebuffer[He]=[];for(let pt=0;pt<$.mipmaps.length;pt++)de.__webglFramebuffer[He][pt]=n.createFramebuffer()}else de.__webglFramebuffer[He]=n.createFramebuffer()}else{if($.mipmaps&&$.mipmaps.length>0){de.__webglFramebuffer=[];for(let He=0;He<$.mipmaps.length;He++)de.__webglFramebuffer[He]=n.createFramebuffer()}else de.__webglFramebuffer=n.createFramebuffer();if(ut)for(let He=0,pt=Fe.length;He<pt;He++){const yt=s.get(Fe[He]);yt.__webglTexture===void 0&&(yt.__webglTexture=n.createTexture(),o.memory.textures++)}if(G.samples>0&&De(G)===!1){de.__webglMultisampledFramebuffer=n.createFramebuffer(),de.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,de.__webglMultisampledFramebuffer);for(let He=0;He<Fe.length;He++){const pt=Fe[He];de.__webglColorRenderbuffer[He]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,de.__webglColorRenderbuffer[He]);const yt=r.convert(pt.format,pt.colorSpace),Oe=r.convert(pt.type),tt=b(pt.internalFormat,yt,Oe,pt.colorSpace,G.isXRRenderTarget===!0),Nt=Re(G);n.renderbufferStorageMultisample(n.RENDERBUFFER,Nt,tt,G.width,G.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+He,n.RENDERBUFFER,de.__webglColorRenderbuffer[He])}n.bindRenderbuffer(n.RENDERBUFFER,null),G.depthBuffer&&(de.__webglDepthRenderbuffer=n.createRenderbuffer(),ke(de.__webglDepthRenderbuffer,G,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(ve){t.bindTexture(n.TEXTURE_CUBE_MAP,xe.__webglTexture),fe(n.TEXTURE_CUBE_MAP,$);for(let He=0;He<6;He++)if($.mipmaps&&$.mipmaps.length>0)for(let pt=0;pt<$.mipmaps.length;pt++)_e(de.__webglFramebuffer[He][pt],G,$,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+He,pt);else _e(de.__webglFramebuffer[He],G,$,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+He,0);m($)&&A(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(ut){for(let He=0,pt=Fe.length;He<pt;He++){const yt=Fe[He],Oe=s.get(yt);let tt=n.TEXTURE_2D;(G.isWebGL3DRenderTarget||G.isWebGLArrayRenderTarget)&&(tt=G.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),t.bindTexture(tt,Oe.__webglTexture),fe(tt,yt),_e(de.__webglFramebuffer,G,yt,n.COLOR_ATTACHMENT0+He,tt,0),m(yt)&&A(tt)}t.unbindTexture()}else{let He=n.TEXTURE_2D;if((G.isWebGL3DRenderTarget||G.isWebGLArrayRenderTarget)&&(He=G.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),t.bindTexture(He,xe.__webglTexture),fe(He,$),$.mipmaps&&$.mipmaps.length>0)for(let pt=0;pt<$.mipmaps.length;pt++)_e(de.__webglFramebuffer[pt],G,$,n.COLOR_ATTACHMENT0,He,pt);else _e(de.__webglFramebuffer,G,$,n.COLOR_ATTACHMENT0,He,0);m($)&&A(He),t.unbindTexture()}G.depthBuffer&&Ue(G)}function Ce(G){const $=G.textures;for(let de=0,xe=$.length;de<xe;de++){const Fe=$[de];if(m(Fe)){const ve=y(G),ut=s.get(Fe).__webglTexture;t.bindTexture(ve,ut),A(ve),t.unbindTexture()}}}const be=[],ge=[];function ye(G){if(G.samples>0){if(De(G)===!1){const $=G.textures,de=G.width,xe=G.height;let Fe=n.COLOR_BUFFER_BIT;const ve=G.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,ut=s.get(G),He=$.length>1;if(He)for(let yt=0;yt<$.length;yt++)t.bindFramebuffer(n.FRAMEBUFFER,ut.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+yt,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,ut.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+yt,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,ut.__webglMultisampledFramebuffer);const pt=G.texture.mipmaps;pt&&pt.length>0?t.bindFramebuffer(n.DRAW_FRAMEBUFFER,ut.__webglFramebuffer[0]):t.bindFramebuffer(n.DRAW_FRAMEBUFFER,ut.__webglFramebuffer);for(let yt=0;yt<$.length;yt++){if(G.resolveDepthBuffer&&(G.depthBuffer&&(Fe|=n.DEPTH_BUFFER_BIT),G.stencilBuffer&&G.resolveStencilBuffer&&(Fe|=n.STENCIL_BUFFER_BIT)),He){n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,ut.__webglColorRenderbuffer[yt]);const Oe=s.get($[yt]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,Oe,0)}n.blitFramebuffer(0,0,de,xe,0,0,de,xe,Fe,n.NEAREST),l===!0&&(be.length=0,ge.length=0,be.push(n.COLOR_ATTACHMENT0+yt),G.depthBuffer&&G.resolveDepthBuffer===!1&&(be.push(ve),ge.push(ve),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,ge)),n.invalidateFramebuffer(n.READ_FRAMEBUFFER,be))}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),He)for(let yt=0;yt<$.length;yt++){t.bindFramebuffer(n.FRAMEBUFFER,ut.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+yt,n.RENDERBUFFER,ut.__webglColorRenderbuffer[yt]);const Oe=s.get($[yt]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,ut.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+yt,n.TEXTURE_2D,Oe,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,ut.__webglMultisampledFramebuffer)}else if(G.depthBuffer&&G.resolveDepthBuffer===!1&&l){const $=G.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[$])}}}function Re(G){return Math.min(i.maxSamples,G.samples)}function De(G){const $=s.get(G);return G.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&$.__useRenderToTexture!==!1}function Me(G){const $=o.render.frame;u.get(G)!==$&&(u.set(G,$),G.update())}function Tt(G,$){const de=G.colorSpace,xe=G.format,Fe=G.type;return G.isCompressedTexture===!0||G.isVideoTexture===!0||de!==yu&&de!==Qa&&(gn.getTransfer(de)===kn?(xe!==ys||Fe!==Di)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",de)),$}function At(G){return typeof HTMLImageElement<"u"&&G instanceof HTMLImageElement?(c.width=G.naturalWidth||G.width,c.height=G.naturalHeight||G.height):typeof VideoFrame<"u"&&G instanceof VideoFrame?(c.width=G.displayWidth,c.height=G.displayHeight):(c.width=G.width,c.height=G.height),c}this.allocateTextureUnit=D,this.resetTextureUnits=N,this.setTexture2D=L,this.setTexture2DArray=z,this.setTexture3D=q,this.setTextureCube=V,this.rebindTextures=ht,this.setupRenderTarget=W,this.updateRenderTargetMipmap=Ce,this.updateMultisampleRenderTarget=ye,this.setupDepthRenderbuffer=Ue,this.setupFrameBufferTexture=_e,this.useMultisampledRTT=De}function XF(n,e){function t(s,i=Qa){let r;const o=gn.getTransfer(i);if(s===Di)return n.UNSIGNED_BYTE;if(s===AI)return n.UNSIGNED_SHORT_4_4_4_4;if(s===yI)return n.UNSIGNED_SHORT_5_5_5_1;if(s===wE)return n.UNSIGNED_INT_5_9_9_9_REV;if(s===vE)return n.UNSIGNED_INT_10F_11F_11F_REV;if(s===IE)return n.BYTE;if(s===CE)return n.SHORT;if(s===jd)return n.UNSIGNED_SHORT;if(s===gI)return n.INT;if(s===Ri)return n.UNSIGNED_INT;if(s===gr)return n.FLOAT;if(s===vp)return n.HALF_FLOAT;if(s===SE)return n.ALPHA;if(s===EE)return n.RGB;if(s===ys)return n.RGBA;if(s===Jd)return n.DEPTH_COMPONENT;if(s===Zd)return n.DEPTH_STENCIL;if(s===xI)return n.RED;if(s===Kg)return n.RED_INTEGER;if(s===_E)return n.RG;if(s===Jg)return n.RG_INTEGER;if(s===ha)return n.RGBA_INTEGER;if(s===Hm||s===qm||s===Ym||s===Xm)if(o===kn)if(r=e.get("WEBGL_compressed_texture_s3tc_srgb"),r!==null){if(s===Hm)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===qm)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===Ym)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===Xm)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(r=e.get("WEBGL_compressed_texture_s3tc"),r!==null){if(s===Hm)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===qm)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===Ym)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Xm)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===J0||s===Z0||s===eb||s===tb)if(r=e.get("WEBGL_compressed_texture_pvrtc"),r!==null){if(s===J0)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===Z0)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===eb)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===tb)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===nb||s===sb||s===ib)if(r=e.get("WEBGL_compressed_texture_etc"),r!==null){if(s===nb||s===sb)return o===kn?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(s===ib)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===rb||s===ob||s===ab||s===lb||s===cb||s===ub||s===hb||s===db||s===pb||s===fb||s===mb||s===gb||s===Ab||s===yb)if(r=e.get("WEBGL_compressed_texture_astc"),r!==null){if(s===rb)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===ob)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===ab)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===lb)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===cb)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===ub)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===hb)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===db)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===pb)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===fb)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===mb)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===gb)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===Ab)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===yb)return o===kn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===xb||s===bb||s===Ib)if(r=e.get("EXT_texture_compression_bptc"),r!==null){if(s===xb)return o===kn?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===bb)return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===Ib)return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(s===Cb||s===wb||s===vb||s===Sb)if(r=e.get("EXT_texture_compression_rgtc"),r!==null){if(s===Cb)return r.COMPRESSED_RED_RGTC1_EXT;if(s===wb)return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===vb)return r.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===Sb)return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===Kd?n.UNSIGNED_INT_24_8:n[s]!==void 0?n[s]:null}return{convert:t}}const EX=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,_X=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class TX{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t){if(this.texture===null){const s=new GE(e.texture);(e.depthNear!==t.depthNear||e.depthFar!==t.depthFar)&&(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=s}}getMesh(e){if(this.texture!==null&&this.mesh===null){const t=e.cameras[0].viewport,s=new Hr({vertexShader:EX,fragmentShader:_X,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new On(new Qu(20,20),s)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class BX extends Ca{constructor(e,t){super();const s=this;let i=null,r=1,o=null,a="local-floor",l=1,c=null,u=null,h=null,d=null,p=null,f=null;const g=typeof XRWebGLBinding<"u",m=new TX,A={},y=t.getContextAttributes();let b=null,x=null;const C=[],w=[],E=new $e;let T=null;const v=new Es;v.viewport=new Yt;const S=new Es;S.viewport=new Yt;const _=[v,S],N=new OF;let D=null,P=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(re){let ue=C[re];return ue===void 0&&(ue=new x0,C[re]=ue),ue.getTargetRaySpace()},this.getControllerGrip=function(re){let ue=C[re];return ue===void 0&&(ue=new x0,C[re]=ue),ue.getGripSpace()},this.getHand=function(re){let ue=C[re];return ue===void 0&&(ue=new x0,C[re]=ue),ue.getHandSpace()};function L(re){const ue=w.indexOf(re.inputSource);if(ue===-1)return;const _e=C[ue];_e!==void 0&&(_e.update(re.inputSource,re.frame,c||o),_e.dispatchEvent({type:re.type,data:re.inputSource}))}function z(){i.removeEventListener("select",L),i.removeEventListener("selectstart",L),i.removeEventListener("selectend",L),i.removeEventListener("squeeze",L),i.removeEventListener("squeezestart",L),i.removeEventListener("squeezeend",L),i.removeEventListener("end",z),i.removeEventListener("inputsourceschange",q);for(let re=0;re<C.length;re++){const ue=w[re];ue!==null&&(w[re]=null,C[re].disconnect(ue))}D=null,P=null,m.reset();for(const re in A)delete A[re];e.setRenderTarget(b),p=null,d=null,h=null,i=null,x=null,Ee.stop(),s.isPresenting=!1,e.setPixelRatio(T),e.setSize(E.width,E.height,!1),s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(re){r=re,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(re){a=re,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||o},this.setReferenceSpace=function(re){c=re},this.getBaseLayer=function(){return d!==null?d:p},this.getBinding=function(){return h===null&&g&&(h=new XRWebGLBinding(i,t)),h},this.getFrame=function(){return f},this.getSession=function(){return i},this.setSession=async function(re){if(i=re,i!==null){if(b=e.getRenderTarget(),i.addEventListener("select",L),i.addEventListener("selectstart",L),i.addEventListener("selectend",L),i.addEventListener("squeeze",L),i.addEventListener("squeezestart",L),i.addEventListener("squeezeend",L),i.addEventListener("end",z),i.addEventListener("inputsourceschange",q),y.xrCompatible!==!0&&await t.makeXRCompatible(),T=e.getPixelRatio(),e.getSize(E),g&&"createProjectionLayer"in XRWebGLBinding.prototype){let _e=null,ke=null,Ne=null;y.depth&&(Ne=y.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,_e=y.stencil?Zd:Jd,ke=y.stencil?Kd:Ri);const Ue={colorFormat:t.RGBA8,depthFormat:Ne,scaleFactor:r};h=this.getBinding(),d=h.createProjectionLayer(Ue),i.updateRenderState({layers:[d]}),e.setPixelRatio(1),e.setSize(d.textureWidth,d.textureHeight,!1),x=new ao(d.textureWidth,d.textureHeight,{format:ys,type:Di,depthTexture:new VE(d.textureWidth,d.textureHeight,ke,void 0,void 0,void 0,void 0,void 0,void 0,_e),stencilBuffer:y.stencil,colorSpace:e.outputColorSpace,samples:y.antialias?4:0,resolveDepthBuffer:d.ignoreDepthValues===!1,resolveStencilBuffer:d.ignoreDepthValues===!1})}else{const _e={antialias:y.antialias,alpha:!0,depth:y.depth,stencil:y.stencil,framebufferScaleFactor:r};p=new XRWebGLLayer(i,t,_e),i.updateRenderState({baseLayer:p}),e.setPixelRatio(1),e.setSize(p.framebufferWidth,p.framebufferHeight,!1),x=new ao(p.framebufferWidth,p.framebufferHeight,{format:ys,type:Di,colorSpace:e.outputColorSpace,stencilBuffer:y.stencil,resolveDepthBuffer:p.ignoreDepthValues===!1,resolveStencilBuffer:p.ignoreDepthValues===!1})}x.isXRRenderTarget=!0,this.setFoveation(l),c=null,o=await i.requestReferenceSpace(a),Ee.setContext(i),Ee.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return m.getDepthTexture()};function q(re){for(let ue=0;ue<re.removed.length;ue++){const _e=re.removed[ue],ke=w.indexOf(_e);ke>=0&&(w[ke]=null,C[ke].disconnect(_e))}for(let ue=0;ue<re.added.length;ue++){const _e=re.added[ue];let ke=w.indexOf(_e);if(ke===-1){for(let Ue=0;Ue<C.length;Ue++)if(Ue>=w.length){w.push(_e),ke=Ue;break}else if(w[Ue]===null){w[Ue]=_e,ke=Ue;break}if(ke===-1)break}const Ne=C[ke];Ne&&Ne.connect(_e)}}const V=new U,X=new U;function te(re,ue,_e){V.setFromMatrixPosition(ue.matrixWorld),X.setFromMatrixPosition(_e.matrixWorld);const ke=V.distanceTo(X),Ne=ue.projectionMatrix.elements,Ue=_e.projectionMatrix.elements,ht=Ne[14]/(Ne[10]-1),W=Ne[14]/(Ne[10]+1),Ce=(Ne[9]+1)/Ne[5],be=(Ne[9]-1)/Ne[5],ge=(Ne[8]-1)/Ne[0],ye=(Ue[8]+1)/Ue[0],Re=ht*ge,De=ht*ye,Me=ke/(-ge+ye),Tt=Me*-ge;if(ue.matrixWorld.decompose(re.position,re.quaternion,re.scale),re.translateX(Tt),re.translateZ(Me),re.matrixWorld.compose(re.position,re.quaternion,re.scale),re.matrixWorldInverse.copy(re.matrixWorld).invert(),Ne[10]===-1)re.projectionMatrix.copy(ue.projectionMatrix),re.projectionMatrixInverse.copy(ue.projectionMatrixInverse);else{const At=ht+Me,G=W+Me,$=Re-Tt,de=De+(ke-Tt),xe=Ce*W/G*At,Fe=be*W/G*At;re.projectionMatrix.makePerspective($,de,xe,Fe,At,G),re.projectionMatrixInverse.copy(re.projectionMatrix).invert()}}function se(re,ue){ue===null?re.matrixWorld.copy(re.matrix):re.matrixWorld.multiplyMatrices(ue.matrixWorld,re.matrix),re.matrixWorldInverse.copy(re.matrixWorld).invert()}this.updateCamera=function(re){if(i===null)return;let ue=re.near,_e=re.far;m.texture!==null&&(m.depthNear>0&&(ue=m.depthNear),m.depthFar>0&&(_e=m.depthFar)),N.near=S.near=v.near=ue,N.far=S.far=v.far=_e,(D!==N.near||P!==N.far)&&(i.updateRenderState({depthNear:N.near,depthFar:N.far}),D=N.near,P=N.far),N.layers.mask=re.layers.mask|6,v.layers.mask=N.layers.mask&3,S.layers.mask=N.layers.mask&5;const ke=re.parent,Ne=N.cameras;se(N,ke);for(let Ue=0;Ue<Ne.length;Ue++)se(Ne[Ue],ke);Ne.length===2?te(N,v,S):N.projectionMatrix.copy(v.projectionMatrix),fe(re,N,ke)};function fe(re,ue,_e){_e===null?re.matrix.copy(ue.matrixWorld):(re.matrix.copy(_e.matrixWorld),re.matrix.invert(),re.matrix.multiply(ue.matrixWorld)),re.matrix.decompose(re.position,re.quaternion,re.scale),re.updateMatrixWorld(!0),re.projectionMatrix.copy(ue.projectionMatrix),re.projectionMatrixInverse.copy(ue.projectionMatrixInverse),re.isPerspectiveCamera&&(re.fov=tp*2*Math.atan(1/re.projectionMatrix.elements[5]),re.zoom=1)}this.getCamera=function(){return N},this.getFoveation=function(){if(!(d===null&&p===null))return l},this.setFoveation=function(re){l=re,d!==null&&(d.fixedFoveation=re),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=re)},this.hasDepthSensing=function(){return m.texture!==null},this.getDepthSensingMesh=function(){return m.getMesh(N)},this.getCameraTexture=function(re){return A[re]};let me=null;function Te(re,ue){if(u=ue.getViewerPose(c||o),f=ue,u!==null){const _e=u.views;p!==null&&(e.setRenderTargetFramebuffer(x,p.framebuffer),e.setRenderTarget(x));let ke=!1;_e.length!==N.cameras.length&&(N.cameras.length=0,ke=!0);for(let W=0;W<_e.length;W++){const Ce=_e[W];let be=null;if(p!==null)be=p.getViewport(Ce);else{const ye=h.getViewSubImage(d,Ce);be=ye.viewport,W===0&&(e.setRenderTargetTextures(x,ye.colorTexture,ye.depthStencilTexture),e.setRenderTarget(x))}let ge=_[W];ge===void 0&&(ge=new Es,ge.layers.enable(W),ge.viewport=new Yt,_[W]=ge),ge.matrix.fromArray(Ce.transform.matrix),ge.matrix.decompose(ge.position,ge.quaternion,ge.scale),ge.projectionMatrix.fromArray(Ce.projectionMatrix),ge.projectionMatrixInverse.copy(ge.projectionMatrix).invert(),ge.viewport.set(be.x,be.y,be.width,be.height),W===0&&(N.matrix.copy(ge.matrix),N.matrix.decompose(N.position,N.quaternion,N.scale)),ke===!0&&N.cameras.push(ge)}const Ne=i.enabledFeatures;if(Ne&&Ne.includes("depth-sensing")&&i.depthUsage=="gpu-optimized"&&g){h=s.getBinding();const W=h.getDepthInformation(_e[0]);W&&W.isValid&&W.texture&&m.init(W,i.renderState)}if(Ne&&Ne.includes("camera-access")&&g){e.state.unbindTexture(),h=s.getBinding();for(let W=0;W<_e.length;W++){const Ce=_e[W].camera;if(Ce){let be=A[Ce];be||(be=new GE,A[Ce]=be);const ge=h.getCameraImage(Ce);be.sourceTexture=ge}}}}for(let _e=0;_e<C.length;_e++){const ke=w[_e],Ne=C[_e];ke!==null&&Ne!==void 0&&Ne.update(ke,ue,c||o)}me&&me(re,ue),ue.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:ue}),f=null}const Ee=new GF;Ee.setAnimationLoop(Te),this.setAnimationLoop=function(re){me=re},this.dispose=function(){}}}const Rc=new Wr,kX=new kt;function MX(n,e){function t(m,A){m.matrixAutoUpdate===!0&&m.updateMatrix(),A.value.copy(m.matrix)}function s(m,A){A.color.getRGB(m.fogColor.value,j3(n)),A.isFog?(m.fogNear.value=A.near,m.fogFar.value=A.far):A.isFogExp2&&(m.fogDensity.value=A.density)}function i(m,A,y,b,x){A.isMeshBasicMaterial||A.isMeshLambertMaterial?r(m,A):A.isMeshToonMaterial?(r(m,A),h(m,A)):A.isMeshPhongMaterial?(r(m,A),u(m,A)):A.isMeshStandardMaterial?(r(m,A),d(m,A),A.isMeshPhysicalMaterial&&p(m,A,x)):A.isMeshMatcapMaterial?(r(m,A),f(m,A)):A.isMeshDepthMaterial?r(m,A):A.isMeshDistanceMaterial?(r(m,A),g(m,A)):A.isMeshNormalMaterial?r(m,A):A.isLineBasicMaterial?(o(m,A),A.isLineDashedMaterial&&a(m,A)):A.isPointsMaterial?l(m,A,y,b):A.isSpriteMaterial?c(m,A):A.isShadowMaterial?(m.color.value.copy(A.color),m.opacity.value=A.opacity):A.isShaderMaterial&&(A.uniformsNeedUpdate=!1)}function r(m,A){m.opacity.value=A.opacity,A.color&&m.diffuse.value.copy(A.color),A.emissive&&m.emissive.value.copy(A.emissive).multiplyScalar(A.emissiveIntensity),A.map&&(m.map.value=A.map,t(A.map,m.mapTransform)),A.alphaMap&&(m.alphaMap.value=A.alphaMap,t(A.alphaMap,m.alphaMapTransform)),A.bumpMap&&(m.bumpMap.value=A.bumpMap,t(A.bumpMap,m.bumpMapTransform),m.bumpScale.value=A.bumpScale,A.side===ji&&(m.bumpScale.value*=-1)),A.normalMap&&(m.normalMap.value=A.normalMap,t(A.normalMap,m.normalMapTransform),m.normalScale.value.copy(A.normalScale),A.side===ji&&m.normalScale.value.negate()),A.displacementMap&&(m.displacementMap.value=A.displacementMap,t(A.displacementMap,m.displacementMapTransform),m.displacementScale.value=A.displacementScale,m.displacementBias.value=A.displacementBias),A.emissiveMap&&(m.emissiveMap.value=A.emissiveMap,t(A.emissiveMap,m.emissiveMapTransform)),A.specularMap&&(m.specularMap.value=A.specularMap,t(A.specularMap,m.specularMapTransform)),A.alphaTest>0&&(m.alphaTest.value=A.alphaTest);const y=e.get(A),b=y.envMap,x=y.envMapRotation;b&&(m.envMap.value=b,Rc.copy(x),Rc.x*=-1,Rc.y*=-1,Rc.z*=-1,b.isCubeTexture&&b.isRenderTargetTexture===!1&&(Rc.y*=-1,Rc.z*=-1),m.envMapRotation.value.setFromMatrix4(kX.makeRotationFromEuler(Rc)),m.flipEnvMap.value=b.isCubeTexture&&b.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=A.reflectivity,m.ior.value=A.ior,m.refractionRatio.value=A.refractionRatio),A.lightMap&&(m.lightMap.value=A.lightMap,m.lightMapIntensity.value=A.lightMapIntensity,t(A.lightMap,m.lightMapTransform)),A.aoMap&&(m.aoMap.value=A.aoMap,m.aoMapIntensity.value=A.aoMapIntensity,t(A.aoMap,m.aoMapTransform))}function o(m,A){m.diffuse.value.copy(A.color),m.opacity.value=A.opacity,A.map&&(m.map.value=A.map,t(A.map,m.mapTransform))}function a(m,A){m.dashSize.value=A.dashSize,m.totalSize.value=A.dashSize+A.gapSize,m.scale.value=A.scale}function l(m,A,y,b){m.diffuse.value.copy(A.color),m.opacity.value=A.opacity,m.size.value=A.size*y,m.scale.value=b*.5,A.map&&(m.map.value=A.map,t(A.map,m.uvTransform)),A.alphaMap&&(m.alphaMap.value=A.alphaMap,t(A.alphaMap,m.alphaMapTransform)),A.alphaTest>0&&(m.alphaTest.value=A.alphaTest)}function c(m,A){m.diffuse.value.copy(A.color),m.opacity.value=A.opacity,m.rotation.value=A.rotation,A.map&&(m.map.value=A.map,t(A.map,m.mapTransform)),A.alphaMap&&(m.alphaMap.value=A.alphaMap,t(A.alphaMap,m.alphaMapTransform)),A.alphaTest>0&&(m.alphaTest.value=A.alphaTest)}function u(m,A){m.specular.value.copy(A.specular),m.shininess.value=Math.max(A.shininess,1e-4)}function h(m,A){A.gradientMap&&(m.gradientMap.value=A.gradientMap)}function d(m,A){m.metalness.value=A.metalness,A.metalnessMap&&(m.metalnessMap.value=A.metalnessMap,t(A.metalnessMap,m.metalnessMapTransform)),m.roughness.value=A.roughness,A.roughnessMap&&(m.roughnessMap.value=A.roughnessMap,t(A.roughnessMap,m.roughnessMapTransform)),A.envMap&&(m.envMapIntensity.value=A.envMapIntensity)}function p(m,A,y){m.ior.value=A.ior,A.sheen>0&&(m.sheenColor.value.copy(A.sheenColor).multiplyScalar(A.sheen),m.sheenRoughness.value=A.sheenRoughness,A.sheenColorMap&&(m.sheenColorMap.value=A.sheenColorMap,t(A.sheenColorMap,m.sheenColorMapTransform)),A.sheenRoughnessMap&&(m.sheenRoughnessMap.value=A.sheenRoughnessMap,t(A.sheenRoughnessMap,m.sheenRoughnessMapTransform))),A.clearcoat>0&&(m.clearcoat.value=A.clearcoat,m.clearcoatRoughness.value=A.clearcoatRoughness,A.clearcoatMap&&(m.clearcoatMap.value=A.clearcoatMap,t(A.clearcoatMap,m.clearcoatMapTransform)),A.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=A.clearcoatRoughnessMap,t(A.clearcoatRoughnessMap,m.clearcoatRoughnessMapTransform)),A.clearcoatNormalMap&&(m.clearcoatNormalMap.value=A.clearcoatNormalMap,t(A.clearcoatNormalMap,m.clearcoatNormalMapTransform),m.clearcoatNormalScale.value.copy(A.clearcoatNormalScale),A.side===ji&&m.clearcoatNormalScale.value.negate())),A.dispersion>0&&(m.dispersion.value=A.dispersion),A.iridescence>0&&(m.iridescence.value=A.iridescence,m.iridescenceIOR.value=A.iridescenceIOR,m.iridescenceThicknessMinimum.value=A.iridescenceThicknessRange[0],m.iridescenceThicknessMaximum.value=A.iridescenceThicknessRange[1],A.iridescenceMap&&(m.iridescenceMap.value=A.iridescenceMap,t(A.iridescenceMap,m.iridescenceMapTransform)),A.iridescenceThicknessMap&&(m.iridescenceThicknessMap.value=A.iridescenceThicknessMap,t(A.iridescenceThicknessMap,m.iridescenceThicknessMapTransform))),A.transmission>0&&(m.transmission.value=A.transmission,m.transmissionSamplerMap.value=y.texture,m.transmissionSamplerSize.value.set(y.width,y.height),A.transmissionMap&&(m.transmissionMap.value=A.transmissionMap,t(A.transmissionMap,m.transmissionMapTransform)),m.thickness.value=A.thickness,A.thicknessMap&&(m.thicknessMap.value=A.thicknessMap,t(A.thicknessMap,m.thicknessMapTransform)),m.attenuationDistance.value=A.attenuationDistance,m.attenuationColor.value.copy(A.attenuationColor)),A.anisotropy>0&&(m.anisotropyVector.value.set(A.anisotropy*Math.cos(A.anisotropyRotation),A.anisotropy*Math.sin(A.anisotropyRotation)),A.anisotropyMap&&(m.anisotropyMap.value=A.anisotropyMap,t(A.anisotropyMap,m.anisotropyMapTransform))),m.specularIntensity.value=A.specularIntensity,m.specularColor.value.copy(A.specularColor),A.specularColorMap&&(m.specularColorMap.value=A.specularColorMap,t(A.specularColorMap,m.specularColorMapTransform)),A.specularIntensityMap&&(m.specularIntensityMap.value=A.specularIntensityMap,t(A.specularIntensityMap,m.specularIntensityMapTransform))}function f(m,A){A.matcap&&(m.matcap.value=A.matcap)}function g(m,A){const y=e.get(A).light;m.referencePosition.value.setFromMatrixPosition(y.matrixWorld),m.nearDistance.value=y.shadow.camera.near,m.farDistance.value=y.shadow.camera.far}return{refreshFogUniforms:s,refreshMaterialUniforms:i}}function NX(n,e,t,s){let i={},r={},o=[];const a=n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);function l(y,b){const x=b.program;s.uniformBlockBinding(y,x)}function c(y,b){let x=i[y.id];x===void 0&&(f(y),x=u(y),i[y.id]=x,y.addEventListener("dispose",m));const C=b.program;s.updateUBOMapping(y,C);const w=e.render.frame;r[y.id]!==w&&(d(y),r[y.id]=w)}function u(y){const b=h();y.__bindingPointIndex=b;const x=n.createBuffer(),C=y.__size,w=y.usage;return n.bindBuffer(n.UNIFORM_BUFFER,x),n.bufferData(n.UNIFORM_BUFFER,C,w),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,b,x),x}function h(){for(let y=0;y<a;y++)if(o.indexOf(y)===-1)return o.push(y),y;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(y){const b=i[y.id],x=y.uniforms,C=y.__cache;n.bindBuffer(n.UNIFORM_BUFFER,b);for(let w=0,E=x.length;w<E;w++){const T=Array.isArray(x[w])?x[w]:[x[w]];for(let v=0,S=T.length;v<S;v++){const _=T[v];if(p(_,w,v,C)===!0){const N=_.__offset,D=Array.isArray(_.value)?_.value:[_.value];let P=0;for(let L=0;L<D.length;L++){const z=D[L],q=g(z);typeof z=="number"||typeof z=="boolean"?(_.__data[0]=z,n.bufferSubData(n.UNIFORM_BUFFER,N+P,_.__data)):z.isMatrix3?(_.__data[0]=z.elements[0],_.__data[1]=z.elements[1],_.__data[2]=z.elements[2],_.__data[3]=0,_.__data[4]=z.elements[3],_.__data[5]=z.elements[4],_.__data[6]=z.elements[5],_.__data[7]=0,_.__data[8]=z.elements[6],_.__data[9]=z.elements[7],_.__data[10]=z.elements[8],_.__data[11]=0):(z.toArray(_.__data,P),P+=q.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,N,_.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function p(y,b,x,C){const w=y.value,E=b+"_"+x;if(C[E]===void 0)return typeof w=="number"||typeof w=="boolean"?C[E]=w:C[E]=w.clone(),!0;{const T=C[E];if(typeof w=="number"||typeof w=="boolean"){if(T!==w)return C[E]=w,!0}else if(T.equals(w)===!1)return T.copy(w),!0}return!1}function f(y){const b=y.uniforms;let x=0;const C=16;for(let E=0,T=b.length;E<T;E++){const v=Array.isArray(b[E])?b[E]:[b[E]];for(let S=0,_=v.length;S<_;S++){const N=v[S],D=Array.isArray(N.value)?N.value:[N.value];for(let P=0,L=D.length;P<L;P++){const z=D[P],q=g(z),V=x%C,X=V%q.boundary,te=V+X;x+=X,te!==0&&C-te<q.storage&&(x+=C-te),N.__data=new Float32Array(q.storage/Float32Array.BYTES_PER_ELEMENT),N.__offset=x,x+=q.storage}}}const w=x%C;return w>0&&(x+=C-w),y.__size=x,y.__cache={},this}function g(y){const b={boundary:0,storage:0};return typeof y=="number"||typeof y=="boolean"?(b.boundary=4,b.storage=4):y.isVector2?(b.boundary=8,b.storage=8):y.isVector3||y.isColor?(b.boundary=16,b.storage=12):y.isVector4?(b.boundary=16,b.storage=16):y.isMatrix3?(b.boundary=48,b.storage=48):y.isMatrix4?(b.boundary=64,b.storage=64):y.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",y),b}function m(y){const b=y.target;b.removeEventListener("dispose",m);const x=o.indexOf(b.__bindingPointIndex);o.splice(x,1),n.deleteBuffer(i[b.id]),delete i[b.id],delete r[b.id]}function A(){for(const y in i)n.deleteBuffer(i[y]);o=[],i={},r={}}return{bind:l,update:c,dispose:A}}class jF{constructor(e={}){const{canvas:t=q3(),context:s=null,depth:i=!0,stencil:r=!1,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:u="default",failIfMajorPerformanceCaveat:h=!1,reversedDepthBuffer:d=!1}=e;this.isWebGLRenderer=!0;let p;if(s!==null){if(typeof WebGLRenderingContext<"u"&&s instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");p=s.getContextAttributes().alpha}else p=o;const f=new Uint32Array(4),g=new Int32Array(4);let m=null,A=null;const y=[],b=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=Ya,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const x=this;let C=!1;this._outputColorSpace=Ei;let w=0,E=0,T=null,v=-1,S=null;const _=new Yt,N=new Yt;let D=null;const P=new ot(0);let L=0,z=t.width,q=t.height,V=1,X=null,te=null;const se=new Yt(0,0,z,q),fe=new Yt(0,0,z,q);let me=!1;const Te=new Ep;let Ee=!1,re=!1;const ue=new kt,_e=new U,ke=new Yt,Ne={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Ue=!1;function ht(){return T===null?V:1}let W=s;function Ce(Q,he){return t.getContext(Q,he)}try{const Q={alpha:!0,depth:i,stencil:r,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:u,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${fI}`),t.addEventListener("webglcontextlost",je,!1),t.addEventListener("webglcontextrestored",mt,!1),t.addEventListener("webglcontextcreationerror",Qe,!1),W===null){const he="webgl2";if(W=Ce(he,Q),W===null)throw Ce(he)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(Q){throw console.error("THREE.WebGLRenderer: "+Q.message),Q}let be,ge,ye,Re,De,Me,Tt,At,G,$,de,xe,Fe,ve,ut,He,pt,yt,Oe,tt,Nt,_t,st,Wt;function ie(){be=new G6(W),be.init(),_t=new XF(W,be),ge=new P6(W,be,e,_t),ye=new vX(W,be),ge.reversedDepthBuffer&&d&&ye.buffers.depth.setReversed(!0),Re=new q6(W),De=new hX,Me=new SX(W,be,ye,De,ge,_t,Re),Tt=new O6(x),At=new V6(x),G=new Z5(W),st=new F6(W,G),$=new W6(W,G,Re,st),de=new X6(W,$,G,Re),Oe=new Y6(W,ge,Me),He=new L6(De),xe=new uX(x,Tt,At,be,ge,st,He),Fe=new MX(x,De),ve=new pX,ut=new xX(be),yt=new D6(x,Tt,At,ye,de,p,l),pt=new CX(x,de,ge),Wt=new NX(W,Re,ge,ye),tt=new $6(W,be,Re),Nt=new H6(W,be,Re),Re.programs=xe.programs,x.capabilities=ge,x.extensions=be,x.properties=De,x.renderLists=ve,x.shadowMap=pt,x.state=ye,x.info=Re}ie();const Ve=new BX(x,W);this.xr=Ve,this.getContext=function(){return W},this.getContextAttributes=function(){return W.getContextAttributes()},this.forceContextLoss=function(){const Q=be.get("WEBGL_lose_context");Q&&Q.loseContext()},this.forceContextRestore=function(){const Q=be.get("WEBGL_lose_context");Q&&Q.restoreContext()},this.getPixelRatio=function(){return V},this.setPixelRatio=function(Q){Q!==void 0&&(V=Q,this.setSize(z,q,!1))},this.getSize=function(Q){return Q.set(z,q)},this.setSize=function(Q,he,Ae=!0){if(Ve.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}z=Q,q=he,t.width=Math.floor(Q*V),t.height=Math.floor(he*V),Ae===!0&&(t.style.width=Q+"px",t.style.height=he+"px"),this.setViewport(0,0,Q,he)},this.getDrawingBufferSize=function(Q){return Q.set(z*V,q*V).floor()},this.setDrawingBufferSize=function(Q,he,Ae){z=Q,q=he,V=Ae,t.width=Math.floor(Q*Ae),t.height=Math.floor(he*Ae),this.setViewport(0,0,Q,he)},this.getCurrentViewport=function(Q){return Q.copy(_)},this.getViewport=function(Q){return Q.copy(se)},this.setViewport=function(Q,he,Ae,we){Q.isVector4?se.set(Q.x,Q.y,Q.z,Q.w):se.set(Q,he,Ae,we),ye.viewport(_.copy(se).multiplyScalar(V).round())},this.getScissor=function(Q){return Q.copy(fe)},this.setScissor=function(Q,he,Ae,we){Q.isVector4?fe.set(Q.x,Q.y,Q.z,Q.w):fe.set(Q,he,Ae,we),ye.scissor(N.copy(fe).multiplyScalar(V).round())},this.getScissorTest=function(){return me},this.setScissorTest=function(Q){ye.setScissorTest(me=Q)},this.setOpaqueSort=function(Q){X=Q},this.setTransparentSort=function(Q){te=Q},this.getClearColor=function(Q){return Q.copy(yt.getClearColor())},this.setClearColor=function(){yt.setClearColor(...arguments)},this.getClearAlpha=function(){return yt.getClearAlpha()},this.setClearAlpha=function(){yt.setClearAlpha(...arguments)},this.clear=function(Q=!0,he=!0,Ae=!0){let we=0;if(Q){let pe=!1;if(T!==null){const Ge=T.texture.format;pe=Ge===ha||Ge===Jg||Ge===Kg}if(pe){const Ge=T.texture.type,lt=Ge===Di||Ge===Ri||Ge===jd||Ge===Kd||Ge===AI||Ge===yI,xt=yt.getClearColor(),it=yt.getClearAlpha(),Dt=xt.r,Ft=xt.g,Ct=xt.b;lt?(f[0]=Dt,f[1]=Ft,f[2]=Ct,f[3]=it,W.clearBufferuiv(W.COLOR,0,f)):(g[0]=Dt,g[1]=Ft,g[2]=Ct,g[3]=it,W.clearBufferiv(W.COLOR,0,g))}else we|=W.COLOR_BUFFER_BIT}he&&(we|=W.DEPTH_BUFFER_BIT),Ae&&(we|=W.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),W.clear(we)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",je,!1),t.removeEventListener("webglcontextrestored",mt,!1),t.removeEventListener("webglcontextcreationerror",Qe,!1),yt.dispose(),ve.dispose(),ut.dispose(),De.dispose(),Tt.dispose(),At.dispose(),de.dispose(),st.dispose(),Wt.dispose(),xe.dispose(),Ve.dispose(),Ve.removeEventListener("sessionstart",Jr),Ve.removeEventListener("sessionend",ka),Ma.stop()};function je(Q){Q.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),C=!0}function mt(){console.log("THREE.WebGLRenderer: Context Restored."),C=!1;const Q=Re.autoReset,he=pt.enabled,Ae=pt.autoUpdate,we=pt.needsUpdate,pe=pt.type;ie(),Re.autoReset=Q,pt.enabled=he,pt.autoUpdate=Ae,pt.needsUpdate=we,pt.type=pe}function Qe(Q){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",Q.statusMessage)}function Pe(Q){const he=Q.target;he.removeEventListener("dispose",Pe),dt(he)}function dt(Q){Gt(Q),De.remove(Q)}function Gt(Q){const he=De.get(Q).programs;he!==void 0&&(he.forEach(function(Ae){xe.releaseProgram(Ae)}),Q.isShaderMaterial&&xe.releaseShaderCache(Q))}this.renderBufferDirect=function(Q,he,Ae,we,pe,Ge){he===null&&(he=Ne);const lt=pe.isMesh&&pe.matrixWorld.determinant()<0,xt=sm(Q,he,Ae,we,pe);ye.setMaterial(we,lt);let it=Ae.index,Dt=1;if(we.wireframe===!0){if(it=$.getWireframeAttribute(Ae),it===void 0)return;Dt=2}const Ft=Ae.drawRange,Ct=Ae.attributes.position;let en=Ft.start*Dt,Cn=(Ft.start+Ft.count)*Dt;Ge!==null&&(en=Math.max(en,Ge.start*Dt),Cn=Math.min(Cn,(Ge.start+Ge.count)*Dt)),it!==null?(en=Math.max(en,0),Cn=Math.min(Cn,it.count)):Ct!=null&&(en=Math.max(en,0),Cn=Math.min(Cn,Ct.count));const Yn=Cn-en;if(Yn<0||Yn===1/0)return;st.setup(pe,we,xt,Ae,it);let Tn,Bn=tt;if(it!==null&&(Tn=G.get(it),Bn=Nt,Bn.setIndex(Tn)),pe.isMesh)we.wireframe===!0?(ye.setLineWidth(we.wireframeLinewidth*ht()),Bn.setMode(W.LINES)):Bn.setMode(W.TRIANGLES);else if(pe.isLine){let Rt=we.linewidth;Rt===void 0&&(Rt=1),ye.setLineWidth(Rt*ht()),pe.isLineSegments?Bn.setMode(W.LINES):pe.isLineLoop?Bn.setMode(W.LINE_LOOP):Bn.setMode(W.LINE_STRIP)}else pe.isPoints?Bn.setMode(W.POINTS):pe.isSprite&&Bn.setMode(W.TRIANGLES);if(pe.isBatchedMesh)if(pe._multiDrawInstances!==null)mg("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),Bn.renderMultiDrawInstances(pe._multiDrawStarts,pe._multiDrawCounts,pe._multiDrawCount,pe._multiDrawInstances);else if(be.get("WEBGL_multi_draw"))Bn.renderMultiDraw(pe._multiDrawStarts,pe._multiDrawCounts,pe._multiDrawCount);else{const Rt=pe._multiDrawStarts,Wn=pe._multiDrawCounts,dn=pe._multiDrawCount,yi=it?G.get(it).bytesPerElement:1,Na=De.get(we).currentProgram.getUniforms();for(let Rn=0;Rn<dn;Rn++)Na.setValue(W,"_gl_DrawID",Rn),Bn.render(Rt[Rn]/yi,Wn[Rn])}else if(pe.isInstancedMesh)Bn.renderInstances(en,Yn,pe.count);else if(Ae.isInstancedBufferGeometry){const Rt=Ae._maxInstanceCount!==void 0?Ae._maxInstanceCount:1/0,Wn=Math.min(Ae.instanceCount,Rt);Bn.renderInstances(en,Yn,Wn)}else Bn.render(en,Yn)};function _n(Q,he,Ae){Q.transparent===!0&&Q.side===io&&Q.forceSinglePass===!1?(Q.side=ji,Q.needsUpdate=!0,Al(Q,he,Ae),Q.side=Za,Q.needsUpdate=!0,Al(Q,he,Ae),Q.side=io):Al(Q,he,Ae)}this.compile=function(Q,he,Ae=null){Ae===null&&(Ae=Q),A=ut.get(Ae),A.init(he),b.push(A),Ae.traverseVisible(function(pe){pe.isLight&&pe.layers.test(he.layers)&&(A.pushLight(pe),pe.castShadow&&A.pushShadow(pe))}),Q!==Ae&&Q.traverseVisible(function(pe){pe.isLight&&pe.layers.test(he.layers)&&(A.pushLight(pe),pe.castShadow&&A.pushShadow(pe))}),A.setupLights();const we=new Set;return Q.traverse(function(pe){if(!(pe.isMesh||pe.isPoints||pe.isLine||pe.isSprite))return;const Ge=pe.material;if(Ge)if(Array.isArray(Ge))for(let lt=0;lt<Ge.length;lt++){const xt=Ge[lt];_n(xt,Ae,pe),we.add(xt)}else _n(Ge,Ae,pe),we.add(Ge)}),A=b.pop(),we},this.compileAsync=function(Q,he,Ae=null){const we=this.compile(Q,he,Ae);return new Promise(pe=>{function Ge(){if(we.forEach(function(lt){De.get(lt).currentProgram.isReady()&&we.delete(lt)}),we.size===0){pe(Q);return}setTimeout(Ge,10)}be.get("KHR_parallel_shader_compile")!==null?Ge():setTimeout(Ge,10)})};let hn=null;function or(Q){hn&&hn(Q)}function Jr(){Ma.stop()}function ka(){Ma.start()}const Ma=new GF;Ma.setAnimationLoop(or),typeof self<"u"&&Ma.setContext(self),this.setAnimationLoop=function(Q){hn=Q,Ve.setAnimationLoop(Q),Q===null?Ma.stop():Ma.start()},Ve.addEventListener("sessionstart",Jr),Ve.addEventListener("sessionend",ka),this.render=function(Q,he){if(he!==void 0&&he.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(C===!0)return;if(Q.matrixWorldAutoUpdate===!0&&Q.updateMatrixWorld(),he.parent===null&&he.matrixWorldAutoUpdate===!0&&he.updateMatrixWorld(),Ve.enabled===!0&&Ve.isPresenting===!0&&(Ve.cameraAutoUpdate===!0&&Ve.updateCamera(he),he=Ve.getCamera()),Q.isScene===!0&&Q.onBeforeRender(x,Q,he,T),A=ut.get(Q,b.length),A.init(he),b.push(A),ue.multiplyMatrices(he.projectionMatrix,he.matrixWorldInverse),Te.setFromProjectionMatrix(ue,Lr,he.reversedDepth),re=this.localClippingEnabled,Ee=He.init(this.clippingPlanes,re),m=ve.get(Q,y.length),m.init(),y.push(m),Ve.enabled===!0&&Ve.isPresenting===!0){const Ge=x.xr.getDepthSensingMesh();Ge!==null&&Tr(Ge,he,-1/0,x.sortObjects)}Tr(Q,he,0,x.sortObjects),m.finish(),x.sortObjects===!0&&m.sort(X,te),Ue=Ve.enabled===!1||Ve.isPresenting===!1||Ve.hasDepthSensing()===!1,Ue&&yt.addToRenderList(m,Q),this.info.render.frame++,Ee===!0&&He.beginShadows();const Ae=A.state.shadowsArray;pt.render(Ae,Q,he),Ee===!0&&He.endShadows(),this.info.autoReset===!0&&this.info.reset();const we=m.opaque,pe=m.transmissive;if(A.setupLights(),he.isArrayCamera){const Ge=he.cameras;if(pe.length>0)for(let lt=0,xt=Ge.length;lt<xt;lt++){const it=Ge[lt];nm(we,pe,Q,it)}Ue&&yt.render(Q);for(let lt=0,xt=Ge.length;lt<xt;lt++){const it=Ge[lt];jo(m,Q,it,it.viewport)}}else pe.length>0&&nm(we,pe,Q,he),Ue&&yt.render(Q),jo(m,Q,he);T!==null&&E===0&&(Me.updateMultisampleRenderTarget(T),Me.updateRenderTargetMipmap(T)),Q.isScene===!0&&Q.onAfterRender(x,Q,he),st.resetDefaultState(),v=-1,S=null,b.pop(),b.length>0?(A=b[b.length-1],Ee===!0&&He.setGlobalState(x.clippingPlanes,A.state.camera)):A=null,y.pop(),y.length>0?m=y[y.length-1]:m=null};function Tr(Q,he,Ae,we){if(Q.visible===!1)return;if(Q.layers.test(he.layers)){if(Q.isGroup)Ae=Q.renderOrder;else if(Q.isLOD)Q.autoUpdate===!0&&Q.update(he);else if(Q.isLight)A.pushLight(Q),Q.castShadow&&A.pushShadow(Q);else if(Q.isSprite){if(!Q.frustumCulled||Te.intersectsSprite(Q)){we&&ke.setFromMatrixPosition(Q.matrixWorld).applyMatrix4(ue);const lt=de.update(Q),xt=Q.material;xt.visible&&m.push(Q,lt,xt,Ae,ke.z,null)}}else if((Q.isMesh||Q.isLine||Q.isPoints)&&(!Q.frustumCulled||Te.intersectsObject(Q))){const lt=de.update(Q),xt=Q.material;if(we&&(Q.boundingSphere!==void 0?(Q.boundingSphere===null&&Q.computeBoundingSphere(),ke.copy(Q.boundingSphere.center)):(lt.boundingSphere===null&&lt.computeBoundingSphere(),ke.copy(lt.boundingSphere.center)),ke.applyMatrix4(Q.matrixWorld).applyMatrix4(ue)),Array.isArray(xt)){const it=lt.groups;for(let Dt=0,Ft=it.length;Dt<Ft;Dt++){const Ct=it[Dt],en=xt[Ct.materialIndex];en&&en.visible&&m.push(Q,lt,en,Ae,ke.z,Ct)}}else xt.visible&&m.push(Q,lt,xt,Ae,ke.z,null)}}const Ge=Q.children;for(let lt=0,xt=Ge.length;lt<xt;lt++)Tr(Ge[lt],he,Ae,we)}function jo(Q,he,Ae,we){const pe=Q.opaque,Ge=Q.transmissive,lt=Q.transparent;A.setupLightsView(Ae),Ee===!0&&He.setGlobalState(x.clippingPlanes,Ae),we&&ye.viewport(_.copy(we)),pe.length>0&&Gn(pe,he,Ae),Ge.length>0&&Gn(Ge,he,Ae),lt.length>0&&Gn(lt,he,Ae),ye.buffers.depth.setTest(!0),ye.buffers.depth.setMask(!0),ye.buffers.color.setMask(!0),ye.setPolygonOffset(!1)}function nm(Q,he,Ae,we){if((Ae.isScene===!0?Ae.overrideMaterial:null)!==null)return;A.state.transmissionRenderTarget[we.id]===void 0&&(A.state.transmissionRenderTarget[we.id]=new ao(1,1,{generateMipmaps:!0,type:be.has("EXT_color_buffer_half_float")||be.has("EXT_color_buffer_float")?vp:Di,minFilter:la,samples:4,stencilBuffer:r,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:gn.workingColorSpace}));const Ge=A.state.transmissionRenderTarget[we.id],lt=we.viewport||_;Ge.setSize(lt.z*x.transmissionResolutionScale,lt.w*x.transmissionResolutionScale);const xt=x.getRenderTarget(),it=x.getActiveCubeFace(),Dt=x.getActiveMipmapLevel();x.setRenderTarget(Ge),x.getClearColor(P),L=x.getClearAlpha(),L<1&&x.setClearColor(16777215,.5),x.clear(),Ue&&yt.render(Ae);const Ft=x.toneMapping;x.toneMapping=Ya;const Ct=we.viewport;if(we.viewport!==void 0&&(we.viewport=void 0),A.setupLightsView(we),Ee===!0&&He.setGlobalState(x.clippingPlanes,we),Gn(Q,Ae,we),Me.updateMultisampleRenderTarget(Ge),Me.updateRenderTargetMipmap(Ge),be.has("WEBGL_multisampled_render_to_texture")===!1){let en=!1;for(let Cn=0,Yn=he.length;Cn<Yn;Cn++){const Tn=he[Cn],Bn=Tn.object,Rt=Tn.geometry,Wn=Tn.material,dn=Tn.group;if(Wn.side===io&&Bn.layers.test(we.layers)){const yi=Wn.side;Wn.side=ji,Wn.needsUpdate=!0,Br(Bn,Ae,we,Rt,Wn,dn),Wn.side=yi,Wn.needsUpdate=!0,en=!0}}en===!0&&(Me.updateMultisampleRenderTarget(Ge),Me.updateRenderTargetMipmap(Ge))}x.setRenderTarget(xt,it,Dt),x.setClearColor(P,L),Ct!==void 0&&(we.viewport=Ct),x.toneMapping=Ft}function Gn(Q,he,Ae){const we=he.isScene===!0?he.overrideMaterial:null;for(let pe=0,Ge=Q.length;pe<Ge;pe++){const lt=Q[pe],xt=lt.object,it=lt.geometry,Dt=lt.group;let Ft=lt.material;Ft.allowOverride===!0&&we!==null&&(Ft=we),xt.layers.test(Ae.layers)&&Br(xt,he,Ae,it,Ft,Dt)}}function Br(Q,he,Ae,we,pe,Ge){Q.onBeforeRender(x,he,Ae,we,pe,Ge),Q.modelViewMatrix.multiplyMatrices(Ae.matrixWorldInverse,Q.matrixWorld),Q.normalMatrix.getNormalMatrix(Q.modelViewMatrix),pe.onBeforeRender(x,he,Ae,we,Q,Ge),pe.transparent===!0&&pe.side===io&&pe.forceSinglePass===!1?(pe.side=ji,pe.needsUpdate=!0,x.renderBufferDirect(Ae,he,we,pe,Q,Ge),pe.side=Za,pe.needsUpdate=!0,x.renderBufferDirect(Ae,he,we,pe,Q,Ge),pe.side=io):x.renderBufferDirect(Ae,he,we,pe,Q,Ge),Q.onAfterRender(x,he,Ae,we,pe,Ge)}function Al(Q,he,Ae){he.isScene!==!0&&(he=Ne);const we=De.get(Q),pe=A.state.lights,Ge=A.state.shadowsArray,lt=pe.state.version,xt=xe.getParameters(Q,pe.state,Ge,he,Ae),it=xe.getProgramCacheKey(xt);let Dt=we.programs;we.environment=Q.isMeshStandardMaterial?he.environment:null,we.fog=he.fog,we.envMap=(Q.isMeshStandardMaterial?At:Tt).get(Q.envMap||we.environment),we.envMapRotation=we.environment!==null&&Q.envMap===null?he.environmentRotation:Q.envMapRotation,Dt===void 0&&(Q.addEventListener("dispose",Pe),Dt=new Map,we.programs=Dt);let Ft=Dt.get(it);if(Ft!==void 0){if(we.currentProgram===Ft&&we.lightsStateVersion===lt)return yc(Q,xt),Ft}else xt.uniforms=xe.getUniforms(Q),Q.onBeforeCompile(xt,x),Ft=xe.acquireProgram(xt,it),Dt.set(it,Ft),we.uniforms=xt.uniforms;const Ct=we.uniforms;return(!Q.isShaderMaterial&&!Q.isRawShaderMaterial||Q.clipping===!0)&&(Ct.clippingPlanes=He.uniform),yc(Q,xt),we.needsLights=xc(Q),we.lightsStateVersion=lt,we.needsLights&&(Ct.ambientLightColor.value=pe.state.ambient,Ct.lightProbe.value=pe.state.probe,Ct.directionalLights.value=pe.state.directional,Ct.directionalLightShadows.value=pe.state.directionalShadow,Ct.spotLights.value=pe.state.spot,Ct.spotLightShadows.value=pe.state.spotShadow,Ct.rectAreaLights.value=pe.state.rectArea,Ct.ltc_1.value=pe.state.rectAreaLTC1,Ct.ltc_2.value=pe.state.rectAreaLTC2,Ct.pointLights.value=pe.state.point,Ct.pointLightShadows.value=pe.state.pointShadow,Ct.hemisphereLights.value=pe.state.hemi,Ct.directionalShadowMap.value=pe.state.directionalShadowMap,Ct.directionalShadowMatrix.value=pe.state.directionalShadowMatrix,Ct.spotShadowMap.value=pe.state.spotShadowMap,Ct.spotLightMatrix.value=pe.state.spotLightMatrix,Ct.spotLightMap.value=pe.state.spotLightMap,Ct.pointShadowMap.value=pe.state.pointShadowMap,Ct.pointShadowMatrix.value=pe.state.pointShadowMatrix),we.currentProgram=Ft,we.uniformsList=null,Ft}function tx(Q){if(Q.uniformsList===null){const he=Q.currentProgram.getUniforms();Q.uniformsList=b0.seqWithValue(he.seq,Q.uniforms)}return Q.uniformsList}function yc(Q,he){const Ae=De.get(Q);Ae.outputColorSpace=he.outputColorSpace,Ae.batching=he.batching,Ae.batchingColor=he.batchingColor,Ae.instancing=he.instancing,Ae.instancingColor=he.instancingColor,Ae.instancingMorph=he.instancingMorph,Ae.skinning=he.skinning,Ae.morphTargets=he.morphTargets,Ae.morphNormals=he.morphNormals,Ae.morphColors=he.morphColors,Ae.morphTargetsCount=he.morphTargetsCount,Ae.numClippingPlanes=he.numClippingPlanes,Ae.numIntersection=he.numClipIntersection,Ae.vertexAlphas=he.vertexAlphas,Ae.vertexTangents=he.vertexTangents,Ae.toneMapping=he.toneMapping}function sm(Q,he,Ae,we,pe){he.isScene!==!0&&(he=Ne),Me.resetTextureUnits();const Ge=he.fog,lt=we.isMeshStandardMaterial?he.environment:null,xt=T===null?x.outputColorSpace:T.isXRRenderTarget===!0?T.texture.colorSpace:yu,it=(we.isMeshStandardMaterial?At:Tt).get(we.envMap||lt),Dt=we.vertexColors===!0&&!!Ae.attributes.color&&Ae.attributes.color.itemSize===4,Ft=!!Ae.attributes.tangent&&(!!we.normalMap||we.anisotropy>0),Ct=!!Ae.morphAttributes.position,en=!!Ae.morphAttributes.normal,Cn=!!Ae.morphAttributes.color;let Yn=Ya;we.toneMapped&&(T===null||T.isXRRenderTarget===!0)&&(Yn=x.toneMapping);const Tn=Ae.morphAttributes.position||Ae.morphAttributes.normal||Ae.morphAttributes.color,Bn=Tn!==void 0?Tn.length:0,Rt=De.get(we),Wn=A.state.lights;if(Ee===!0&&(re===!0||Q!==S)){const Ks=Q===S&&we.id===v;He.setState(we,Q,Ks)}let dn=!1;we.version===Rt.__version?(Rt.needsLights&&Rt.lightsStateVersion!==Wn.state.version||Rt.outputColorSpace!==xt||pe.isBatchedMesh&&Rt.batching===!1||!pe.isBatchedMesh&&Rt.batching===!0||pe.isBatchedMesh&&Rt.batchingColor===!0&&pe.colorTexture===null||pe.isBatchedMesh&&Rt.batchingColor===!1&&pe.colorTexture!==null||pe.isInstancedMesh&&Rt.instancing===!1||!pe.isInstancedMesh&&Rt.instancing===!0||pe.isSkinnedMesh&&Rt.skinning===!1||!pe.isSkinnedMesh&&Rt.skinning===!0||pe.isInstancedMesh&&Rt.instancingColor===!0&&pe.instanceColor===null||pe.isInstancedMesh&&Rt.instancingColor===!1&&pe.instanceColor!==null||pe.isInstancedMesh&&Rt.instancingMorph===!0&&pe.morphTexture===null||pe.isInstancedMesh&&Rt.instancingMorph===!1&&pe.morphTexture!==null||Rt.envMap!==it||we.fog===!0&&Rt.fog!==Ge||Rt.numClippingPlanes!==void 0&&(Rt.numClippingPlanes!==He.numPlanes||Rt.numIntersection!==He.numIntersection)||Rt.vertexAlphas!==Dt||Rt.vertexTangents!==Ft||Rt.morphTargets!==Ct||Rt.morphNormals!==en||Rt.morphColors!==Cn||Rt.toneMapping!==Yn||Rt.morphTargetsCount!==Bn)&&(dn=!0):(dn=!0,Rt.__version=we.version);let yi=Rt.currentProgram;dn===!0&&(yi=Al(we,he,pe));let Na=!1,Rn=!1,yl=!1;const Hn=yi.getUniforms(),li=Rt.uniforms;if(ye.useProgram(yi.program)&&(Na=!0,Rn=!0,yl=!0),we.id!==v&&(v=we.id,Rn=!0),Na||S!==Q){ye.buffers.depth.getReversed()&&Q.reversedDepth!==!0&&(Q._reversedDepth=!0,Q.updateProjectionMatrix()),Hn.setValue(W,"projectionMatrix",Q.projectionMatrix),Hn.setValue(W,"viewMatrix",Q.matrixWorldInverse);const xi=Hn.map.cameraPosition;xi!==void 0&&xi.setValue(W,_e.setFromMatrixPosition(Q.matrixWorld)),ge.logarithmicDepthBuffer&&Hn.setValue(W,"logDepthBufFC",2/(Math.log(Q.far+1)/Math.LN2)),(we.isMeshPhongMaterial||we.isMeshToonMaterial||we.isMeshLambertMaterial||we.isMeshBasicMaterial||we.isMeshStandardMaterial||we.isShaderMaterial)&&Hn.setValue(W,"isOrthographic",Q.isOrthographicCamera===!0),S!==Q&&(S=Q,Rn=!0,yl=!0)}if(pe.isSkinnedMesh){Hn.setOptional(W,pe,"bindMatrix"),Hn.setOptional(W,pe,"bindMatrixInverse");const Ks=pe.skeleton;Ks&&(Ks.boneTexture===null&&Ks.computeBoneTexture(),Hn.setValue(W,"boneTexture",Ks.boneTexture,Me))}pe.isBatchedMesh&&(Hn.setOptional(W,pe,"batchingTexture"),Hn.setValue(W,"batchingTexture",pe._matricesTexture,Me),Hn.setOptional(W,pe,"batchingIdTexture"),Hn.setValue(W,"batchingIdTexture",pe._indirectTexture,Me),Hn.setOptional(W,pe,"batchingColorTexture"),pe._colorsTexture!==null&&Hn.setValue(W,"batchingColorTexture",pe._colorsTexture,Me));const Qi=Ae.morphAttributes;if((Qi.position!==void 0||Qi.normal!==void 0||Qi.color!==void 0)&&Oe.update(pe,Ae,yi),(Rn||Rt.receiveShadow!==pe.receiveShadow)&&(Rt.receiveShadow=pe.receiveShadow,Hn.setValue(W,"receiveShadow",pe.receiveShadow)),we.isMeshGouraudMaterial&&we.envMap!==null&&(li.envMap.value=it,li.flipEnvMap.value=it.isCubeTexture&&it.isRenderTargetTexture===!1?-1:1),we.isMeshStandardMaterial&&we.envMap===null&&he.environment!==null&&(li.envMapIntensity.value=he.environmentIntensity),Rn&&(Hn.setValue(W,"toneMappingExposure",x.toneMappingExposure),Rt.needsLights&&rd(li,yl),Ge&&we.fog===!0&&Fe.refreshFogUniforms(li,Ge),Fe.refreshMaterialUniforms(li,we,V,q,A.state.transmissionRenderTarget[Q.id]),b0.upload(W,tx(Rt),li,Me)),we.isShaderMaterial&&we.uniformsNeedUpdate===!0&&(b0.upload(W,tx(Rt),li,Me),we.uniformsNeedUpdate=!1),we.isSpriteMaterial&&Hn.setValue(W,"center",pe.center),Hn.setValue(W,"modelViewMatrix",pe.modelViewMatrix),Hn.setValue(W,"normalMatrix",pe.normalMatrix),Hn.setValue(W,"modelMatrix",pe.matrixWorld),we.isShaderMaterial||we.isRawShaderMaterial){const Ks=we.uniformsGroups;for(let xi=0,om=Ks.length;xi<om;xi++){const Ko=Ks[xi];Wt.update(Ko,yi),Wt.bind(Ko,yi)}}return yi}function rd(Q,he){Q.ambientLightColor.needsUpdate=he,Q.lightProbe.needsUpdate=he,Q.directionalLights.needsUpdate=he,Q.directionalLightShadows.needsUpdate=he,Q.pointLights.needsUpdate=he,Q.pointLightShadows.needsUpdate=he,Q.spotLights.needsUpdate=he,Q.spotLightShadows.needsUpdate=he,Q.rectAreaLights.needsUpdate=he,Q.hemisphereLights.needsUpdate=he}function xc(Q){return Q.isMeshLambertMaterial||Q.isMeshToonMaterial||Q.isMeshPhongMaterial||Q.isMeshStandardMaterial||Q.isShadowMaterial||Q.isShaderMaterial&&Q.lights===!0}this.getActiveCubeFace=function(){return w},this.getActiveMipmapLevel=function(){return E},this.getRenderTarget=function(){return T},this.setRenderTargetTextures=function(Q,he,Ae){const we=De.get(Q);we.__autoAllocateDepthBuffer=Q.resolveDepthBuffer===!1,we.__autoAllocateDepthBuffer===!1&&(we.__useRenderToTexture=!1),De.get(Q.texture).__webglTexture=he,De.get(Q.depthTexture).__webglTexture=we.__autoAllocateDepthBuffer?void 0:Ae,we.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(Q,he){const Ae=De.get(Q);Ae.__webglFramebuffer=he,Ae.__useDefaultFramebuffer=he===void 0};const nx=W.createFramebuffer();this.setRenderTarget=function(Q,he=0,Ae=0){T=Q,w=he,E=Ae;let we=!0,pe=null,Ge=!1,lt=!1;if(Q){const it=De.get(Q);if(it.__useDefaultFramebuffer!==void 0)ye.bindFramebuffer(W.FRAMEBUFFER,null),we=!1;else if(it.__webglFramebuffer===void 0)Me.setupRenderTarget(Q);else if(it.__hasExternalTextures)Me.rebindTextures(Q,De.get(Q.texture).__webglTexture,De.get(Q.depthTexture).__webglTexture);else if(Q.depthBuffer){const Ct=Q.depthTexture;if(it.__boundDepthTexture!==Ct){if(Ct!==null&&De.has(Ct)&&(Q.width!==Ct.image.width||Q.height!==Ct.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");Me.setupDepthRenderbuffer(Q)}}const Dt=Q.texture;(Dt.isData3DTexture||Dt.isDataArrayTexture||Dt.isCompressedArrayTexture)&&(lt=!0);const Ft=De.get(Q).__webglFramebuffer;Q.isWebGLCubeRenderTarget?(Array.isArray(Ft[he])?pe=Ft[he][Ae]:pe=Ft[he],Ge=!0):Q.samples>0&&Me.useMultisampledRTT(Q)===!1?pe=De.get(Q).__webglMultisampledFramebuffer:Array.isArray(Ft)?pe=Ft[Ae]:pe=Ft,_.copy(Q.viewport),N.copy(Q.scissor),D=Q.scissorTest}else _.copy(se).multiplyScalar(V).floor(),N.copy(fe).multiplyScalar(V).floor(),D=me;if(Ae!==0&&(pe=nx),ye.bindFramebuffer(W.FRAMEBUFFER,pe)&&we&&ye.drawBuffers(Q,pe),ye.viewport(_),ye.scissor(N),ye.setScissorTest(D),Ge){const it=De.get(Q.texture);W.framebufferTexture2D(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_CUBE_MAP_POSITIVE_X+he,it.__webglTexture,Ae)}else if(lt){const it=he;for(let Dt=0;Dt<Q.textures.length;Dt++){const Ft=De.get(Q.textures[Dt]);W.framebufferTextureLayer(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0+Dt,Ft.__webglTexture,Ae,it)}}else if(Q!==null&&Ae!==0){const it=De.get(Q.texture);W.framebufferTexture2D(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_2D,it.__webglTexture,Ae)}v=-1},this.readRenderTargetPixels=function(Q,he,Ae,we,pe,Ge,lt,xt=0){if(!(Q&&Q.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let it=De.get(Q).__webglFramebuffer;if(Q.isWebGLCubeRenderTarget&&lt!==void 0&&(it=it[lt]),it){ye.bindFramebuffer(W.FRAMEBUFFER,it);try{const Dt=Q.textures[xt],Ft=Dt.format,Ct=Dt.type;if(!ge.textureFormatReadable(Ft)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!ge.textureTypeReadable(Ct)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}he>=0&&he<=Q.width-we&&Ae>=0&&Ae<=Q.height-pe&&(Q.textures.length>1&&W.readBuffer(W.COLOR_ATTACHMENT0+xt),W.readPixels(he,Ae,we,pe,_t.convert(Ft),_t.convert(Ct),Ge))}finally{const Dt=T!==null?De.get(T).__webglFramebuffer:null;ye.bindFramebuffer(W.FRAMEBUFFER,Dt)}}},this.readRenderTargetPixelsAsync=async function(Q,he,Ae,we,pe,Ge,lt,xt=0){if(!(Q&&Q.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let it=De.get(Q).__webglFramebuffer;if(Q.isWebGLCubeRenderTarget&&lt!==void 0&&(it=it[lt]),it)if(he>=0&&he<=Q.width-we&&Ae>=0&&Ae<=Q.height-pe){ye.bindFramebuffer(W.FRAMEBUFFER,it);const Dt=Q.textures[xt],Ft=Dt.format,Ct=Dt.type;if(!ge.textureFormatReadable(Ft))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!ge.textureTypeReadable(Ct))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const en=W.createBuffer();W.bindBuffer(W.PIXEL_PACK_BUFFER,en),W.bufferData(W.PIXEL_PACK_BUFFER,Ge.byteLength,W.STREAM_READ),Q.textures.length>1&&W.readBuffer(W.COLOR_ATTACHMENT0+xt),W.readPixels(he,Ae,we,pe,_t.convert(Ft),_t.convert(Ct),0);const Cn=T!==null?De.get(T).__webglFramebuffer:null;ye.bindFramebuffer(W.FRAMEBUFFER,Cn);const Yn=W.fenceSync(W.SYNC_GPU_COMMANDS_COMPLETE,0);return W.flush(),await gW(W,Yn,4),W.bindBuffer(W.PIXEL_PACK_BUFFER,en),W.getBufferSubData(W.PIXEL_PACK_BUFFER,0,Ge),W.deleteBuffer(en),W.deleteSync(Yn),Ge}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(Q,he=null,Ae=0){const we=Math.pow(2,-Ae),pe=Math.floor(Q.image.width*we),Ge=Math.floor(Q.image.height*we),lt=he!==null?he.x:0,xt=he!==null?he.y:0;Me.setTexture2D(Q,0),W.copyTexSubImage2D(W.TEXTURE_2D,Ae,0,0,lt,xt,pe,Ge),ye.unbindTexture()};const im=W.createFramebuffer(),rm=W.createFramebuffer();this.copyTextureToTexture=function(Q,he,Ae=null,we=null,pe=0,Ge=null){Ge===null&&(pe!==0?(mg("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),Ge=pe,pe=0):Ge=0);let lt,xt,it,Dt,Ft,Ct,en,Cn,Yn;const Tn=Q.isCompressedTexture?Q.mipmaps[Ge]:Q.image;if(Ae!==null)lt=Ae.max.x-Ae.min.x,xt=Ae.max.y-Ae.min.y,it=Ae.isBox3?Ae.max.z-Ae.min.z:1,Dt=Ae.min.x,Ft=Ae.min.y,Ct=Ae.isBox3?Ae.min.z:0;else{const Qi=Math.pow(2,-pe);lt=Math.floor(Tn.width*Qi),xt=Math.floor(Tn.height*Qi),Q.isDataArrayTexture?it=Tn.depth:Q.isData3DTexture?it=Math.floor(Tn.depth*Qi):it=1,Dt=0,Ft=0,Ct=0}we!==null?(en=we.x,Cn=we.y,Yn=we.z):(en=0,Cn=0,Yn=0);const Bn=_t.convert(he.format),Rt=_t.convert(he.type);let Wn;he.isData3DTexture?(Me.setTexture3D(he,0),Wn=W.TEXTURE_3D):he.isDataArrayTexture||he.isCompressedArrayTexture?(Me.setTexture2DArray(he,0),Wn=W.TEXTURE_2D_ARRAY):(Me.setTexture2D(he,0),Wn=W.TEXTURE_2D),W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL,he.flipY),W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL,he.premultiplyAlpha),W.pixelStorei(W.UNPACK_ALIGNMENT,he.unpackAlignment);const dn=W.getParameter(W.UNPACK_ROW_LENGTH),yi=W.getParameter(W.UNPACK_IMAGE_HEIGHT),Na=W.getParameter(W.UNPACK_SKIP_PIXELS),Rn=W.getParameter(W.UNPACK_SKIP_ROWS),yl=W.getParameter(W.UNPACK_SKIP_IMAGES);W.pixelStorei(W.UNPACK_ROW_LENGTH,Tn.width),W.pixelStorei(W.UNPACK_IMAGE_HEIGHT,Tn.height),W.pixelStorei(W.UNPACK_SKIP_PIXELS,Dt),W.pixelStorei(W.UNPACK_SKIP_ROWS,Ft),W.pixelStorei(W.UNPACK_SKIP_IMAGES,Ct);const Hn=Q.isDataArrayTexture||Q.isData3DTexture,li=he.isDataArrayTexture||he.isData3DTexture;if(Q.isDepthTexture){const Qi=De.get(Q),Ks=De.get(he),xi=De.get(Qi.__renderTarget),om=De.get(Ks.__renderTarget);ye.bindFramebuffer(W.READ_FRAMEBUFFER,xi.__webglFramebuffer),ye.bindFramebuffer(W.DRAW_FRAMEBUFFER,om.__webglFramebuffer);for(let Ko=0;Ko<it;Ko++)Hn&&(W.framebufferTextureLayer(W.READ_FRAMEBUFFER,W.COLOR_ATTACHMENT0,De.get(Q).__webglTexture,pe,Ct+Ko),W.framebufferTextureLayer(W.DRAW_FRAMEBUFFER,W.COLOR_ATTACHMENT0,De.get(he).__webglTexture,Ge,Yn+Ko)),W.blitFramebuffer(Dt,Ft,lt,xt,en,Cn,lt,xt,W.DEPTH_BUFFER_BIT,W.NEAREST);ye.bindFramebuffer(W.READ_FRAMEBUFFER,null),ye.bindFramebuffer(W.DRAW_FRAMEBUFFER,null)}else if(pe!==0||Q.isRenderTargetTexture||De.has(Q)){const Qi=De.get(Q),Ks=De.get(he);ye.bindFramebuffer(W.READ_FRAMEBUFFER,im),ye.bindFramebuffer(W.DRAW_FRAMEBUFFER,rm);for(let xi=0;xi<it;xi++)Hn?W.framebufferTextureLayer(W.READ_FRAMEBUFFER,W.COLOR_ATTACHMENT0,Qi.__webglTexture,pe,Ct+xi):W.framebufferTexture2D(W.READ_FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_2D,Qi.__webglTexture,pe),li?W.framebufferTextureLayer(W.DRAW_FRAMEBUFFER,W.COLOR_ATTACHMENT0,Ks.__webglTexture,Ge,Yn+xi):W.framebufferTexture2D(W.DRAW_FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_2D,Ks.__webglTexture,Ge),pe!==0?W.blitFramebuffer(Dt,Ft,lt,xt,en,Cn,lt,xt,W.COLOR_BUFFER_BIT,W.NEAREST):li?W.copyTexSubImage3D(Wn,Ge,en,Cn,Yn+xi,Dt,Ft,lt,xt):W.copyTexSubImage2D(Wn,Ge,en,Cn,Dt,Ft,lt,xt);ye.bindFramebuffer(W.READ_FRAMEBUFFER,null),ye.bindFramebuffer(W.DRAW_FRAMEBUFFER,null)}else li?Q.isDataTexture||Q.isData3DTexture?W.texSubImage3D(Wn,Ge,en,Cn,Yn,lt,xt,it,Bn,Rt,Tn.data):he.isCompressedArrayTexture?W.compressedTexSubImage3D(Wn,Ge,en,Cn,Yn,lt,xt,it,Bn,Tn.data):W.texSubImage3D(Wn,Ge,en,Cn,Yn,lt,xt,it,Bn,Rt,Tn):Q.isDataTexture?W.texSubImage2D(W.TEXTURE_2D,Ge,en,Cn,lt,xt,Bn,Rt,Tn.data):Q.isCompressedTexture?W.compressedTexSubImage2D(W.TEXTURE_2D,Ge,en,Cn,Tn.width,Tn.height,Bn,Tn.data):W.texSubImage2D(W.TEXTURE_2D,Ge,en,Cn,lt,xt,Bn,Rt,Tn);W.pixelStorei(W.UNPACK_ROW_LENGTH,dn),W.pixelStorei(W.UNPACK_IMAGE_HEIGHT,yi),W.pixelStorei(W.UNPACK_SKIP_PIXELS,Na),W.pixelStorei(W.UNPACK_SKIP_ROWS,Rn),W.pixelStorei(W.UNPACK_SKIP_IMAGES,yl),Ge===0&&he.generateMipmaps&&W.generateMipmap(Wn),ye.unbindTexture()},this.initRenderTarget=function(Q){De.get(Q).__webglFramebuffer===void 0&&Me.setupRenderTarget(Q)},this.initTexture=function(Q){Q.isCubeTexture?Me.setTextureCube(Q,0):Q.isData3DTexture?Me.setTexture3D(Q,0):Q.isDataArrayTexture||Q.isCompressedArrayTexture?Me.setTexture2DArray(Q,0):Me.setTexture2D(Q,0),ye.unbindTexture()},this.resetState=function(){w=0,E=0,T=null,ye.reset(),st.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Lr}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=gn._getDrawingBufferColorSpace(e),t.unpackColorSpace=gn._getUnpackColorSpace()}}const RX=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:E3,AddEquation:Nl,AddOperation:C3,AdditiveAnimationBlendMode:TE,AdditiveBlending:zS,AgXToneMapping:T3,AlphaFormat:SE,AlwaysCompare:G3,AlwaysDepth:H0,AlwaysStencilFunc:GS,AmbientLight:i2,AnimationAction:QF,AnimationClip:Cg,AnimationLoader:QH,AnimationMixer:A5,AnimationObjectGroup:m5,AnimationUtils:LH,ArcCurve:aF,ArrayCamera:OF,ArrowHelper:G5,AttachedBindMode:VS,Audio:zF,AudioAnalyser:r5,AudioContext:o2,AudioListener:n5,AudioLoader:ZH,AxesHelper:W5,BackSide:ji,BasicDepthPacking:F3,BasicShadowMap:yG,BatchedMesh:sF,Bone:zE,BooleanKeyframeTrack:Vu,Box2:T5,Box3:Us,Box3Helper:Q5,BoxGeometry:rc,BoxHelper:U5,BufferAttribute:Sn,BufferGeometry:Xt,BufferGeometryLoader:LF,ByteType:IE,Cache:ca,Camera:CI,CameraHelper:z5,CanvasTexture:aH,CapsuleGeometry:BI,CatmullRomCurve3:lF,CineonToneMapping:S3,CircleGeometry:kI,ClampToEdgeWrapping:Pr,Clock:VI,Color:ot,ColorKeyframeTrack:t2,ColorManagement:gn,CompressedArrayTexture:rH,CompressedCubeTexture:oH,CompressedTexture:TI,CompressedTextureLoader:VH,ConeGeometry:nA,ConstantAlphaFactor:x3,ConstantColorFactor:A3,Controls:q5,CubeCamera:$E,CubeReflectionMapping:el,CubeRefractionMapping:Gl,CubeTexture:eA,CubeTextureLoader:GH,CubeUVReflectionMapping:wp,CubicBezierCurve:HE,CubicBezierCurve3:cF,CubicInterpolant:_F,CullFaceBack:OS,CullFaceFront:t3,CullFaceFrontBack:AG,CullFaceNone:e3,Curve:Vo,CurvePath:hF,CustomBlending:s3,CustomToneMapping:_3,CylinderGeometry:tA,Cylindrical:_5,Data3DTexture:Zg,DataArrayTexture:ko,DataTexture:Mo,DataTextureLoader:WH,DataUtils:kW,DecrementStencilOp:MG,DecrementWrapStencilOp:RG,DefaultLoadingManager:kF,DepthFormat:Jd,DepthStencilFormat:Zd,DepthTexture:VE,DetachedBindMode:k3,DirectionalLight:DF,DirectionalLightHelper:O5,DiscreteInterpolant:TF,DodecahedronGeometry:MI,DoubleSide:io,DstAlphaFactor:d3,DstColorFactor:f3,DynamicCopyUsage:qG,DynamicDrawUsage:W3,DynamicReadUsage:GG,EdgesGeometry:oF,EllipseCurve:NI,EqualCompare:z3,EqualDepth:Y0,EqualStencilFunc:PG,EquirectangularReflectionMapping:og,EquirectangularRefractionMapping:ag,Euler:Wr,EventDispatcher:Ca,ExternalTexture:GE,ExtrudeGeometry:RI,FileLoader:ma,Float16BufferAttribute:PW,Float32BufferAttribute:gt,FloatType:gr,Fog:vI,FogExp2:wI,FramebufferTexture:iH,FrontSide:Za,Frustum:Ep,FrustumArray:_I,GLBufferAttribute:C5,GLSL1:XG,GLSL3:pg,GreaterCompare:U3,GreaterDepth:j0,GreaterEqualCompare:V3,GreaterEqualDepth:X0,GreaterEqualStencilFunc:UG,GreaterStencilFunc:OG,GridHelper:P5,Group:Jc,HalfFloatType:vp,HemisphereLight:MF,HemisphereLightHelper:$5,IcosahedronGeometry:DI,ImageBitmapLoader:JH,ImageLoader:wg,ImageUtils:Y3,IncrementStencilOp:kG,IncrementWrapStencilOp:NG,InstancedBufferAttribute:bu,InstancedBufferGeometry:r2,InstancedInterleavedBuffer:I5,InstancedMesh:nF,Int16BufferAttribute:FW,Int32BufferAttribute:$W,Int8BufferAttribute:NW,IntType:gI,InterleavedBuffer:SI,InterleavedBufferAttribute:xu,Interpolant:oA,InterpolateDiscrete:cg,InterpolateLinear:Eb,InterpolateSmooth:y0,InterpolationSamplingMode:JG,InterpolationSamplingType:KG,InvertStencilOp:DG,KeepStencilOp:$c,KeyframeTrack:po,LOD:eF,LatheGeometry:FI,Layers:II,LessCompare:O3,LessDepth:q0,LessEqualCompare:BE,LessEqualDepth:Au,LessEqualStencilFunc:LG,LessStencilFunc:$G,Light:ac,LightProbe:PF,Line:Wl,Line3:M5,LineBasicMaterial:ir,LineCurve:qE,LineCurve3:uF,LineDashedMaterial:vF,LineLoop:iF,LineSegments:va,LinearFilter:Os,LinearInterpolant:e2,LinearMipMapLinearFilter:M3,LinearMipMapNearestFilter:IG,LinearMipmapLinearFilter:la,LinearMipmapNearestFilter:Wm,LinearSRGBColorSpace:yu,LinearToneMapping:w3,LinearTransfer:hg,Loader:rr,LoaderUtils:XS,LoadingManager:n2,LoopOnce:N3,LoopPingPong:D3,LoopRepeat:R3,MOUSE:mG,Material:Li,MaterialLoader:QI,MathUtils:ME,Matrix2:cA,Matrix3:Ht,Matrix4:kt,MaxEquation:a3,Mesh:On,MeshBasicMaterial:wa,MeshDepthMaterial:KE,MeshDistanceMaterial:JE,MeshLambertMaterial:CF,MeshMatcapMaterial:wF,MeshNormalMaterial:IF,MeshPhongMaterial:xF,MeshPhysicalMaterial:yF,MeshStandardMaterial:xg,MeshToonMaterial:bF,MinEquation:o3,MirroredRepeatWrapping:lg,MixOperation:I3,MultiplyBlending:QS,MultiplyOperation:jg,NearestFilter:bs,NearestMipMapLinearFilter:bG,NearestMipMapNearestFilter:xG,NearestMipmapLinearFilter:zd,NearestMipmapNearestFilter:bE,NeutralToneMapping:B3,NeverCompare:L3,NeverDepth:W0,NeverStencilFunc:FG,NoBlending:qa,NoColorSpace:Qa,NoToneMapping:Ya,NormalAnimationBlendMode:bI,NormalBlending:cu,NotEqualCompare:Q3,NotEqualDepth:K0,NotEqualStencilFunc:zG,NumberKeyframeTrack:bg,Object3D:un,ObjectLoader:jH,ObjectSpaceNormalMap:P3,OctahedronGeometry:sA,OneFactor:c3,OneMinusConstantAlphaFactor:b3,OneMinusConstantColorFactor:y3,OneMinusDstAlphaFactor:p3,OneMinusDstColorFactor:m3,OneMinusSrcAlphaFactor:G0,OneMinusSrcColorFactor:h3,OrthographicCamera:lA,PCFShadowMap:xE,PCFSoftShadowMap:n3,PMREMGenerator:Mb,Path:kb,PerspectiveCamera:Es,Plane:kl,PlaneGeometry:Qu,PlaneHelper:V5,PointLight:RF,PointLightHelper:D5,Points:rF,PointsMaterial:UE,PolarGridHelper:L5,PolyhedronGeometry:oc,PositionalAudio:i5,PropertyBinding:yn,PropertyMixer:UF,QuadraticBezierCurve:YE,QuadraticBezierCurve3:XE,Quaternion:$n,QuaternionKeyframeTrack:aA,QuaternionLinearInterpolant:BF,RED_GREEN_RGTC2_Format:vb,RED_RGTC1_Format:Cb,REVISION:fI,RGBADepthPacking:$3,RGBAFormat:ys,RGBAIntegerFormat:ha,RGBA_ASTC_10x10_Format:gb,RGBA_ASTC_10x5_Format:pb,RGBA_ASTC_10x6_Format:fb,RGBA_ASTC_10x8_Format:mb,RGBA_ASTC_12x10_Format:Ab,RGBA_ASTC_12x12_Format:yb,RGBA_ASTC_4x4_Format:rb,RGBA_ASTC_5x4_Format:ob,RGBA_ASTC_5x5_Format:ab,RGBA_ASTC_6x5_Format:lb,RGBA_ASTC_6x6_Format:cb,RGBA_ASTC_8x5_Format:ub,RGBA_ASTC_8x6_Format:hb,RGBA_ASTC_8x8_Format:db,RGBA_BPTC_Format:xb,RGBA_ETC2_EAC_Format:ib,RGBA_PVRTC_2BPPV1_Format:tb,RGBA_PVRTC_4BPPV1_Format:eb,RGBA_S3TC_DXT1_Format:qm,RGBA_S3TC_DXT3_Format:Ym,RGBA_S3TC_DXT5_Format:Xm,RGBDepthPacking:EG,RGBFormat:EE,RGBIntegerFormat:CG,RGB_BPTC_SIGNED_Format:bb,RGB_BPTC_UNSIGNED_Format:Ib,RGB_ETC1_Format:nb,RGB_ETC2_Format:sb,RGB_PVRTC_2BPPV1_Format:Z0,RGB_PVRTC_4BPPV1_Format:J0,RGB_S3TC_DXT1_Format:Hm,RGDepthPacking:_G,RGFormat:_E,RGIntegerFormat:Jg,RawShaderMaterial:rA,Ray:Sp,Raycaster:w5,RectAreaLight:FF,RedFormat:xI,RedIntegerFormat:Kg,ReinhardToneMapping:v3,RenderTarget:NE,RenderTarget3D:y5,RepeatWrapping:Xd,ReplaceStencilOp:BG,ReverseSubtractEquation:r3,RingGeometry:$I,SIGNED_RED_GREEN_RGTC2_Format:Sb,SIGNED_RED_RGTC1_Format:wb,SRGBColorSpace:Ei,SRGBTransfer:kn,Scene:LE,ShaderChunk:Kt,ShaderLib:wo,ShaderMaterial:Hr,ShadowMaterial:AF,Shape:hu,ShapeGeometry:PI,ShapePath:H5,ShapeUtils:_o,ShortType:CE,Skeleton:EI,SkeletonHelper:R5,SkinnedMesh:tF,Source:Rl,Sphere:pi,SphereGeometry:iA,Spherical:E5,SphericalHarmonics3:$F,SplineCurve:jE,SpotLight:NF,SpotLightHelper:N5,Sprite:Z3,SpriteMaterial:OE,SrcAlphaFactor:V0,SrcAlphaSaturateFactor:g3,SrcColorFactor:u3,StaticCopyUsage:HG,StaticDrawUsage:dg,StaticReadUsage:VG,StereoCamera:e5,StreamCopyUsage:YG,StreamDrawUsage:QG,StreamReadUsage:WG,StringKeyframeTrack:Gu,SubtractEquation:i3,SubtractiveBlending:US,TOUCH:gG,TangentSpaceNormalMap:ic,TetrahedronGeometry:LI,Texture:cs,TextureLoader:HH,TextureUtils:J5,Timer:v5,TimestampQuery:jG,TorusGeometry:OI,TorusKnotGeometry:zI,Triangle:fr,TriangleFanDrawMode:SG,TriangleStripDrawMode:vG,TrianglesDrawMode:wG,TubeGeometry:UI,UVMapping:mI,Uint16BufferAttribute:DE,Uint32BufferAttribute:FE,Uint8BufferAttribute:RW,Uint8ClampedBufferAttribute:DW,Uniform:c2,UniformsGroup:b5,UniformsLib:rt,UniformsUtils:K3,UnsignedByteType:Di,UnsignedInt101111Type:vE,UnsignedInt248Type:Kd,UnsignedInt5999Type:wE,UnsignedIntType:Ri,UnsignedShort4444Type:AI,UnsignedShort5551Type:yI,UnsignedShortType:jd,VSMShadowMap:ta,Vector2:$e,Vector3:U,Vector4:Yt,VectorKeyframeTrack:Ig,VideoFrameTexture:sH,VideoTexture:QE,WebGL3DRenderTarget:bW,WebGLArrayRenderTarget:RE,WebGLCoordinateSystem:Lr,WebGLCubeRenderTarget:PE,WebGLRenderTarget:ao,WebGLRenderer:jF,WebGLUtils:XF,WebGPUCoordinateSystem:ep,WebXRController:x0,WireframeGeometry:gF,WrapAroundEnding:ug,ZeroCurvatureEnding:jc,ZeroFactor:l3,ZeroSlopeEnding:Kc,ZeroStencilOp:TG,createCanvasElement:q3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DX=1e-7,FX=1e-4;class WI{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class uA{refCount(e){return cr("refCount")}incRef(e){return cr("incRef")}timerAvailable(){return!0}time(e){return cr("time")}read(e){return cr("read")}readSync(e){return cr("readSync")}readToGPU(e,t){return cr("readToGPU")}numDataIds(){return cr("numDataIds")}disposeData(e,t){return cr("disposeData")}write(e,t,s){return cr("write")}move(e,t,s,i,r){return cr("move")}createTensorFromGPUData(e,t,s){return cr("createTensorFromGPUData")}memory(){return cr("memory")}floatPrecision(){return cr("floatPrecision")}epsilon(){return this.floatPrecision()===32?DX:FX}dispose(){return cr("dispose")}}function cr(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Ga(n,e,t)}function $X(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,Ga(n,t,s),Ga(e,t,s)}function Hl(n,e,t){return Math.max(n,Math.min(e,t))}function HI(n){return n%2===0?n:n+1}function Ga(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function d2(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function PX(n,e){const t=Math.random();return e*t+(1-t)*n}function LX(n,e){let t=0;for(let s=0;s<n.length;s++){const i=Number(n[s])-Number(e[s]);t+=i*i}return t}function R(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Xs(n,e,t=""){R(qt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Wu(n){R(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ce(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function ZS(n){return n.length===0}function KF(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function qt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Cu(n){return n%1===0}function OX(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function Nb(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function zX(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return h2(e),e}function du(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function e1(n,e=i=>0,t,s){return new Promise((i,r)=>{let o=0;const a=()=>{if(n()){i();return}o++;const l=e(o);if(t!=null&&o>=t){r();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function qI(n,e){let t=1,s=-1;for(let r=0;r<n.length;++r)if(n[r]>=0)t*=n[r];else if(n[r]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${r}`);s=r}else if(n[r]<0)throw Error(`Shapes can not be < 0. Found ${n[r]} at dim ${r}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=n.slice();return i[s]=e/t,i}function Vt(n,e){const t=e.length;return n=n==null?e.map((s,i)=>i):[].concat(n),R(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),R(n.every(s=>Cu(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function ul(n,e){const t=[],s=[],i=e!=null&&Array.isArray(e)&&e.length===0,r=e==null||i?null:Vt(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(r!=null){if(r[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(r[o]==null||r[o]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),r[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function Cs(n,e){return ns(n,e)}function ns(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function JF(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function ZF(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function YI(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function vg(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function e$(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function To(n){return typeof n=="string"||n instanceof String}function t$(n){return typeof n=="boolean"}function Rb(n){return typeof n=="number"}function lc(n){return Array.isArray(n)?lc(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Rb(n)?"float32":To(n)?"string":t$(n)?"bool":"float32"}function ql(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Db(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function vt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function n$(n,e,t,s=!1){const i=new Array;if(e.length===1){const r=e[0]*(s?2:1);for(let o=0;o<r;o++)i[o]=t[n+o]}else{const r=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<r;l++)i[l]=n$(n+l*a,o,t,s)}return i}function Vr(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((i,r)=>i*r)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return n$(0,n,e,t)}function Zm(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function XI(n,e){const t=Ws(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Ws(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function p2(n,e){const t=n.reduce((s,i)=>s*i,1);if(e==null||e==="float32")return Vr(n,new Float32Array(t));if(e==="int32")return Vr(n,new Int32Array(t));if(e==="bool")return Vr(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Sr(n){n.forEach(e=>{R(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function No(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let i=0;i<n.length-1;++i)s+=t[i]*n[i];return s}function Hu(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let i=0;i<s.length-1;++i)s[i]=Math.floor(n/t[i]),n-=s[i]*t[i];return s[s.length-1]=n,s}function tl(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tN="tfjsflags";class s${constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=UX,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ae().getBool("IS_TEST")||ae().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const i=this.urlFlags[e];ae().getBool("IS_TEST")||ae().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(tl(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);tN in e&&e[tN].split(",").forEach(s=>{const[i,r]=s.split(":");this.urlFlags[i]=VX(i,r)})}}function UX(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(QX(e,s[0],s[1]),s.join("="))),e}function QX(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function VX(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ae(){return f2}let f2=null;function GX(n){f2=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qv;function i$(){if(qv==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");qv=n}return qv}function WX(){const n=i$();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function m2(n,e){const t=WX();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const Tp="Abs",qu="Acos",Yu="Acosh",cc="Add",Bp="AddN",hA="All",dA="Any",kp="ArgMax",Mp="ArgMin",Xu="Asin",ju="Asinh",Ku="Atan",Ju="Atanh",Zu="Atan2",Np="AvgPool",pA="AvgPoolGrad",Rp="AvgPool3D",fA="AvgPool3DGrad",Dp="BatchMatMul",Fp="BatchToSpaceND",mA="Bincount",gA="BitwiseAnd",r$="BroadcastTo",AA="BroadcastArgs",eh="Cast",th="Ceil",nh="ClipByValue",yA="Complex",$p="ComplexAbs",Pp="Concat",Lp="Conv2D",xA="Conv2DBackpropFilter",Op="Conv2DBackpropInput",zp="Conv3D",bA="Conv3DBackpropFilterV2",IA="Conv3DBackpropInputV2",sh="Cos",ih="Cosh",CA="Cumprod",Up="Cumsum",wA="CropAndResize",vA="DenseBincount",SA="DepthToSpace",Qp="DepthwiseConv2dNative",EA="DepthwiseConv2dNativeBackpropFilter",_A="DepthwiseConv2dNativeBackpropInput",TA="Diag",Vp="Dilation2D",Sg="Dilation2DBackpropInput",Eg="Dilation2DBackpropFilter",BA="Draw",rh="RealDiv",kA="Einsum",oh="Elu",MA="EluGrad",ah="Erf",Gp="Equal",lh="Exp",Wp="ExpandDims",ch="Expm1",NA="FFT",RA="Fill",DA="FlipLeftRight",uh="Floor",hh="FloorDiv",Hp="FusedBatchNorm",qp="GatherV2",FA="GatherNd",Yp="Greater",dh="GreaterEqual",ph="Identity",$A="IFFT",PA="Imag",fh="IsFinite",mh="IsInf",gh="IsNan",Xp="LeakyRelu",jp="Less",Kp="LessEqual",LA="LinSpace",Ah="Log",yh="Log1p",Jp="LogicalAnd",Zp="LogicalNot",ef="LogicalOr",HX="LogicalXor",o$="LogSoftmax",qX="LowerBound",tf="LRN",OA="LRNGrad",YX="MatrixBandPart",nf="Max",xh="Maximum",sf="MaxPool",zA="MaxPoolGrad",rf="MaxPool3D",UA="MaxPool3DGrad",QA="MaxPoolWithArgmax",of="Mean",af="Min",bh="Minimum",lf="MirrorPad",Ih="Mod",VA="Multinomial",Ch="Multiply",cf="Neg",uf="NotEqual",GA="NonMaxSuppressionV3",jI="NonMaxSuppressionV4",WA="NonMaxSuppressionV5",hf="OnesLike",df="OneHot",pf="Pack",ff="PadV2",XX="Pool",wh="Pow",mf="Prelu",gf="Prod",KI="RaggedGather",JI="RaggedRange",ZI="RaggedTensorToTensor",HA="Range",qA="Real",vh="Reciprocal",Sh="Relu",Af="Reshape",yf="ResizeNearestNeighbor",YA="ResizeNearestNeighborGrad",xf="ResizeBilinear",XA="ResizeBilinearGrad",Eh="Relu6",bf="Reverse",_h="Round",Th="Rsqrt",jA="ScatterNd",KA="TensorScatterUpdate",JA="SearchSorted",If="Select",Bh="Selu",Cf="Slice",kh="Sin",Mh="Sinh",Nh="Sign",Rh="Sigmoid",Dh="Softplus",Fh="Sqrt",wf="Sum",vf="SpaceToBatchND",Sf="SplitV",Ef="Softmax",eC="SparseFillEmptyRows",tC="SparseReshape",ZA="SparseSegmentMean",ey="SparseSegmentSum",ty="SparseToDense",$h="SquaredDifference",ny="Square",sy="StaticRegexReplace",iy="StridedSlice",ry="StringNGrams",nC="StringSplit",sC="StringToHashBucketFast",Ph="Sub",Lh="Tan",Oh="Tanh",zh="Tile",oy="TopK",ay="Transform",Ol="Transpose",iC="Unique",_f="Unpack",Tf="UnsortedSegmentSum",jX="UpperBound",Bf="ZerosLike",Uh="Step",_g="FromPixels",ly="RotateWithOffset",ip="_FusedMatMul",rp="FusedConv2D",op="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(...n){ae().getBool("IS_TEST")||ae().getBool("PROD")||console.warn(...n)}function KX(...n){ae().getBool("IS_TEST")||ae().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ap=m2("kernelRegistry",()=>new Map),Tg=m2("gradRegistry",()=>new Map);function Bg(n,e){const t=g2(n,e);return ap.get(t)}function t1(n){return Tg.get(n)}function Fb(n){const e=ap.entries(),t=[];for(;;){const{done:s,value:i}=e.next();if(s)break;const[r,o]=i,[a]=r.split("_");a===n&&t.push(o)}return t}function cy(n){const{kernelName:e,backendName:t}=n,s=g2(e,t);ap.has(s)&&Dr(`The kernel '${e}' for backend '${t}' is already registered`),ap.set(s,n)}function a$(n){const{kernelName:e}=n;Tg.has(e)&&ae().getBool("DEBUG")&&Dr(`Overriding the gradient for '${e}'`),Tg.set(e,n)}function JX(n,e){const t=g2(n,e);if(!ap.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);ap.delete(t)}function ZX(n){if(!Tg.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Tg.delete(n)}function ej(n,e){Fb(n).forEach(s=>{const i=Object.assign({},s,{backendName:e});cy(i)})}function g2(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var nN=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function tj(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function nj(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){var i=!1;try{i=this instanceof s}catch{}return i?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var i=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,i.get?i:{enumerable:!0,get:function(){return n[s]}})}),t}var Yv,sN;function sj(){if(sN)return Yv;sN=1,Yv=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(S,_,N){this.low=S|0,this.high=_|0,this.unsigned=!!N}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(S){return(S&&S.__isLong__)===!0}e.isLong=t;var s={},i={};function r(S,_){var N,D,P;return _?(S>>>=0,(P=0<=S&&S<256)&&(D=i[S],D)?D:(N=a(S,(S|0)<0?-1:0,!0),P&&(i[S]=N),N)):(S|=0,(P=-128<=S&&S<128)&&(D=s[S],D)?D:(N=a(S,S<0?-1:0,!1),P&&(s[S]=N),N))}e.fromInt=r;function o(S,_){if(isNaN(S))return _?y:A;if(_){if(S<0)return y;if(S>=f)return E}else{if(S<=-g)return T;if(S+1>=g)return w}return S<0?o(-S,_).neg():a(S%p|0,S/p|0,_)}e.fromNumber=o;function a(S,_,N){return new e(S,_,N)}e.fromBits=a;var l=Math.pow;function c(S,_,N){if(S.length===0)throw Error("empty string");if(S==="NaN"||S==="Infinity"||S==="+Infinity"||S==="-Infinity")return A;if(typeof _=="number"?(N=_,_=!1):_=!!_,N=N||10,N<2||36<N)throw RangeError("radix");var D;if((D=S.indexOf("-"))>0)throw Error("interior hyphen");if(D===0)return c(S.substring(1),_,N).neg();for(var P=o(l(N,8)),L=A,z=0;z<S.length;z+=8){var q=Math.min(8,S.length-z),V=parseInt(S.substring(z,z+q),N);if(q<8){var X=o(l(N,q));L=L.mul(X).add(o(V))}else L=L.mul(P),L=L.add(o(V))}return L.unsigned=_,L}e.fromString=c;function u(S,_){return typeof S=="number"?o(S,_):typeof S=="string"?c(S,_):a(S.low,S.high,typeof _=="boolean"?_:S.unsigned)}e.fromValue=u;var h=65536,d=1<<24,p=h*h,f=p*p,g=f/2,m=r(d),A=r(0);e.ZERO=A;var y=r(0,!0);e.UZERO=y;var b=r(1);e.ONE=b;var x=r(1,!0);e.UONE=x;var C=r(-1);e.NEG_ONE=C;var w=a(-1,2147483647,!1);e.MAX_VALUE=w;var E=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=E;var T=a(0,-2147483648,!1);e.MIN_VALUE=T;var v=e.prototype;return v.toInt=function(){return this.unsigned?this.low>>>0:this.low},v.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},v.toString=function(_){if(_=_||10,_<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(T)){var N=o(_),D=this.div(N),P=D.mul(N).sub(this);return D.toString(_)+P.toInt().toString(_)}else return"-"+this.neg().toString(_);for(var L=o(l(_,6),this.unsigned),z=this,q="";;){var V=z.div(L),X=z.sub(V.mul(L)).toInt()>>>0,te=X.toString(_);if(z=V,z.isZero())return te+q;for(;te.length<6;)te="0"+te;q=""+te+q}},v.getHighBits=function(){return this.high},v.getHighBitsUnsigned=function(){return this.high>>>0},v.getLowBits=function(){return this.low},v.getLowBitsUnsigned=function(){return this.low>>>0},v.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,N=31;N>0&&(_&1<<N)==0;N--);return this.high!=0?N+33:N+1},v.isZero=function(){return this.high===0&&this.low===0},v.eqz=v.isZero,v.isNegative=function(){return!this.unsigned&&this.high<0},v.isPositive=function(){return this.unsigned||this.high>=0},v.isOdd=function(){return(this.low&1)===1},v.isEven=function(){return(this.low&1)===0},v.equals=function(_){return t(_)||(_=u(_)),this.unsigned!==_.unsigned&&this.high>>>31===1&&_.high>>>31===1?!1:this.high===_.high&&this.low===_.low},v.eq=v.equals,v.notEquals=function(_){return!this.eq(_)},v.neq=v.notEquals,v.ne=v.notEquals,v.lessThan=function(_){return this.comp(_)<0},v.lt=v.lessThan,v.lessThanOrEqual=function(_){return this.comp(_)<=0},v.lte=v.lessThanOrEqual,v.le=v.lessThanOrEqual,v.greaterThan=function(_){return this.comp(_)>0},v.gt=v.greaterThan,v.greaterThanOrEqual=function(_){return this.comp(_)>=0},v.gte=v.greaterThanOrEqual,v.ge=v.greaterThanOrEqual,v.compare=function(_){if(t(_)||(_=u(_)),this.eq(_))return 0;var N=this.isNegative(),D=_.isNegative();return N&&!D?-1:!N&&D?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},v.comp=v.compare,v.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(b)},v.neg=v.negate,v.add=function(_){t(_)||(_=u(_));var N=this.high>>>16,D=this.high&65535,P=this.low>>>16,L=this.low&65535,z=_.high>>>16,q=_.high&65535,V=_.low>>>16,X=_.low&65535,te=0,se=0,fe=0,me=0;return me+=L+X,fe+=me>>>16,me&=65535,fe+=P+V,se+=fe>>>16,fe&=65535,se+=D+q,te+=se>>>16,se&=65535,te+=N+z,te&=65535,a(fe<<16|me,te<<16|se,this.unsigned)},v.subtract=function(_){return t(_)||(_=u(_)),this.add(_.neg())},v.sub=v.subtract,v.multiply=function(_){if(this.isZero())return A;if(t(_)||(_=u(_)),n){var N=n.mul(this.low,this.high,_.low,_.high);return a(N,n.get_high(),this.unsigned)}if(_.isZero())return A;if(this.eq(T))return _.isOdd()?T:A;if(_.eq(T))return this.isOdd()?T:A;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(m)&&_.lt(m))return o(this.toNumber()*_.toNumber(),this.unsigned);var D=this.high>>>16,P=this.high&65535,L=this.low>>>16,z=this.low&65535,q=_.high>>>16,V=_.high&65535,X=_.low>>>16,te=_.low&65535,se=0,fe=0,me=0,Te=0;return Te+=z*te,me+=Te>>>16,Te&=65535,me+=L*te,fe+=me>>>16,me&=65535,me+=z*X,fe+=me>>>16,me&=65535,fe+=P*te,se+=fe>>>16,fe&=65535,fe+=L*X,se+=fe>>>16,fe&=65535,fe+=z*V,se+=fe>>>16,fe&=65535,se+=D*te+P*X+L*V+z*q,se&=65535,a(me<<16|Te,se<<16|fe,this.unsigned)},v.mul=v.multiply,v.divide=function(_){if(t(_)||(_=u(_)),_.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&_.low===-1&&_.high===-1)return this;var N=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,_.low,_.high);return a(N,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?y:A;var D,P,L;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return y;if(_.gt(this.shru(1)))return x;L=y}else{if(this.eq(T)){if(_.eq(b)||_.eq(C))return T;if(_.eq(T))return b;var z=this.shr(1);return D=z.div(_).shl(1),D.eq(A)?_.isNegative()?b:C:(P=this.sub(_.mul(D)),L=D.add(P.div(_)),L)}else if(_.eq(T))return this.unsigned?y:A;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();L=A}for(P=this;P.gte(_);){D=Math.max(1,Math.floor(P.toNumber()/_.toNumber()));for(var q=Math.ceil(Math.log(D)/Math.LN2),V=q<=48?1:l(2,q-48),X=o(D),te=X.mul(_);te.isNegative()||te.gt(P);)D-=V,X=o(D,this.unsigned),te=X.mul(_);X.isZero()&&(X=b),L=L.add(X),P=P.sub(te)}return L},v.div=v.divide,v.modulo=function(_){if(t(_)||(_=u(_)),n){var N=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,_.low,_.high);return a(N,n.get_high(),this.unsigned)}return this.sub(this.div(_).mul(_))},v.mod=v.modulo,v.rem=v.modulo,v.not=function(){return a(~this.low,~this.high,this.unsigned)},v.and=function(_){return t(_)||(_=u(_)),a(this.low&_.low,this.high&_.high,this.unsigned)},v.or=function(_){return t(_)||(_=u(_)),a(this.low|_.low,this.high|_.high,this.unsigned)},v.xor=function(_){return t(_)||(_=u(_)),a(this.low^_.low,this.high^_.high,this.unsigned)},v.shiftLeft=function(_){return t(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?a(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):a(0,this.low<<_-32,this.unsigned)},v.shl=v.shiftLeft,v.shiftRight=function(_){return t(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?a(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):a(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},v.shr=v.shiftRight,v.shiftRightUnsigned=function(_){if(t(_)&&(_=_.toInt()),_&=63,_===0)return this;var N=this.high;if(_<32){var D=this.low;return a(D>>>_|N<<32-_,N>>>_,this.unsigned)}else return _===32?a(N,0,this.unsigned):a(N>>>_-32,0,this.unsigned)},v.shru=v.shiftRightUnsigned,v.shr_u=v.shiftRightUnsigned,v.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},v.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},v.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},v.toBytesLE=function(){var _=this.high,N=this.low;return[N&255,N>>>8&255,N>>>16&255,N>>>24,_&255,_>>>8&255,_>>>16&255,_>>>24]},v.toBytesBE=function(){var _=this.high,N=this.low;return[_>>>24,_>>>16&255,_>>>8&255,_&255,N>>>24,N>>>16&255,N>>>8&255,N&255]},e.fromBytes=function(_,N,D){return D?e.fromBytesLE(_,N):e.fromBytesBE(_,N)},e.fromBytesLE=function(_,N){return new e(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,N)},e.fromBytesBE=function(_,N){return new e(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],N)},Yv}var c$=sj();const u$=tj(c$),ij=fG({__proto__:null,default:u$},[c$]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vc=u$||ij;function uy(n){return Vc.fromString(n,!0,16)}const h$=uy("c3a5c85c97cb3127"),Lc=uy("b492b66fbe98f273"),Ti=uy("9ae16a3b2f90404f");function n1(n){return n.xor(n.shru(47))}function d$(n,e,t){const s=n.slice(e,e+t);return Vc.fromBytes(Array.from(s),!0,!0)}function Ln(n,e){return d$(n,e,8)}function iN(n,e){return d$(n,e,4)}function Ls(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function zl(n,e,t=uy("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let i=e.xor(s).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function rj(n,e,t,s,i,r){i=i.add(n),r=Ls(r.add(i).add(s),21);const o=i;return i=i.add(e),i=i.add(t),r=r.add(Ls(i,44)),[i.add(s),r.add(o)]}function Jx(n,e,t,s){return rj(Ln(n,e),Ln(n,e+8),Ln(n,e+16),Ln(n,e+24),t,s)}function oj(n,e=n.length){if(e>=8){const t=Ti.add(e*2),s=Ln(n,0).add(Ti),i=Ln(n,e-8),r=Ls(i,37).mul(t).add(s),o=Ls(s,25).add(i).mul(t);return zl(r,o,t)}if(e>=4){const t=Ti.add(e*2),s=iN(n,0);return zl(s.shl(3).add(e),iN(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],i=n[e-1],r=t+(s<<8),o=e+(i<<2);return n1(Ti.mul(r).xor(h$.mul(o))).mul(Ti)}return Ti}function aj(n,e=n.length){const t=Ti.add(e*2),s=Ln(n,0).mul(Lc),i=Ln(n,8),r=Ln(n,e-8).mul(t),o=Ln(n,e-16).mul(Ti);return zl(Ls(s.add(i),43).add(Ls(r,30)).add(o),s.add(Ls(i.add(Ti),18)).add(r),t)}function lj(n,e=n.length){const t=Ti.add(e*2),s=Ln(n,0).mul(Ti),i=Ln(n,8),r=Ln(n,e-8).mul(t),o=Ln(n,e-16).mul(Ti),a=Ls(s.add(i),43).add(Ls(r,30)).add(o),l=zl(a,s.add(Ls(i.add(Ti),18)).add(r),t),c=Ln(n,16).mul(t),u=Ln(n,24),h=a.add(Ln(n,e-32)).mul(t),d=l.add(Ln(n,e-24)).mul(t);return zl(Ls(c.add(u),43).add(Ls(h,30)).add(d),c.add(Ls(u.add(s),18)).add(h),t)}function p$(n,e=n.length){const t=Vc.fromNumber(81,!0);if(e<=32)return e<=16?oj(n,e):aj(n,e);if(e<=64)return lj(n,e);let s=t,i=t.mul(Lc).add(113),r=n1(i.mul(Ti).add(113)).mul(Ti),o=[Vc.UZERO,Vc.UZERO],a=[Vc.UZERO,Vc.UZERO];s=s.mul(Ti).add(Ln(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do s=Ls(s.add(i).add(o[0]).add(Ln(n,l+8)),37).mul(Lc),i=Ls(i.add(o[1]).add(Ln(n,l+48)),42).mul(Lc),s=s.xor(a[1]),i=i.add(o[0]).add(Ln(n,l+40)),r=Ls(r.add(a[0]),33).mul(Lc),o=Jx(n,l,o[1].mul(Lc),s.add(a[0])),a=Jx(n,l+32,r.add(a[1]),i.add(Ln(n,l+16))),[r,s]=[s,r],l+=64;while(l!==c);const h=Lc.add(r.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=Ls(s.add(i).add(o[0]).add(Ln(n,l+8)),37).mul(h),i=Ls(i.add(o[1]).add(Ln(n,l+48)),42).mul(h),s=s.xor(a[1].mul(9)),i=i.add(o[0].mul(9).add(Ln(n,l+40))),r=Ls(r.add(a[0]),33).mul(h),o=Jx(n,l,o[1].mul(h),s.add(a[0])),a=Jx(n,l+32,r.add(a[1]),i.add(Ln(n,l+16))),[r,s]=[s,r],zl(zl(o[0],a[0],h).add(n1(i).mul(h$)).add(r),zl(o[1],a[1],h).add(s),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hl(n,e){return e==="string"?Ro(n):uc([n],e)}function cj(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function uc(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=co(n)),ae().getBool("DEBUG")&&JF(n,e),cj(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Zs(){return ae().platform.now()}function f$(n,e){return ae().platform.fetch(n,e)}function Ro(n,e="utf-8"){return e=e||"utf-8",ae().platform.encode(n,e)}function lo(n,e="utf-8"){return e=e||"utf-8",ae().platform.decode(n,e)}function _s(n){return ae().platform.isTypedArray!=null?ae().platform.isTypedArray(n):l$(n)}function co(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||tl(n)||n==null||_s(n)&&t)e.push(n);else if(Array.isArray(n)||_s(n))for(let s=0;s<n.length;++s)co(n[s],e,t);else{let s=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)co(n[i],e,t)}return e}const uj=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:qt,arraysEqualWithNull:KF,assert:R,assertNonNegativeIntegerDimensions:Sr,assertNonNull:Wu,assertShapesMatch:Xs,bytesFromStringArray:e$,bytesPerElement:vg,checkConversionForErrors:JF,clamp:Hl,computeStrides:vt,convertBackendValuesAndArrayBuffer:Zm,createScalarValue:hl,createShuffledIndices:zX,decodeString:lo,distSquared:LX,encodeString:Ro,fetch:f$,fingerPrint64:p$,flatten:co,getArrayFromDType:ns,getTypedArrayFromDType:Cs,hasEncodingLoss:YI,hexToLong:uy,indexToLoc:Hu,inferDtype:lc,inferFromImplicitShape:qI,isBoolean:t$,isFunction:ql,isInt:Cu,isNumber:Rb,isPromise:tl,isScalarShape:ZS,isString:To,isTypedArray:_s,isValidDtype:ZF,locToIndex:No,makeOnesTypedArray:XI,makeZerosNestedTypedArray:p2,makeZerosTypedArray:Ws,nearestDivisor:Db,nearestLargerEven:HI,now:Zs,parseAxisParam:Vt,randUniform:PX,repeatedTry:e1,rightPad:du,shuffle:h2,shuffleCombo:$X,sizeFromShape:ce,sizeToSquarishShape:Nb,squeezeShape:ul,sum:d2,swap:Ga,tanh:OX,toNestedArray:Vr,toTypedArray:uc},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hj{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new pj)}profileKernel(e,t,s){let i;const r=()=>{i=s()};let o;const a=Zs();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(r);else{r();for(const c of i)c.dataSync();o=Promise.resolve({kernelMs:Zs()-a})}if(ae().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const u=i[c];u.data().then(h=>{dj(h,u.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:i,inputs:r,extraInfo:o}=e;s.forEach(a=>{Promise.all([a.data(),i,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],r,l[2])})})}}function dj(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const i=n[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class pj{logKernelProfile(e,t,s,i,r,o){const a=typeof i=="number"?du(`${i}ms`,9):i.error,l=du(e,25),c=t.rank,u=t.size,h=du(t.shape.toString(),14);let d="";for(const p in r){const f=r[p];if(f!=null){const g=f.shape||t.shape,m=g.length;d+=`${p}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fj(n,e,t){const s={},i={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const d=u[h];let p=!1;for(let f=0;f<e.length;f++)if(s[d.id]){c.outputs.forEach(g=>s[g.id]=!0),p=!0,i[c.id]=!0;break}if(p)break}}const r={};r[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(r[c.outputs[h].id]){for(const d in u)r[u[d].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(i[c.id]&&o[c.id]){const u={};for(const d in c.inputs){const p=c.inputs[d];s[p.id]&&(u[d]=p)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function mj(n,e,t,s){for(let i=e.length-1;i>=0;i--){const r=e[i],o=[];if(r.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),r.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);const a=r.gradient(o);for(const l in r.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=r.inputs[l];if(!qt(c.shape,u.shape))throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=s(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rN=20,wm=3,Xv=7;function gj(n,e,t,s){const i=vt(e),r=Aj(n,e,t,i),o=e.length,a=I0(n,e,t,i,r),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function Aj(n,e,t,s){const i=ce(e),r=s[s.length-1],o=new Array(r).fill(0),a=e.length,l=t==="complex64"?Rm(n):n;if(a>1)for(let c=0;c<i/r;c++){const u=c*r;for(let h=0;h<r;h++)o[h]=Math.max(o[h],Nm(l[u+h],0,t).length)}return o}function Nm(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Xv))} + ${parseFloat(n[1].toFixed(Xv))}j`:To(n)?s=`'${n}'`:t==="bool"?s=m$(n):s=parseFloat(n.toFixed(Xv)).toString(),du(s,e)}function m$(n){return n===0?"false":"true"}function I0(n,e,t,s,i,r=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const g=Rm(n);return[Nm(g[0],0,t)]}return t==="bool"?[m$(n[0])]:[n[0].toString()]}if(l===1){if(a>rN){const m=wm*o;let A=Array.from(n.slice(0,m)),y=Array.from(n.slice((a-wm)*o,a*o));return t==="complex64"&&(A=Rm(A),y=Rm(y)),["["+A.map((b,x)=>Nm(b,i[x],t)).join(", ")+", ..., "+y.map((b,x)=>Nm(b,i[a-wm+x],t)).join(", ")+"]"]}return["["+(t==="complex64"?Rm(n):Array.from(n)).map((m,A)=>Nm(m,i[A],t)).join(", ")+"]"]}const c=e.slice(1),u=s.slice(1),h=s[0]*o,d=[];if(a>rN){for(let g=0;g<wm;g++){const m=g*h,A=m+h;d.push(...I0(n.slice(m,A),c,t,u,i,!1))}d.push("...");for(let g=a-wm;g<a;g++){const m=g*h,A=m+h;d.push(...I0(n.slice(m,A),c,t,u,i,g===a-1))}}else for(let g=0;g<a;g++){const m=g*h,A=m+h;d.push(...I0(n.slice(m,A),c,t,u,i,g===a-1))}const p=l===2?",":"";d[0]="["+(a>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=`,
`;for(let g=2;g<l;g++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(r?"":f),d}function Rm(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Is{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=ce(e),s!=null){const i=s.length;R(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||ns(t,this.size),this.strides=vt(e)}set(e,...t){t.length===0&&(t=[0]),R(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let s=e[e.length-1];for(let i=0;i<e.length-1;++i)s+=this.strides[i]*e[i];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return vo().makeTensor(this.values,this.shape,this.dtype)}}let vo=null,Pd=null;function yj(n){vo=n}function xj(n){Pd=n}class nn{constructor(e,t,s,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ce(e),this.strides=vt(e),this.dataId=s,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Pd.buffer(this.shape,this.dtype,e)}bufferSync(){return Pd.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Vr(this.shape,e,this.dtype==="complex64")}arraySync(){return Vr(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=vo().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>lo(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),vo().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=vo().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>lo(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await vo().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),vo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Pd.print(this,e)}clone(){return this.throwIfDisposed(),Pd.clone(this)}toString(e=!1){const t=this.dataSync();return gj(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Pd.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),vo().makeVariable(this,e,t,s)}}Object.defineProperty(nn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Se(){return m2("Tensor",()=>nn)}Se();class kg extends nn{constructor(e,t,s,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!qt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);vo().disposeTensor(this),this.dataId=e.dataId,vo().incRef(this,null)}dispose(){vo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(kg,Symbol.hasInstance,{value:n=>n instanceof nn&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var s1;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(s1||(s1={}));var i1;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(i1||(i1={}));var r1;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(r1||(r1={}));var o1;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(o1||(o1={}));var a1;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(a1||(a1={}));const bj={float32:o1,int32:i1,bool:r1,complex64:a1};function Ns(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return bj[n][e]}function hy(n){return Ns(n,"int32")}function g$(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function A$(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function is(n,e){if(n.dtype===e.dtype)return[n,e];const t=Ns(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function y$(n,e){R(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function rC(n,e){return e.some(t=>t.id===n.id)}function nl(n){const e=[];return x$(n,e,new Set),e}function x$(n,e,t){if(n==null)return;if(n instanceof nn){e.push(n);return}if(!Ij(n))return;const s=n;for(const i in s){const r=s[i];t.has(r)||(t.add(r),x$(r,e,t))}}function Ij(n){return Array.isArray(n)||typeof n=="object"}const Cj=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:y$,getTensorsInContainer:nl,isTensorInList:rC,makeTypesMatch:is},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(n){return n.kernelName!=null}class oN{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class lp{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new oN}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Dr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new hj(this.backendInstance),!0}setupRegisteredKernels(){Fb(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Fb(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof uA)&&typeof s.then=="function"){const i=++this.pendingBackendInitId,r=s.then(o=>i<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Dr(`Initialization of backend ${e} failed`),Dr(o.stack||o.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Dr(`Initialization of backend ${e} failed`),Dr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:i,asyncInit:r}=this.initializeBackend(s);if(r||i)return{name:s,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),i=s.backend,r=this.readSync(t),o=i.refCount(t);i.disposeData(t,!0),s.backend=e,e.move(t,r,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,s){e();try{const i=s();return t(),i}catch(i){throw t(),i}}nextTensorId(){return lp.nextTensorId++}nextVariableId(){return lp.nextVariableId++}clone(e){const t=J.runKernel(ph,{x:e}),s={x:e},i=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return J.runKernel(eh,l,c)}}),r=[];return this.addTapeNode(this.state.activeScope.name,s,[t],i,r,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(Bg(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const i=this.backend.numDataIds();let r=0;s.forEach(l=>{r+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=i-t-r-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const i=this.isTapeOn(),r=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=jv(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(jv(e)){const{kernelName:f,inputs:g,attrs:m}=e;this.backendName==null&&this.backend;const A=Bg(f,this.backendName);R(A!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const y=this.backend.numDataIds();l=A.kernelFunc({inputs:g,attrs:m,backend:this.backend});const b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,y,b);const x=b.map(C=>C.rank!=null?C:this.makeTensorFromTensorInfo(C));if(i){const C=this.getTensorsForGradient(f,g,x);s=this.saveTensorsForBackwardMode(C)}return x}}else{const{forwardFunc:f}=e,g=m=>{i&&(s=m.map(A=>this.keep(this.clone(A))))};a=()=>{const m=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,g));const A=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,m,A),A}}const{inputs:u,attrs:h}=e,d=jv(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),i&&this.addTapeNode(c,u,t,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const i=t1(e);if(i!=null){const r=i.inputsToSave||[],o=i.outputsToSave||[];let a;i.saveAllInputs?(R(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=r.map(c=>t[c]);const l=s.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,s,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let r=e;s==="string"&&To(e[0])&&(r=e.map(l=>Ro(l)));const o=i.write(r,t,s),a=new nn(t,s,o,this.nextTensorId());if(this.trackTensor(a,i),s==="string"){const l=this.state.tensorInfo.get(o),c=e$(r);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,s,i){s=s||"float32";const r={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:i,dtype:r}=e,o=new nn(i,r,s,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const r=new kg(e,t,s,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*vg(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof kg||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*vg(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,i,r,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:r},l=t1(e);l!=null&&(i=l.gradFunc),i!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const d=s[h],p=Ws(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return u}),i(c.length>1?c:c[0],r,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=nl(e),s=new Set(t.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){const o=this.state.activeScope.track[r];!o.kept&&!s.has(o.id)&&o.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(r=>{!r.kept&&r.scopeId===i.id&&this.track(r)})}gradients(e,t,s,i=!1){if(R(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));R(r instanceof nn,()=>"The result y returned by f() must be a tensor.");const o=fj(this.state.activeTape,t,r);if(!i&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[r.id]=s??wj(r.shape),mj(a,o,c=>this.tidy(c),vj);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:r,grads:l}})}customGrad(e){return R(ql(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{R(t.every(a=>a instanceof nn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const i={};t.forEach((a,l)=>{i[l]=a});const r=(a,l)=>(s=e(...t,l),R(s.value instanceof nn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),R(ql(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const c=s.gradFunc(a,l),u=Array.isArray(c)?c:[c];R(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),R(u.every(d=>d instanceof nn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:r,backwardsFunc:o,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Zs(),s=await this.backend.time(e);return s.wallMs=Zs()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new oN;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}lp.nextTensorId=0;lp.nextVariableId=0;function wj(n){const e=XI(ce(n),"float32");return J.makeTensor(e,n,"float32")}function b$(){const n=i$();if(n._tfengine==null){const e=new s$(n);n._tfengine=new lp(e)}return GX(n._tfengine.ENV),yj(()=>n._tfengine),n._tfengine}const J=b$();function vj(n,e){const t={a:n,b:e};return J.runKernel(cc,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(){return typeof navigator<"u"&&navigator!=null}let l1;function Ej(n){l1=n}function A2(n){if(l1!==void 0)return l1;if(n||Sj()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function y2(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const _j=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:y2,isMobile:A2,mockIsMobile:Ej},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tr=ae();tr.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});tr.registerFlag("IS_BROWSER",()=>y2());tr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");tr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));tr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));tr.registerFlag("PROD",()=>!1);tr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>tr.getBool("DEBUG"));tr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);tr.registerFlag("IS_TEST",()=>!1);tr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>tr.getBool("DEBUG"));tr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);tr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);tr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ga(n,e){let t=n;if(_s(n))return e==="string"?[]:[n.length];if(g$(n)){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if(A$(n))return[n.buffer.size/(e==null?4:vg(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||_s(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ae().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&I$(n,s,[]),s}function I$(n,e,t){if(t=t||[],!Array.isArray(n)&&!_s(n)){R(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}R(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),R(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let i=0;i<n.length;++i)I$(n[i],s,t.concat(i))}function aN(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function O(n,e,t,s="numeric"){if(n instanceof Se())return aN(s,n.dtype,e,t),n;let i=lc(n);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),aN(s,i,e,t),n==null||!_s(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const r=ga(n,i);!_s(n)&&!Array.isArray(n)&&(n=[n]);const a=i!=="string"?uc(n,i):co(n,[],!0);return J.makeTensor(a,r,i)}function Mg(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((r,o)=>O(r,`${e}[${o}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x2="__op";function Z(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+x2;const i=(...r)=>{J.startScope(t);try{const o=s(...r);return tl(o)&&console.error("Cannot return a Promise inside of tidy."),J.endScope(o),o}catch(o){throw J.endScope(null),o}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tj(n,e){const t=O(n,"real","complex"),s=O(e,"imag","complex");Xs(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const i={real:t,imag:s};return J.runKernel(yA,i)}const sl=Z({complex_:Tj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hc(n,e,t,s){if(s==null)s=lc(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(A$(n)||g$(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return J.backend.createTensorFromGPUData(n,e||t,s)}if(!_s(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Sr(e);const i=ce(e),r=ce(t);R(i===r,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${r}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==ce(e.slice(o)):!0;R(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!_s(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?uc(n,s):co(n,[],!0),J.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ar(n,e,t){const s=ga(n,t);return hc(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wu={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Go{static join(e){return new Go(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>_s(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const i=e[s];s!==e.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+i.byteLength;this.shards.push({buffer:i,start:t,end:r}),t=r}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const i=t-e,r=new ArrayBuffer(i),o=new Uint8Array(r);let a=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],h=e+a-c.start,d=a,f=Math.min(t,c.end)-c.start,g=new Uint8Array(c.buffer,h,f-h);if(o.set(g,d),a+=g.length,t<c.end)break}return r}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(i){return e<i.start?-1:e>=i.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=Bj(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function Bj(n,e){let t=0,s=n.length;for(;t<=s;){const i=Math.floor((s-t)/2)+t,r=e(n[i]);if(r===0)return i;r<0?s=i:t=i+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kj(){ae().set("PROD",!0)}function Mj(){ae().set("DEBUG",!0)}function Nj(){ae().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Rj(n){ae().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Dj(){J.disposeVariables()}function hi(){return J}function c1(){return J.memory()}function Fj(n){return J.profile(n)}function le(n,e){return J.tidy(n,e)}function Et(n){nl(n).forEach(t=>t.dispose())}function Ts(n){return J.keep(n)}function $j(n){return J.time(n)}function C$(n){return J.setBackend(n)}function w$(){return J.ready()}function vu(){return J.backendName}function Pj(n){J.removeBackend(n)}function Lj(n){return J.findBackend(n)}function Oj(n){return J.findBackendFactory(n)}function oC(n,e,t=1){return J.registerBackend(n,e,t)}function Yl(){return J.backend}function zj(n,e){ae().setPlatform(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xl=4;async function u1(n,e){const t=[],s=[],i=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<i.length;++o){const a=i[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((m,A)=>m+A.length,0)+Xl*d.length,f=new Uint8Array(p);let g=0;for(let m=0;m<d.length;m++){const A=d[m],y=new Uint8Array(new Uint32Array([A.length]).buffer);f.set(y,g),g+=Xl,f.set(A,g),g+=A.length}h(f)});s.push(u)}else s.push(l.data());e!=null&&(c.group=e),t.push(c)}const r=await Promise.all(s);return{data:Vj(r),specs:t}}function b2(n,e){const t=new Go(n),s={};let i=0;for(const r of e){const o=Uj(r,(a,l)=>t.slice(i+a,i+l));s[r.name]=v$(r,t.slice(i,i+o)),i+=o}return s}function Uj(n,e){const t=ce(n.shape);let s;if("quantization"in n){const i=n.quantization;s=wu[i.dtype]}else if(n.dtype==="string"){let i=0;for(let r=0;r<t;r++)i+=Xl+new Uint32Array(e(i,i+Xl))[0];return i}else s=wu[n.dtype];return t*s}async function Qj(n,e){const t=ce(n.shape);let s;if("quantization"in n){const i=n.quantization;s=wu[i.dtype]}else if(n.dtype==="string"){let i=0;for(let r=0;r<t;r++)i+=Xl+new Uint32Array(await e(i,i+Xl))[0];return i}else s=wu[n.dtype];return t*s}function v$(n,e){const t=n.name,s=n.dtype,i=n.shape,r=ce(i);let o,a=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=wu[l.dtype],u=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){o=new Float32Array(u.length);for(let h=0;h<u.length;h++){const d=u[h];o[h]=d*l.scale+l.min}}else if(l.dtype==="float16")o=Xj()(u);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);o=new Int32Array(u.length);for(let h=0;h<u.length;h++){const d=u[h];o[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=r*c}else if(s==="string"){const l=ce(n.shape);o=[];for(let c=0;c<l;c++){const u=new Uint32Array(e.slice(a,a+Xl))[0];a+=Xl;const h=new Uint8Array(e.slice(a,a+u));o.push(h),a+=u}}else{const l=wu[s];if(s==="float32")o=new Float32Array(e);else if(s==="int32")o=new Int32Array(e);else if(s==="bool")o=new Uint8Array(e);else if(s==="complex64"){o=new Float32Array(e);const c=new Float32Array(o.length/2),u=new Float32Array(o.length/2);for(let f=0;f<c.length;f++)c[f]=o[f*2],u[f]=o[f*2+1];const h=Ar(c,i,"float32"),d=Ar(u,i,"float32"),p=sl(h,d);return h.dispose(),d.dispose(),p}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=r*l}return Ar(o,i,s)}async function lN(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:i,value:r}=await n.read();if(i&&r==null){const a=t-s.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const o=new Uint8Array(s.length+r.byteLength);o.set(s,0),o.set(new Uint8Array(r),s.length),s=o}return s.buffer}async function S$(n,e){const t={},s=n.getReader();let i=new ArrayBuffer(0);for(const r of e){const o=await Qj(r,async(c,u)=>(i=await lN(s,i,u),i.slice(c,u)));i=await lN(s,i,o);const a=i.slice(0,o);i=i.slice(o);const l=v$(r,a);if(t[r.name]=l,vu()==="webgpu"){const c=Yl();"uploadToGPU"in c&&ce(l.shape)>=ae().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return t}function Vj(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(r=>{if(e+=r.byteLength,t.push(r.byteLength===r.buffer.byteLength?r:new r.constructor(r)),!(r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`)});const s=new Uint8Array(e);let i=0;return t.forEach(r=>{s.set(new Uint8Array(r.buffer),i),i+=r.byteLength}),s.buffer}const I2=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function cN(n){return I2?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Gj(n){if(I2)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,i=e.length;s<i;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function Wj(n){if(I2){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function E$(n){return Go.join(n)}function uN(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function _$(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function C2(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function w2(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),C2(n,t,s)}function dy(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:cN(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:cN(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Go(n.weightData).byteLength}}function $b(n){const e=[];for(const t of n)e.push(...t.weights);return e}function Hj(){const n=t=>{let s=t<<13,i=0;for(;(s&8388608)===0;)i-=8388608,s<<=1;return s&=-8388609,i+=947912704,s|i},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function qj(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function Yj(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Xj(){const n=Hj(),e=qj(),t=Yj();return s=>{const i=new ArrayBuffer(4*s.length),r=new Uint32Array(i);for(let o=0;o<s.length;o++){const a=s[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];r[o]=l}return new Float32Array(i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class es{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return es.instance==null&&(es.instance=new es),es.instance}static registerSaveRouter(e){es.getInstance().saveRouters.push(e)}static registerLoadRouter(e){es.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return es.getHandlers(e,"save")}static getLoadHandlers(e,t){return es.getHandlers(e,"load",t)}static getHandlers(e,t,s){const i=[];return(t==="load"?es.getInstance().loadRouters:es.getInstance().saveRouters).forEach(o=>{const a=o(e,s);a!==null&&i.push(a)}),i}}const jj=n=>es.registerSaveRouter(n),Kj=n=>es.registerLoadRouter(n),T$=n=>es.getSaveHandlers(n),B$=(n,e)=>es.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h1="tensorflowjs",d1=1,eu="models_store",Dl="model_info_store";function k$(){if(!ae().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function p1(n){const e=n.result;e.createObjectStore(eu,{keyPath:"modelPath"}),e.createObjectStore(Dl,{keyPath:"modelPath"})}class Su{constructor(e){if(this.indexedDB=k$(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,i)=>{const r=this.indexedDB.open(h1,d1);r.onupgradeneeded=()=>p1(r),r.onsuccess=()=>{const o=r.result;if(t==null){const a=o.transaction(eu,"readonly"),c=a.objectStore(eu).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=u=>(o.close(),i(c.error)),a.oncomplete=()=>o.close()}else{t.weightData=Go.join(t.weightData);const a=dy(t),l=o.transaction(Dl,"readwrite");let c=l.objectStore(Dl),u;try{u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return i(d)}let h;u.onsuccess=()=>{h=o.transaction(eu,"readwrite");const d=h.objectStore(eu);let p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(f){return i(f)}p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=f=>{c=l.objectStore(Dl);const g=c.delete(this.modelPath);g.onsuccess=()=>(o.close(),i(p.error)),g.onerror=m=>(o.close(),i(p.error))}},u.onerror=d=>(o.close(),i(u.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},r.onerror=o=>i(r.error)})}}Su.URL_SCHEME="indexeddb://";const M$=n=>ae().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Su.URL_SCHEME)?Jj(n.slice(Su.URL_SCHEME.length)):null;es.registerSaveRouter(M$);es.registerLoadRouter(M$);function Jj(n){return new Su(n)}function Zj(n){return n.startsWith(Su.URL_SCHEME)?n.slice(Su.URL_SCHEME.length):n}class eK{constructor(){this.indexedDB=k$()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(h1,d1);s.onupgradeneeded=()=>p1(s),s.onsuccess=()=>{const i=s.result,r=i.transaction(Dl,"readonly"),a=r.objectStore(Dl).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(i.close(),t(a.error)),r.oncomplete=()=>i.close()},s.onerror=i=>t(s.error)})}async removeModel(e){return e=Zj(e),new Promise((t,s)=>{const i=this.indexedDB.open(h1,d1);i.onupgradeneeded=()=>p1(i),i.onsuccess=()=>{const r=i.result,o=r.transaction(Dl,"readwrite"),a=o.objectStore(Dl),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return r.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),h=()=>{c=r.transaction(eu,"readwrite");const p=c.objectStore(eu).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=f=>s(l.error)};u.onsuccess=h,u.onerror=d=>(h(),r.close(),s(l.error))}},l.onerror=u=>(r.close(),s(l.error)),o.oncomplete=()=>{c==null?r.close():c.oncomplete=()=>r.close()}},i.onerror=r=>s(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wa="/",Ld="tensorflowjs_models",N$="info",tK="model_topology",nK="weight_specs",sK="weight_data",iK="model_metadata";function R$(n){return{info:[Ld,n,N$].join(Wa),topology:[Ld,n,tK].join(Wa),weightSpecs:[Ld,n,nK].join(Wa),weightData:[Ld,n,sK].join(Wa),modelMetadata:[Ld,n,iK].join(Wa)}}function D$(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function rK(n){const e=n.split(Wa);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Wa)}function oK(n){return n.startsWith(Eu.URL_SCHEME)?n.slice(Eu.URL_SCHEME.length):n}class Eu{constructor(e){if(!ae().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=R$(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),i=dy(e),r=Go.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,Gj(r));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:i}}catch{throw D$(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){const a=JSON.parse(r);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Wj(o),t}}Eu.URL_SCHEME="localstorage://";const F$=n=>ae().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Eu.URL_SCHEME)?aK(n.slice(Eu.URL_SCHEME.length)):null;es.registerSaveRouter(F$);es.registerLoadRouter(F$);function aK(n){return new Eu(n)}class lK{constructor(){R(ae().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),R(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Ld+Wa,s=Wa+N$;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(t)&&r.endsWith(s)){const o=rK(r);e[o]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=oK(e);const t=R$(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return D$(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wd="://";class _i{constructor(){this.managers={}}static getInstance(){return _i.instance==null&&(_i.instance=new _i),_i.instance}static registerManager(e,t){R(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Wd)&&(e=e.slice(0,e.indexOf(Wd))),R(e.length>0,()=>"scheme must not be an empty string.");const s=_i.getInstance();R(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=_i.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(_i.getInstance().managers)}}function C0(n){if(n.indexOf(Wd)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${_i.getSchemes().join(",")}`);return{scheme:n.split(Wd)[0],path:n.split(Wd)[1]}}async function $$(n,e,t=!1){R(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=es.getLoadHandlers(n);R(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),R(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const i=s[0],r=es.getSaveHandlers(e);R(r.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),R(r.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const o=r[0],a=C0(n).scheme,l=C0(n).path,c=a===C0(n).scheme,u=await i.load();t&&c&&await _i.getManager(a).removeModel(l);const h=await o.save(u);return t&&!c&&await _i.getManager(a).removeModel(l),h.modelArtifactsInfo}async function cK(){const n=_i.getSchemes(),e={};for(const t of n){const s=await _i.getManager(t).listModels();for(const i in s){const r=t+Wd+i;e[r]=s[i]}}return e}async function uK(n){const e=C0(n);return _i.getManager(e.scheme).removeModel(e.path)}async function hK(n,e){return $$(n,e,!1)}async function dK(n,e){return $$(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pK{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ae().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const i=this.functionRefs[s.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return l$(e)}}if(ae().get("IS_BROWSER")){ae().setPlatform("browser",new pK);try{_i.registerManager(Eu.URL_SCHEME,new lK)}catch{}try{_i.registerManager(Su.URL_SCHEME,new eK)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fK={importFetch:()=>require("node-fetch")};let Kv;class mK{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ae().global.fetch!=null?ae().global.fetch(e,t):(Kv==null&&(Kv=fK.importFetch()),Kv(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ae().get("IS_NODE")&&!ae().get("IS_BROWSER")&&ae().setPlatform("node",new mK);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zt(n,e="float32",t){return e=e||"float32",Sr(n),new Is(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gK(n,e){const t=O(n,"x","cast");if(!ZF(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},i={dtype:e};return J.runKernel(eh,s,i)}const We=Z({cast_:gK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AK(n){const t={x:O(n,"x","clone","string_or_numeric")};return J.runKernel(ph,t)}const da=Z({clone_:AK});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v2(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */b$();const yK={buffer:zt,cast:We,clone:da,print:v2};xj(yK);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xK(n,e){let t=O(n,"a","add"),s=O(e,"b","add");[t,s]=is(t,s);const i={a:t,b:s};return J.runKernel(cc,i)}const Be=Z({add_:xK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bK(n,e){let t=O(n,"a","floorDiv"),s=O(e,"b","floorDiv");[t,s]=is(t,s);const i={a:t,b:s};return J.runKernel(hh,i)}const aC=Z({floorDiv_:bK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IK(n,e){let t=O(n,"a","div"),s=O(e,"b","div");if([t,s]=is(t,s),t.dtype==="int32"&&s.dtype==="int32")return aC(t,s);const i={a:t,b:s},r={};return J.runKernel(rh,i,r)}const et=Z({div_:IK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CK(n,e){let t=O(n,"a","mul"),s=O(e,"b","mul");[t,s]=is(t,s);const i={a:t,b:s};return J.runKernel(Ch,i)}const K=Z({mul_:CK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wK(n){const e=O(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return J.runKernel($p,t)}else{const t={x:e};return J.runKernel(Tp,t)}}const As=Z({abs_:wK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vK(n){const t={x:O(n,"x","acos")};return J.runKernel(qu,t)}const S2=Z({acos_:vK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SK(n){const t={x:O(n,"x","acosh")};return J.runKernel(Yu,t)}const E2=Z({acosh_:SK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EK(n){R(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),R(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((i,r)=>O(i,`tensors${r}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!qt(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return J.runKernel(Bp,s)}const P$=Z({addN_:EK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _K(n,e=null,t=!1){const i={x:O(n,"x","all","bool")},r={axis:e,keepDims:t};return J.runKernel(hA,i,r)}const lC=Z({all_:_K});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TK(n,e=null,t=!1){const i={x:O(n,"x","any","bool")},r={axis:e,keepDims:t};return J.runKernel(dA,i,r)}const Ng=Z({any_:TK});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BK(n,e=0){const s={x:O(n,"x","argMax")},i={axis:e};return J.runKernel(kp,s,i)}const jl=Z({argMax_:BK});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kK(n,e=0){const s={x:O(n,"x","argMin")},i={axis:e};return J.runKernel(Mp,s,i)}const _2=Z({argMin_:kK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MK(n){const t={x:O(n,"x","asin")};return J.runKernel(Xu,t)}const T2=Z({asin_:MK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NK(n){const t={x:O(n,"x","asinh")};return J.runKernel(ju,t)}const B2=Z({asinh_:NK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RK(n){const t={x:O(n,"x","atan")};return J.runKernel(Ku,t)}const k2=Z({atan_:RK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DK(n,e){let t=O(n,"a","atan2"),s=O(e,"b","atan2");[t,s]=is(t,s);const i={a:t,b:s};return J.runKernel(Zu,i)}const M2=Z({atan2_:DK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FK(n){const t={x:O(n,"x","atanh")};return J.runKernel(Ju,t)}const N2=Z({atanh_:FK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dc(n,e,t,s,i="NHWC",r){const o=n[3],a=[...e,o],l=Er(i);return Qn(n,a,t,r,s,null,null,l)}function mi(n,e,t,s,i,r,o="channelsLast"){const[a,l]=Rg(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Qn(n,c,t,s,i,r,!1,o)}function Xr(n,e,t,s,i,r,o="NDHWC"){const[a,l,c]=f1(e);let u,h;if(o==="NDHWC")h="channelsLast",u=[a,l,c,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",u=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Wo(n,u,t,s,i,!1,h,r)}function Qn(n,e,t,s,i,r,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h]=n;else if(a==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,f]=e,[g,m]=Rg(t),[A,y]=Rg(s),b=Hd(d,A),x=Hd(p,y),{padInfo:C,outHeight:w,outWidth:E}=LK(i,c,u,g,m,b,x,r,a),T=o?f*h:f;let v;return a==="channelsFirst"?v=[l,T,w,E]:a==="channelsLast"&&(v=[l,w,E,T]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:w,outWidth:E,outChannels:T,padInfo:C,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:x,dilationHeight:A,dilationWidth:y,inShape:n,outShape:v,filterShape:e}}function Wo(n,e,t,s,i,r=!1,o="channelsLast",a){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h,d]=n;else if(o==="channelsFirst")[l,d,c,u,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,f,g,,m]=e,[A,y,b]=f1(t),[x,C,w]=f1(s),E=Hd(p,x),T=Hd(f,C),v=Hd(g,w),{padInfo:S,outDepth:_,outHeight:N,outWidth:D}=OK(i,c,u,h,A,y,b,E,T,v,a),P=r?m*d:m;let L;return o==="channelsFirst"?L=[l,P,_,N,D]:o==="channelsLast"&&(L=[l,_,N,D,P]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:_,outHeight:N,outWidth:D,outChannels:P,padInfo:S,strideDepth:A,strideHeight:y,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:E,effectiveFilterHeight:T,effectiveFilterWidth:v,dilationDepth:x,dilationHeight:C,dilationWidth:w,inShape:n,outShape:L,filterShape:e}}function $K(n,e,t,s,i){s==null&&(s=R2(n,e,t));const r=n[0],o=n[1],a=Dg((r-e+2*s)/t+1,i),l=Dg((o-e+2*s)/t+1,i);return[a,l]}function PK(n,e,t,s,i,r){i==null&&(i=R2(n,e[0],s[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*i>=e[a]&&(o[a]=Dg((n[a]-e[a]+2*i)/s[a]+1,r));return o}function R2(n,e,t,s=1){const i=Hd(e,s);return Math.floor((n[0]*(t-1)-t+i)/2)}function Rg(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function f1(n){return typeof n=="number"?[n,n,n]:n}function Hd(n,e){return e<=1?n:n+(n-1)*(e-1)}function LK(n,e,t,s,i,r,o,a,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=$K([e,t],r,s,n,a);u=p[0],h=p[1]}else if(n==="same"){u=Math.ceil(e/s),h=Math.ceil(t/i);const d=Math.max(0,(u-1)*s+r-e),p=Math.max(0,(h-1)*i+o-t),f=Math.floor(d/2),g=d-f,m=Math.floor(p/2),A=p-m;c={top:f,bottom:g,left:m,right:A,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-r+1)/s),h=Math.ceil((t-o+1)/i);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],f=l==="channelsLast"?n[2][0]:n[3][0],g=l==="channelsLast"?n[2][1]:n[3][1];c={top:d,bottom:p,left:f,right:g,type:d===0&&p===0&&f===0&&g===0?"VALID":"EXPLICIT"},u=Dg((e-r+d+p)/s+1,a),h=Dg((t-o+f+g)/i+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function OK(n,e,t,s,i,r,o,a,l,c,u){let h,d,p,f;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const m=PK([e,t,s,1],[a,l,c],1,[i,r,o],n,u);d=m[0],p=m[1],f=m[2]}else if(n==="same"){d=Math.ceil(e/i),p=Math.ceil(t/r),f=Math.ceil(s/o);const g=(d-1)*i+a-e,m=(p-1)*r+l-t,A=(f-1)*o+c-s,y=Math.floor(g/2),b=g-y,x=Math.floor(m/2),C=m-x,w=Math.floor(A/2),E=A-w;h={top:x,bottom:C,left:w,right:E,front:y,back:b,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function Dg(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Kl(n){const[e,t,s]=Rg(n);return e===1&&t===1&&s===1}function Rs(n,e){return Kl(n)||Kl(e)}function _u(n){return Rg(n).every(e=>e>0)}function Er(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Oi(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")R(Cu(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(i=>{R(Cu(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zK(n,e){const s={x:O(n,"x","reshape","string_or_numeric")},i={shape:e};return J.runKernel(Af,s,i)}const ee=Z({reshape_:zK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UK(n,e,t,s,i){const r=O(n,"x","avgPool","float32"),o=1;R(Rs(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=r,l=!1;r.rank===3&&(l=!0,a=ee(r,[1,r.shape[0],r.shape[1],r.shape[2]])),R(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Oi("avgPool",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i};let h=J.runKernel(Np,c,u);return h=We(h,r.dtype),l?ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const py=Z({avgPool_:UK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QK(n,e,t,s,i,r="NDHWC"){const o=O(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),R(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),R(r==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),R(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Oi("avgPool3d",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:r};let h=J.runKernel(Rp,c,u);return h=We(h,a.dtype),l?ee(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const D2=Z({avgPool3d_:QK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VK(n,e=0){R(n.length>=1,()=>"Pass at least one tensor to concat");const t=Mg(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(r=>{if(r.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `)}),t.length===1)return da(t[0]);const s=t,i={axis:e};return J.runKernel(Pp,s,i)}const Jn=Z({concat_:VK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GK(n,e,t=!1,s=!1){let i=O(n,"a","matMul"),r=O(e,"b","matMul");[i,r]=is(i,r);const o={a:i,b:r},a={transposeA:t,transposeB:s};return J.runKernel(Dp,o,a)}const tn=Z({matMul_:GK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WK(n){const t={x:O(n,"x","sigmoid","float32")};return J.runKernel(Rh,t)}const yr=Z({sigmoid_:WK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HK(n,e,t){const s=O(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const i={x:s},r={begin:e,size:t};return J.runKernel(Cf,i,r)}const $t=Z({slice_:HK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qK(n){const t={x:O(n,"x","tanh","float32")};return J.runKernel(Oh,t)}const Jl=Z({tanh_:qK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YK(n,e,t,s,i,r){const o=O(n,"forgetBias","basicLSTMCell"),a=O(e,"lstmKernel","basicLSTMCell"),l=O(t,"lstmBias","basicLSTMCell"),c=O(s,"data","basicLSTMCell"),u=O(i,"c","basicLSTMCell"),h=O(r,"h","basicLSTMCell"),d=Jn([c,h],1),p=tn(d,a),f=Be(p,l),g=f.shape[0],m=f.shape[1]/4,A=[g,m],y=$t(f,[0,0],A),b=$t(f,[0,m],A),x=$t(f,[0,m*2],A),C=$t(f,[0,m*3],A),w=Be(K(yr(y),Jl(b)),K(u,yr(Be(o,x)))),E=K(Jl(w),yr(C));return[w,E]}const L$=Z({basicLSTMCell_:YK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XK(n,e,t){const s=O(n,"x","batchToSpaceND"),i=e.reduce((a,l)=>a*l);R(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),R(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),R(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const r={x:s},o={blockShape:e,crops:t};return J.runKernel(Fp,r,o)}const fy=Z({batchToSpaceND_:XK});function jK(n){let e;return n.rank===0||n.rank===1?e=ee(n,[1,1,1,n.size]):n.rank===2?e=ee(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ee(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KK(n,e,t,s,i,r){r==null&&(r=.001);const o=O(n,"x","batchNorm"),a=O(e,"mean","batchNorm"),l=O(t,"variance","batchNorm");let c;i!=null&&(c=O(i,"scale","batchNorm"));let u;s!=null&&(u=O(s,"offset","batchNorm")),R(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:jK(o),scale:c,offset:u,mean:a,variance:l},p={varianceEpsilon:r},f=J.runKernel(Hp,d,p);return ee(f,o.shape)}const kf=Z({batchNorm_:KK});function JK(n,e,t,s,i,r){const o=O(n,"x","batchNorm"),a=O(e,"mean","batchNorm"),l=O(t,"variance","batchNorm");let c;i!=null&&(c=O(i,"scale","batchNorm"));let u;return s!=null&&(u=O(s,"offset","batchNorm")),R(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),R(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),R(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&R(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&R(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),kf(o,a,l,u,c,r)}const F2=Z({batchNorm2d_:JK});function ZK(n,e,t,s,i,r){const o=O(n,"x","batchNorm"),a=O(e,"mean","batchNorm"),l=O(t,"variance","batchNorm");let c;i!=null&&(c=O(i,"scale","batchNorm"));let u;return s!=null&&(u=O(s,"offset","batchNorm")),R(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),R(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),R(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&R(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&R(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),kf(o,a,l,u,c,r)}const $2=Z({batchNorm3d_:ZK});function eJ(n,e,t,s,i,r){const o=O(n,"x","batchNorm"),a=O(e,"mean","batchNorm"),l=O(t,"variance","batchNorm");let c;i!=null&&(c=O(i,"scale","batchNorm"));let u;return s!=null&&(u=O(s,"offset","batchNorm")),R(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),R(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),R(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&R(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&R(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),kf(o,a,l,u,c,r)}const P2=Z({batchNorm4d_:eJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tJ(n,e,t){const s=O(n,"x","bincount"),i=O(e,"weights","bincount");R(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),R(t>=0,()=>`size must be non-negative, but got ${t}.`),R(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const r={x:s,weights:i},o={size:t};return J.runKernel(mA,r,o)}const L2=Z({bincount_:tJ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(n,e){const t=O(n,"x","bitwiseAnd"),s=O(e,"y","bitwiseAnd");if(!qt(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const i={a:t,b:s};return J.runKernel(gA,i)}const O$=Z({bitwiseAnd_:nJ});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sJ(n,e){const t=O(n,"s0","broadcastArgs","int32"),s=O(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const i={s0:t,s1:s};return J.runKernel(AA,i)}const z$=Z({broadcastArgs_:sJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(n,e){let t=O(n,"broadcastTo","x");const s=t.shape;if(Sr(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=ee(t,c)}const i=t.shape,r=Array.from(e);for(let c=e.length-1;c>=0;c--)if(i[c]===e[c])r[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(r.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return da(t);const a={x:t},l={reps:r};return J.runKernel(zh,a,l)}const pu=Z({broadcastTo_:iJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(n){const t={x:O(n,"x","ceil","float32")};return J.runKernel(th,t)}const O2=Z({ceil_:rJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qh(n,e,t){Sr(n),t=t||lc(e);const s={shape:n,value:e,dtype:t};return J.runKernel(RA,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oJ(n,e,t){const s=O(n,"x","clipByValue");if(R(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Qh(s.shape,e,s.dtype);const i={x:s},r={clipValueMin:e,clipValueMax:t};return J.runKernel(nh,i,r)}const Fi=Z({clipByValue_:oJ});function aJ(n){return Jn(n,0)}const z2=Z({concat1d_:aJ});function lJ(n,e){return Jn(n,e)}const U2=Z({concat2d_:lJ});function cJ(n,e){return Jn(n,e)}const Q2=Z({concat3d_:cJ});function uJ(n,e){return Jn(n,e)}const V2=Z({concat4d_:uJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hJ(n,e,t,s,i="NHWC",r=[1,1],o){const a=O(n,"x","conv2d","float32"),l=O(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),R(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Oi("conv2d",s,o);const h=i==="NHWC"?c.shape[3]:c.shape[1];R(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),R(Rs(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),R(_u(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),R(_u(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:c,filter:l},p={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o},f=J.runKernel(Lp,d,p);return u?ee(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const il=Z({conv2d_:hJ});function dJ(n,e,t,s,i="NWC",r=1,o){const a=O(n,"x","conv1d"),l=O(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=ee(a,[1,a.shape[0],a.shape[1]])),R(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),R(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Oi("conv1d",s,o),R(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),R(Rs(t,r),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${r}'`),R(_u(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),R(_u(t),()=>"Error in conv1D: Stride should be larger than 0."),R(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const h=ee(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=ee(c,[c.shape[0],1,c.shape[1],c.shape[2]]),m=il(d,h,[1,t],s,"NHWC",[1,r],o);return u?ee(m,[m.shape[2],m.shape[3]]):ee(m,[m.shape[0],m.shape[2],m.shape[3]])}const cC=Z({conv1d_:dJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pJ(n,e,t,s,i,r="NHWC",o){R(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),R(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),R(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),R(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=r==="NHWC"?a[3]:a[1],h=r==="NHWC"?l.shape[3]:l.shape[1];R(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),R(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),Oi("conv2dDerInput",i,o);const d={dy:l,filter:t},p={strides:s,pad:i,dataFormat:r,dimRoundingMode:o,inputShape:a},f=J.runKernel(Op,d,p);return c?ee(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const G2=Z({conv2DBackpropInput_:pJ});function fJ(n,e,t,s,i,r){const o=O(n,"x","conv2dTranspose"),a=O(e,"filter","conv2dTranspose");return G2(t,o,a,s,i,"NHWC",r)}const uC=Z({conv2dTranspose_:fJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mJ(n,e,t,s,i="NDHWC",r=[1,1,1]){const o=O(n,"x","conv3d"),a=O(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),R(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),R(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),R(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),R(Rs(t,r),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),R(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),R(_u(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),R(_u(t),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:l,filter:a},h={strides:t,pad:s,dataFormat:i,dilations:r},d=J.runKernel(zp,u,h);return c?ee(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const W2=Z({conv3d_:mJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gJ(n,e,t,s,i){R(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let r=n,o=e,a=!1;e.rank===4&&(a=!0,o=ee(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),r=[1,n[0],n[1],n[2],n[3]]);const l=r[4],c=o.shape[4];R(r.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`),R(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),R(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),R(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),R(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const u={dy:o,filter:t},h={pad:i,strides:s,inputShape:r},d=J.runKernel(IA,u,h);return a?ee(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const U$=Z({conv3DBackpropInput_:gJ});function AJ(n,e,t,s,i){const r=O(n,"x","conv3dTranspose"),o=O(e,"filter","conv3dTranspose");return U$(t,r,o,s,i)}const H2=Z({conv3dTranspose_:AJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yJ(n){const t={x:O(n,"x","cos","float32")};return J.runKernel(sh,t)}const my=Z({cos_:yJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xJ(n){const t={x:O(n,"x","cosh","float32")};return J.runKernel(ih,t)}const hC=Z({cosh_:xJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bJ(n,e=0,t=!1,s=!1){const r={x:O(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:s};return J.runKernel(CA,r,o)}const Fg=Z({cumprod_:bJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IJ(n,e=0,t=!1,s=!1){const r={x:O(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return J.runKernel(Up,r,o)}const dC=Z({cumsum_:IJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CJ(n,e,t,s=!1){const i=O(n,"x","denseBincount"),r=O(e,"weights","denseBincount");R(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),R(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),R(t>=0,()=>`size must be non-negative, but got ${t}.`),R(r.size===i.size||r.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${r.shape}.`);const o={x:i,weights:r},a={size:t,binaryOutput:s};return J.runKernel(vA,o,a)}const Pb=Z({denseBincount_:CJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wJ(n,e,t="NHWC"){const s=O(n,"x","depthToSpace","float32"),i=t==="NHWC"?s.shape[1]:s.shape[2],r=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];R(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),R(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${s.shape}`),R(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e} for depthToSpace with input shape
        ${s.shape}`),R(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:e,dataFormat:t};return J.runKernel(SA,a,l)}const q2=Z({depthToSpace_:wJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vJ(n,e,t,s,i="NHWC",r=[1,1],o){const a=O(n,"x","depthwiseConv2d","float32"),l=O(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),R(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=i==="NHWC"?c.shape[3]:c.shape[1];R(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),Oi("depthwiseConv2d",s,o);const d={x:c,filter:l},p={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o},f=J.runKernel(Qp,d,p);return u?ee(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Mf=Z({depthwiseConv2d_:vJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SJ(n){const t={x:O(n,"x","diag")};return J.runKernel(TA,t)}const Q$=Z({diag_:SJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EJ(n,e,t,s,i=[1,1],r="NHWC"){const o=O(n,"x","dilation2d"),a=O(e,"filter","dilation2d");R(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),R(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),R(r==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);let l=o,c=!1;o.rank===3&&(l=ee(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),R(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const u={x:l,filter:a},h={strides:t,pad:s,dilations:i},d=J.runKernel(Vp,u,h);return c?ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Y2=Z({dilation2d_:EJ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rl(n,e){const t=n.length,s=[];for(let i=0;i<t;i++){const r=t-1-i,o=n[r]||1;(e[e.length-1-i]||1)>1&&o===1&&s.unshift(r)}return s}function ws(n,e){const t=[];for(let s=0;s<e.length;s++){const i=n[n.length-s-1],r=e.length-s-1,o=e[r];(i==null||i===1&&o>1)&&t.unshift(r)}return t}function Mt(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let i=0;i<t;i++){let r=n[n.length-i-1];r==null&&(r=1);let o=e[e.length-i-1];if(o==null&&(o=1),r===1)s[t-i-1]=o;else if(o===1)s[t-i-1]=r;else if(r!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else s[t-i-1]=r}return s}const _J=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Mt,getBroadcastDims:rl,getReductionAxes:ws},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TJ(n,e){let t=O(n,"a","equal","string_or_numeric"),s=O(e,"b","equal","string_or_numeric");[t,s]=is(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(Gp,i)}const br=Z({equal_:TJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BJ(n,e,t){const s=O(e,"a","where"),i=O(t,"b","where"),r=O(n,"condition","where","bool"),o=Mt(Mt(r.shape,s.shape),i.shape),a=pu(r,o),l=pu(s,o),c=pu(i,o),u={condition:a,t:l,e:c};return J.runKernel(If,u)}const Qs=Z({where_:BJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kJ(n){const t={x:O(n,"x","zerosLike")};return J.runKernel(Bf,t)}const an=Z({zerosLike_:kJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MJ(n,e){let t=O(n,"a","div"),s=O(e,"b","div");[t,s]=is(t,s);const i=et(t,s),r=an(i),o=br(s,r);return Qs(o,r,i)}const X2=Z({divNoNan_:MJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NJ(n,e){const t=O(n,"t1","dot"),s=O(e,"t2","dot");R((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const i=t.rank===1?t.size:t.shape[1],r=s.rank===1?s.size:s.shape[0];if(R(i===r,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${r}.`),t.rank===1&&s.rank===1){const o=ee(t,[1,-1]),a=ee(s,[-1,1]),l=tn(o,a);return ee(l,[])}else if(t.rank===1&&s.rank===2){const o=ee(t,[1,-1]),a=ee(s,[s.shape[0],s.shape[1]]),l=tn(o,a);return ee(l,[l.size])}else if(t.rank===2&&s.rank===1){const o=ee(s,[-1,1]),a=tn(t,o);return ee(a,[a.size])}else{const o=ee(s,[s.shape[0],s.shape[1]]);return tn(t,o)}}const j2=Z({dot_:NJ});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RJ(n,...e){const t=e.map((i,r)=>O(i,`tensors${r}`,"einsum")),s={equation:n};return J.runKernel(kA,t,s)}const Gc=Z({einsum_:RJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DJ(n){const t={x:O(n,"x","elu","float32")};return J.runKernel(oh,t)}const Nf=Z({elu_:DJ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FJ(n,e){const t=O(n,"x","ensureShape","string_or_numeric");if(!KF(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const V$=Z({ensureShape_:FJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $J(n){let e=O(n,"x","erf");R(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=We(e,"float32"));const t={x:e};return J.runKernel(ah,t)}const pC=Z({erf_:$J});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function G$(n,e,t){const s=n.length+e.length,i=[];let r=0,o=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?i.push(n[r++]):i.push(e[o++]);return i}function ps(n,e){const t=[],s=n.length;for(let r=0;r<s;r++)e.indexOf(r)===-1&&t.push(n[r]);const i=e.map(r=>n[r]);return[t,i]}function us(n,e){const t=e.map(s=>1);return G$(n,t,e)}function vs(n,e,t){R(K2(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Nn(n,e){if(K2(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Sa(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Vn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PJ(n,e=null,t=!1){const i={x:O(n,"x","max")},r={reductionIndices:e,keepDims:t};return J.runKernel(nf,i,r)}const Gr=Z({max_:PJ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LJ(n,e=null,t=!1){const i={x:O(n,"x","min")},r={axis:e,keepDims:t};return J.runKernel(af,i,r)}const cp=Z({min_:LJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OJ(n,e){let t=O(n,"base","pow"),s=O(e,"exp","pow");[t,s]=is(t,s);const i={a:t,b:s};return J.runKernel(wh,i)}const Aa=Z({pow_:OJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wt(n,e){if((_s(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&_s(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return hc(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zJ(n){const t={x:O(n,"x","sqrt","float32")};return J.runKernel(Fh,t)}const Hs=Z({sqrt_:zJ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UJ(n){const e=O(n,"x","square"),t={};return J.runKernel("Square",{x:e},t)}const vn=Z({square_:UJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QJ(n,e=null,t=!1){let s=O(n,"x","sum");s.dtype==="bool"&&(s=We(s,"int32"));const i={x:s},r={axis:e,keepDims:t};return J.runKernel(wf,i,r)}const ft=Z({sum_:QJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VJ(n,e="euclidean",t=null,s=!1){n=O(n,"x","norm");const i=W$(n,e,t);let r=i.shape;if(s){const o=Vt(t,n.shape);r=us(i.shape,o)}return ee(i,r)}function W$(n,e,t=null){if(n.rank===0)return As(n);if(n.rank!==1&&t===null)return W$(ee(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return ft(As(n),t);if(e===1/0)return Gr(As(n),t);if(e===-1/0)return cp(As(n),t);if(e==="euclidean"||e===2)return Hs(ft(Aa(As(n),wt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Gr(ft(As(n),t[0]),t[1]-1);if(e===1/0)return Gr(ft(As(n),t[1]),t[0]);if(e===-1/0)return cp(ft(As(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Hs(ft(vn(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Rf=Z({norm_:VJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(n,e=null,t=!1){return Rf(n,"euclidean",e,t)}const J2=Z({euclideanNorm_:GJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(n){const t={x:O(n,"x","exp")};return J.runKernel(lh,t)}const fi=Z({exp_:WJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HJ(n,e=0){const t=O(n,"x","expandDims","string_or_numeric");R(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},i={dim:e};return J.runKernel(Wp,s,i)}const rs=Z({expandDims_:HJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qJ(n){const t={x:O(n,"x","expm1")};return J.runKernel(ch,t)}const Z2=Z({expm1_:qJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YJ(n,e){const t=O(n,"x","tile","string_or_numeric");R(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},i={reps:e};return J.runKernel(zh,s,i)}const Or=Z({tile_:YJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJ(n,e,t,s="float32"){e==null&&(e=n);const i=zt([n,e],s),r=n<=e?n:e;for(let a=0;a<r;++a)i.set(1,a,a);const o=ee(i.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Or(rs(o,0),[t[0],1,1]);if(t.length===2)return Or(rs(rs(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Or(rs(rs(rs(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const fC=Z({eye_:XJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jJ(n){const t={x:O(n,"x","floor","float32")};return J.runKernel(uh,t)}const Df=Z({floor_:jJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KJ(n,e,t=0,s=0){const i=O(n,"x","gather"),r=O(e,"indices","gather","int32"),o={x:i,indices:r},a={axis:t,batchDims:s};return J.runKernel(qp,o,a)}const Ff=Z({gather_:KJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JJ(n,e){let t=O(n,"a","greater","string_or_numeric"),s=O(e,"b","greater","string_or_numeric");[t,s]=is(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(Yp,i)}const zi=Z({greater_:JJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZJ(n,e){let t=O(n,"a","greaterEqual","string_or_numeric"),s=O(e,"b","greaterEqual","string_or_numeric");[t,s]=is(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(dh,i)}const dl=Z({greaterEqual_:ZJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e9(n){const t={input:O(n,"input","imag")};return J.runKernel(PA,t)}const gy=Z({imag_:e9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t9(n){const t={x:O(n,"x","isFinite")};return J.runKernel(fh,t)}const e_=Z({isFinite_:t9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n9(n){const t={x:O(n,"x","isInf")};return J.runKernel(mh,t)}const t_=Z({isInf_:n9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s9(n){const t={x:O(n,"x","isNaN")};return J.runKernel(gh,t)}const n_=Z({isNaN_:s9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i9(n,e=.2){const s={x:O(n,"x","leakyRelu")},i={alpha:e};return J.runKernel(Xp,s,i)}const Ay=Z({leakyRelu_:i9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r9(n,e){let t=O(n,"a","less","string_or_numeric"),s=O(e,"b","less","string_or_numeric");[t,s]=is(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(jp,i)}const up=Z({less_:r9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o9(n,e){let t=O(n,"a","lessEqual","string_or_numeric"),s=O(e,"b","lessEqual","string_or_numeric");[t,s]=is(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(Kp,i)}const pc=Z({lessEqual_:o9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return J.runKernel(LA,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a9(n,e=5,t=1,s=1,i=.5){const r=O(n,"x","localResponseNormalization");R(r.rank===4||r.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`),R(Cu(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=r,a=!1;r.rank===3&&(a=!0,o=ee(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:s,beta:i},u=J.runKernel(tf,l,c);return a?ee(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const s_=Z({localResponseNormalization_:a9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l9(n){const t={x:O(n,"x","log","float32")};return J.runKernel(Ah,t)}const Ir=Z({log_:l9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c9(n){const t={x:O(n,"x","log1p")};return J.runKernel(yh,t)}const yy=Z({log1p_:c9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u9(n){return R(ql(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=O(e,"x","tf.grad","string_or_numeric"),i=t!=null?O(t,"dy","tf.grad"):null;return J.tidy(()=>{const{value:r,grads:o}=J.gradients(()=>n(s),[s],i);return i!=null&&Xs(r.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),mC(o),o[0]})}}function h9(n){return R(ql(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{R(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=Mg(e,"args","tf.grads","string_or_numeric"),i=t!=null?O(t,"dy","tf.grads"):null;return J.tidy(()=>{const{value:r,grads:o}=J.gradients(()=>n(...s),s,i);return i!=null&&Xs(r.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),mC(o),o})}}function d9(n){return R(ql(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{R(e instanceof nn,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),R(t==null||t instanceof nn,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:i}=J.gradients(()=>n(e),[e],t);return mC(s),{grad:s[0],value:i}}}function p9(n){return R(ql(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{R(Array.isArray(e)&&e.every(i=>i instanceof nn),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),R(t==null||t instanceof nn,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=J.gradients(()=>n(...e),e,t);return t!=null&&Xs(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),mC(s.grads),s}}function q$(n,e){R(ql(n),()=>"The f passed in variableGrads(f) must be a function"),R(e==null||Array.isArray(e)&&e.every(c=>c instanceof kg),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in J.registeredVariables)e.push(J.registeredVariables[c])}const s=t?e.filter(c=>!c.trainable):null,i=e.length;e=e.filter(c=>c.trainable),R(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const r=!0,{value:o,grads:a}=J.gradients(n,e,null,r);R(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),R(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((c,u)=>{a[u]!=null&&(l[c.name]=a[u])}),s?.forEach(c=>l[c.name]=null),{value:o,grads:l}}function ya(n){return J.customGrad(n)}function mC(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f9(n){const t={x:O(n,"x","neg")};return J.runKernel(cf,t)}const zn=Z({neg_:f9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m9(n){const t={x:O(n,"x","softplus")};return J.runKernel(Dh,t)}const Vh=Z({softplus_:m9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g9(n){const e=O(n,"x","logSigmoid");return ya(s=>({value:zn(Vh(zn(s))),gradFunc:o=>K(o,yr(zn(s)))}))(e)}const i_=Z({logSigmoid_:g9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A9(n,e){let t=O(n,"a","sub"),s=O(e,"b","sub");[t,s]=is(t,s);const i={a:t,b:s};return J.runKernel(Ph,i)}const nt=Z({sub_:A9});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y9(n,e=-1){const t=O(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return ya((i,r)=>{const a=Gr(i,e,!0),l=nt(i,a),c=nt(We(l,"float32"),Ir(ft(fi(l),e,!0)));return r([c]),{value:c,gradFunc:(h,d)=>{const[p]=d,f=!0,g=fi(p);return nt(h,K(ft(h,e,f),g))}}})(t)}const gC=Z({logSoftmax_:y9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x9(n,e=null,t=!1){const s=O(n,"x","logSumExp"),i=Vt(e,s.shape),r=Gr(s,i,!0),o=nt(s,r),a=fi(o),l=ft(a,i),c=Ir(l),u=Be(ee(r,c.shape),c);if(t){const h=us(u.shape,i);return ee(u,h)}return u}const xy=Z({logSumExp_:x9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b9(n,e){const t=O(n,"a","logicalAnd","bool"),s=O(e,"b","logicalAnd","bool");Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(Jp,i)}const uo=Z({logicalAnd_:b9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I9(n){const t={x:O(n,"x","logicalNot","bool")};return J.runKernel(Zp,t)}const by=Z({logicalNot_:I9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C9(n,e){const t=O(n,"a","logicalOr","bool"),s=O(e,"b","logicalOr","bool");Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(ef,i)}const AC=Z({logicalOr_:C9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w9(n,e){const t=O(n,"a","logicalXor","bool"),s=O(e,"b","logicalXor","bool");return Mt(t.shape,s.shape),uo(AC(n,e),by(uo(n,e)))}const r_=Z({logicalXor_:w9});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zx=2147483648;function v9(n,e,t="left"){const s=O(n,"sortedSequence","searchSorted"),i=O(e,"values","searchSorted"),r=s.shape[s.shape.length-1],o=i.shape[i.shape.length-1],a=ee(s,[-1,r]),l=ee(i,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ce(l.shape)>=Zx)throw new Error(`values tensor size must less than ${Zx}`);if(a.shape[1]>=Zx)throw new Error(`trailing dim_size must less than ${Zx} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},u={side:t};return J.runKernel(JA,c,u)}const yC=Z({searchSorted_:v9});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(n,e){return yC(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S9(n,e,t,s,i){const r=O(n,"x","maxPool"),o=1;let a=r,l=!1;r.rank===3&&(l=!0,a=ee(r,[1,r.shape[0],r.shape[1],r.shape[2]])),R(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),R(Rs(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Oi("maxPool",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i},h=J.runKernel(sf,c,u);return l?ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Iy=Z({maxPool_:S9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E9(n,e=[1,1,1],t,s,i,r="NDHWC"){const o=O(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),R(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),R(r==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),Oi("maxPool3d",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:r},h=J.runKernel(rf,c,u);return l?ee(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const o_=Z({maxPool3d_:E9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _9(n,e,t,s,i=!1){const o={x:O(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:s,includeBatchInIndex:i},l=J.runKernel(QA,o,a);return{result:l[0],indexes:l[1]}}const X$=Z({maxPoolWithArgmax_:_9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T9(n,e){let t=O(n,"a","maximum"),s=O(e,"b","maximum");[t,s]=is(t,s),t.dtype==="bool"&&(t=We(t,"int32"),s=We(s,"int32")),Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(xh,i)}const Ea=Z({maximum_:T9});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B9(n,e=null,t=!1){const i={x:O(n,"x","mean")},r={axis:e,keepDims:t};return J.runKernel(of,i,r)}const ts=Z({mean_:B9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function as(n,e="float32"){if(Sr(n),e==="complex64"){const s=as(n,"float32"),i=as(n,"float32");return sl(s,i)}const t=Ws(ce(n),e);return J.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xi(n,e="float32"){if(Sr(n),e==="complex64"){const s=Xi(n,"float32"),i=as(n,"float32");return sl(s,i)}const t=XI(ce(n),e);return J.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=O(n,"x","meshgrid",n instanceof nn?n.dtype:"float32");if(e===void 0)return[s];let i=O(e,"y","meshgrid",e instanceof nn?e.dtype:"float32");const r=ce(s.shape),o=ce(i.shape);return t==="xy"?(s=ee(s,[1,-1]),i=ee(i,[-1,1]),[tn(Xi([o,1],s.dtype),s),tn(i,Xi([1,r],i.dtype))]):(s=ee(s,[-1,1]),i=ee(i,[1,-1]),[tn(s,Xi([1,o],s.dtype)),tn(Xi([r,1],i.dtype),i)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k9(n,e){let t=O(n,"a","minimum"),s=O(e,"b","minimum");[t,s]=is(t,s),t.dtype==="bool"&&(t=We(t,"int32"),s=We(s,"int32")),Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(bh,i)}const ol=Z({minimum_:k9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M9(n,e,t){R(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=O(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");R(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)R(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),R(e[a][0]>=0&&e[a][0]<=s.shape[a]-i&&e[a][1]>=0&&e[a][1]<=s.shape[a]-i,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-i} or less than 0 for input of shape ${s.shape}`);const r={paddings:e,mode:t},o={x:s};return J.runKernel(lf,o,r)}const xC=Z({mirrorPad_:M9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N9(n,e){let t=O(n,"a","mod"),s=O(e,"b","mod");[t,s]=is(t,s);const i={a:t,b:s};return J.runKernel(Ih,i)}const a_=Z({mod_:N9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R9(n,e=null,t=!1){n=O(n,"x","moments");const s=Vt(e,n.shape),i=ts(n,s,t);let r=i.shape;t||(r=us(i.shape,s));const o=vn(nt(We(n,"float32"),ee(i,r))),a=ts(o,s,t);return{mean:i,variance:a}}const Cy=Z({moments_:R9});function D9(n,e,t,s){const i=O(e,"data","multiRNNCell"),r=Mg(t,"c","multiRNNCell"),o=Mg(s,"h","multiRNNCell");let a=i;const l=[];for(let h=0;h<n.length;h++){const d=n[h](a,r[h],o[h]);l.push(d[0]),l.push(d[1]),a=d[1]}const c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}const K$=Z({multiRNNCell_:D9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F9(n,e,t,s=!1){const i=O(n,"logits","multinomial"),r=i.size,o=i.rank;if(r<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${r}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?ee(i,[1,-1]):i},c={numSamples:e,seed:t,normalized:s},u=J.runKernel(VA,l,c);return o===1?ee(u,[u.size]):u}const J$=Z({multinomial_:F9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $9(n,e){let t=O(n,"a","notEqual","string_or_numeric"),s=O(e,"b","notEqual","string_or_numeric");[t,s]=is(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return J.runKernel(uf,i)}const Tu=Z({notEqual_:$9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P9(n,e,t=1,s=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:O(n,"indices","oneHot","int32")},a={dtype:i,depth:e,onValue:t,offValue:s};return J.runKernel(df,o,a)}const hp=Z({oneHot_:P9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L9(n){const t={x:O(n,"x","onesLike")};return J.runKernel(hf,t)}const Cr=Z({onesLike_:L9});function O9(n,e){const t=O(n,"v1","outerProduct"),s=O(e,"v2","outerProduct");R(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const i=ee(t,[-1,1]),r=ee(s,[1,-1]);return tn(i,r)}const Z$=Z({outerProduct_:O9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z9(n,e,t=0){const s=O(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},r={x:s};return J.runKernel(ff,r,i)}const ho=Z({pad_:z9});function U9(n,e,t=0){return R(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),ho(n,[e],t)}const eP=Z({pad1d_:U9});function Q9(n,e,t=0){return R(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(n,e,t)}const tP=Z({pad2d_:Q9});function V9(n,e,t=0){return R(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(n,e,t)}const nP=Z({pad3d_:V9});function G9(n,e,t=0){return R(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(n,e,t)}const sP=Z({pad4d_:G9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W9(n,e,t){const s=O(n,"x","spaceToBatchND");R(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),R(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),R(s.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:s},r={blockShape:e,paddings:t};return J.runKernel(vf,i,r)}const wy=Z({spaceToBatchND_:W9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H9(n,e,t,s,i,r,o){i==null&&(i=[1,1]),r==null&&(r=1),s===0&&(s="valid");const a=O(n,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(Rs(r,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);const u=mi(l.shape,e,r,i,s),h=[u.dilationHeight,u.dilationWidth];let d;s==="same"?d=Y9([u.filterHeight,u.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[f,g]=q9([u.inHeight,u.inWidth],h,d),m=p?s:"valid",A=p?l:wy(l,h,f),b=(t==="avg"?()=>py(A,e,r,m,o):()=>Iy(A,e,r,m,o))(),x=p?b:fy(b,h,g);return c?ee(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function q9(n,e,t){const s=t.map(u=>u[0]),i=t.map(u=>u[1]),r=n.concat(s,i),o=e.map((u,h)=>(u-r[h]%u)%u),a=i.map((u,h)=>u+o[h]),l=e.map((u,h)=>[s[h],a[h]]),c=e.map((u,h)=>[0,o[h]]);return[l,c]}function Y9(n,e){const s=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),i=s.map(o=>Math.floor(o/2)),r=s.map((o,a)=>o-i[a]);return s.map((o,a)=>[i[a],r[a]])}const l_=Z({pool_:H9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X9(n,e){const t=O(n,"x","prelu"),s=O(e,"alpha","prelu"),i={x:t,alpha:s};return J.runKernel(mf,i)}const vy=Z({prelu_:X9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j9(n,e=null,t=!1){let s=O(n,"x","prod");s.dtype==="bool"&&(s=We(s,"int32"));const i={x:s},r={axis:e,keepDims:t};return J.runKernel(gf,i,r)}const c_=Z({prod_:j9});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K9(n,e,t,s){const i=n.map((u,h)=>O(u,`tensors${h}`,"raggedGather","int32")),r=O(e,"paramsDenseValues","raggedGather"),o=O(t,"indices","raggedGather","int32"),a={paramsNestedSplits:i,paramsDenseValues:r,indices:o},l={outputRaggedRank:s},c=J.runKernel(KI,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const iP=Z({raggedGather_:K9});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J9(n,e,t){const s=O(n,"starts","raggedRange"),i=O(e,"limits","raggedRange",s.dtype),r=O(t,"deltas","raggedRange",s.dtype),o={starts:s,limits:i,deltas:r},a=J.runKernel(JI,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const rP=Z({raggedRange_:J9});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z9(n,e,t,s,i){const r=O(n,"shape","raggedTensorToTensor","int32"),o=O(e,"values","raggedTensorToTensor"),a=O(t,"defaultValue","raggedTensorToTensor",o.dtype),l=s.map((h,d)=>O(h,`tensors${d}`,"raggedTensorToTensor","int32")),c={shape:r,values:o,defaultValue:a,rowPartitionTensors:l},u={rowPartitionTypes:i};return J.runKernel(ZI,c,u)}const oP=Z({raggedTensorToTensor_:Z9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7(n,e,t){Sr(n);const s=ce(n);let i=null;if(t==null||t==="float32")i=new Float32Array(s);else if(t==="int32")i=new Int32Array(s);else if(t==="bool")i=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let r=0;r<s;r++)i[r]=e();return J.makeTensor(i,n,t)}const aP=Z({rand_:e7});var w0={exports:{}},t7=w0.exports,hN;function n7(){return hN||(hN=1,(function(n){(function(e,t,s){function i(l){var c=this,u=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function r(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new i(l),h=c&&c.state,d=u.next;return d.int32=function(){return u.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&r(h,u),d.state=function(){return r(u,{})}),d}function a(){var l=4022871197,c=function(u){u=String(u);for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:this.alea=o})(t7,n)})(w0)),w0.exports}var v0={exports:{}},s7=v0.exports,dN;function i7(){return dN||(dN=1,(function(n){(function(e,t,s){function i(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function r(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:this.xor128=o})(s7,n)})(v0)),v0.exports}var S0={exports:{}},r7=S0.exports,pN;function o7(){return pN||(pN=1,(function(n){(function(e,t,s){function i(a){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function r(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:this.xorwow=o})(r7,n)})(S0)),S0.exports}var E0={exports:{}},a7=E0.exports,fN;function l7(){return fN||(fN=1,(function(n){(function(e,t,s){function i(a){var l=this;l.next=function(){var u=l.x,h=l.i,d,p;return d=u[h],d^=d>>>7,p=d^d<<24,d=u[h+1&7],p^=d^d>>>10,d=u[h+3&7],p^=d^d>>>3,d=u[h+4&7],p^=d^d<<7,d=u[h+7&7],d=d^d<<13,p^=d^d<<9,u[h]=p,l.i=h+1&7,p};function c(u,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],u.x=p,u.i=0,d=256;d>0;--d)u.next()}c(l,a)}function r(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.x&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:this.xorshift7=o})(a7,n)})(E0)),E0.exports}var _0={exports:{}},c7=_0.exports,mN;function u7(){return mN||(mN=1,(function(n){(function(e,t,s){function i(a){var l=this;l.next=function(){var u=l.w,h=l.X,d=l.i,p,f;return l.w=u=u+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(u^u>>>16)|0};function c(u,h){var d,p,f,g,m,A=[],y=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,y=Math.max(y,h.length)),f=0,g=-32;g<y;++g)h&&(p^=h.charCodeAt((g+32)%h.length)),g===0&&(m=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,g>=0&&(m=m+1640531527|0,d=A[g&127]^=p+m,f=d==0?f+1:0);for(f>=128&&(A[(h&&h.length||0)&127]=-1),f=127,g=512;g>0;--g)p=A[f+34&127],d=A[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,A[f]=p^d;u.w=m,u.X=A,u.i=f}c(l,a)}function r(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.X&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:this.xor4096=o})(c7,n)})(_0)),_0.exports}var T0={exports:{}},h7=T0.exports,gN;function d7(){return gN||(gN=1,(function(n){(function(e,t,s){function i(a){var l=this,c="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function r(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:this.tychei=o})(h7,n)})(T0)),T0.exports}var B0={exports:{}};const p7={},f7=Object.freeze(Object.defineProperty({__proto__:null,default:p7},Symbol.toStringTag,{value:"Module"})),m7=nj(f7);var g7=B0.exports,AN;function A7(){return AN||(AN=1,(function(n){(function(e,t,s){var i=256,r=6,o=52,a="random",l=s.pow(i,r),c=s.pow(2,o),u=c*2,h=i-1,d;function p(x,C,w){var E=[];C=C==!0?{entropy:!0}:C||{};var T=A(m(C.entropy?[x,b(t)]:x??y(),3),E),v=new f(E),S=function(){for(var _=v.g(r),N=l,D=0;_<c;)_=(_+D)*i,N*=i,D=v.g(1);for(;_>=u;)_/=2,N/=2,D>>>=1;return(_+D)/N};return S.int32=function(){return v.g(4)|0},S.quick=function(){return v.g(4)/4294967296},S.double=S,A(b(v.S),t),(C.pass||w||function(_,N,D,P){return P&&(P.S&&g(P,v),_.state=function(){return g(v,{})}),D?(s[a]=_,N):_})(S,T,"global"in C?C.global:this==s,C.state)}function f(x){var C,w=x.length,E=this,T=0,v=E.i=E.j=0,S=E.S=[];for(w||(x=[w++]);T<i;)S[T]=T++;for(T=0;T<i;T++)S[T]=S[v=h&v+x[T%w]+(C=S[T])],S[v]=C;(E.g=function(_){for(var N,D=0,P=E.i,L=E.j,z=E.S;_--;)N=z[P=h&P+1],D=D*i+z[h&(z[P]=z[L=h&L+N])+(z[L]=N)];return E.i=P,E.j=L,D})(i)}function g(x,C){return C.i=x.i,C.j=x.j,C.S=x.S.slice(),C}function m(x,C){var w=[],E=typeof x,T;if(C&&E=="object")for(T in x)try{w.push(m(x[T],C-1))}catch{}return w.length?w:E=="string"?x:x+"\0"}function A(x,C){for(var w=x+"",E,T=0;T<w.length;)C[h&T]=h&(E^=C[h&T]*19)+w.charCodeAt(T++);return b(C)}function y(){try{var x;return d&&(x=d.randomBytes)?x=x(i):(x=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(x)),b(x)}catch{var C=e.navigator,w=C&&C.plugins;return[+new Date,e,w,e.screen,b(t)]}}function b(x){return String.fromCharCode.apply(0,x)}if(A(s.random(),t),n.exports){n.exports=p;try{d=m7}catch{}}else s["seed"+a]=p})(typeof self<"u"?self:g7,[],Math)})(B0)),B0.exports}var Jv,yN;function y7(){if(yN)return Jv;yN=1;var n=n7(),e=i7(),t=o7(),s=l7(),i=u7(),r=d7(),o=A7();return o.alea=n,o.xor128=e,o.xorwow=t,o.xorshift7=s,o.xor4096=i,o.tychei=r,Jv=o,Jv}var $f=y7();/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x7=.001,lP=.1;function b7(n,e,t){return t==null&&(t=u_()),m1(n,e,(s,i)=>h_(s,i,t))}function u_(){return J.backend.floatPrecision()===32?x7:lP}function m1(n,e,t){let s=!0;if((_s(n)||_s(e))&&(s=!1),_s(n)&&_s(e)&&(s=!0),s){const o=n.constructor.name,a=e.constructor.name;if(o!==a)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(e)){const o=ga(n),a=ga(e);if(!qt(o,a))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${a}]`)}const i=_s(n)?n:co(n),r=_s(e)?e:co(e);if(i.length!==r.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${r.length}.
Actual:   ${i}.
Expected: ${r}.`);for(let o=0;o<r.length;++o){const a=i[o],l=r[o];if(!t(a,l))throw new Error(`Arrays differ: actual[${o}] = ${a}, expected[${o}] = ${l}.
Actual:   ${i}.
Expected: ${r}.`)}typeof expect<"u"&&expect().nothing()}function I7(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function C7(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return To(n)||To(n[0])||To(e)||To(e[0])?m1(n,t,(s,i)=>s==i):m1(n,e,(s,i)=>h_(s,i,0))}function w7(n,e,t){if(t==null&&(t=u_()),!h_(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function h_(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function v7(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function S7(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let i=0;i<s.length;i++)if(t[i]!==s[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${s[i]} but got ${t[i]} instead`)}function cP(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?cP(t):n[e]=Ro(t)}return n}function E7(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function _7(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const T7=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:lP,createVideoElement:E7,encodeStrings:cP,expectArrayBuffersEqual:S7,expectArraysClose:b7,expectArraysEqual:C7,expectNumbersClose:w7,expectPromiseToFail:I7,expectValuesInRange:v7,play:_7,testEpsilon:u_},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d_{constructor(e,t,s,i,r){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=r||Math.random();this.random=$f.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,s=!1;for(;!s;){let i,r,o;do i=2*this.random()-1,r=2*this.random()-1,o=i*i+r*r;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*i*a,t=this.mean+this.stdDev*r*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class B7{constructor(e,t,s,i){this.alpha=e,this.beta=1/t,this.dtype=s;const r=i||Math.random();this.randu=$f.alea(r.toString()),this.randn=new d_(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,i,r,o;for(;;){do i=this.randn.nextValue(),o=1+this.c*i;while(o<=0);if(o*=o*o,e=i*i,t=1-.331*e*e,s=.5*e+this.d*(1-o+Math.log(o)),r=this.randu(),r<t||Math.log(r)<s)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class k7{constructor(e=0,t=1,s,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=$f.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M7(n,e,t=1,s="float32",i){if(Sr(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const r=new B7(e,t,s,i),o=zt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=r.nextValue();return o.toTensor()}const uP=Z({randomGamma_:M7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N7(n,e=0,t=1,s,i){if(Sr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const r=new d_(e,t,s,!1,i),o=zt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=r.nextValue();return o.toTensor()}const bC=Z({randomNormal_:N7});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R7(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return bC(n,0,1,e,t)}const hP=Z({randomStandardNormal_:R7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7(n,e=0,t=1,s="float32",i){Sr(n);const r=zt(n,s),o=new k7(e,t,null,i);for(let a=0;a<r.values.length;a++)r.values[a]=o.nextValue();return r.toTensor()}const fc=Z({randomUniform_:D7});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F7(n,e,t,s){return fc(n,e,t,"int32",s)}const dP=Z({randomUniformInt_:F7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bu(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:e,step:t,dtype:s};return J.runKernel(HA,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7(n){const t={input:O(n,"input","real")};return J.runKernel(qA,t)}const dp=Z({real_:$7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P7(n){const t={x:O(n,"x","reciprocal")};return J.runKernel(vh,t)}const p_=Z({reciprocal_:P7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L7(n){const t={x:O(n,"x","relu")};return J.runKernel(Sh,t)}const Ho=Z({relu_:L7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O7(n){const t={x:O(n,"x","relu6")};return J.runKernel(Eh,t)}const IC=Z({relu6_:O7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z7(n,e){const s={x:O(n,"x","reverse")},i={dims:e};return J.runKernel(bf,s,i)}const qr=Z({reverse_:z7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U7(n){const e=O(n,"x","reverse");return R(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),qr(e,0)}const pP=Z({reverse1d_:U7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q7(n,e){const t=O(n,"x","reverse");return R(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),qr(t,e)}const fP=Z({reverse2d_:Q7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V7(n,e){const t=O(n,"x","reverse");return R(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),qr(t,e)}const mP=Z({reverse3d_:V7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G7(n,e){const t=O(n,"x","reverse");return R(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),qr(t,e)}const gP=Z({reverse4d_:G7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W7(n){const t={x:O(n,"x","round")};return J.runKernel(_h,t)}const CC=Z({round_:W7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H7(n){const t={x:O(n,"x","rsqrt","float32")};return J.runKernel(Th,t)}const wC=Z({rsqrt_:H7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q7(n){const t={x:O(n,"x","selu")};return J.runKernel(Bh,t)}const vC=Z({selu_:q7});function Y7(n,e,t,s,i,r=[1,1],o="NHWC"){const a=O(n,"x","separableConv2d"),l=O(e,"depthwiseFilter","separableConv2d"),c=O(t,"pointwiseFilter","separableConv2d");let u=a,h=!1;if(a.rank===3&&(h=!0,u=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");R(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),R(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),R(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),R(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),R(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const d=l.shape[2],p=l.shape[3];R(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);const f=Mf(u,l,s,i,o,r),m=il(f,c,1,"valid",o);return h?ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const SC=Z({separableConv2d_:Y7});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function X7(n,e){const t=O(n,"x","setdiff1d"),s=O(e,"y","setdiff1d");R(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),R(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),R(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const i=await t.data(),r=await s.data(),o=new Set(r);let a=0;for(let u=0;u<i.length;u++)o.has(i[u])||a++;const l=new Is([a],t.dtype),c=new Is([a],"int32");for(let u=0,h=0;u<i.length;u++)o.has(i[u])||(l.values[h]=i[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}const AP=X7;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j7(n){const t={x:O(n,"x","sign")};return J.runKernel(Nh,t)}const f_=Z({sign_:j7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K7(n){const t={x:O(n,"x","sin","float32")};return J.runKernel(kh,t)}const EC=Z({sin_:K7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J7(n){const t={x:O(n,"x","sinh")};return J.runKernel(Mh,t)}const _C=Z({sinh_:J7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z7(n,e,t){const s=O(n,"x","slice1d");return R(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),$t(s,[e],[t])}const Sy=Z({slice1d_:Z7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eZ(n,e,t){const s=O(n,"x","slice2d");return R(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),$t(s,e,t)}const TC=Z({slice2d_:eZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tZ(n,e,t){const s=O(n,"x","slice3d");return R(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),$t(s,e,t)}const Ey=Z({slice3d_:tZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZ(n,e,t){const s=O(n,"x","slice4d");return R(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),$t(s,e,t)}const pp=Z({slice4d_:nZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sZ(n,e=-1){const t=O(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},i={dim:e};return J.runKernel(Ef,s,i)}const _y=Z({softmax_:sZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iZ(n){R(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return J.runKernel(NA,e)}const Ty=Z({fft_:iZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rZ(n){R(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return J.runKernel($A,e)}const fp=Z({ifft_:rZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oZ(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const i=ee(n,[t,e]);s=fp(i)}else{const i=[t,2*(e-1)],r=ee(dp(n),[t,e]),o=ee(gy(n),[t,e]),a=qr($t(r,[0,1],[t,e-2]),1),l=K(qr($t(o,[0,1],[t,e-2]),1),wt(-1)),c=Jn([r,a],1),u=Jn([o,l],1),h=ee(sl(c,u),[i[0],i[1]]);s=fp(h)}if(s=dp(s),n.rank===3&&n.shape[0]!==0){const i=s,r=n.shape[0];s=ee(s,[r,s.shape[0]/r,s.shape[1]]),i.dispose()}return s}const BC=Z({irfft_:oZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aZ(n,e,t=0){const i={x:O(n,"x","split")},r={numOrSizeSplits:e,axis:t};return J.runKernel(Sf,i,r)}const Ki=Z({split_:aZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lZ(n,e){R(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let i;if(e!=null&&e<t){const f=n.shape.map(m=>0),g=n.shape.map(m=>m);g[n.shape.length-1]=e,i=$t(n,f,g),t=e}else if(e!=null&&e>t){const f=n.shape.map(g=>g);f[n.shape.length-1]=e-t,i=Jn([n,as(f)],n.shape.length-1),t=e}else i=n;const r=an(i),o=ee(sl(i,r),[s,t]),a=Ty(o),l=Math.floor(t/2)+1,c=dp(a),u=gy(a),h=Ki(c,[l,t-l],c.shape.length-1),d=Ki(u,[l,t-l],u.shape.length-1),p=i.shape.slice();return p[i.shape.length-1]=l,ee(sl(h[0],d[0]),p)}const By=Z({rfft_:lZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cZ(n,e){let t=O(n,"a","squaredDifference"),s=O(e,"b","squaredDifference");[t,s]=is(t,s),Mt(t.shape,s.shape);const i={a:t,b:s},r={};return J.runKernel($h,i,r)}const kC=Z({squaredDifference_:cZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uZ(n,e){const t=O(n,"x","squeeze","string_or_numeric");return ee(t,ul(t.shape,e).newShape)}const mn=Z({squeeze_:uZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZ(n,e=0){const t=Mg(n,"tensors","stack","string_or_numeric");R(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&R(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,i={axis:e};return J.runKernel(pf,s,i)}const $i=Z({stack_:hZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dZ(n,e=0){const s={x:O(n,"x","step")},i={alpha:e};return J.runKernel(Uh,s,i)}const Gh=Z({step_:dZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pZ(n,e,t,s,i=0,r=0,o=0,a=0,l=0){const u={x:O(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:s,beginMask:i,endMask:r,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return J.runKernel(iy,u,h)}const m_=Z({stridedSlice_:pZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fZ(n){const t={x:O(n,"x","tan","float32")};return J.runKernel(Lh,t)}const g_=Z({tan_:fZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls(n,e){Wu(n);const t=ga(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return hc(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ji(n,e,t){if(Wu(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=ga(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return hc(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_(n,e,t){if(Wu(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=ga(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return hc(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yP(n,e,t){if(Wu(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=ga(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return hc(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xP(n,e,t){if(Wu(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=ga(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return hc(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bP(n,e,t){if(Wu(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=ga(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,hc(n,e,s,t)}function y_(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,r=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(r+` update.rank < ${i}. `);if(n.length<s+(t.rank-i))throw new Error(r+` Output shape length < ${s+(t.rank-i)}`);if(t.rank!==i+n.length-s)throw new Error(r+` update.rank != ${i+n.length-s}`);for(let o=0;o<i;++o)if(t.shape[o]!==e.shape[o])throw new Error(r+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-i;++o)if(t.shape[o+i]!==n[o+s])throw new Error(r+` updates.shape[${o+i}] (${t.shape[o+i]}) != shape[${o+i}] (${n[o+i]})`)}function MC(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}y_(t,e,n)}function qo(n,e,t){const s=e.shape.length,i=s>1?e.shape[s-1]:1,r=t.length;let o=1;for(let h=i;h<r;++h)o*=t[h];const a=i<1?1:i,l=ce(e.shape)/a,c=[...vt(t.slice(0,i)),1],u=ce(t);return{sliceRank:i,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}const mZ=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:qo,validateInput:MC,validateUpdateShape:y_},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZ(n,e,t){const s=O(n,"tensor","tensorScatterupdate"),i=O(e,"indices","tensorScatterupdate","int32"),r=O(t,"updates","tensorScatterupdate");if(MC(r,i,s.shape),s.dtype!==r.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${r.dtype}.`);const o={tensor:s,indices:i,updates:r},a={};return J.runKernel(KA,o,a)}const IP=Z({tensorScatterUpdate_:gZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AZ(n,e=1,t=!0){const s=O(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const r={x:s},o={k:e,sorted:t},[a,l]=J.runKernel(oy,r,o);return{values:a,indices:l}}const x_=Z({topk_:AZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yZ(n,e=0,t=1,s,i){if(Sr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const r=new d_(e,t,s,!0,i),o=zt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=r.nextValue();return o.toTensor()}const NC=Z({truncatedNormal_:yZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZ(n,e=0){const t=O(n,"x","unique","string_or_numeric");R(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},i={axis:e},[r,o]=J.runKernel(iC,s,i);return{values:r,indices:o}}const b_=Z({unique_:xZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bZ(n,e,t){const s=O(n,"x","unsortedSegmentSum"),i=O(e,"segmentIds","unsortedSegmentSum","int32");R(Cu(t),()=>"numSegments must be of dtype int");const r={x:s,segmentIds:i},o={numSegments:t};return J.runKernel(Tf,r,o)}const RC=Z({unsortedSegmentSum_:bZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IZ(n,e=0){const t=O(n,"x","unstack","string_or_numeric");R(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},i={axis:e};return J.runKernel(_f,s,i)}const Yr=Z({unstack_:IZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CP(n,e){return yC(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_(n,e=!0,t,s){return J.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DC(n,e){const t=[];for(let r=0;r<e.length;r++)e[r]&&t.push(r);const s=zt(n,"int32"),i=zt([t.length,n.length],"int32");for(let r=0;r<t.length;r++){const o=s.indexToLoc(t[r]),a=r*n.length;i.values.set(o,a)}return i.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function CZ(n){const e=O(n,"condition","whereAsync","bool"),t=await e.data(),s=DC(e.shape,t);return n!==e&&e.dispose(),s}const C_=CZ;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function wZ(n,e,t){const s=O(n,"tensor","boolMask"),i=O(e,"mask","boolMask","bool"),r=t??0,o=i.rank,a=s.shape;R(o>0,()=>"mask cannot be scalar"),Xs(a.slice(r,r+o),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=r;g<r+o;g++)l*=a[g];const c=a.slice(0,r).concat([l],a.slice(r+o)),u=ee(s,c),h=ee(i,[-1]),d=await C_(h),p=mn(d,[1]),f=Ff(u,p,r);return n!==s&&s.dispose(),e!==i&&i.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f}const wP=wZ;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vZ(n,e,t){const s=O(n,"x","transpose");if(e==null&&(e=s.shape.map((o,a)=>a).reverse()),R(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(o=>{R(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const i={x:s},r={perm:e};return s.dtype==="complex64"?le(()=>{let o=dp(s),a=gy(s);return o=J.runKernel(Ol,{x:o},r),a=J.runKernel(Ol,{x:a},r),t&&(a=zn(a)),sl(o,a)}):J.runKernel(Ol,i,r)}const on=Z({transpose_:vZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SZ(n,e,t,s,i=!0){const r=O(n,"v","movingAverage"),o=O(e,"x","movingAverage"),a=O(t,"decay","movingAverage");y$(r,o),R(qt(r.shape,o.shape),()=>"Shape mismatch in v and x");const l=wt(1),c=nt(l,a);let u=K(nt(o,r),c);if(i){R(s!=null,()=>"When using zeroDebias: true, step is required.");const h=O(s,"step","movingAverage");u=et(u,nt(l,Aa(a,h)))}return Be(r,u)}const vP=Z({movingAverage_:SZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EZ(n,e,t){Sr(t);const s=O(n,"indices","scatterND","int32"),i=O(e,"updates","scatterND");MC(i,s,t);const r={indices:s,updates:i},o={shape:t};return J.runKernel(jA,r,o)}const SP=Z({scatterND_:EZ});function _Z(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const i=n.rank>0?n.shape[0]:1,r=n.rank>1?n.shape[1]:1;if(t.length!==r)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${r}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TZ(n,e,t,s=0){Sr(t);const i=O(n,"sparseIndices","sparseToDense","int32"),r=O(e,"sparseValues","sparseToDense","string_or_numeric"),o=O(s,"defaultValue","sparseToDense",r.dtype);_Z(i,r,t,o);const a={sparseIndices:i,sparseValues:r,defaultValue:o},l={outputShape:t};return J.runKernel(ty,a,l)}const EP=Z({sparseToDense_:TZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BZ(n,e){const t=O(e,"indices","gatherND","int32"),i={params:O(n,"x","gatherND","string_or_numeric"),indices:t};return J.runKernel(FA,i)}const _P=Z({gatherND_:BZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kZ(n,e){if(e==null)return n.shape.slice();if(qt(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MZ(n,e,t,s){const i=O(n,"x","dropout");if(R(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),R(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof nn?i.clone():i;const r=kZ(i,t),o=1-e,a=et(Df(Be(fc(r,0,1,"float32",s),o)),o);return K(i,a)}const w_=Z({dropout_:MZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v_(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function FC(n,e,t){const s=1-n%2,i=new Float32Array(n);for(let r=0;r<n;++r){const o=2*Math.PI*r/(n+s-1);i[r]=e-t*Math.cos(o)}return ls(i,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function NZ(n,e,t=1){const s=O(n,"predictions","inTopK"),i=O(e,"targets","inTopK");R(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),R(s.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${i.rank}`),Xs(s.shape.slice(0,s.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const r=s.shape[s.shape.length-1];R(t>0&&t<=r,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${r}), but got ${t}`);const o=await s.data(),a=await i.data(),[l,c]=[o.length/r,r],u=Cs("bool",l);for(let h=0;h<l;h++){const d=h*c,p=o.subarray(d,d+c),f=[];for(let g=0;g<p.length;g++)f.push({value:p[g],index:g});f.sort((g,m)=>m.value-g.value),u[h]=0;for(let g=0;g<t;g++)if(f[g].index===a[h]){u[h]=1;break}}return n!==s&&s.dispose(),e!==i&&i.dispose(),Ar(u,i.shape,"bool")}const TP=NZ;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RZ(n,e,t,s,i,r="NHWC",o){let a=n;n.rank===3&&(a=ee(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]])),R(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),R(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),R(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=r==="NHWC"?a.shape[3]:a.shape[1],u=r==="NHWC"?l.shape[3]:l.shape[1];R(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),R(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),Oi("conv2dDerFilter",i,o);const h={x:a,dy:l},d={strides:s,pad:i,dataFormat:r,dimRoundingMode:o,filterShape:t};return J.runKernel(xA,h,d)}const S_=Z({conv2DBackpropFilter_:RZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $C(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return K(n,Gh(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function PC(n,e){let t=e;const s=ws(n.shape,e.shape);return s.length>0&&(t=ft(t,s)),ee(t,n.shape)}function LC(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Ho(n);if(e==="elu")return Nf(n);if(e==="relu6")return IC(n);if(e==="prelu")return vy(n,t);if(e==="leakyrelu")return Ay(n,s);if(e==="sigmoid")return yr(n);throw new Error(`Unknown fused activation ${e}.`)}const OC=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DZ({x:n,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",OC(J.state.gradientDepth,l)===!1){R(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let w=il(n,e,t,s,i,r,o);return a!=null&&(w=Be(w,a)),LC(w,l,c,u)}const h=O(n,"x","conv2d","float32"),d=O(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=ee(h,[1,h.shape[0],h.shape[1],h.shape[2]])),R(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),R(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Oi("fused conv2d",s,o);const g=i==="NHWC"?p.shape[3]:p.shape[1];R(d.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),R(Rs(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`);const m=Qn(p.shape,d.shape,t,r,s,o);let A;a!=null&&(A=O(a,"bias","fused conv2d"),[A]=is(A,h),i==="NHWC"?Mt(m.outShape,A.shape):(R(A.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${A.shape.length}.`),R(A.shape.length===0||A.shape[0]===m.outChannels||A.shape[0]===1,()=>`Error in fused conv2d: bias shape (${A.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let y;if(c!=null){const w=c.shape;if(R(w.length<=1||w.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${w.length}.`),w.length===1)R(w[0]===1||w[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the number of output channels (${m.outChannels}).`);else if(w.length===3)try{Mt(w,m.outShape)}catch{const T=`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(T)}y=O(c,"prelu weights","fused conv2d")}const b=(w,E)=>{R(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[T,v,S,_]=E,N=$C(w,S,l);R(Kl(r),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const D=G2(v.shape,N,T,t,s),P=S_(v,N,T.shape,t,s),L=[D,P];if(_!=null){const z=PC(_,N);L.push(z)}return L},x={x:p,filter:d,bias:A,preluActivationWeights:y},C={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?ya((E,T,v)=>{let S=J.runKernel(rp,x,C);return v([T,E,S]),f&&(S=ee(S,[S.shape[1],S.shape[2],S.shape[3]])),{value:S,gradFunc:b}})(p,d):ya((E,T,v,S)=>{let _=J.runKernel(rp,x,C);return S([T,E,_,v]),f&&(_=ee(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:b}})(p,d,A)}const BP=Z({fusedConv2d_:DZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FZ(n,e,t,s,i,r=[1,1],o){let a=n;n.rank===3&&(a=ee(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:s,pad:i,dimRoundingMode:o,dilations:r,filterShape:t};return J.runKernel(EA,c,u)}const kP=Z({depthwiseConv2dNativeBackpropFilter_:FZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Z(n,e,t,s,i,r=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},u={strides:s,pad:i,dimRoundingMode:o,dilations:r,inputShape:n},h=J.runKernel(_A,c,u);return l?ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const MP=Z({depthwiseConv2dNativeBackpropInput_:$Z});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PZ({x:n,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(OC(J.state.gradientDepth,l)===!1){let C=Mf(n,e,t,s,i,r,o);return a!=null&&(C=Be(C,a)),LC(C,l,c,u)}const h=O(n,"x","depthwiseConv2d","float32"),d=O(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=ee(h,[1,h.shape[0],h.shape[1],h.shape[2]])),R(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),R(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),R(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),r==null&&(r=[1,1]),R(Rs(t,r),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),Oi("fused depthwiseConv2d",s,o);const g=Qn(p.shape,d.shape,t,r,s,o,!0);let m;a!=null&&(m=O(a,"bias","fused conv2d"),[m]=is(m,h),Mt(g.outShape,m.shape));let A;c!=null&&(A=O(c,"prelu weights","fused depthwiseConv2d"));const y=(C,w)=>{R(Kl(r),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${r}'`);const[E,T,v,S]=w,_=$C(C,v,l),N=MP(T.shape,_,E,t,s,r,o),D=kP(T,_,E.shape,t,s,r,o);if(S!=null){const P=PC(m,_);return[N,D,P]}return[N,D]},b={x:p,filter:d,bias:m,preluActivationWeights:A},x={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?ya((w,E,T)=>{let v=J.runKernel(op,b,x);return T([E,w,v]),f&&(v=ee(v,[v.shape[1],v.shape[2],v.shape[3]])),{value:v,gradFunc:y}})(p,d):ya((w,E,T,v)=>{let S=J.runKernel(op,b,x);return v([E,w,S,T]),f&&(S=ee(S,[S.shape[1],S.shape[2],S.shape[3]])),{value:S,gradFunc:y}})(p,d,m)}const LZ=Z({fusedDepthwiseConv2d_:PZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OZ({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:i,activation:r="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(OC(J.state.gradientDepth,r)===!1){let _=tn(n,e,t,s);return i!=null&&(_=Be(_,i)),LC(_,r,o,a)}let l=O(n,"a","fused matMul"),c=O(e,"b","fused matMul");[l,c]=is(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?c.shape[c.rank-1]:c.shape[c.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),g=c.shape.slice(0,-2),m=ce(f),A=ce(g);R(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const b=Mt(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,p]),x=t?ee(l,[m,u,d]):ee(l,[m,d,u]),C=s?ee(c,[A,p,h]):ee(c,[A,h,p]);let w;i!=null&&(w=O(i,"bias","fused matMul"),[w]=is(w,l),Mt(b,w.shape));let E;o!=null&&(E=O(o,"prelu weights","fused matMul"));const T=(_,N)=>{const[D,P,L,z]=N,q=$C(ee(_,L.shape),L,r);let V,X;if(!t&&!s?(V=tn(q,P,!1,!0),X=tn(D,q,!0,!1)):!t&&s?(V=tn(q,P,!1,!1),X=tn(q,D,!0,!1)):t&&!s?(V=tn(P,q,!1,!0),X=tn(D,q,!1,!1)):(V=tn(P,q,!0,!0),X=tn(q,D,!0,!0)),i!=null){const te=PC(z,q);return[V,X,te]}else return[V,X]},v={a:x,b:C,bias:w,preluActivationWeights:E},S={transposeA:t,transposeB:s,activation:r,leakyreluAlpha:a};return i==null?ya((N,D,P)=>{const L=J.runKernel(ip,v,S);return P([N,D,L]),{value:ee(L,b),gradFunc:T}})(x,C):ya((N,D,P,L)=>{const z=J.runKernel(ip,v,S);return L([N,D,z,P]),{value:ee(z,b),gradFunc:T}})(x,C,w)}const g1=Z({fusedMatMul_:OZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NP=Object.freeze(Object.defineProperty({__proto__:null,conv2d:BP,depthwiseConv2d:LZ,matMul:g1},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zZ(n){return FC(n,.54,.46)}const UZ=Z({hammingWindow_:zZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QZ(n){return FC(n,.5,.5)}const RP=Z({hannWindow_:QZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VZ(n,e,t,s=!1,i=0){let r=0;const o=[];for(;r+e<=n.size;)o.push($t(n,r,e)),r+=t;if(s)for(;r<n.size;){const a=r+e-n.size,l=Jn([$t(n,r,e-a),Qh([a],i)]);o.push(l),r+=t}return o.length===0?Ji([],[0,e]):ee(Jn(o),[o.length,e])}const DP=Z({frame_:VZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GZ(n,e,t,s,i=RP){s==null&&(s=v_(e));const r=DP(n,e,t),o=K(r,i(e));return By(o,s)}const WZ=Z({stft_:GZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HZ(n,e,t,s,i="bilinear",r=0){const o=O(n,"image","cropAndResize"),a=O(e,"boxes","cropAndResize","float32"),l=O(t,"boxInd","cropAndResize","int32"),c=a.shape[0];R(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),R(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),R(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),R(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),R(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),R(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const u={image:o,boxes:a,boxInd:l},h={method:i,extrapolationValue:r,cropSize:s};return J.runKernel(wA,u,h)}const qZ=Z({cropAndResize_:HZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YZ(n){const e=O(n,"image","flipLeftRight","float32");R(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return J.runKernel(DA,t,{})}const XZ=Z({flipLeftRight_:YZ});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jZ(n){const e=O(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];R(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),R(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,Or(e,i)}const KZ=Z({grayscaleToRGB_:jZ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JZ(n){const e=O(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];R(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),R(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const i=e.dtype,r=We(e,"float32"),o=ls([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Gc("ij,j->i",r,o);break;case 3:a=Gc("ijk,k->ij",r,o);break;case 4:a=Gc("ijkl,l->ijk",r,o);break;case 5:a=Gc("ijklm,m->ijkl",r,o);break;case 6:a=Gc("ijklmn,n->ijklm",r,o);break;default:throw new Error("Not a valid tensor rank.")}return a=rs(a,-1),We(a,i)}const ZZ=Z({rgbToGrayscale_:JZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eee(n,e,t=0,s=.5){const i=O(n,"image","rotateWithOffset","float32");R(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const r={image:i},o={radians:e,fillValue:t,center:s};return J.runKernel(ly,r,o)}const tee=Z({rotateWithOffset_:eee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pf(n,e,t,s,i,r){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),r==null&&(r=0);const o=n.shape[0];return t=Math.min(t,o),R(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),R(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),R(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),R(e.rank===1,()=>"scores must be a 1D tensor"),R(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),R(0<=r&&r<=1,()=>`softNmsSigma must be in [0, 1], but was '${r}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nee(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const r=O(n,"boxes","nonMaxSuppression","float32"),o=O(e,"scores","nonMaxSuppression","float32"),a=Pf(r,o,t,s,i);t=a.maxOutputSize,s=a.iouThreshold,i=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:i};return J.runKernel(GA,{boxes:r,scores:o},l)}const see=Z({nonMaxSuppression_:nee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iee(n,e,t){const s=ree(n,e,t),i=s<0?-(s+1):s;n.splice(i,0,e)}function ree(n,e,t){return aee(n,e,t||oee)}function oee(n,e){return n>e?1:n<e?-1:0}function aee(n,e,t){let s=0,i=n.length,r=0,o=!1;for(;s<i;){r=s+(i-s>>>1);const a=t(e,n[r]);a>0?s=r+1:(i=r,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ky(n,e,t,s,i){return E_(n,e,t,s,i,0)}function zC(n,e,t,s,i,r){return E_(n,e,t,s,i,0,!1,r,!0)}function My(n,e,t,s,i,r){return E_(n,e,t,s,i,r,!0)}function E_(n,e,t,s,i,r,o=!1,a=!1,l=!1){const c=[];for(let m=0;m<e.length;m++)e[m]>i&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(xN);const u=r>0?-.5/r:0,h=[],d=[];for(;h.length<t&&c.length>0;){const m=c.pop(),{score:A,boxIndex:y,suppressBeginIndex:b}=m;if(A<i)break;let x=!1;for(let C=h.length-1;C>=b;--C){const w=lee(n,y,h[C]);if(w>=s){x=!0;break}if(m.score=m.score*cee(s,u,w),m.score<=i)break}m.suppressBeginIndex=h.length,x||(m.score===A?(h.push(y),d.push(m.score)):m.score>i&&iee(c,m,xN))}const p=h.length,f=t-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function lee(n,e,t){const s=n.subarray(e*4,e*4+4),i=n.subarray(t*4,t*4+4),r=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),d=Math.max(i[1],i[3]),p=(a-r)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const g=Math.max(r,c),m=Math.max(o,u),A=Math.min(a,h),y=Math.min(l,d),b=Math.max(A-g,0)*Math.max(y-m,0);return b/(p+f-b)}function cee(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function xN(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function uee(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const r=O(n,"boxes","nonMaxSuppressionAsync"),o=O(e,"scores","nonMaxSuppressionAsync"),a=Pf(r,o,t,s,i);t=a.maxOutputSize,s=a.iouThreshold,i=a.scoreThreshold;const l=await Promise.all([r.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=ky(c,u,t,s,i);return r!==n&&r.dispose(),o!==e&&o.dispose(),ls(h,"int32")}const hee=uee;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dee(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const o=O(n,"boxes","nonMaxSuppression"),a=O(e,"scores","nonMaxSuppression"),l=Pf(o,a,t,s,i,r);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:r},h=J.runKernel(WA,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const pee=Z({nonMaxSuppressionWithScore_:dee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function fee(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const o=O(n,"boxes","nonMaxSuppressionAsync"),a=O(e,"scores","nonMaxSuppressionAsync"),l=Pf(o,a,t,s,i,r);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=My(u,h,t,s,i,r);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ls(d,"int32"),selectedScores:ls(p)}}const mee=fee;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gee(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const o=O(n,"boxes","nonMaxSuppression"),a=O(e,"scores","nonMaxSuppression"),l=Pf(o,a,t,s,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:o,scores:a},p={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:r},f=J.runKernel(jI,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const Aee=Z({nonMaxSuppressionPadded_:gee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function yee(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const o=O(n,"boxes","nonMaxSuppressionAsync"),a=O(e,"scores","nonMaxSuppressionAsync"),l=Pf(o,a,t,s,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:g}=zC(d,p,c,u,h,r);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ls(f,"int32"),validOutputs:wt(g,"int32")}}const xee=yee;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bee(n,e,t=!1,s=!1){const i=O(n,"images","resizeBilinear");R(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),R(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),R(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=i,o=!1;i.rank===3&&(o=!0,r=ee(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:r},l={alignCorners:t,halfPixelCenters:s,size:e},c=J.runKernel(xf,a,l);return o?ee(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const FP=Z({resizeBilinear_:bee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iee(n,e,t=!1,s=!1){const i=O(n,"images","resizeNearestNeighbor");R(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),R(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),R(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),R(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=i,o=!1;i.rank===3&&(o=!0,r=ee(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:r},l={alignCorners:t,halfPixelCenters:s,size:e},c=J.runKernel(yf,a,l);return o?ee(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const $P=Z({resizeNearestNeighbor_:Iee});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cee(n,e="binary",t=!1,s=.5){const i=O(n,"image","threshold"),r=.2989,o=.587,a=.114,l=i.shape[0]*i.shape[1];let c=K(ls([s]),255),u,h,d,p;if(R(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),R(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),R(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),R(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[u,h,d]=Ki(i,[1,1,1],-1);const m=K(u,r),A=K(h,o),y=K(d,a);p=Be(Be(m,A),y)}else p=n;if(e==="otsu"){const m=L2(We(CC(p),"int32"),Ar([]),256);c=wee(m,l)}const f=t?pc(p,c):zi(p,c);return We(K(f,255),"int32")}function wee(n,e){let t=ls([-1]),s=ls([0]),i=ls([0]),r,o,a,l,c,u;for(let h=0;h<n.size-1;h++){r=$t(n,0,h+1),o=$t(n,h+1),c=et(ft(r),e),u=et(ft(o),e);const d=ft(K(r,Bu(0,r.size)));a=et(d,ft(r));const p=Qh(o.shape,r.size),f=Be(Bu(0,o.size),p),g=K(o,f);l=et(ft(g),ft(o));const m=nt(a,l),A=nt(a,l),y=K(c,u);i=K(K(y,m),A);const b=zi(i,s);s=Qs(b,i,s),t=Qs(b,ls([h]),t)}return t}const vee=Z({threshold_:Cee});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function See(n,e,t="nearest",s="constant",i=0,r){const o=O(n,"image","transform","float32"),a=O(e,"transforms","transform","float32");R(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),R(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),R(r==null||r.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${r}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:s,fillValue:i,outputShape:r};return J.runKernel(ay,l,c)}const Eee=Z({transform_:See});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ee(n,e,t){const s=O(n,"a","bandPart");R(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const i=s.shape,[r,o]=s.shape.slice(-2);let a,l;typeof e=="number"?(R(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),R(e<=r,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${r}).`),a=O(e<0?r:e,"numLower","bandPart")):(R(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Qs(up(e,0),r,ol(e,r))),typeof t=="number"?(R(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),R(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=O(t<0?o:t,"numUpper","bandPart")):(R(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Qs(up(t,0),o,ol(t,o)));const c=ee(Bu(0,r,1,"int32"),[-1,1]),u=Bu(0,o,1,"int32"),h=nt(c,u),d=uo(pc(h,a),dl(h,zn(l))),p=as([r,o],s.dtype);return ee($i(Yr(ee(s,[-1,r,o])).map(f=>Qs(d,f,p))),i)}const Tee=Z({bandPart_:_ee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bee(n){let e;if(Array.isArray(n)){e=!1,R(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let r=1;r<n.length;++r)R(n[r].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[r].shape[0]} vs. ${i})`)}else e=!0,n=Ki(n,n.shape[0],0).map(i=>mn(i,[0]));R(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let i=0;i<n.length;++i)t.push(J.tidy(()=>{let r=s[i];if(i>0)for(let o=0;o<i;++o){const a=K(ft(K(t[o],r)),t[o]);r=nt(r,a)}return et(r,Rf(r,"euclidean"))}));return e?$i(t,0):t}const kee=Z({gramSchmidt_:Bee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mee(n,e=!1){if(R(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return bN(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=Yr(ee(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],r=[];s.forEach(l=>{const[c,u]=bN(l,e);i.push(c),r.push(u)});const o=ee($i(i,0),n.shape),a=ee($i(r,0),n.shape);return[o,a]}}function bN(n,e=!1){return J.tidy(()=>{R(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let i=fC(t),r=da(n);const o=Ji([[1]],[1,1]);let a=da(o);const l=t>=s?s:t;for(let c=0;c<l;++c){const u=r,h=a,d=i;[a,r,i]=J.tidy(()=>{const p=$t(r,[c,c],[t-c,1]),f=Rf(p),g=$t(r,[c,c],[1,1]),m=Qs(zi(g,0),Ji([[-1]]),Ji([[1]])),A=nt(g,K(m,f)),y=et(p,A);y.shape[0]===1?a=da(o):a=Jn([o,$t(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);const b=zn(et(tn(m,A),f)),x=$t(r,[c,0],[t-c,s]),C=K(b,a),w=on(a);if(c===0)r=nt(x,tn(C,tn(w,x)));else{const v=nt(x,tn(C,tn(w,x)));r=Jn([$t(r,[0,0],[c,s]),v],0)}const E=on(C),T=$t(i,[0,c],[t,i.shape[1]-c]);if(c===0)i=nt(T,tn(tn(T,a),E));else{const v=nt(T,tn(tn(T,a),E));i=Jn([$t(i,[0,0],[t,c]),v],1)}return[a,r,i]}),Et([u,h,d])}return!e&&t>s&&(i=$t(i,[0,0],[t,s]),r=$t(r,[0,0],[s,s])),[i,r]})}const Nee=Z({qr_:Mee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Mi;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Mi||(Mi={}));function Ree(n,e,t=Mi.SUM_BY_NONZERO_WEIGHTS){const s=O(n,"losses","computeWeightedLoss");let i=null;e!=null&&(i=O(e,"weights","computeWeightedLoss"));const r=i==null?s:K(s,i);if(t===Mi.NONE)return r;if(t===Mi.SUM)return ft(r);if(t===Mi.MEAN){if(i==null)return ts(r);{const o=s.size/i.size,a=et(ft(r),ft(i));return o>1?et(a,wt(o)):a}}if(t===Mi.SUM_BY_NONZERO_WEIGHTS){if(i==null)return et(ft(r),wt(s.size));{const o=K(i,Xi(s.shape)),a=We(ft(Tu(o,wt(0))),"float32");return et(ft(r),a)}}throw Error(`Unknown reduction: ${t}`)}const pl=Z({computeWeightedLoss_:Ree});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dee(n,e,t,s=Mi.SUM_BY_NONZERO_WEIGHTS){const i=O(n,"labels","absoluteDifference"),r=O(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=O(t,"weights","absoluteDifference")),Xs(i.shape,r.shape,"Error in absoluteDifference: ");const a=As(nt(i,r));return pl(a,o,s)}const Fee=Z({absoluteDifference_:Dee});function $ee(n,e,t,s,i=Mi.SUM_BY_NONZERO_WEIGHTS){const r=O(n,"labels","cosineDistance"),o=O(e,"predictions","cosineDistance");let a=null;s!=null&&(a=O(s,"weights","cosineDistance")),Xs(r.shape,o.shape,"Error in cosineDistance: ");const l=wt(1),c=nt(l,ft(K(r,o),t,!0));return pl(c,a,i)}const Pee=Z({cosineDistance_:$ee});function Lee(n,e,t,s=Mi.SUM_BY_NONZERO_WEIGHTS){let i=O(n,"labels","hingeLoss");const r=O(e,"predictions","hingeLoss");let o=null;t!=null&&(o=O(t,"weights","hingeLoss")),Xs(i.shape,r.shape,"Error in hingeLoss: ");const a=wt(1);i=nt(K(wt(2),i),a);const l=Ho(nt(a,K(i,r)));return pl(l,o,s)}const Oee=Z({hingeLoss_:Lee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zee(n,e,t,s=1,i=Mi.SUM_BY_NONZERO_WEIGHTS){const r=O(n,"labels","huberLoss"),o=O(e,"predictions","huberLoss");let a=null;t!=null&&(a=O(t,"weights","huberLoss")),Xs(r.shape,o.shape,"Error in huberLoss: ");const l=wt(s),c=As(nt(o,r)),u=ol(c,l),h=nt(c,u),d=Be(K(wt(.5),vn(u)),K(l,h));return pl(d,a,i)}const Uee=Z({huberLoss_:zee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qee(n,e,t,s=1e-7,i=Mi.SUM_BY_NONZERO_WEIGHTS){const r=O(n,"labels","logLoss"),o=O(e,"predictions","logLoss");let a=null;t!=null&&(a=O(t,"weights","logLoss")),Xs(r.shape,o.shape,"Error in logLoss: ");const l=wt(1),c=wt(s),u=zn(K(r,Ir(Be(o,c)))),h=K(nt(l,r),Ir(Be(nt(l,o),c))),d=nt(u,h);return pl(d,a,i)}const Vee=Z({logLoss_:Qee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gee(n,e,t,s=Mi.SUM_BY_NONZERO_WEIGHTS){const i=O(n,"labels","meanSquaredError"),r=O(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=O(t,"weights","meanSquaredError")),Xs(i.shape,r.shape,"Error in meanSquaredError: ");const a=kC(i,r);return pl(a,o,s)}const Wee=Z({meanSquaredError_:Gee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hee(n,e){const t=O(n,"labels","sigmoidCrossEntropyWithLogits"),s=O(e,"logits","sigmoidCrossEntropyWithLogits");Xs(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=Ho(s),r=K(s,t),o=yy(fi(zn(As(s))));return Be(nt(i,r),o)}function qee(n,e,t,s=0,i=Mi.SUM_BY_NONZERO_WEIGHTS){let r=O(n,"multiClassLabels","sigmoidCrossEntropy");const o=O(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=O(t,"weights","sigmoidCrossEntropy")),Xs(r.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=wt(s),u=wt(1),h=wt(.5);r=Be(K(r,nt(u,c)),K(h,c))}const l=Hee(r,o);return pl(l,a,i)}const Yee=Z({sigmoidCrossEntropy_:qee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xee(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return ya((i,r,o)=>{const l=xy(r,[t],!0),c=nt(We(r,"float32"),l);o([i,c]);const u=zn(K(c,i));return{value:ft(u,[t]),gradFunc:(p,f)=>{const[g,m]=f,A=us(p.shape,[t]);return[K(ee(p,A),nt(We(g,"float32"),fi(m))),K(ee(p,A),nt(fi(m),We(g,"float32")))]}}})(n,e)}function jee(n,e,t,s=0,i=Mi.SUM_BY_NONZERO_WEIGHTS){let r=O(n,"onehotLabels","softmaxCrossEntropy");const o=O(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=O(t,"weights","softmaxCrossEntropy")),Xs(r.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const c=wt(s),u=wt(1),h=wt(r.shape[1]);r=Be(K(r,nt(u,c)),et(c,h))}const l=Xee(r,o);return pl(l,a,i)}const Kee=Z({softmaxCrossEntropy_:jee});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jee(n,e,t,s){const i=O(n,"indices","sparseFillEmptyRows","int32"),r=O(e,"values","sparseFillEmptyRows"),o=O(t,"denseShape","sparseFillEmptyRows","int32"),a=O(s,"defaultValue","sparseFillEmptyRows",r.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(r.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:i,values:r,denseShape:o,defaultValue:a},c=J.runKernel(eC,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const Zee=Z({sparseFillEmptyRows_:Jee});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ete(n,e,t){const s=O(n,"inputIndices","sparseReshape","int32"),i=O(e,"inputShape","sparseReshape","int32"),r=O(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(r.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${r.shape}`);const o={inputIndices:s,inputShape:i,newShape:r},a=J.runKernel(tC,o);return{outputIndices:a[0],outputShape:a[1]}}const tte=Z({sparseReshape_:ete});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nte(n,e,t){const s=O(n,"data","sparseSegmentMean"),i=O(e,"indices","sparseSegmentMean","int32"),r=O(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(r.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${r.shape}`);const o={data:s,indices:i,segmentIds:r};return J.runKernel(ZA,o)}const ste=Z({sparseSegmentMean_:nte});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ite(n,e,t){const s=O(n,"data","sparseSegmentSum"),i=O(e,"indices","sparseSegmentSum","int32"),r=O(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(r.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${r.shape}`);const o={data:s,indices:i,segmentIds:r};return J.runKernel(ey,o)}const rte=Z({sparseSegmentSum_:ite});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ote(n,e,t,s,i,r,o,a){const l=O(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=O(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:s,leftPad:i,rightPad:r,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:c},d=J.runKernel(ry,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}const ate=Z({stringNGrams_:ote});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lte(n,e,t=!0){const s=O(n,"input","stringSplit","string"),i=O(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const r={skipEmpty:t},o={input:s,delimiter:i},a=J.runKernel(nC,o,r);return{indices:a[0],values:a[1],shape:a[2]}}const cte=Z({stringSplit_:lte});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ute(n,e){const t=O(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const i={input:t};return J.runKernel(sC,i,s)}const hte=Z({stringToHashBucketFast_:ute});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dte(n,e,t,s=!0){const i=O(n,"input","staticRegexReplace","string"),r={pattern:e,rewrite:t,replaceGlobal:s};return J.runKernel(sy,{x:i},r)}const pte=Z({staticRegexReplace_:dte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP={fft:Ty,ifft:fp,rfft:By,irfft:BC},LP={hammingWindow:UZ,hannWindow:RP,frame:DP,stft:WZ},ii={flipLeftRight:XZ,grayscaleToRGB:KZ,resizeNearestNeighbor:$P,resizeBilinear:FP,rgbToGrayscale:ZZ,rotateWithOffset:tee,cropAndResize:qZ,nonMaxSuppression:see,nonMaxSuppressionAsync:hee,nonMaxSuppressionWithScore:pee,nonMaxSuppressionWithScoreAsync:mee,nonMaxSuppressionPadded:Aee,nonMaxSuppressionPaddedAsync:xee,threshold:vee,transform:Eee},__={bandPart:Tee,gramSchmidt:kee,qr:Nee},OP={absoluteDifference:Fee,computeWeightedLoss:pl,cosineDistance:Pee,hingeLoss:Oee,huberLoss:Uee,logLoss:Vee,meanSquaredError:Wee,sigmoidCrossEntropy:Yee,softmaxCrossEntropy:Kee},zP={sparseFillEmptyRows:Zee,sparseReshape:tte,sparseSegmentMean:ste,sparseSegmentSum:rte},UP={stringNGrams:ate,stringSplit:cte,stringToHashBucketFast:hte,staticRegexReplace:pte};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fte=new Map,A1=new Map;class Wh{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Fr{constructor(){this.classNameMap={}}static getMap(){return Fr.instance==null&&(Fr.instance=new Fr),Fr.instance}static register(e){Fr.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Le(n,e,t){R(n.className!=null,()=>"Class being registered does not have the static className property defined."),R(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),R(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,i=e+">"+s;return Fr.register(n),fte.set(i,n),A1.set(n,i),n}function mte(n){return A1.has(n)?A1.get(n):n.className}const gte=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Wh,SerializationMap:Fr,getRegisteredName:mte,registerClass:Le},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fl extends Wh{minimize(e,t=!1,s){const{value:i,grads:r}=this.computeGradients(e,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:r[a.name]}));this.applyGradients(o)}else this.applyGradients(r);return Et(r),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return q$(e,t)}dispose(){this.iterations_!=null&&Et(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:wt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(fl,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T_ extends fl{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=J.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=J.registeredVariables[s],o=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:le(()=>an(r).variable(o))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:le(()=>an(r).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[s];if(a==null)return;const l=this.accumulatedGrads[i].variable,c=this.accumulatedUpdates[i].variable;le(()=>{const u=Be(K(l,this.rho),K(vn(a),1-this.rho)),h=K(et(Hs(Be(c,this.epsilon)),Hs(Be(l,this.epsilon))),a),d=Be(K(c,this.rho),K(vn(h),1-this.rho));l.assign(u),c.assign(d);const p=Be(K(h,-this.learningRate),r);r.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Et(this.accumulatedGrads.map(e=>e.variable)),Et(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B_ extends fl{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=J.registeredVariables[s];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:le(()=>Qh(r.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[i].tensor:e[s];if(o==null)return;const a=this.accumulatedGrads[i].variable;le(()=>{const l=Be(a,vn(o));a.assign(l);const c=Be(K(et(o,Hs(Be(l,J.backend.epsilon()))),-this.learningRate),r);r.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Et(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k_ extends fl{static get className(){return"Adam"}constructor(e,t,s,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],le(()=>{this.accBeta1=wt(t).variable(),this.accBeta2=wt(s).variable()}),i==null&&(this.epsilon=J.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);le(()=>{const s=nt(1,this.accBeta1),i=nt(1,this.accBeta2);t.forEach((r,o)=>{const a=J.registeredVariables[r],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${r}/m`,variable:le(()=>an(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${r}/v`,variable:le(()=>an(a).variable(l))});const c=Array.isArray(e)?e[o].tensor:e[r];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,d=Be(K(u,this.beta1),K(c,1-this.beta1)),p=Be(K(h,this.beta2),K(vn(c),1-this.beta2)),f=et(d,s),g=et(p,i);u.assign(d),h.assign(p);const m=Be(K(et(f,Be(Hs(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(K(this.accBeta1,this.beta1)),this.accBeta2.assign(K(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Et(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),le(()=>{this.accBeta1.assign(Aa(this.beta1,this.iterations_+1)),this.accBeta2.assign(Aa(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M_ extends fl{static get className(){return"Adamax"}constructor(e,t,s,i=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],le(()=>{this.iteration=wt(0).variable(),this.accBeta1=wt(t).variable()}),i==null&&(this.epsilon=J.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);le(()=>{const s=nt(1,this.accBeta1),i=et(-this.learningRate,Be(K(this.iteration,this.decay),1));t.forEach((r,o)=>{const a=J.registeredVariables[r],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${r}/m`,variable:an(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${r}/v`,variable:an(a).variable(l)});const c=Array.isArray(e)?e[o].tensor:e[r];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,d=Be(K(u,this.beta1),K(c,1-this.beta1)),p=K(h,this.beta2),f=As(c),g=Ea(p,f);u.assign(d),h.assign(g);const m=Be(K(et(i,s),et(d,Be(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(Be(this.iteration,1)),this.accBeta1.assign(K(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Et(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UC extends fl{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=Array.isArray(e)?e[i].tensor:e[s];if(r==null)return;const o=J.registeredVariables[s];le(()=>{const a=Be(K(this.c,r),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ts(wt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N_ extends UC{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=wt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=J.registeredVariables[s];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:le(()=>an(r).variable(!1))});const o=this.accumulations[i].variable,a=Array.isArray(e)?e[i].tensor:e[s];a!=null&&le(()=>{let l;const c=Be(K(this.m,o),a);this.useNesterov?l=Be(K(this.c,Be(a,K(c,this.m))),r):l=Be(K(this.c,c),r),o.assign(c),r.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Et(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R_ extends fl{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,i=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,i==null&&(this.epsilon=J.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=J.registeredVariables[s],o=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:le(()=>an(r).variable(o))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:le(()=>an(r).variable(o))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:le(()=>an(r).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[s];if(a==null)return;const l=this.accumulatedMeanSquares[i].variable,c=this.accumulatedMoments[i].variable;le(()=>{const u=Be(K(l,this.decay),K(vn(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[i].variable,d=Be(K(h,this.decay),K(a,1-this.decay)),p=et(K(a,this.learningRate),Hs(nt(u,Be(vn(d),this.epsilon)))),f=Be(K(c,this.momentum),p);l.assign(u),h.assign(d),c.assign(f);const g=nt(r,f);r.assign(g)}else{const h=Be(K(l,this.decay),K(vn(a),1-this.decay)),d=Be(K(c,this.momentum),et(K(a,this.learningRate),Hs(Be(h,this.epsilon))));l.assign(h),c.assign(d);const p=nt(r,d);r.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Et(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Et(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Et(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ate=[T_,B_,k_,M_,N_,R_,UC];function yte(){for(const n of Ate)Le(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xte="model",bte=".json",Ite=".weights.bin";function IN(n){return new Promise(e=>setTimeout(e)).then(n)}class ku{constructor(e){if(!ae().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ku.URL_SCHEME)&&(e=e.slice(ku.URL_SCHEME.length)),(e==null||e.length===0)&&(e=xte),this.modelJsonFileName=e+bte,this.weightDataFileName=e+Ite}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Go.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=_$(e,i),o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await IN(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await IN(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:dy(e)}}}}ku.URL_SCHEME="downloads://";class Cte{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=i=>{const r=JSON.parse(i.target.result),o=r.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=w2(r,c=>this.loadWeights(c));e(l)},s.onerror=i=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const o of e)t.push(...o.weights),s.push(...o.paths);const i=this.checkManifestAndWeightFiles(e),r=s.map(o=>this.loadWeightsFile(o,i[o]));return Promise.all(r).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((s,i)=>{const r=new FileReader;r.onload=o=>{const a=o.target.result;s(a)},r.onerror=o=>i(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(r=>uN(r.name)),i={};for(const r of e)r.paths.forEach(o=>{const a=uN(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),s.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);i[o]=this.weightsFiles[s.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const wte=n=>ae().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ku.URL_SCHEME)?vte(n.slice(ku.URL_SCHEME.length)):null;es.registerSaveRouter(wte);function vte(n="model"){return new ku(n)}function Ste(n){return new Cte(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CN(n,e,t,s){o(n),t=t??0,s=s??1,a(t,s);let i=0;const r=l=>(l.then(c=>{const u=t+ ++i/n.length*(s-t);return e(u),c}),l);function o(l){R(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){R(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),R(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),R(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function QP(n,e){e==null&&(e={});const t=e.fetchFunc==null?ae().platform.fetch:e.fetchFunc,s=n.map(h=>t(h,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(s):await CN(s,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(a):await CN(a,e.onProgress,.5,1)}function Ete(n,e){var t;const s=e.fetchFunc==null?ae().platform.fetch:e.fetchFunc;let i=0,r;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async o=>{for(var a;i<n.length;){r||(r=(await s(n[i],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await r.read();if(l){i++,r=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,i/n.length);continue}o.enqueue(c);return}o.close()}})}async function VP(n,e="",t,s){return GP(o=>QP(o,{requestInit:s}))(n,e,t)}function GP(n){return async(e,t="",s)=>{const i=e.map(()=>!1),r={},o=s!=null?s.map(()=>!1):[],a=[];if(e.forEach((p,f)=>{let g=0;p.weights.forEach(m=>{const A="quantization"in m?m.quantization.dtype:m.dtype,y=wu[A]*ce(m.shape),b=()=>{i[f]=!0,r[f]==null&&(r[f]=[]),r[f].push({manifestEntry:m,groupOffset:g,sizeBytes:y})};s!=null?s.forEach((x,C)=>{x===m.name&&(b(),o[C]=!0)}):b(),a.push(m.name),g+=y})}),!o.every(p=>p)){const p=s.filter((f,g)=>!o[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=i.reduce((p,f,g)=>(f&&p.push(g),p),[]),c=[];l.forEach(p=>{e[p].paths.forEach(f=>{const g=t+(t.endsWith("/")?"":"/")+f;c.push(g)})});const u=await n(c),h={};let d=0;return l.forEach(p=>{const f=e[p].paths.length,g=new Go(u.slice(d,d+f));r[p].forEach(A=>{const y=g.slice(A.groupOffset,A.groupOffset+A.sizeBytes),b=b2(y,[A.manifestEntry]);for(const x in b)h[x]=b[x]}),d+=f}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _te="application/octet-stream",Tte="application/json";class D_{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(R(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ae().platform.fetch,R(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&R(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=_$(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(i)],{type:Tte}),"model.json"),e.weightData!=null){const o=Go.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:_te}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:dy(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=t.modelTopology,i=t.weightsManifest;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return w2(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=$b(e.weightsManifest),i=()=>Ete(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:i})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=Bte(t),r=this.weightPathPrefix||s,o=[],a=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(c)):o.push(r+c+i);return this.weightUrlConverter&&o.push(...await Promise.all(a)),o}async loadWeights(e){const t=await this.getWeightUrls(e),s=$b(e),i=await QP(t,this.loadOptions);return[s,i]}}D_.URL_SCHEME_REGEX=/^https?:\/\//;function Bte(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),i=t>e?n.substring(t):"";return[s+"/",i]}function y1(n){return n.match(D_.URL_SCHEME_REGEX)!=null}const WP=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>y1(s)):t=y1(n),t)return F_(n,e)}return null};es.registerSaveRouter(WP);es.registerLoadRouter(WP);function F_(n,e){return new D_(n,e)}function HP(n,e){return F_(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zv{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class qP{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class kte{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Mte(n,e,t,s){const i=arguments;return new kte(Lb(...i))}function Lb(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Zv(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Zv({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Zv({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function Nte(n){return new qP(n)}function Rte(n){return new qP(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $_=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Go,browserFiles:Ste,browserHTTPRequest:HP,concatenateArrayBuffers:E$,copyModel:hK,decodeWeights:b2,decodeWeightsStream:S$,encodeWeights:u1,fromMemory:Mte,fromMemorySync:Lb,getLoadHandlers:B$,getModelArtifactsForJSON:w2,getModelArtifactsForJSONSync:C2,getModelArtifactsInfoForJSON:dy,getSaveHandlers:T$,getWeightSpecs:$b,http:F_,isHTTPScheme:y1,listModels:cK,loadWeights:VP,moveModel:dK,registerLoadRouter:Kj,registerSaveRouter:jj,removeModel:uK,weightsLoaderFactory:GP,withSaveHandler:Nte,withSaveHandlerSync:Rte},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dte(n,e,t){const s=O(n,"labels","confusionMatrix"),i=O(e,"predictions","confusionMatrix");R(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),R(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),R(i.rank===1,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),R(s.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),R(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const r=hp(We(s,"int32"),t),o=hp(We(i,"int32"),t),a=on(r),l=tn(a,o);return We(l,"int32")}const Fte=Z({confusionMatrix_:Dte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $te=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:Fte},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dc,wN=!1;function YP(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,i=!1,r=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)r=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Bg(_g,J.backendName)!=null){const f={pixels:n},g={numChannels:e};return J.runKernel(_g,f,g)}const[c,u]=i?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,c,u).data;else if(s||t)h=n.data;else if(r||i||a){if(Dc==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Dc=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Dc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Dc.canvas.width=c,Dc.canvas.height=u,Dc.drawImage(n,0,0,c,u),h=Dc.getImageData(0,0,c,u).data}let d;if(e===4)d=new Int32Array(h);else{const f=c*u;d=new Int32Array(f*e);for(let g=0;g<f;g++)for(let m=0;m<e;++m)d[g*e+m]=h[g*4+m]}return A_(d,[u,c,e],"int32")}function Pte(n){return n!=null&&n.data instanceof Uint8Array}function Lte(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Ote(n){return n!=null&&n.width!==0&&n.height!==0}function zte(n){return Lte()&&!(n instanceof ImageBitmap)&&Ote(n)&&!Pte(n)}async function Ute(n,e=3){let t=null;if(ae().getBool("WRAP_TO_IMAGEBITMAP")&&zte(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return YP(t,e)}function XP(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function Qte(n){const e=n?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function QC(n,e){let t=O(n,"img","toPixels");if(!(n instanceof nn)){const c=t;t=We(c,"int32"),c.dispose()}XP(t);const[s,i]=t.shape.slice(0,2),r=t.rank===2?1:t.shape[2],o=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(i*s*4);for(let c=0;c<s*i;++c){const u=[0,0,0,255];for(let d=0;d<r;d++){const p=o[c*r+d];if(t.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(t.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);r===1?(u[0]=p*a,u[1]=p*a,u[2]=p*a):u[d]=p*a}const h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(e!=null){wN||Bg(BA,J.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),wN=!0),e.width=i,e.height=s;const c=e.getContext("2d"),u=new ImageData(l,i,s);c.putImageData(u,0,0)}return t!==n&&t.dispose(),l}function Vte(n,e,t){let s=O(n,"img","draw");if(!(n instanceof nn)){const o=s;s=We(o,"int32"),o.dispose()}XP(s),Qte(t?.imageOptions);const i={image:s},r={canvas:e,options:t};J.runKernel(BA,i,r)}const VC=Z({fromPixels_:YP}),Gte=Object.freeze(Object.defineProperty({__proto__:null,draw:Vte,fromPixels:VC,fromPixelsAsync:Ute,toPixels:QC},Symbol.toStringTag,{value:"Module"}));function Ny(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(ce(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=e.shape,r=i[i.length-1];let o=1;for(let h=0;h<i.length-1;++h)o*=i[h];const a=n.shape,l=i.slice();l.pop();let c=1;for(let h=r;h<t;++h)c*=a[h],l.push(a[h]);const u=[...vt(n.shape).map(h=>h/c),1].slice(0,r);return[l,o,c,u]}const Wte=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:Ny},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x1=-2,Hte=-1;function GC(n,e,t){const s=n.shape.length;R(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),R(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let i=0;i<s;++i)R(e[i]+t[i]<=n.shape[i],()=>`Error in slice${s}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function qte(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function WC(n,e,t){const s=[];for(let i=0;i<n.length;i++)s[i]=Math.ceil((e[i]-n[i])/t[i]);return s}function jP(n,e,t,s){const i=[...n];for(let r=i.length;r<s.length;r++)i.push(1);for(let r=0;r<t;r++)r===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function KP(n,e,t){return t<=n?t:t-(e-1)}function JP(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function Yte(n,e,t,s,i,r,o,a,l){const c=n.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&t>0){const p=e[0],f=t+1;u=ZP(o,p,f,s,n),h=eL(a,p,f,i,n),d=jP(r,p,f,n)}else for(let p=0;p<c;p++)u[p]=nL(o,s,r,n,p,l),h[p]=sL(a,i,r,n,p,l),d[p]=tL(r,p,l);return{begin:u,end:h,strides:d}}function ZP(n,e,t,s,i){const r=[...i],o=JP(t,e);for(let a=0;a<r.length;a++)if(o.indexOf(a)>-1)r[a]=0;else{const l=KP(e,t,a);let c=s[l];n&1<<l&&(c=0),r[a]=c}return r}function eL(n,e,t,s,i){const r=[...i],o=JP(t,e);for(let a=0;a<r.length;a++)if(o.indexOf(a)>-1)r[a]=Number.MAX_SAFE_INTEGER;else{const l=KP(e,t,a);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),r[a]=c}for(let a=0;a<r.length;a++){const l=i[a];r[a]<0&&(r[a]+=l),r[a]=Hl(0,r[a],i[a])}return r}function tL(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function nL(n,e,t,s,i,r){let o=e[i];const a=t[i]||1;(n&1<<i||r&1<<i||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[i];return o<0&&(o+=l),o=Hl(0,o,l-1),o}function sL(n,e,t,s,i,r){let o=e[i];const a=t[i]||1;(n&1<<i||r&1<<i||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[i];return o<0&&(o+=l),a>0?o=Hl(0,o,l):o=Hl(-1,o,l-1),o}function P_(n,e,t){let s=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){s=i;break}for(let i=s+1;i<t.length;i++)if(e[i]>0||t[i]!==n[i])return!1;return!0}function L_(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function Ry(n,e,t){let s;const i=n.shape.length;typeof e=="number"?s=[e,...new Array(i-1).fill(0)]:e.length<i?s=e.concat(new Array(i-e.length).fill(0)):s=e.slice(),s.forEach(o=>{R(o!==-1,()=>"slice() does not support negative begin indexing.")});let r;return t==null?r=new Array(i).fill(-1):typeof t=="number"?r=[t,...new Array(i-1).fill(-1)]:t.length<i?r=t.concat(new Array(i-t.length).fill(-1)):r=t,r=r.map((o,a)=>o>=0?o:(R(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,r]}function HC(n,e,t,s,i,r,o,a,l){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:i,endMask:r,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let b=0;b<h.dims;b++)u&&(1<<b&a)!==0&&h.numAddAxisAfterEllipsis++,1<<b&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Xte(h,d);let p=!0,f=!0,g=!0;const m=[],A=[];for(let b=0;b<n.length;++b){if(d.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const x=!!(d.shrinkAxisMask&1<<b),C=n[b];if(C===-1){m.push(x?1:-1);continue}const w=[d.beginMask&1<<b,d.endMask&1<<b],E=[d.strides[b]>0?0:-1,d.strides[b]>0?C:C-1];if(x&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&d.strides[b]===1;const T=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(x){const N=d.begin[b]<0?C+d.begin[b]:d.begin[b];if(d.begin[b]=N,d.end[b]=d.begin[b]+1,N<0||N>=C)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=vN(d.begin[b],0,d.strides[b],C,w,E),d.end[b]=vN(d.end[b],1,d.strides[b],C,w,E);const _=d.strides[b]===1&&d.begin[b]===0&&d.end[b]===C;p=p&&_,f=f&&(b===0&&d.strides[b]===1||_)}else p=p&&d.strides[b]===1&&T,f=f&&(b===0&&d.strides[b]===1||T);let v,S=!1;if(d.beginValid&&d.endValid?(v=d.end[b]-d.begin[b],S=!0):x?(v=1,S=!0):T&&C>=0&&(d.strides[b]<0?v=-C:v=C,S=!0),S){let _;v===0||v<0!=d.strides[b]<0?_=0:_=Math.trunc(v/d.strides[b])+(v%d.strides[b]!==0?1:0),m.push(_)}else m.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const x=d.finalShapeGatherIndices[b];x>=0?A.push(m[x]):x===x1&&A.push(1)}return{finalShapeSparse:A.filter((b,x)=>d.finalShapeGatherIndices[x]!==x1),finalShape:A,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function Xte(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const i=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(x1),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(Hte),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function vN(n,e,t,s,i,r){if(i[e])return t>0?r[e]:r[e+1&1];{const o=n<0?s+n:n;return o<r[0]?r[0]:o>r[1]?r[1]:o}}const iL=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:GC,computeFlatOffset:L_,computeOutShape:WC,getNormalizedAxes:Yte,isSliceContinous:P_,maskToAxes:qte,parseSliceParams:Ry,sliceInfo:HC,startForAxis:nL,startIndicesWithElidedDims:ZP,stopForAxis:sL,stopIndicesWithElidedDims:eL,stridesForAxis:tL,stridesWithElidedDims:jP},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const rL="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oL{static sgd(e){return new UC(e)}static momentum(e,t,s=!1){return new N_(e,t,s)}static rmsprop(e,t=.9,s=0,i=null,r=!1){return new R_(e,t,s,i,r)}static adam(e=.001,t=.9,s=.999,i=null){return new k_(e,t,s,i)}static adadelta(e=.001,t=.95,s=null){return new T_(e,t,s)}static adamax(e=.002,t=.9,s=.999,i=null,r=0){return new M_(e,t,s,i,r)}static adagrad(e,t=.1){return new B_(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oc=oL;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jte=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function O_(){return new Promise(n=>jte(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qC(n,e){const t=n[0].length;n.forEach((i,r)=>{R(i.length===t,()=>`Error in concat${t}D: rank of tensors[${r}] must be the same as the rank of the rest (${t})`)}),R(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((i,r)=>{for(let o=0;o<t;o++)R(o===e||i[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${r}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function Zi(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var So;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(So||(So={}));function aL(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let i=1;i<t.length;++i){const r=t[i],o=s[s.length-t.length+i],a=s[o];if(r>=0)if(a>=0){if(a!==r)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+n}] = ${r} but shape[${i+n}] = ${a}`)}else s[o]=r}return s}function lL(n){const e={FIRST_DIM_SIZE:So.FIRST_DIM_SIZE,VALUE_ROWIDS:So.VALUE_ROWIDS,ROW_LENGTHS:So.ROW_LENGTHS,ROW_SPLITS:So.ROW_SPLITS,ROW_LIMITS:So.ROW_LIMITS,ROW_STARTS:So.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function cL(n){return n.length===0?0:n[0]===So.FIRST_DIM_SIZE?n.length-1:n.length}function uL(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let i=0;i<Math.min(t,s-1);++i){const r=n[i],o=e[i+1];if(r>=0&&o>=0&&r!==1&&r!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-n.length}] = ${r} but ragged tensor input.flatValues.shape[${i-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z_=30;function YC(n){return n<=z_?n:Db(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XC(n,e,t){const s=t*(typeof n=="number"?n:n[0]),i=e*(typeof n=="number"?n:n[1]);return[s,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hh(n,e,t,s=!0){let i=[];if(s)i=i.concat(e.slice(0)),i.push(n[0]/t),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const r=e.length;for(let o=0;o<r;++o)i=i.concat([n[o+1]/e[o],e[o]]);i=i.concat(n.slice(r+1))}return i}function qh(n,e,t=!0){const s=[];if(t){s.push(e);for(let i=e+1;i<n;++i)i<=2*e?(s.push(i),s.push(i-(e+1))):s.push(i)}else{const i=[],r=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?r.push(o):i.push(o);s.push(...i),s.push(0),s.push(...r)}return s}function Yh(n,e,t,s=!0){const i=[];s?i.push(n[0]/t):i.push(n[0]*t);for(let r=1;r<n.length;++r)r<=e.length?s?i.push(e[r-1]*n[r]):i.push(n[r]/e[r-1]):i.push(n[r]);return i}function jC(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function KC(n,e,t){const s=n.slice(0,1);for(let i=0;i<t;++i)s.push(n[i+1]-e[i][0]-e[i][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dy=1.7580993408473768,Fy=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JC=.3275911,ZC=.254829592,ew=-.284496736,tw=1.421413741,nw=-1.453152027,sw=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $o(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function hL(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function dL(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=0;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function pL(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=2;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function U_(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function fL(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function mL(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const r=(e?2:-2)*Math.PI*(i/n);t[i]=Math.cos(r),s[i]=Math.sin(r)}return{real:t,imag:s}}function gL(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),i=Math.cos(s),r=Math.sin(s);return{real:i,imag:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eS="->",Kte=/->/g,SN=",",EN="...";function iw(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(Kte,"").length)/eS.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${eS}").`);const[s,i]=n.split(eS);R(s.indexOf(EN)===-1,()=>`The ellipsis notation ("${EN}") is not supported yet.`);const r=s.split(SN),o=r.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<i.length;++d){const p=i[d];if(!r.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let d=0;d<s.length;++d){const p=s[d];a.indexOf(p)===-1&&p!==SN&&a.push(p)}const l=new Array(r.length);for(let d=0;d<o;++d){if(new Set(r[d].split("")).size!==r[d].length)throw new Error(`Found duplicate axes in input component ${r[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<r[d].length;++p)l[d].push(a.indexOf(r[d][p]))}const c=a.length,u=i.length,h=[];for(let d=u;d<c;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function rw(n,e){let t=new Array(n);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const s=[];for(let i=0;i<n;++i)t[i]===-1&&s.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:s}}function ow(n,e,t){const s=new Array(n);for(let i=0;i<t.length;++i){const r=t[i].shape;for(let o=0;o<e[i].length;++o)s[e[i][o]]===void 0?s[e[i][o]]=r[o]:R(s[e[i][o]]===r[o],()=>`Expected dimension ${s[e[i][o]]} at axis ${o} of input shaped ${JSON.stringify(r)}, but got dimension ${r[o]}`)}}function aw(n,e){const t=n,s=[];let i=0;n.length===0&&t.push(-1),i=n.length+1;for(let o=0;o<i;++o)s.push([]);const r=[];for(let o=0;o<t.length;++o){const a=t[o],l=Jte(e,a);for(const c of l)r.indexOf(c)===-1&&(s[o].push(c),r.push(c))}return{path:t,steps:s}}function lw(n){return n.every((e,t)=>e===t)}function Jte(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function cw(n,e,t=0){let s=[];if(typeof e=="number")R(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const i=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);R(i<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(r!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[r]=n.shape[t]-o}R(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AL(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function yL(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function xL(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bL(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function IL(n,e){return`size ${n} must be non-negative, not ${e}`}function CL(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function wL(n,e){const t=ce(n),s=ce(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function vL(n,e){const t=ce(n),s=ce(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b1(){return"segment ids must be >= 0"}function SL(){return"segment ids are not increasing"}function EL(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function _L(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TL(n,e){let t=!1,s;for(n<=z_?(s=n,t=!0):s=Db(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=Db(n,s+1);return s}function Q_(n,e,t){const s=[],i=n.length;for(let r=0;r<i;r++)r!==e?s.push(n[r]):s.push(t);return s}function uw(n,e,t,s){const i=e.shape.length,r=n.shape.length;if(s!==0&&(s<-i||s>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);if(s<0&&(s+=i),s>r)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${r}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let h=0;h<s;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,c=1,u=1;for(let h=0;h<s;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=s;h<t;h++)a.push(n.shape[h]),c*=n.shape[h];for(let h=s;h<i;h++)a.push(e.shape[h]);for(let h=t+1;h<r;h++)a.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}const Zte=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:uw,computeOutShape:Q_,segOpComputeOptimalWindowSize:TL},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Po(n){try{return n.map(e=>lo(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function BL(n){return n.map(e=>Ro(e))}const kL=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:ZC,ERF_A2:ew,ERF_A3:tw,ERF_A4:nw,ERF_A5:sw,ERF_P:JC,PARALLELIZE_THRESHOLD:z_,get RowPartitionType(){return So},SELU_SCALE:Fy,SELU_SCALEALPHA:Dy,applyActivation:LC,assertAndGetBroadcastShape:Mt,assertAxesAreInnerMostDims:vs,assertParamsConsistent:qC,assignToTypedArray:fL,axesAreInnerMostDims:K2,calculateShapes:qo,checkEinsumDimSizes:ow,checkPadOnDimRoundingMode:Oi,combineLocations:G$,combineRaggedTensorToTensorShapes:aL,complexWithEvenIndex:dL,complexWithOddIndex:pL,computeConv2DInfo:Qn,computeConv3DInfo:Wo,computeDefaultPad:R2,computeDilation2DInfo:dc,computeOptimalWindowSize:YC,computeOutAndReduceShapes:ps,computeOutShape:Zi,computePool2DInfo:mi,computePool3DInfo:Xr,convertConv2DDataFormat:Er,decodeEinsumEquation:iw,eitherStridesOrDilationsAreOne:Rs,expandShapeToKeepDim:us,exponent:gL,exponents:mL,fromStringArrayToUint8:BL,fromUint8ToStringArray:Po,getAxesPermutation:Nn,getBroadcastDims:rl,getComplexWithIndex:U_,getEinsumComputePath:aw,getEinsumPermutation:rw,getFusedBiasGradient:PC,getFusedDyActivation:$C,getImageCenter:XC,getInnerMostAxes:Vn,getPermuted:qh,getRaggedRank:cL,getReductionAxes:ws,getReshaped:Hh,getReshapedPermuted:Yh,getRowPartitionTypesHelper:lL,getSliceBeginCoords:jC,getSliceSize:KC,getSparseFillEmptyRowsIndicesDenseShapeMismatch:AL,getSparseFillEmptyRowsNegativeIndexErrorMessage:yL,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:xL,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:CL,getSparseReshapeInputOutputMismatchErrorMessage:vL,getSparseReshapeInputOutputMultipleErrorMessage:wL,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:bL,getSparseReshapeNegativeOutputDimErrorMessage:IL,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:_L,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:b1,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:SL,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:EL,getUndoAxesPermutation:Sa,isIdentityPermutation:lw,log:KX,mergeRealAndImagArrays:$o,prepareAndValidate:Ny,prepareSplitSize:cw,segment_util:Zte,shouldFuse:OC,slice_util:iL,splitRealAndImagArrays:hL,stridesOrDilationsArePositive:_u,tupleValuesAreOne:Kl,upcastType:Ns,validateDefaultValueShape:uL,validateInput:MC,validateUpdateShape:y_,warn:Dr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ene=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:ky,nonMaxSuppressionV4Impl:zC,nonMaxSuppressionV5Impl:My,whereImpl:DC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */yte();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ML={kernelName:Tp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,Gh(We(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tne={kernelName:qu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=vn(We(t,"float32")),i=Hs(nt(wt(1),s));return zn(et(n,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nne={kernelName:Yu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Hs(nt(vn(We(t,"float32")),1));return et(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sne={kernelName:cc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{let a=n;const l=ws(t.shape,i);return l.length>0&&(a=ft(a,l)),ee(a,t.shape)},b:()=>{let a=n;const l=ws(s.shape,i);return l.length>0&&(a=ft(a,l)),ee(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ine={kernelName:Bp,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,i)=>{t[i]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rne={kernelName:kp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const one={kernelName:Mp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ane={kernelName:Xu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>et(n,Hs(nt(wt(1),vn(We(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lne={kernelName:ju,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Hs(Be(wt(1),vn(We(t,"float32"))));return et(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cne={kernelName:Zu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=Be(vn(t),vn(s));let l=K(n,et(s,a));const c=ws(t.shape,i);return c.length>0&&(l=ft(l,c)),ee(l,t.shape)},b:()=>{const a=Be(vn(t),vn(s));let l=zn(K(n,et(t,a)));const c=ws(s.shape,i);return c.length>0&&(l=ft(l,c)),ee(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const une={kernelName:Ku,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>et(n,Be(vn(We(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hne={kernelName:Ju,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>et(n,nt(wt(1),vn(We(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dne(n,e,t,s,i,r){const o=O(n,"dy","avgPool3dGrad"),a=O(e,"input","avgPool3dGrad");let l=o,c=a,u=!1;a.rank===4&&(u=!0,l=ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=ee(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),R(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),R(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Oi("avgPool3dGrad",i,r);const h={dy:l,input:c},d={filterSize:t,strides:s,pad:i,dimRoundingMode:r},p=J.runKernel(fA,h,d);return u?ee(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const pne=Z({avgPool3dGrad_:dne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fne={kernelName:Rp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:r,pad:o,dimRoundingMode:a}=t;return{x:()=>pne(n,s,i,r,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mne(n,e,t,s,i){const r=O(n,"dy","avgPoolGrad"),o=O(e,"input","avgPoolGrad");R(o.rank===r.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${r.rank})`);let a=o,l=r,c=!1;o.rank===3&&(c=!0,a=ee(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ee(r,[1,r.shape[0],r.shape[1],r.shape[2]])),R(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),R(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const u={dy:l,input:a},h={filterSize:t,strides:s,pad:i},d=J.runKernel(pA,u,h);return c?ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const gne=Z({avgPoolGrad_:mne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ane={kernelName:Np,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:r,pad:o}=t;return{x:()=>gne(n,s,i,r,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yne={kernelName:Dp,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,i]=e,{transposeA:r,transposeB:o}=t;return!r&&!o?{a:()=>tn(n,i,!1,!0),b:()=>tn(s,n,!0,!1)}:!r&&o?{a:()=>tn(n,i,!1,!1),b:()=>tn(n,s,!0,!1)}:r&&!o?{a:()=>tn(i,n,!1,!0),b:()=>tn(s,n,!1,!1)}:{a:()=>tn(i,n,!0,!0),b:()=>tn(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xne={kernelName:Fp,gradFunc:(n,e,t)=>{const{blockShape:s,crops:i}=t;return{x:()=>wy(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bne={kernelName:r$,gradFunc:(n,e,t)=>{const s=t,i=s.inputShape,r=s.shape,o=Array.from(r);for(let l=i.length-1;l>=0;l--)if(i[l]===r[l])o[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${r}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>ft(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ine={kernelName:eh,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cne={kernelName:th,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wne={kernelName:nh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:i,clipValueMax:r}=t;return{x:()=>Qs(uo(dl(s,i),pc(s,r)),n,an(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vne={kernelName:$p,inputsToSave:["x"],gradFunc:ML.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sne={kernelName:Pp,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:i}=t,r=Vt(i,e[0].shape)[0],o=s.map(l=>l[r]);return Ki(n,o,r).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ene={kernelName:Lp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{dilations:r,strides:o,pad:a,dataFormat:l}=t;return R(Kl(r),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`),{x:()=>G2(s.shape,n,i,o,a,l),filter:()=>S_(s,n,i.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ne={kernelName:Op,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{strides:r,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>il(n,i,r,o,a,1,l),filter:()=>S_(n,s,i.shape,r,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tne(n,e,t,s,i){let r=n;n.rank===4&&(r=ee(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=ee(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),R(r.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`),R(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),R(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),R(r.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${t[3]}.`),R(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:r,dy:o},l={strides:s,pad:i,filterShape:t};return J.runKernel(bA,a,l)}const Bne=Z({conv3DBackpropFilter_:Tne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kne={kernelName:zp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:r}=t;R(Kl(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=e;return{x:()=>U$(o.shape,n,a,i,r),filter:()=>Bne(o,n,a.shape,i,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mne={kernelName:sh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(zn(EC(We(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nne={kernelName:ih,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(_C(We(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rne={kernelName:Up,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i,exclusive:r,reverse:o}=t;return{x:()=>{const a=Nn([i],s.rank);let l=dC(n,i,r,!o);return a!=null&&(l=on(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dne={kernelName:Qp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:r,dimRoundingMode:o}=t,a=s??[1,1];R(Kl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;return R(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),R(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),R(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),R(Rs(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),Oi("depthwiseConv2d",r,o),{x:()=>MP(l.shape,n,c,i,r,a,o),filter:()=>kP(l,n,c.shape,i,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fne={kernelName:Vp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,r={x:s,filter:i,dy:n},o={x:s,filter:i,dy:n};return{x:()=>J.runKernel(Sg,r,t),filter:()=>J.runKernel(Eg,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ne={kernelName:oh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>J.runKernel(MA,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pne={kernelName:ah,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=K(fi(zn(vn(t))),2/Math.sqrt(Math.PI));return{x:()=>K(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lne={kernelName:lh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const One={kernelName:Wp,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ee(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zne={kernelName:ch,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,fi(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Une={kernelName:uh,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qne={kernelName:hh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=et(n,We(s,"float32")),l=ws(t.shape,i);return l.length>0?ee(ft(a,l),t.shape):a},b:()=>{let a=K(n,We(t,"float32"));const l=ws(s.shape,i);l.length>0&&(a=ee(ft(a,l),s.shape));const c=vn(s);return zn(et(a,We(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vne={kernelName:Hp,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[i,r,o,a]=e,l=a??wt(1),c=ws(r.shape,i.shape),u=[];if(r.rank===1){for(let x=0;x<i.shape.length-1;++x)u.push(i.shape[x]);u.push(1)}const h=nt(i,r),d=K(n,l),p=wC(Be(o,wt(s))),f=K(K(K(p,p),p),wt(-.5));return{x:()=>r.rank===1?ee(K(K(n,Or(ee(p,[1,1,1,r.shape[0]]),u)),l),i.shape):ee(K(K(n,p),l),i.shape),mean:()=>{let x=K(K(p,wt(-1)),d);return r.rank===1&&(x=ft(x,c)),ee(x,r.shape)},variance:()=>{let x=K(K(f,h),d);return r.rank===1&&(x=ft(x,c)),ee(x,r.shape)},scale:()=>{const x=K(h,p);let C=K(n,x);return r.rank===1&&(C=ft(C,c)),ee(C,r.shape)},offset:()=>{let x=n;return r.rank===1&&(x=ft(x,c)),ee(x,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gne={kernelName:qp,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,i]=e,{axis:r,batchDims:o}=t,a=Vt(r,s.shape)[0],l=(c,u,h)=>()=>{const d=c.shape,p=u.size,f=d.slice(0,a),g=f.length,m=d.slice(r,d.length).slice(1),A=m.length,y=_N(0,g),b=_N(g+1,g+1+A),x=TN([f,[p],m]),C=ee(h,x),w=ee(u,[p]),E=TN([[g],y,b]),T=on(C,E);let v=RC(T,w,c.shape[a]);const S=Sa(E);return v=on(v,S),v};if(o===1){const c=s.shape[0],u=s.split(c,0);return{x:()=>$i(u.map((p,f)=>l(p,i.slice(f,1),n.slice(f,1))())).reshape(s.shape),indices:()=>i}}else return{x:l(s,i,n),indices:()=>i}}};function _N(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function TN(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wne={kernelName:dh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>an(t),b:()=>an(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hne={kernelName:ph,gradFunc:n=>({x:()=>We(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qne={kernelName:fh,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yne={kernelName:mh,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xne={kernelName:gh,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jne={kernelName:Xp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:i}=t,r=zi(s,0);return{x:()=>Qs(r,n,K(n,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kne={kernelName:yh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>et(n,Be(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jne={kernelName:Ah,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>et(n,We(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zne={kernelName:o$,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;return{logits:()=>{const o=fi(s);return nt(n,K(ft(n,i,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ese(n,e,t,s=5,i=1,r=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:s,bias:i,alpha:r,beta:o};return J.runKernel(OA,a,l)}const tse=Z({localResponseNormalizationBackprop_:ese});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nse={kernelName:tf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{depthRadius:r,bias:o,alpha:a,beta:l}=t;return{x:()=>tse(s,i,n,r,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NL(n,e,t,s){return e.rank<t.rank&&(e=ee(e,us(e.shape,s))),n.rank<t.rank&&(n=ee(n,us(n.shape,s))),{x:()=>K(n,We(br(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BN={kernelName:nf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:i}=s,r=e[0],o=e[1],a=Vt(i,r.shape),l=NL(n,o,r,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sse={kernelName:xh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>K(n,We(dl(t,s),"float32")),b:()=>K(n,We(up(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ise(n,e,t,s,i,r,o){const a=O(n,"dy","maxPool3dGrad"),l=O(e,"input","maxPool3dGrad"),c=O(t,"output","maxPool3dGrad");let u=a,h=l,d=c,p=!1;l.rank===4&&(p=!0,u=ee(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=ee(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=ee(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),R(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),R(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),R(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),Oi("maxPool3dGrad",r,o);const f={dy:u,input:h,output:d},g={filterSize:s,strides:i,pad:r,dimRoundingMode:o},m=J.runKernel(UA,f,g);return p?ee(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const rse=Z({maxPool3dGrad_:ise});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ose={kernelName:rf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>rse(n,s,i,r,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ase(n,e,t,s,i,r,o){const a=O(n,"dy","maxPoolGrad"),l=O(e,"input","maxPoolGrad"),c=O(t,"output","maxPoolGrad");R(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),R(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),R(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Oi("maxPoolGrad",r,o);const u={dy:a,input:l,output:c},h={filterSize:s,strides:i,pad:r,dimRoundingMode:o};return J.runKernel(zA,u,h)}const lse=Z({maxPoolGrad_:ase});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cse={kernelName:sf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:r,strides:o,pad:a}=t;return{x:()=>lse(n,s,i,r,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const use={kernelName:of,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t,r=Vt(i,s.shape),a=ps(s.shape,r)[1],l=ce(a);return{x:()=>{const u=s.shape.slice();r.forEach(p=>{u[p]=1});const h=ee(n,u);return et(K(h,Xi(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hse={kernelName:af,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:i}=s,[r,o]=e,a=Vt(i,r.shape),l=NL(n,o,r,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dse={kernelName:bh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>K(n,We(pc(t,s),"float32")),b:()=>K(n,We(zi(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pse={kernelName:lf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,r=i.map(o=>o[0]);return{x:()=>$t(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fse={kernelName:Ih,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=ws(t.shape,i);return a.length>0?ee(ft(n,a),t.shape):n},b:()=>{const a=K(n,zn(Df(et(t,s)))),l=ws(s.shape,i);return l.length>0?ee(ft(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mse={kernelName:Ch,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=K(n,We(s,"float32")),l=ws(t.shape,i);return l.length>0?ee(ft(a,l),t.shape):a},b:()=>{const a=K(n,We(t,"float32")),l=ws(s.shape,i);return l.length>0?ee(ft(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gse={kernelName:cf,gradFunc:n=>({x:()=>zn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ase={kernelName:df,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>as(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yse={kernelName:hf,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xse={kernelName:pf,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Yr(n,s).map(r=>()=>r)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kN={kernelName:ff,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,r=i.map(o=>o[0]);return{x:()=>$t(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bse={kernelName:wh,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,i]=e,r=t,o=s,a=Mt(r.shape,o.shape);return{a:()=>{const u=We(o,"float32");let h=K(n,K(u,Aa(r,nt(u,wt(1)))));const d=ws(r.shape,a);return d.length>0&&(h=ft(h,d)),ee(h,r.shape)},b:()=>{const u=zi(r,0),h=Qs(u,Ir(r),an(r));let d=K(n,K(i,h));const p=ws(o.shape,a);return p.length>0&&(d=ft(d,p)),ee(d,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ise={kernelName:mf,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,i=zi(t,0);return{x:()=>Qs(i,n,K(n,s)),alpha:()=>{let r=Qs(i,an(n),K(n,t));const o=ws(s.shape,n.shape);return o.length>0&&(r=ft(r,o)),ee(r,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cse(n,e,t){const s=n.shape.slice();s[t]=1;const i=ee(e,s),r=Fg(n,t,!0,!1),o=Fg(n,t,!0,!0),a=K(r,o);return K(i,a)}function wse(n,e,t){const s=n.shape.length,i=s-t.length,r=Nn(t,s);let o=n;r!=null&&(o=on(n,r));const a=o.shape.slice(),c=a.splice(s-t.length,t.length).reduce((d,p)=>d*p,1);a.push(c);const u=o.reshape(a);let h=Cse(u,e,i);if(h=h.reshape(o.shape),r!=null){const d=Sa(r);h=on(h,d)}return h}const vse={kernelName:gf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;let r=[];return i==null?r=s.shape.map((o,a)=>a):typeof i=="number"?r=[i]:r=i,{x:()=>wse(s,n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sse={kernelName:rh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=et(n,We(s,"float32")),l=ws(t.shape,i);return l.length>0?ee(ft(a,l),t.shape):a},b:()=>{let a=K(n,We(t,"float32"));const l=ws(s.shape,i);l.length>0&&(a=ee(ft(a,l),s.shape));const c=vn(s);return zn(et(a,We(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ese={kernelName:vh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>et(n,zn(vn(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _se={kernelName:Eh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=K(pc(t,6),Gh(t));return{x:()=>K(n,We(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tse={kernelName:Sh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,We(Gh(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bse={kernelName:Af,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ee(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kse={kernelName:xf,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>J.runKernel(XA,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mse={kernelName:yf,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>J.runKernel(YA,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nse={kernelName:bf,gradFunc:(n,e,t)=>{const{dims:s}=t,i=Vt(s,n.shape);return{x:()=>qr(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rse={kernelName:_h,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dse={kernelName:Th,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>zn(et(n,K(Aa(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fse={kernelName:If,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>We(an(t),"float32"),t:()=>K(n,We(t,n.dtype)),e:()=>K(n,We(by(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $se={kernelName:Bh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=zi(t,wt(0)),i=wt(Dy),r=wt(Fy),o=K(n,r),a=K(K(n,i),fi(We(t,"float32")));return Qs(s,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pse={kernelName:Rh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,K(t,nt(wt(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lse={kernelName:Nh,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ose={kernelName:kh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(my(We(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zse={kernelName:Mh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(hC(We(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Use={kernelName:Cf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:i,size:r}=t,o=s.shape,[a,l]=Ry(s,i,r),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>ho(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qse={kernelName:Ef,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:i}=t,r=!0,o=K(n,s);return{logits:()=>nt(o,K(ft(o,[i],r),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vse={kernelName:Dh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,yr(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MN={kernelName:vf,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:i}=t;return{x:()=>fy(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NN={kernelName:Sf,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>Jn(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gse={kernelName:Fh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>et(n,K(Hs(We(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wse={kernelName:ny,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,K(We(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hse={kernelName:$h,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=wt(2);return{a:()=>K(n,K(i,nt(t,s))),b:()=>K(n,K(i,nt(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qse={kernelName:Uh,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yse={kernelName:Ph,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{let a=n;const l=ws(t.shape,i);return l.length>0&&(a=ft(a,l)),ee(a,t.shape)},b:()=>{let a=n;const l=ws(s.shape,i);return l.length>0&&(a=ft(a,l)),ee(zn(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xse={kernelName:wf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,i=s.shape.slice(),{axis:r}=t;Vt(r,s.shape).forEach(c=>{i[c]=1});const a=ee(n,i),l=K(a,Xi(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jse={kernelName:Lh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>et(n,vn(my(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kse={kernelName:Oh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(nt(wt(1),vn(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jse={kernelName:zh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:i}=t;return{x:()=>{let o=an(s);if(s.rank===1)for(let a=0;a<i[0];++a)o=Be(o,$t(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)o=Be(o,$t(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)o=Be(o,$t(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)for(let u=0;u<i[3];++u)o=Be(o,$t(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2],u*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zse={kernelName:Ol,gradFunc:(n,e,t)=>{const s=t,{perm:i}=s,r=Sa(i);return{x:()=>on(n,r)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eie={kernelName:_f,gradFunc:(n,e,t)=>{const s=t,{axis:i}=s;return{value:()=>$i(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tie={kernelName:Tf,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nie(n,t)}}};function nie(n,e){const t=Ea(e,an(e)),s=Ff(n,t);let i=dl(e,wt(0,"int32"));const r=s.rank-i.rank;for(let a=0;a<r;++a)i=rs(i,a+1);i=uo(i,Xi(s.shape,"bool"));const o=an(s);return Qs(i,s,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sie={kernelName:Bf,gradFunc:n=>({x:()=>an(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iie=[ML,tne,nne,sne,ine,rne,one,ane,lne,cne,une,hne,fne,Ane,yne,xne,bne,Ine,Cne,wne,vne,Sne,_ne,Ene,kne,Mne,Nne,Rne,Dne,Fne,Sse,$ne,Pne,Lne,One,zne,Qne,Une,Vne,Gne,Wne,Hne,qne,Yne,Xne,jne,Kne,Jne,Zne,nse,BN,BN,sse,ose,cse,use,hse,dse,pse,fse,mse,gse,Ase,yse,xse,kN,kN,bse,Ise,vse,Ese,_se,Tse,Bse,kse,Mse,Nse,Rse,Dse,Fse,$se,Pse,Lse,Ose,zse,Use,Qse,Vse,MN,MN,NN,NN,Gse,Hse,Wse,qse,Yse,Xse,jse,Kse,Jse,Zse,eie,tie,sie];for(const n of iie)a$(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.abs=function(){return this.throwIfDisposed(),As(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.acos=function(){return this.throwIfDisposed(),S2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.acosh=function(){return this.throwIfDisposed(),E2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.add=function(n){return this.throwIfDisposed(),Be(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.all=function(n,e){return this.throwIfDisposed(),lC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.any=function(n,e){return this.throwIfDisposed(),Ng(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.argMax=function(n){return this.throwIfDisposed(),jl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.argMin=function(n){return this.throwIfDisposed(),_2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.asScalar=function(){return this.throwIfDisposed(),R(this.size===1,()=>"The array must have only 1 element."),ee(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.asType=function(n){return this.throwIfDisposed(),We(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as1D=function(){return this.throwIfDisposed(),ee(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as2D=function(n,e){return this.throwIfDisposed(),ee(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),ee(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),ee(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as5D=function(n,e,t,s,i){return this.throwIfDisposed(),ee(this,[n,e,t,s,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.asin=function(){return this.throwIfDisposed(),T2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.asinh=function(){return this.throwIfDisposed(),B2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.atan=function(){return this.throwIfDisposed(),k2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.atan2=function(n){return this.throwIfDisposed(),M2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.atanh=function(){return this.throwIfDisposed(),N2(this)};Se().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),py(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),fy(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.batchNorm=function(n,e,t,s,i){return this.throwIfDisposed(),kf(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.broadcastTo=function(n){return this.throwIfDisposed(),pu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cast=function(n){return this.throwIfDisposed(),We(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.ceil=function(){return this.throwIfDisposed(),O2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Fi(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof nn&&(n=[n]),Jn([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.conv1d=function(n,e,t,s,i,r){return this.throwIfDisposed(),cC(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.conv2dTranspose=function(n,e,t,s,i){return this.throwIfDisposed(),uC(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.conv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),il(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cos=function(){return this.throwIfDisposed(),my(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cosh=function(){return this.throwIfDisposed(),hC(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),Fg(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),dC(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),q2(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.depthwiseConv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),Mf(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.dilation2d=function(n,e,t,s,i){return this.throwIfDisposed(),Y2(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.divNoNan=function(n){return this.throwIfDisposed(),X2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.div=function(n){return this.throwIfDisposed(),et(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.dot=function(n){return this.throwIfDisposed(),j2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.elu=function(){return this.throwIfDisposed(),Nf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.equal=function(n){return this.throwIfDisposed(),br(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.erf=function(){return this.throwIfDisposed(),pC(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),J2(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.exp=function(){return this.throwIfDisposed(),fi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.expandDims=function(n){return this.throwIfDisposed(),rs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.expm1=function(){return this.throwIfDisposed(),Z2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.fft=function(){return this.throwIfDisposed(),Ty(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.flatten=function(){return this.throwIfDisposed(),ee(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.floor=function(){return this.throwIfDisposed(),Df(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.floorDiv=function(n){return this.throwIfDisposed(),aC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.gather=function(n,e,t){return this.throwIfDisposed(),Ff(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.greaterEqual=function(n){return this.throwIfDisposed(),dl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.greater=function(n){return this.throwIfDisposed(),zi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.ifft=function(){return this.throwIfDisposed(),fp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.irfft=function(){return this.throwIfDisposed(),BC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.isFinite=function(){return this.throwIfDisposed(),e_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.isInf=function(){return this.throwIfDisposed(),t_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.isNaN=function(){return this.throwIfDisposed(),n_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Ay(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.lessEqual=function(n){return this.throwIfDisposed(),pc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.less=function(n){return this.throwIfDisposed(),up(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),s_(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logSigmoid=function(){return this.throwIfDisposed(),i_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logSoftmax=function(n){return this.throwIfDisposed(),gC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),xy(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.log=function(){return this.throwIfDisposed(),Ir(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.log1p=function(){return this.throwIfDisposed(),yy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logicalAnd=function(n){return this.throwIfDisposed(),uo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logicalNot=function(){return this.throwIfDisposed(),by(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logicalOr=function(n){return this.throwIfDisposed(),AC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logicalXor=function(n){return this.throwIfDisposed(),r_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),tn(this,n,e,t)};Se().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),Iy(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.max=function(n,e){return this.throwIfDisposed(),Gr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.maximum=function(n){return this.throwIfDisposed(),Ea(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.mean=function(n,e){return this.throwIfDisposed(),ts(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.min=function(n,e){return this.throwIfDisposed(),cp(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.minimum=function(n){return this.throwIfDisposed(),ol(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),xC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.mod=function(n){return this.throwIfDisposed(),a_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.mul=function(n){return this.throwIfDisposed(),K(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.neg=function(){return this.throwIfDisposed(),zn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Rf(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.notEqual=function(n){return this.throwIfDisposed(),Tu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),hp(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.onesLike=function(){return this.throwIfDisposed(),Cr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.pad=function(n,e){return this.throwIfDisposed(),ho(this,n,e)};Se().prototype.pool=function(n,e,t,s,i,r){return this.throwIfDisposed(),l_(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.pow=function(n){return this.throwIfDisposed(),Aa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.prelu=function(n){return this.throwIfDisposed(),vy(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.prod=function(n,e){return this.throwIfDisposed(),c_(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.reciprocal=function(){return this.throwIfDisposed(),p_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.relu=function(){return this.throwIfDisposed(),Ho(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.relu6=function(){return this.throwIfDisposed(),IC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.reshapeAs=function(n){return this.throwIfDisposed(),ee(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.reshape=function(n){return this.throwIfDisposed(),ee(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),FP(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),$P(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.reverse=function(n){return this.throwIfDisposed(),qr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.rfft=function(){return this.throwIfDisposed(),By(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.round=function(){return this.throwIfDisposed(),CC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.rsqrt=function(){return this.throwIfDisposed(),wC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.selu=function(){return this.throwIfDisposed(),vC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.separableConv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),SC(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sigmoid=function(){return this.throwIfDisposed(),yr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sign=function(){return this.throwIfDisposed(),f_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sin=function(){return this.throwIfDisposed(),EC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sinh=function(){return this.throwIfDisposed(),_C(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.slice=function(n,e){return this.throwIfDisposed(),$t(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.softmax=function(n){return this.throwIfDisposed(),_y(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.softplus=function(){return this.throwIfDisposed(),Vh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),wy(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.split=function(n,e){return this.throwIfDisposed(),Ki(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sqrt=function(){return this.throwIfDisposed(),Hs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.square=function(){return this.throwIfDisposed(),vn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.squaredDifference=function(n){return this.throwIfDisposed(),kC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.squeeze=function(n){return this.throwIfDisposed(),mn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof nn?[this,n]:[this,...n];return $i(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.step=function(n){return this.throwIfDisposed(),Gh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.stridedSlice=function(n,e,t,s,i,r,o,a){return this.throwIfDisposed(),m_(this,n,e,t,s,i,r,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sub=function(n){return this.throwIfDisposed(),nt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sum=function(n,e){return this.throwIfDisposed(),ft(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.tan=function(){return this.throwIfDisposed(),g_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.tanh=function(){return this.throwIfDisposed(),Jl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.tile=function(n){return this.throwIfDisposed(),Or(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.toBool=function(){return this.throwIfDisposed(),We(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.toFloat=function(){return this.throwIfDisposed(),We(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.toInt=function(){return this.throwIfDisposed(),We(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.topk=function(n,e){return this.throwIfDisposed(),x_(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.transpose=function(n){return this.throwIfDisposed(),on(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.unique=function(n){return this.throwIfDisposed(),b_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),RC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.unstack=function(n){return this.throwIfDisposed(),Yr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.where=function(n,e){return this.throwIfDisposed(),Qs(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.zerosLike=function(){return this.throwIfDisposed(),an(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ia extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ia.prototype)}}class oo extends Error{constructor(e){super(e),Object.setPrototypeOf(this,oo.prototype)}}class ne extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ne.prototype)}}class jt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,jt.prototype)}}class V_ extends Error{constructor(e){super(e),Object.setPrototypeOf(this,V_.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class RL{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Mu(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function ra(n,e){if(!n)throw new V_(e)}function RN(n,e){let t=0;for(const s of n)s===e&&t++;return t}function qi(n){return n.length===1?n[0]:n}function wn(n){return Array.isArray(n)?n:[n]}function Oa(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Wc(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let to={};function G_(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function I1(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>I1(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:I1(s))}}}function $y(n,e={},t={},s="object",i=!1){if(typeof n=="string"){const r=n;let o;if(r in t)o=t[r];else if(r in to)o=to[r];else if(o=e[r],o==null)throw new ne(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const r=n;if(r.className==null||r.config==null)throw new ne(`${s}: Improper config format: ${JSON.stringify(r)}.
'className' and 'config' must set.`);const o=r.className;let a,l;if(o in t?[a,l]=t[o]:o in to?[a,l]=to.className:o in e&&([a,l]=e[o]),a==null)throw new ne(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const p of Object.keys(to))c[p]=to[p];for(const p of Object.keys(t))c[p]=t[p];const u=r.config;u.customObjects=c;const h=Object.assign({},to);for(const p of Object.keys(t))to[p]=t[p];I1(r.config);const d=l(a,r.config,t,i);return to=Object.assign({},h),d}else{const c=Object.assign({},to);for(const h of Object.keys(t))to[h]=t[h];const u=new a(r.config);return to=Object.assign({},c),u}}}function rie(n,e){return n<e?-1:n>e?1:0}function e0(n,e){return-1*rie(n,e)}function Ul(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function oie(n){if(n==null)throw new ne(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Xh(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new ne(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function W_(n,e,t=0,s=1/0){return ra(t>=0),ra(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(i=>typeof i===e)}function zs(n,e){Array.isArray(n)?(R(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>zs(t,`element ${s+1} of ${e}`))):R(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${DL(n)}.`)}function DL(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>DL(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function aie(n,e,t){let s=t!=null?t():Zs(),i;return(...o)=>{const a=t!=null?t():Zs();return a-s<e||(s=a,i=n(...o)),i}}function FL(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let lie=0;function $L(){return lie++}const t0={};function hw(n=""){return n in t0||(t0[n]=0),t0[n]+=1,n+t0[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const cie=["channelsFirst","channelsLast"],uie=["nearest","bilinear"],hie=["valid","same","causal"],die=["max","avg"],pie=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Td=new Map;function fs(n){Xh(cie,"DataFormat",n)}function fie(n){Xh(uie,"InterpolationFormat",n)}function jr(n){Xh(hie,"PaddingMode",n)}function PL(n){Xh(die,"PoolMode",n)}const eg=[],DN="/";function fu(n,e){eg.push(n);try{const t=e();return eg.pop(),t}catch(t){throw eg.pop(),t}}function mie(){return eg.length===0?"":eg.join(DN)+DN}function LL(n){if(!zL(n))throw new Error("Not a valid tensor name: '"+n+"'");return mie()+n}function OL(n){if(!zL(n))throw new Error("Not a valid tensor name: '"+n+"'");Td.has(n)||Td.set(n,0);const e=Td.get(n);if(Td.set(n,Td.get(n)+1),e>0){const t=`${n}_${e}`;return Td.set(t,1),t}else return n}const gie=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function zL(n){return!!n.match(gie)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Aie(n){return n===parseInt(n.toString(),10)}function Ql(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let i=e;i<t;++i)s*=n[i];return s}function mp(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Zl(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function Lo(n,e){if(e<n)throw new ne(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let tS;function Bs(){return tS==null&&(tS=Yl().epsilon()),tS}function Oo(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pa(n,e){return We(n,e)}function Py(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ee(n,t)}function yie(n,e){return le(()=>{if(n.shape.length!==2)throw new ne(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Py(n,1);return C1(t,[1,e,1])})}function xie(n){const e=[Ql(n.shape)];return ee(n,e)}function bie(n){if(n.rank<=1)throw new ne(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Ql(n.shape,1)];return ee(n,e)}function mu(n,e,t){return le(()=>{switch(n.rank){case 1:return Sy(n,e,t);case 2:return TC(n,[e,0],[t,n.shape[1]]);case 3:return Ey(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return pp(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return $t(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return $t(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new ne(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function nS(n,e,t){return le(()=>{switch(n.rank){case 1:return Sy(n,e,t);case 2:return TC(n,[0,e],[n.shape[0],t]);case 3:return Ey(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return pp(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new ne(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function n0(n,e,t,s){return le(()=>{switch(n.rank){case 1:return Sy(n,e,t);case 2:switch(s){case 1:return mu(n,e,t);case 2:return nS(n,e,t);default:throw new ne(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return mu(n,e,t);case 2:return Ey(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return nS(n,e,t);default:throw new ne(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return mu(n,e,t);case 2:return pp(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return pp(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return nS(n,e,t);default:throw new ne(`The axis is not within the rank of the tensor ${s}`)}default:throw new ne(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function H_(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),Jn(n,e)}function FN(n,e){switch(n.rank){case 1:return z2([n,e]);case 2:return U2([n,e],0);case 3:return Q2([n,e],0);case 4:return V2([n,e],0);default:throw new ne(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function C1(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new ne(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return Or(n,e)}function dw(n,e=0,t=1,s,i){return bC(n,e,t,s,i)}function fa(n,e,t,s){if(n.rank<2||e.rank<2)throw new jt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const i=n.shape.slice(-1)[0],r=e.shape.slice(-2)[0];if(i!==r)throw new jt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return g1({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?w1(n.rank,s,Oo()):null,activation:t});{const i=n.shape.slice(),r=i.pop();n=ee(n,[-1,r]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:e.rank},(f,g)=>g===0?e.rank-2:g<=e.rank-2?g-1:g);e=ee(on(e,u),[l,-1]);const h=[...i,...c];return ee(g1({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?w1(n.rank,s,Oo()):null,activation:t}),h)}}function UL(n,e,t){return le(()=>(Array.isArray(e)?e=ls(e,"int32"):e=We(e,"int32"),Ff(n,e,t)))}function Ly(n){return K(n,n)}function w1(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new ne(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?ee(e,[1,s[0],1,1,1]):ee(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?ee(e,[1,1,1,1,s[0]]):ee(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?ee(e,[1,s[0],1,1]):ee(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?ee(e,[1,1,1,s[0]]):ee(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?ee(e,[1,s[0],1]):ee(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?ee(e,[1,1,s[0]]):ee(e,[1].concat(s))}else if(n<3)return e;throw new ne(`Unsupported input rank by biasAdd: ${e.rank}`)}function Yo(n,e,t){return le(()=>(t==null&&(t=Oo()),fs(t),Be(n,w1(n.rank,e,t))))}function Iie(n,e=1){if(e!==1)throw new jt(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Nf(n)}function Cie(n){return le(()=>et(n,Be(As(n),1)))}function QL(n,e,t,s){return le(()=>w_(n,e,t,s))}function wie(n){return le(()=>{const e=Be(.5,K(.2,n));return Fi(e,0,1)})}function Oy(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const vie=["fanIn","fanOut","fanAvg"],Sie=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Eie(n){Xh(vie,"FanMode",n)}function _ie(n){Xh(Sie,"Distribution",n)}class fo extends Wh{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class q_ extends fo{apply(e,t){return as(e,t)}}q_.className="Zeros";Le(q_);class pw extends fo{apply(e,t){return Xi(e,t)}}pw.className="Ones";Le(pw);class Y_ extends fo{constructor(e){if(super(),typeof e!="object")throw new ne(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ne(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return le(()=>K(wt(this.value),Xi(e,t)))}getConfig(){return{value:this.value}}}Y_.className="Constant";Le(Y_);class X_ extends fo{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return fc(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}X_.className="RandomUniform";Le(X_);class j_ extends fo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new jt(`randomNormal does not support dType ${t}.`);return dw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}j_.className="RandomNormal";Le(j_);class K_ extends fo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new jt(`truncatedNormal does not support dType ${t}.`);return NC(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}K_.className="TruncatedNormal";Le(K_);class J_ extends fo{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return le(()=>{if(e.length!==2||e[0]!==e[1])throw new ne("Identity matrix initializer can only be used for 2D square matrices.");return K(this.gain,fC(e[0]))})}getConfig(){return{gain:this.gain}}}J_.className="Identity";Le(J_);function Tie(n,e="channelsLast"){let t,s;if(fs(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const i=Ql(n,2);t=n[1]*i,s=n[0]*i}else if(e==="channelsLast"){const i=Ql(n,0,n.length-2);t=n[n.length-2]*i,s=n[n.length-1]*i}}else{const i=Ql(n);t=Math.sqrt(i),s=Math.sqrt(i)}return[t,s]}class nr extends fo{constructor(e){if(super(),e.scale<0)throw new ne(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Eie(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,_ie(this.distribution),this.seed=e.seed}apply(e,t){const s=Tie(e),i=s[0],r=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,i):this.mode==="fanOut"?o/=Math.max(1,r):o/=Math.max(1,(i+r)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new jt(`${this.getClassName()} does not support dType ${t}.`);return NC(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return fc(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}nr.className="VarianceScaling";Le(nr);class fw extends nr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return nr.className}}fw.className="GlorotUniform";Le(fw);class mw extends nr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return nr.className}}mw.className="GlorotNormal";Le(mw);class gw extends nr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return nr.className}}gw.className="HeNormal";Le(gw);class Aw extends nr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return nr.className}}Aw.className="HeUniform";Le(Aw);class yw extends nr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return nr.className}}yw.className="LeCunNormal";Le(yw);class xw extends nr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return nr.className}}xw.className="LeCunUniform";Le(xw);class Z_ extends fo{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return le(()=>{if(e.length<2)throw new jt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=ce(e.slice(0,-1)),i=e[e.length-1],r=s*i;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);const o=[Math.max(i,s),Math.min(i,s)],a=dw(o,0,1,t,this.seed),l=__.qr(a,!1);let c=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(i,s)*Math.min(i,s)],[Math.min(i,s)+1]);return c=K(c,h.sign()),s<i&&(c=c.transpose()),K(wt(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Z_.className="Orthogonal";Le(Z_);const $N={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function PN(n,e={}){return $y(n,Fr.getMap().classNameMap,e,"initializer")}function ss(n){return G_(n)}function Kn(n){if(typeof n=="string"){const e=n in $N?$N[n]:n;if(e==="GlorotNormal")return new mw;if(e==="GlorotUniform")return new fw;if(e==="HeNormal")return new gw;if(e==="HeUniform")return new Aw;if(e==="LeCunNormal")return new yw;if(e==="LeCunUniform")return new xw;{const t={};return t.className=e,t.config={},PN(t)}}else return n instanceof fo?n:PN(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function v1(n){return Array.isArray(n)&&Array.isArray(n[0])}function Ob(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Lt(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new ne(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function An(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new ne(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zb(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,i)=>s*i);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const LN="Variable";class VL{constructor(e,t="float32",s=LN,i=!0,r=null){this.dtype=t??"float32",this.shape=e.shape,this.id=$L(),s=s??LN,this.originalName=LL(s),this.name=OL(this.originalName),this.trainable_=i,this.constraint=r,this.val=I_(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Bie(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Bie(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function S1(n){return n.map(e=>e.read())}function eT(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xs{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class zo{constructor(e,t,s,i,r,o,a){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=i,this.callArgs=r,this.outputTensorIndex=a,this.id=$L(),o!=null&&(this.originalName=LL(o),this.name=OL(this.originalName)),this.rank=t.length}}let kie=0;class bw{constructor(e,t){this.callArgs=t,this.id=kie++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Mie=0;class sn extends Wh{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Mie++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=Oa(s)+"_"+hw(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),s=[r].concat(e.inputShape)}this.batchInputShape=s;let i=e.dtype;i==null&&(i=e.inputDType),i==null&&(i="float32"),this.dtype=i}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new oo(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ne(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return qi(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return qi(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ia(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ia(`Layer ${this.name} is not connected, no input to return.`);return qi(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ia(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ia(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return qi(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=wn(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=wn(this.inputSpec);if(t.length!==s.length)throw new ne(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let i=0;i<t.length;i++){const r=t[i],o=s[i];if(o==null)continue;const a=r.rank;if(o.ndim!=null&&a!==o.ndim)throw new ne(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new ne(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new ne(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&r.dtype!==o.dtype)throw new ne(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${r.dtype}.`);if(o.axes){const l=r.shape;for(const c in o.axes){const u=Number(c),h=o.axes[c],d=u>=0?l[u]:l[l.length+u];if(h!=null&&[h,null].indexOf(d)===-1)throw new ne(`Input ${i} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${h} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const c=o.shape[l],u=r.shape[l];if(c!=null&&u!=null&&c!==u)throw new ne(`Input ${i} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=wn(e),i=Die(e),r=Fie(e);if(i===r)throw new ne("Arguments to apply() must be all SymbolicTensors or all Tensors");return fu(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of wn(e))o.push(a.shape);this.build(qi(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=wn(o),l=[];for(let c of a)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=qi(l),this.activityRegularizer!=null)throw new jt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=Nie(e),a=this.computeOutputShape(o);let l;const c=Rie(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((u,h)=>new zo(c,u,this,wn(e),t,this.name,h)):l=new zo(c,a,this,wn(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new jt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,i)=>{s!=null&&e[i]!=null&&e[i]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ia(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new ia(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new oo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zb(this.weights)}build(e){this.built=!0}getWeights(e=!1){return S1(e?this.trainableWeights:this.weights)}setWeights(e){le(()=>{const t=this.weights;if(t.length!==e.length)throw new ne(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],i=S1(t);for(let r=0;r<i.length;++r){const o=i[r],a=t[r],l=e[r];if(!qt(o.shape,l.shape))throw new ne(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}eT(s)})}addWeight(e,t,s,i,r,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new ne(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(i=l!=null?l():Kn("zeros"));const c=i.apply(t,s),u=new VL(c,s,e,o,a);return c.dispose(),r!=null&&this.addLoss(()=>r.apply(u.read())),o==null&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=wn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const i=this.computeMask(e,s),r=wn(t),o=wn(i);if(r.length!==o.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let a=0;a<r.length;a++)r[a].kerasMask=o[a]}addInboundNode(e,t,s,i,r,o,a=null){const l=wn(e);t=wn(t),s=wn(s),i=wn(i),r=Ob(r),o=Ob(o);const c=[],u=[],h=[];for(const d of l)c.push(d.sourceLayer),u.push(d.nodeIndex),h.push(d.tensorIndex);new bw({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:i,inputShapes:r,outputShapes:o},a);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Nie(n){n=wn(n);const e=[];for(const t of n)e.push(t.shape);return qi(e)}function Rie(n){return"float32"}function GL(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const i=[];for(let r=0;r<s.inboundLayers.length;r++){const o=s.inputTensors[r],a=s.inboundLayers[r],l=s.nodeIndices[r],c=GL(o,a,l);for(const u of c)i.indexOf(u)===-1&&i.push(u)}return i}}}function Die(n){let e=!0;for(const t of wn(n))if(!(t instanceof zo)){e=!1;break}return e}function Fie(n){let e=!0;for(const t of wn(n))if(t instanceof zo){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Lf extends sn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:hw("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ne("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new ne("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ne("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const i=new zo(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new bw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ne(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Lf.className="InputLayer";Le(Lf);function WL(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new ne("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new Lf({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $ie(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return We(e,n.dtype)}catch{throw new ne(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Fl{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Fl)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=$ie(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new ne(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof zo){if(this.id2Value[e.id]==null)throw new ne(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ne(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof zo){if(this.id2Value[e.id]==null)throw new ne(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ne(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Et(this.id2Mask)}}const Ub=new RL,Qb=new RL;function Pie(n){Ub?.setMaxEntries(n),Qb?.setMaxEntries(n)}function Dm(n,e,t,s){const i=t==null?!1:t.training,r=Array.isArray(n),o=r?n:[n],a=o.map(f=>f.name),l=[],c=e.names();for(const f of a)c.indexOf(f)!==-1?l.push(e.getValue(f)):l.push(null);const u=a.join(",")+"|"+e.names().sort().join(",");let h=Ub.get(u),d;if(h==null){const f=Lie(o,e);h=f.sorted,d=f.recipientCounts,Ub.put(u,h),Qb.put(u,d)}d={},i||Object.assign(d,Qb.get(u));const p=new Fl(e);for(let f=0;f<h.length;++f){const g=h[f],m=g.sourceLayer;if(m instanceof Lf)continue;const A=[],y=[],b=[];let x=!1;for(const v of g.inputs){const S=p.getValue(v),_=p.getMask(v);A.push(S),y.push(_),_!=null&&(x=!0),i||(d[v.name]--,d[v.name]===0&&!e.hasKey(v)&&a.indexOf(v.name)===-1&&!S.isDisposed&&v.sourceLayer.stateful!==!0&&b.push(S))}x&&(t=t||{},t.mask=y[0]);const C=wn(m.apply(A,t));let w=null;m.supportsMasking&&(w=m.computeMask(A,y));const E=zie(g),T=Array.isArray(E)?E:[E];for(let v=0;v<T.length;++v){p.hasKey(T[v])||p.add(T[v],C[v],Array.isArray(w)?w[0]:w);const S=a.indexOf(T[v].name);S!==-1&&(l[S]=C[v])}i||Et(b)}return p.disposeMasks(),r?l:l[0]}function Lie(n,e){R(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const i=ON(n[0],e);t=i.sorted,s=i.recipientMap}else{const i=new Set;for(const r of n){const{sorted:o,recipientMap:a}=ON(r,e);for(const l of o)i.has(l.name)||(t.push(l),i.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(c=>s[l].add(c))}}return{sorted:t,recipientCounts:Oie(s)}}function Oie(n){const e={};for(const t in n)e[t]=n[t].size;return e}function ON(n,e){const t=new Set,s=[],i={};for(const a of e.names())t.add(a);const r=[],o=[];for(r.push(n);r.length>0;){const a=r[r.length-1];if(t.has(a.name)){r.pop();continue}const l=o[o.length-1]===r.length-1;if(a.inputs.length===0||l)r.pop(),s.push(a),t.add(a.name),l&&o.pop();else{o.push(r.length-1);for(const c of a.inputs)i[c.name]==null&&(i[c.name]=new Set),i[c.name].add(a.name),!t.has(c.name)&&r.push(c)}}return{sorted:s,recipientMap:i}}function zie(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const i of n.sourceLayer.inboundNodes[s].outputTensors)if(i.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uie=ae();Uie.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Pie);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tT(n,e){return le(()=>Hs(ft(K(n,n),e,!0)))}class zy extends Wh{getConfig(){return{}}}class nT extends zy{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return le(()=>{const t=tT(e,this.axis),s=Fi(t,0,this.maxValue);return K(e,et(s,Be(Bs(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}nT.className="MaxNorm";Le(nT);class sT extends zy{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return le(()=>et(e,Be(Bs(),tT(e,this.axis))))}getConfig(){return{axis:this.axis}}}sT.className="UnitNorm";Le(sT);class iT extends zy{apply(e){return Ho(e)}}iT.className="NonNeg";Le(iT);class rT extends zy{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return le(()=>{const t=tT(e,this.axis),s=Be(K(this.rate,Fi(t,this.minValue,this.maxValue)),K(1-this.rate,t));return K(e,et(s,Be(Bs(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}rT.className="MinMaxNorm";Le(rT);const zN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ks(n){return G_(n)}function UN(n,e={}){return $y(n,Fr.getMap().classNameMap,e,"constraint")}function Ms(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in zN?zN[n]:n,config:{}};return UN(t)}else return n instanceof zy?n:UN(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qie(n){return new nT(n)}function Vie(n){return new sT(n)}function Gie(){return new iT}function Wie(n){return new rT(n)}const Hie=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:Qie,minMaxNorm:Wie,nonNeg:Gie,unitNorm:Vie},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qie(){return new q_}function Yie(){return new pw}function Xie(n){return new Y_(n)}function jie(n){return new X_(n)}function Kie(n){return new j_(n)}function Jie(n){return new K_(n)}function Zie(n){return new J_(n)}function ere(n){return new nr(n)}function tre(n){return new fw(n)}function nre(n){return new mw(n)}function sre(n){return new gw(n)}function ire(n){return new Aw(n)}function rre(n){return new yw(n)}function ore(n){return new xw(n)}function are(n){return new Z_(n)}const lre=Object.freeze(Object.defineProperty({__proto__:null,constant:Xie,glorotNormal:nre,glorotUniform:tre,heNormal:sre,heUniform:ire,identity:Zie,leCunNormal:rre,leCunUniform:ore,ones:Yie,orthogonal:are,randomNormal:Kie,randomUniform:jie,truncatedNormal:Jie,varianceScaling:ere,zeros:qie},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Tl(n){if(n==null)return;const e=[],t=[],s=[];for(const i in n){const r=n[i];if(typeof r!="number"){const o=r;e.push(o.data()),t.push(i),s.push(o)}}if(e.length>0){const i=await Promise.all(e);for(let r=0;r<i.length;++r)n[t[r]]=i[r][0];Et(s)}}function HL(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var QN;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(QN||(QN={}));const cre=125;class gp{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class qL{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class ure extends gp{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const i in t){const r=t[i];if(typeof r=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+r*s;else{let o;i in this.totals?o=this.totals[i]:this.totals[i]=0;const a=le(()=>Be(this.totals[i],K(r,s)));this.totals[i]=a,o?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:le(()=>{const i=K(et(1,this.seen),this.totals[s]);t[s]=i,this.totals[s].dispose(),Ts(t[s])}))}}class YL extends gp{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const r in this.history){const o=this.history[r];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(r),s.push(a)}}const i=await Promise.all(e);for(let r=0;r<i.length;++r)this.history[t[r]][s[r]].dispose(),this.history[t[r]][s[r]]=i[r][0]}}class XL extends gp{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||O_,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=cre),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Rb(this.yieldEvery)&&(this.maybeWait=aie(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const i=[];this.yield!=null&&(await Tl(s),i.push(this.yield(e,t,s))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Tl(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await Tl(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Tl(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await Tl(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Rb(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Tl(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Tl(e),await this.trainEnd(e))}}function jL(n,e){return n==null&&(n={}),n instanceof gp?[n]:Array.isArray(n)&&n[0]instanceof gp?n:wn(n).map(s=>new XL(s,e))}class Rr{constructor(){}static registerCallbackConstructor(e,t){R(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Rr.checkForDuplicate(t),Rr.constructors[e]==null&&(Rr.constructors[e]=[]),Rr.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Rr.constructors)Rr.constructors[+t].forEach(i=>{if(i===e)throw new ne("Duplicate callback constructor.")})}static clear(){Rr.constructors={}}static createCallbacks(e){const t=[];for(const s in Rr.constructors){const i=+s;e>=i&&t.push(...Rr.constructors[i])}return t.map(s=>new s)}}Rr.constructors={};function KL(n,e,t,s,i,r,o,a,l){const c=new YL,u=[new ure,...Rr.createCallbacks(e)];n!=null&&u.push(...n),u.push(c);const h=new qL(u);return h.setParams({epochs:t,initialEpoch:s,samples:i,steps:r,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Do(n,e={},t=!1){return $y(n,Fr.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vb(n,e){return le(()=>{n.dtype!=="float32"&&(n=We(n,"float32"));const t=ft(Ly(n),e,!0),s=Qh(t.shape,Bs()),i=Hs(Ea(t,s));return et(n,i)})}function jh(n,e){return le(()=>ts(Ly(nt(e,n)),-1))}function Iw(n,e){return le(()=>ts(As(nt(e,n)),-1))}function Of(n,e){return le(()=>{const t=nt(n,e),s=Fi(As(n),Bs(),Number.MAX_VALUE),i=As(et(t,s));return K(100,ts(i,-1))})}function hre(n,e){return le(()=>{const t=Fi(e,Bs(),Number.MAX_VALUE),s=Ir(Be(1,t)),i=Fi(n,Bs(),Number.MAX_VALUE),r=Ir(Be(1,i));return ts(Ly(nt(s,r)),-1)})}function dre(n,e){return le(()=>{const t=Ea(0,nt(1,K(n,e)));return ts(Ly(t),-1)})}function pre(n,e){return le(()=>{const t=Ea(0,nt(1,K(n,e)));return ts(t,-1)})}function fre(n,e){return le(()=>{const t=ft(K(n,e),-1),s=Gr(K(nt(1,n),e),-1);return Ea(0,Be(1,nt(s,t)))})}function mre(n,e){return le(()=>{const t=Math.log(2),s=nt(e,n),i=nt(Be(s,Vh(K(-2,s))),t);return ts(i,-1)})}function $g(n,e,t=!1){return le(()=>{if(t)e=_y(e);else{const s=ft(e,e.shape.length-1,!0);e=et(e,s)}return e=Fi(e,Bs(),1-Bs()),zn(ft(K(We(n,"float32"),Ir(e)),e.shape.length-1))})}function Gb(n,e,t=!1){return le(()=>{const s=We(Df(xie(n)),"int32");e=Fi(e,Bs(),1-Bs());const i=e.shape,r=ee(hp(s,i[i.length-1]),i);return $g(r,e,t)})}function gre(n,e){if(!qt(n.shape,e.shape))throw new ne(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return le(()=>{const t=Ho(e),s=zn(As(e));return Be(nt(t,K(e,n)),yy(fi(s)))})}function Cw(n,e){return le(()=>{let t;return t=Fi(e,Bs(),1-Bs()),t=Ir(et(t,nt(1,t))),ts(gre(n,t),-1)})}function Are(n,e){return le(()=>{const t=Fi(n,Bs(),1),s=Fi(e,Bs(),1);return ft(K(n,Ir(et(t,s))),-1)})}function yre(n,e){return le(()=>{const t=Ir(Be(Bs(),e));return ts(nt(e,K(n,t)),-1)})}function oT(n,e){return le(()=>{const t=Vb(n,-1),s=Vb(e,-1),i=K(t,s);return zn(ft(i,-1))})}const Wb={meanSquaredError:jh,meanAbsoluteError:Iw,meanAbsolutePercentageError:Of,meanSquaredLogarithmicError:hre,squaredHinge:dre,hinge:pre,categoricalHinge:fre,logcosh:mre,categoricalCrossentropy:$g,sparseCategoricalCrossentropy:Gb,binaryCrossentropy:Cw,kullbackLeiblerDivergence:Are,poisson:yre,cosineProximity:oT};function sS(n){if(typeof n=="string"){if(n in Wb)return Wb[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ne(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aT(n,e){return le(()=>{const t=K(.5,Cr(e)),s=pa(zi(e,t),n.dtype);return ts(br(n,s),-1)})}function lT(n,e){return le(()=>pa(br(jl(n,-1),jl(e,-1)),"float32"))}function JL(n,e){return le(()=>We(ft(uo(br(n,1),br(e,1))),"float32"))}function xre(n,e){return le(()=>We(ft(uo(br(n,1),br(e,0))),"float32"))}function bre(n,e){return le(()=>We(ft(uo(br(n,0),br(e,1))),"float32"))}function ZL(n,e){return le(()=>{const t=JL(n,e),s=bre(n,e),i=Be(t,s);return We(Qs(zi(i,0),et(t,i),0),"float32")})}function Ire(n,e){return le(()=>{const t=JL(n,e),s=xre(n,e),i=Be(t,s);return We(Qs(zi(i,0),et(t,i),0),"float32")})}function eO(n,e){return Cw(n,e)}function tO(n,e){return n.rank===e.rank&&(n=mn(n,[n.rank-1])),e=jl(e,-1),e.dtype!==n.dtype&&(e=We(e,n.dtype)),We(br(n,e),"float32")}function Cre(n,e){return le(()=>{const t=n.sub(e).square().sum(),s=n.sub(n.mean()).square().sum();return wt(1).sub(t.div(s))})}const wre=jh,vre=jh,Sre=Iw,Ere=Iw,_re=Of,Tre=Of,cT=$g,Bre=oT,nO=Gb,Hb={binaryAccuracy:aT,categoricalAccuracy:lT,precision:ZL,categoricalCrossentropy:cT,sparseCategoricalCrossentropy:nO,mse:wre,MSE:vre,mae:Sre,MAE:Ere,mape:_re,MAPE:Tre,cosine:Bre};function kre(n){if(typeof n=="string"&&n in Hb)return Hb[n];if(typeof n!="string"&&n!=null)return n;throw new ne(`Unknown metric ${n}`)}function s0(n){if(ra(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(Wb))if(Wb[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Hb))if(Hb[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Mre(n){const e={Adagrad:()=>Oc.adagrad(.01),Adadelta:()=>Oc.adadelta(1,.95,Bs()),Adam:()=>Oc.adam(.001,.9,.999,Bs()),Adamax:()=>Oc.adamax(.002,.9,.999,Bs(),0),RMSProp:()=>Oc.rmsprop(.001,.9,0,Bs()),SGD:()=>Oc.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new ne(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const VN=1*1024*1024;function GN(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!E1(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>VN&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${VN}.`)}}function E1(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!E1(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!E1(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Nre(n,e,t,s=console.log){const i=Dre(n),r=["Layer (type)","Input Shape","Output shape","Param #"];i?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(u=>Math.floor(e*u)));let o;if(!i){r.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}s("_".repeat(e)),qb(r,t,s),s("=".repeat(e));const a=n.layers;for(let u=0;u<a.length;++u)i?Fre(a[u],t,s):$re(a[u],t,o,s),s((u===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=Rre(n),c=zb(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(e))}function Rre(n){let e;return n.collectedTrainableWeights!=null?e=zb(n.collectedTrainableWeights):e=zb(n.trainableWeights),e}function Dre(n){let e=!0;const t=[],s=[];for(const i in n.nodesByDepth)t.push(n.nodesByDepth[i]);for(const i of t){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){e=!1;break}s.push(...i)}if(e)for(const i of n.layers){let r=!1;for(const o of i.inboundNodes)if(s.indexOf(o)!==-1)if(r){e=!1;break}else r=!0;if(!e)break}return e}function qb(n,e,t=console.log){let s="";for(let i=0;i<n.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=n[i],s=s.slice(0,e[i]),s+=" ".repeat(e[i]-s.length);t(s)}function Fre(n,e,t){let s,i;try{i=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const r=n.name,o=n.getClassName(),a=[`${r} (${o})`,i,s,n.countParams().toString()];qb(a,e,t)}function $re(n,e,t,s){let i,r;try{r=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{r="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const o=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const p=h.inboundLayers[d].name,f=h.nodeIndices[d],g=h.tensorIndices[d];o.push(`${p}[${f}][${g}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],u=[`${a} (${l})`,r,i,n.countParams().toString(),c];qb(u,e,s);for(let h=1;h<o.length;++h)qb(["","","","",o[h]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sO(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Pg(n,e){if(n===null)return null;if(typeof n=="string")return Wc(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];sO(e,i,r)?t.push(r):t.push(Pg(r,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s];if(s==="name"&&typeof i=="string")t[s]=i;else{const r=Wc(s);t[r]=Pg(i,r)}}return t}}function _1(n,e){if(n==null)return null;if(typeof n=="string")return Oa(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];sO(e,i,r)?t.push(r):t.push(_1(r,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s],r=Oa(s);(s==="name"||s==="className")&&typeof i=="string"?t[r]=i:t[r]=_1(i,s)}return t}}/** @license See the LICENSE file. */const ww="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Pre=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class Co extends sn{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const y=this.getClassName().toLowerCase();this.name=hw(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Ul(this.inputs).length!==this.inputs.length)throw new ne(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);Ul(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const b=y.sourceLayer,x=y.nodeIndex,C=y.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(C)}for(const y of this.inputs){const b=y.sourceLayer,x=y.nodeIndex,C=y.tensorIndex;ra(x===0,"input layer has >1 nodes"),ra(C===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(C)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const b=this.inputLayers[y];if(!(b instanceof Lf))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);const t={},s={},i={},r={},o={},a=[],l=(y,b,x,C,w,E)=>{(C==null||w==null||E==null)&&(C=y.sourceLayer,w=y.nodeIndex,E=y.tensorIndex);const T=C.inboundNodes[w];if(x.indexOf(T)!==-1)throw new oo(`The tensor ${y.name} at layer "${C.name}" is part of a cycle.`);if(b.indexOf(T)!==-1)return;this.containerNodes.add(Co.nodeKey(C,w)),C.id in o||(o[C.id]=Object.keys(o).length),x.indexOf(T)===-1&&x.push(T);const v=T.inboundLayers.length;for(let S=0;S<v;S++){const _=T.inputTensors[S],N=T.inboundLayers[S],D=T.nodeIndices[S],P=T.tensorIndices[S];l(_,b,x,N,D,P)}for(b.push(T);x.indexOf(T)>=0;)x.splice(x.indexOf(T),1);a.push(T)},c=[],u=[];for(const y of this.outputs)l(y,c,u);const h=a.slice().reverse();for(const y of h){s[y.id]=y,y.id in t||(t[y.id]=0);let b=t[y.id];const x=i[y.outboundLayer.id]==null?0:i[y.outboundLayer.id];b=Math.max(b,x),i[y.outboundLayer.id]=b,r[y.outboundLayer.id]=y.outboundLayer,t[y.id]=b;for(let C=0;C<y.inboundLayers.length;C++){const w=y.inboundLayers[C],E=y.nodeIndices[C],T=w.inboundNodes[E],v=t[T.id]==null?0:t[T.id];t[T.id]=Math.max(b+1,v),s[T.id]=T}}const d={};for(const y in t){const b=t[y];b in d||(d[b]=[]),d[b].push(s[y])}const p={};for(const y in i){const b=i[y];b in p||(p[b]=[]),p[b].push(r[y])}let f=Object.keys(p).map(y=>parseInt(y,10)).sort(e0);this.layers=[];for(const y of f){const b=p[y];b.sort((x,C)=>{const w=o[x.id],E=o[C.id];return w<E?-1:w>E?1:0});for(const x of b)x instanceof Co&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=p,f=Object.keys(d).map(y=>parseInt(y,10)).sort(e0);const g=this.inputs.slice(),m=[];for(const y of f)for(const b of d[y]){const x=b.outboundLayer;if(x!=null){for(const C of b.inputTensors)if(g.indexOf(C)===-1)throw new oo(`Graph disconnected: cannot obtain value for tensor ${C} at layer "${x.name}". The following previous layers were accessed without issue: ${m}`);for(const C of b.outputTensors)g.push(C);m.push(x.name)}}this.nodesByDepth=d;const A=this.layers.map(y=>y.name);for(const y of A){const b=A.filter(x=>x===y).length;if(b!==1)throw new oo(`The name "${y}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(A))}this.outboundNodes=[],this.inboundNodes=[],new bw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ne("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let i=0;const r=Pre(e);r&&this.parseWeights(e);for(const a of this.layers)for(const[l,c]of a.weights.entries()){const u=r?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(s[u]!=null)throw new ne(`Duplicate weight name: ${u}`);s[u]=c,i++}const o=[];for(const a in e){let l=a;if(s[a]==null){const c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(s[l]!=null)o.push([s[l],e[a]]);else if(t)throw new ne(`Provided weight data has no target variable: ${a}`);delete s[l]}if(t){const a=[];for(const l in s)a.push(l);if(a.length>0)throw new ne(`${a.length} of ${i} weights are not set: ${a}`)}eT(o)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),i=["vars","layer_checkpoint_dependencies"],r=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!i.includes(o)).join("/");r!==t&&(e[r]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${ww}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=_1(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return le(()=>{e=wn(e);const s=new Fl;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],e[i]);return Dm(this.outputs,s,t)})}computeMask(e,t){return le(()=>{e=wn(e);let s;return t==null?s=Mu(null,e.length):s=wn(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=Ob(e);if(t.length!==this.inputLayers.length)throw new ne(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],c=t[a],u=l.name+"_0_0";s[u]=c}const i=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(e0);if(i.length>1)for(const a of i){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(u.id)!==-1)continue;const h=[];for(let g=0;g<c.inboundLayers.length;g++){const m=c.inboundLayers[g],A=c.nodeIndices[g],y=c.tensorIndices[g],b=`${m.name}_${A}_${y}`,x=s[b];h.push(x)}const d=u.computeOutputShape(qi(h)),p=Ob(d),f=u.inboundNodes.indexOf(c);for(let g=0;g<p.length;g++){const m=`${u.name}_${f}_${g}`;s[m]=p[g]}}}const r=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],h=`${l.name}_${c}_${u}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];ra(l in s),r.push(s[l])}return qi(r)}runInternalGraph(e,t){t==null&&(t=Mu(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],u=e[l],h=t[l];s[c.id]=[u,h]}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(e0);for(const l of i){const c=this.nodesByDepth[l];for(const u of c){const h=u.outboundLayer,d=u.inputTensors,p=u.outputTensors,f=new Array;for(const g of d)g.id in s&&f.push(s[g.id]);if(f.length===d.length){let g={},m,A,y,b;if(u.callArgs!=null&&(g=u.callArgs),f.length===1){const[x,C]=f[0];g.mask==null&&(g.mask=C),y=wn(h.call(x,g)),b=wn(h.computeMask(x,C)),m=[x],A=[C]}else m=f.map(x=>x[0]),A=f.map(x=>x[1]),g.mask==null&&(g.mask=A),y=wn(h.call(m,g)),b=wn(h.computeMask(m,A));if(h.activityRegularizer)throw new jt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<p.length;++x){const C=p[x],w=y[x],E=b[x];s[C.id]=[w,E]}}}}const r=[],o=[],a=[];for(const l of this.outputs){ra(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=s[l.id];a.push(c.shape),r.push(c),o.push(u)}return[r,o,a]}buildNodeConversionMap(e){const t={};let s;for(const i of this.layers){s=i instanceof Co?1:0;for(let r=0;r<i.inboundNodes.length;r++){const o=Co.nodeKey(i,r);this.containerNodes.has(o)&&(t[o]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new ne("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new ne(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new ne(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return le(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const i=Co.nodeKey(t,s);this.containerNodes.has(i)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let h=0;h<o.inboundNodes.length;h++){const d=o.inboundNodes[h],p=Co.nodeKey(o,h);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const g=[];for(let m=0;m<d.inboundLayers.length;m++){const A=d.inboundLayers[m],y=d.nodeIndices[m],b=d.tensorIndices[m],x=Co.nodeKey(A,y);let C=t[x];C==null&&(C=0),g.push([A.name,C,b,f])}c.push(g)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,s.push(u)}e.layers=s;const i=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=Co.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.inputLayersTensorIndices[o];i.push([a.name,u,h])}e.inputLayers=i;const r=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=Co.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.outputLayersTensorIndices[o];r.push([a.name,u,h])}return e.outputLayers=r,e}static fromConfig(e,t,s={},i=!1){const r={},o={};function a(m,A){m.name in o?o[m.name].push(A):o[m.name]=[A]}function l(m,A){const y=[];let b;for(const x of A){const C=x[0],w=x[1],E=x[2];if(b=x[3]==null?{}:x[3],!(C in r)){a(m,A);return}const T=r[C];if(T.inboundNodes.length<=w){a(m,A);return}const v=T.inboundNodes[w];y.push(v.outputTensors[E])}y.length>0&&m.apply(qi(y),b)}function c(m){const A=m.name,y=Do(m,t.customObjects!=null?t.customObjects:{});y.setFastWeightInitDuringBuild(i),r[A]=y,m.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new ne(`Corrupted configuration, expected array for nodeData: ${x}`);a(y,x)})}const u=t.name,h=t.layers;for(const m of h)c(m);for(;!oie(o);)for(const m of h){const A=r[m.name];if(A.name in o){const y=o[A.name];delete o[A.name];for(const b of y)l(A,b)}}const d=[],p=[],f=t.inputLayers;for(const m of f){const A=m[0],y=m[1],b=m[2];ra(A in r);const C=r[A].inboundNodes[y].outputTensors;d.push(C[b])}const g=t.outputLayers;for(const m of g){const A=m[0],y=m[1],b=m[2];ra(A in r);const C=r[A].inboundNodes[y].outputTensors;p.push(C[b])}return new e({inputs:d,outputs:p,name:u})}get stateful(){if(this._stateful)throw new ne("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){le(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lre(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(i=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return e.forEach(r=>{r in n?i.push(n[r]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function iO(n,e){return Lre(n,e,"classWeight")}async function rO(n,e,t,s){if(t!=null){const i=le(()=>{if(n.shape.length===1)return da(n);if(n.shape.length===2){if(n.shape[1]>1)return jl(n,1);if(n.shape[1]===1)return ee(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await i.data());Et(i);const o=[];return r.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),ls(o,"float32")}else return null}function Ore(n,e){return K(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const zre=32;function oO(n,e){let t,s;const i=e;t=i.xs,s=i.ys,R(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const r=WN("input",n.inputNames,t),o=WN("output",n.outputNames,s),a=r[0].shape[0];R(r.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),R(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<r.length;l++)R(r[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${r[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)R(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:r,ys:o}}function WN(n,e,t){if(t instanceof nn)return[t];if(Array.isArray(t))return R(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const i of e){if(t[i]==null)throw new ne(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);s.push(t[i])}return s}}function Ure(n){if(n.length===3)throw new jt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function Qre(n,e,t){const s=t.batchesPerEpoch!=null;if(R(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),R(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),R(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),R(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),R(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=t.validationData!=null;let r,o;if(i)if(HN(t.validationData))R(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const m=Ure(t.validationData);r=m.xs,o=m.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;i?c=l.slice().concat(l.map(m=>"val_"+m)):c=l.slice();const u=jL(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:d,history:p}=KL(u,h,t.epochs,null,null,Vre(e,t),null,i,c);d.setModel(n),n.history=p,await d.onTrainBegin(),n.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,g=await e.iterator();for(;f<t.epochs;){const m={};await d.onEpochBegin(f);let A=0,y=0;for(s||(g=await e.iterator());!s||A<t.batchesPerEpoch;){const b=await g.next();if(s&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${A} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(b.value!=null){const{xs:x,ys:C}=oO(n,b.value),w={};w.batch=y,w.size=x[0].shape[0],await d.onBatchBegin(y,w);const E=[];if(t.classWeight!=null){const S=iO(t.classWeight,n.outputNames);for(let _=0;_<S.length;++_)E.push(await rO(C[_],null,S[_]))}const T=x.concat(C).concat(E),v=a(T);Et(T);for(let S=0;S<l.length;++S){const _=l[S],N=v[S];w[_]=N,Ts(N)}await d.onBatchEnd(y,w),HL(w),y++,A++}if(s?A>=t.batchesPerEpoch:b.done){if(i){let x;HN(t.validationData)?x=wn(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):x=wn(n.evaluate(r,o,{batchSize:t.validationBatchSize==null?zre:t.validationBatchSize,verbose:0}));for(let C=0;C<n.metricsNames.length;++C)m[`val_${n.metricsNames[C]}`]=x[C]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(f,m),f++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Vre(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function HN(n){return typeof n.iterator=="function"}function Gre(n){return typeof n.next=="function"}async function Wre(n,e,t){t=t||{};const s=t.batches!=null,i=n.testFunction;let r=[];if(t.verbose>0)throw new jt("Verbose mode is not implemented yet.");R(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=Gre(e)?e:await e.iterator();let a=0,l=0;for(;!s||l<t.batches;){const c=await o.next();if(r=le(()=>{if(c.value){const{xs:u,ys:h}=oO(n,c.value),d=u.concat(h),p=le(()=>i(d));if(Et(d),l===0)for(let g=0;g<p.length;++g)r.push(wt(0));const f=d[0].shape[0];for(let g=0;g<p.length;++g){const m=p[g],A=r[g];r[g]=le(()=>Be(r[g],K(f,m))),l>0&&Et(A)}Et(p),a+=f,++l}return r}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<r.length;++c){const u=r[c];r[c]=et(r[c],a),Et(u)}return qi(r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function iS(n){R(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function vm(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>mu(s,e,t-e)):mu(n,e,t-e)}function T1(n,e){return le(()=>n==null?null:Array.isArray(n)?n.map(t=>T1(t,e)):UL(n,e.dtype==="int32"?e:We(e,"int32")))}function rS(n,e){const t=[];let s=0,i=null;for(;s<n;)i=s+e,i>=n&&(i=n),t.push([s,i]),s=i;return t}function aO(n){const e=[];n instanceof nn&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(Py(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function bo(n,e){if(n==null)return;const t=[];if(e instanceof nn)t.push(e.id);else if(Array.isArray(e))e.forEach(i=>t.push(i.id));else if(e!=null)for(const i in e){const r=e[i];t.push(r.id)}const s=[];if(n instanceof nn)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(i=>{t.indexOf(i.id)===-1&&s.push(i)});else if(n!=null)for(const i in n){const r=n[i];t.indexOf(r.id)===-1&&s.push(r)}s.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hre(n){return n instanceof nn}function B1(n){return Array.isArray(n)}function qN(n){return!Hre(n)&&!B1(n)}function YN(n,e,t,s=!0,i=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(B1(n)&&n.length>0)o=!0;else if(qN(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new ne(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let r;if(qN(n)){n=n,r=[];for(const o of e){if(n[o]==null)throw new ne(`No data provided for "${o}". Need data for each key in: ${e}`);r.push(n[o])}}else if(B1(n)){if(n=n,n.length!==e.length)throw new ne(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);r=n}else{if(n=n,e.length>1)throw new ne(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);r=[n]}if(r=aO(r),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=r[o];if(a.shape.length!==t[o].length)throw new ne(`Error when checking ${i}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u>=0&&c!==u)throw new ne(`${i} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return r}function qre(n,e,t){const s=Ul(n.map(r=>r.shape[0]));s.sort();const i=Ul(e.map(r=>r.shape[0]));if(i.sort(),s.length>1)throw new ne(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(r=>r.shape))}`);if(i.length>1)throw new ne(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(r=>r.shape))}`);if(s.length>0&&i.length>0&&!qt(s,i))throw new ne(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function Yre(n,e,t){const s=[jh,Cw,$g];for(let i=0;i<n.length;++i){const r=n[i],o=e[i],a=t[i];if(o!=null){if(o===$g&&r.shape[r.shape.length-1]===1)throw new ne(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const l=r.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const h=l[u],d=c[u];if(d!=null&&h!==d)throw new ne(`A target Tensor with shape ${r.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function XN(n,e,t,s=!0,i=""){let r;if(Array.isArray(n)){if(n.length!==e.length)throw new ne(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);r=n}else{if(e.length>1)throw new ne(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);r=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=r[o];if(a.shape.length!==t[o].length)throw new ne(`Error when checking ${i}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u!==c)throw new ne(`Error when checking ${i}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function Xre(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const i of e){let r=t.hasOwnProperty(i)?t[i]:[];Array.isArray(r)||(r=[r]),s.push(r)}return s}}const jre="layers-model";class ja extends Co{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new ne("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Nre(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Mre(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof fl))throw new ne("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new ne(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(sS(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ne(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>sS(a))}else{const o=sS(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],fu("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const i=Xre(e.metrics,this.outputNames),r=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};fu("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=i[o];(c=>{let h,d,p;for(const f of c){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const m=this.internalOutputShapes[o];m[m.length-1]===1||this.lossFunctions[o]===Cw?["accuracy","acc"].indexOf(f)!==-1?d=aT:["crossentropy","ce"].indexOf(f)!==-1&&(d=eO):this.lossFunctions[o]===Gb?["accuracy","acc"].indexOf(f)!==-1?d=tO:["crossentropy","ce"].indexOf(f)!==-1&&(d=nO):["accuracy","acc"].indexOf(f)!==-1?d=lT:["crossentropy","ce"].indexOf(f)!==-1&&(d=cT);let A;["accuracy","acc"].indexOf(f)!==-1?A="acc":["crossentropy","ce"].indexOf(f)!==-1&&(A="ce"),p=d,h=""+A}else p=kre(f),h=""+s0(f);let g;fu(h,()=>{g=p}),r(o,h,g)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const i=s.batchSize==null?32:s.batchSize;iS(i);const o=this.standardizeUserDataXY(e,t,!0,i);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,i,s.verbose,s.steps);return qi(c)}finally{bo(o[0],e),bo(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Wre(this,e,t)}checkNumSamples(e,t,s,i="steps"){let r;if(s!=null){if(r=null,t!=null)throw new ne(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new ne(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new ne("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),i=s?t:[t],r=this.retrieveSymbolicTensors(i),o=new Fl;if(e instanceof nn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ne(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new ne(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=Dm(r,o);return s?a:a[0]}retrieveSymbolicTensors(e){const t=Mu(null,e.length);let s=e.length;for(const i of this.layers){const r=Array.isArray(i.output)?i.output:[i.output],o=r.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=r[l],s--),s===0)break}if(s===0)break}if(s>0){const i=[];throw t.forEach((r,o)=>{r==null&&i.push(e[o])}),new ne(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return t}predictLoop(e,t=32,s=!1){return le(()=>{const i=this.checkNumSamples(e);if(s)throw new jt("Verbose predictLoop() is not implemented yet.");const r=rS(i,t),o=this.outputs.map(a=>[]);for(let a=0;a<r.length;++a)le(()=>{const c=r[a][0],u=r[a][1],h=vm(e,c,u),d=[];if(Array.isArray(h))for(let f=0;f<h.length;++f)d.push({key:this.inputs[f],value:h[f]});else d.push({key:this.inputs[0],value:h});const p=new Fl(d);return Dm(this.outputs,p)}).forEach((c,u)=>o[u].push(c));return qi(o.map(a=>Jn(a,0)))})}predict(e,t={}){const s=aO(e);XN(s,this.inputNames,this.feedInputShapes,!1);try{const i=t.batchSize==null?32:t.batchSize;return iS(i),this.predictLoop(s,i)}finally{bo(s,e)}}predictOnBatch(e){XN(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,i){if(this.optimizer_==null)throw new oo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===Gb?r.push(a.slice(0,a.length-1).concat([1])):r.push(a)}if(e=YN(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=YN(t,this.feedOutputNames,r,!1,"target"),qre(e,t),Yre(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&e[0].shape[0]%i!==0)throw new ne(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,i,r=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,r,o);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(i!=null){const u=iO(i,this.outputNames);c=[];for(let h=0;h<u.length;++h)c.push(await rO(l[h],null,u[h]))}return[a,l,c]}testLoop(e,t,s,i=0,r){return le(()=>{const o=this.checkNumSamples(t,s,r,"steps"),a=[];if(i>0)throw new jt("Verbose mode is not implemented yet.");if(r!=null)throw new jt("steps mode in testLoop() is not implemented yet");{const l=rS(o,s),c=ls(Lo(0,o));for(let u=0;u<l.length;++u){const h=l[u][0],d=l[u][1],p=mu(c,h,d-h),f=T1(t,p),g=e(f);if(u===0)for(let m=0;m<g.length;++m)a.push(wt(0));for(let m=0;m<g.length;++m){const A=g[m];a[m]=Be(a[m],K(d-h,A))}}for(let u=0;u<a.length;++u)a[u]=et(a[u],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const i=e[s];let r=i;if(RN(e,i)>1){const o=RN(e.slice(0,s),i);r+=`_${o}`}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const d=new Fl(h),p=Dm(this.outputs,d,{training:!0});let f;for(let g=0;g<this.lossFunctions.length;++g){const m=this.lossFunctions[g];let A=m(i[g],p[g]);r[g]!=null&&(A=Ore(A,r[g]));const y=ts(A);t.push(y),g===0?f=A:f=Be(f,A)}for(let g=0;g<this.metricsTensors.length;++g){let m;if(this.outputs.length>1&&g<this.outputs.length)m=t[g];else{const A=this.metricsTensors[g][0],y=this.metricsTensors[g][1];m=ts(A(i[y],p[y]))}Ts(m),o.push(m)}return f=ts(f),this.calculateLosses().forEach(g=>{f=Be(f,g)}),f},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>le(()=>{const t=[];let s;const i=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:i[c]});const a=new Fl(o),l=Dm(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const u=this.lossFunctions[c],h=ts(u(r[c],l[c]));c===0?s=h:s=Be(s,h),t.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const u=this.metricsTensors[c][0],h=this.metricsTensors[c][1],d=ts(u(r[h],l[h]));t.push(d)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,r,o,a,l,c,u,h,d;try{const p=s.batchSize==null?32:s.batchSize;iS(p);const g=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,p);i=g[0],r=g[1],d=g[2];let m=!1,A;if(s.validationData!=null&&s.validationData.length>0){if(m=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new jt("validationData including sample weights is not supported yet."):new ne(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const S=await this.standardizeUserData(l,c,null,null,!0,p);u=S[0],h=S[1],A=u.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){m=!0;const v=Math.floor(i[0].shape[0]*(1-s.validationSplit)),S=i[0].shape[0];u=vm(i,v,S),o=i,i=vm(i,0,v),h=vm(r,v,S),a=r,r=vm(r,0,v),A=u.concat(h)}else s.validationSteps!=null&&(m=!0);const y=i.concat(r).concat(d);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let C,w;m?(this.makeTestFunction(),C=this.testFunction,w=x.slice().concat(x.map(v=>"val_"+v))):(C=null,A=[],w=x.slice());const E=jL(s.callbacks,s.yieldEvery);return await this.fitLoop(b,y,x,p,s.epochs,s.verbose,E,C,A,s.shuffle,w,s.initialEpoch,null,null)}finally{this.isTraining=!1,bo(i,e),bo(r,t),bo(o,e),bo(a,t),bo(u,l),bo(h,c),d!=null&&Et(d)}}async fitLoop(e,t,s,i,r,o,a,l,c,u,h,d,p,f){i==null&&(i=32),r==null&&(r=1),u==null&&(u=!0),d==null&&(d=0);let g=!1;if(l!=null&&c!=null&&(g=!0),f!=null&&(g=!0,p==null))throw new ne("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,i,p,"steps_per_epoch");let A;m!=null&&(A=Lo(0,m)),o==null&&(o=1);const{callbackList:y,history:b}=KL(a,o,r,d,m,p,i,g,h);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<r;++x){await y.onEpochBegin(x);const C={};if(p!=null)throw new jt("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new jt("batch shuffling is not implemneted yet");u&&h2(A);const w=ls(A),E=rS(m,i);for(let T=0;T<E.length;++T){const v={};if(await y.onBatchBegin(T,v),le(()=>{const S=E[T][0],_=E[T][1],N=mu(w,S,_-S);v.batch=T,v.size=_-S;const D=T1(t,N),P=e(D);for(let L=0;L<s.length;++L){const z=s[L],q=P[L];v[z]=q,Ts(q)}if(T===E.length-1&&g){const L=this.testLoop(l,c,i);for(let z=0;z<s.length;++z){const q=s[z],V=L[z];Ts(V),C["val_"+q]=V}}}),await y.onBatchEnd(T,v),HL(v),this.stopTraining_)break}w.dispose()}if(await y.onEpochEnd(x,C),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Qre(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),i=s[0],r=s[1],a=this.makeTrainFunction()(i.concat(r)),l=[];for(const c of a){const u=await c.data();l.push(u[0])}return Et(a),bo(s[0],e),bo(s[1],t),qi(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,i=s?this.trainableWeights:this.weights,r=this.getWeights(s);for(let o=0;o<i.length;++o)s&&!i[o].trainable||t.push({name:i[o].originalName,tensor:r[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=c1().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-c1().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Oa(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Oa(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const i of t)if(typeof s[i]=="string")e[i]=Oa(s[i]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Oa(s0(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Oa(s0(e)));{const e={};for(const t in this.metrics)e[t]=Oa(s0(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Pg(e.optimizer_config),s=Do(t);let i;if(typeof e.loss=="string")i=Wc(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(o=>Wc(o));else if(e.loss!=null){i={};for(const o in e.loss)i[o]=Wc(e.loss[o])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(o=>Wc(o));else if(e.metrics!=null){r={};for(const o in e.metrics)r[o]=Wc(e.metrics[o])}this.compile({loss:i,metrics:r,optimizer:s})}async save(e,t){if(typeof e=="string"){const c=T$(e);if(c.length===0)throw new ne(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new ne(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new ne("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await u1(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:jre,generatedBy:`TensorFlow.js tfjs-layers v${ww}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:u,specs:h}=await u1(await this.optimizer.getWeights(),c);s.specs.push(...h),s.data=E$([s.data,u])}return this.userDefinedMetadata!=null&&(GN(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){GN(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}ja.className="Model";Le(ja);class lO extends ja{}lO.className="Functional";Le(lO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Kre(n,e){"modelTopology"in n||(n={modelTopology:n}),n=n;let t=n.modelTopology;t.model_config!=null&&(t=t.model_config);const s=Pg(t),i=Do(s,e);if(n.weightsManifest!=null){const r=await VP(n.weightsManifest,n.pathPrefix,i.weights.map(a=>a.originalName)),o={};for(const a of i.weights)o[a.originalName]=r[a.originalName];i.loadWeights(o),Et(r)}return i}async function Jre(n,e){if(e==null&&(e={}),typeof n=="string"){const t=B$(n,e);if(t.length===0)t.push(HP(n,e));else if(t.length>1)throw new ne(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return Zre(n,void 0,e)}async function Zre(n,e,t){if(t==null&&(t={}),n.load==null)throw new ne("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let i=s.modelTopology;i.model_config!=null&&(i=i.model_config);const r=t.strict==null?!0:t.strict,o=s.weightData!=null&&s.weightSpecs!=null&&r,a=Do(Pg(i),e,o),l=s.trainingConfig;if(l!=null&&a.loadTrainingConfig(l),s.userDefinedMetadata!=null&&a.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new ne("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:c,optimizerWeights:u}=eoe(s.weightData,s.weightSpecs);a.loadWeights(c,r),a.optimizer!=null&&u.length>0&&await a.optimizer.setWeights(u),Et(c),Et(u.map(h=>h.tensor))}return a}function eoe(n,e){const t=b2(n,e),s={},i=[];return e.forEach(r=>{r.group==="optimizer"?i.push({name:r.name,tensor:t[r.name]}):s[r.name]=t[r.name]}),{modelWeights:s,optimizerWeights:i}}class Nu extends ja{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:hw("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ne(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Nu||e instanceof ja;let s;if(t){if(s=e,s.outputs.length!==1)throw new ne("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ne("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new ne("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=WL({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new ne(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new ne("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=GL(this.outputs[0])}this.inboundNodes=[],new bw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Mu(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(An(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ja({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new oo("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new oo("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new oo("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new oo("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},i=!1){let r,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new ne("Legacy serialization format not supported yet.");r=t}else R(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof Nu))throw new jt(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of r){const u=Do(l,void 0,i);i&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(e){if(this.model==null)throw new ne("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new ne("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}Nu.className="Sequential";Le(Nu);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function toe(n){return new ja(n)}function noe(n){return new Nu(n)}function cO(n){return WL(n)}function soe(n,e){Rr.registerCallbackConstructor(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let gi=class extends Wh{getConfig(){return{}}};class uO extends gi{apply(e,t=1){return Iie(e,t)}}uO.className="elu";Le(uO);class hO extends gi{apply(e){return vC(e)}}hO.className="selu";Le(hO);class dO extends gi{apply(e){return Ho(e)}}dO.className="relu";Le(dO);class pO extends gi{apply(e){return le(()=>ol(6,Ho(e)))}}pO.className="relu6";Le(pO);class fO extends gi{apply(e){return e}}fO.className="linear";Le(fO);class mO extends gi{apply(e){return yr(e)}}mO.className="sigmoid";Le(mO);class gO extends gi{apply(e){return wie(e)}}gO.className="hardSigmoid";Le(gO);class AO extends gi{apply(e){return Vh(e)}}AO.className="softplus";Le(AO);class yO extends gi{apply(e){return Cie(e)}}yO.className="softsign";Le(yO);class xO extends gi{apply(e){return Jl(e)}}xO.className="tanh";Le(xO);let uT=class extends gi{apply(e,t=-1){return _y(e,t)}};uT.className="softmax";Le(uT);class bO extends gi{apply(e,t=-1){return gC(e,t)}}bO.className="logSoftmax";Le(bO);class IO extends gi{apply(e){return le(()=>le(()=>{const t=Math.sqrt(2),s=K(.5,Be(1,pC(et(e,t))));return K(e,s)}))}}IO.className="gelu";Le(IO);class CO extends gi{apply(e){return le(()=>K(.5,K(e,Be(1,Jl(K(Hs(et(2,Math.PI)),Be(e,K(.044715,Aa(e,3)))))))))}}CO.className="gelu_new";Le(CO);class wO extends gi{apply(e){return le(()=>K(e,Jl(Vh(e))))}}wO.className="mish";Le(wO);class vO extends gi{apply(e,t=1){return le(()=>K(yr(K(e,t)),e))}}vO.className="swish";Le(vO);function ec(n){return n.getClassName()}function oS(n,e={}){return $y(n,Fr.getMap().classNameMap,e,"activation")}function tc(n){if(n==null){const e={};return e.className="linear",e.config={},oS(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},oS(e)}else return n instanceof gi?n:oS(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hT(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class SO extends Wh{}class Uy extends SO{constructor(e){super(),hT(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return le(()=>{let t=as([1]);return this.hasL1&&(t=Be(t,ft(K(this.l1,As(e))))),this.hasL2&&(t=Be(t,ft(K(this.l2,Ly(e))))),ee(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Uy.className="L1L2";Le(Uy);function ioe(n){return hT(n),new Uy({l1:n!=null?n.l1:null,l2:0})}function roe(n){return hT(n),new Uy({l2:n!=null?n.l2:null,l1:0})}const jN={l1l2:"L1L2"};function Dn(n){return G_(n)}function KN(n,e={}){return $y(n,Fr.getMap().classNameMap,e,"regularizer")}function Zn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in jN?jN[n]:n,config:{}};return KN(t)}else return n instanceof SO?n:KN(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class dT extends sn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Lt(e);let s=Ho(e);return this.maxValue!=null&&(s=Fi(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}dT.className="ReLU";Le(dT);class pT extends sn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Lt(e);return Ay(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}pT.className="LeakyReLU";Le(pT);class fT extends sn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Kn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Zn(e.alphaRegularizer),this.alphaConstraint=Ms(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ne(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=An(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)t[i-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new xs({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=Lt(e),vy(e,this.alpha.read())}getConfig(){const e={alphaInitializer:ss(this.alphaInitializer),alphaRegularizer:Dn(this.alphaRegularizer),alphaConstraint:ks(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}fT.className="PReLU";Le(fT);let mT=class extends sn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new jt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Lt(e);return Nf(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};mT.className="ELU";Le(mT);class gT extends sn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=Lt(e);return K(s,We(zi(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}gT.className="ThresholdedReLU";Le(gT);class AT extends sn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new uT().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return le(()=>{let s=Lt(e);const i=t.mask;if(i!=null){const r=K(nt(Xi(s.shape),We(i,s.dtype)),wt(-1e9));s=Be(s,r)}return this.axis instanceof Array?this.axis.length>1?fi(nt(s,xy(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}AT.className="Softmax";Le(AT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qd(n,e,t){if(typeof n=="number")return Mu(n,e);if(n.length!==e)throw new ne(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const i=n[s];if(!Aie(i))throw new ne(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function Fo(n,e,t,s,i=1){if(n==null)return n;const r=e+(e-1)*(i-1);let o;return t==="same"?o=n:o=n-r+1,Math.floor((o+s-1)/s)}function oa(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Zl([t-e,0]);else if(s==="same")n=n*e;else throw new ne(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yT(n,e){return le(()=>(fs(e),e==="channelsFirst"?on(n,[0,2,3,1]):n))}function EO(n,e){return le(()=>(fs(e),e==="channelsFirst"?on(n,[0,2,3,4,1]):n))}function ooe(n,e,t,s=1,i="valid",r,o=1){return le(()=>{if(r==null&&(r=Oo()),fs(r),n.shape.length!==3)throw new ne(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new ne(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new ne(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(r==="channelsFirst"&&(n=on(n,[0,2,1])),i==="causal")throw new jt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=cC(n,e,s,i==="same"?"same":"valid","NWC",o);return t!=null&&(a=Yo(a,t)),a})}function JN(n,e,t,s=[1,1],i="valid",r,o,a=null){return le(()=>{if(r==null&&(r=Oo()),fs(r),n.rank!==3&&n.rank!==4)throw new ne(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new ne(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=yT(n,r);if(i==="causal")throw new jt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=BP({x:l,filter:e,strides:s,pad:i==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),r==="channelsFirst"&&(l=on(l,[0,3,1,2])),l})}function aoe(n,e,t,s=[1,1,1],i="valid",r,o){return le(()=>{if(r==null&&(r=Oo()),fs(r),n.rank!==4&&n.rank!==5)throw new ne(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new ne(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=EO(n,r);if(i==="causal")throw new jt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=W2(a,e,s,i==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Yo(a,t)),r==="channelsFirst"&&(a=on(a,[0,4,1,2,3])),a})}class vw extends sn{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",vw.verifyArgs(t),this.rank=e,zs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new jt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=qd(t.kernelSize,e,"kernelSize"),this.strides=qd(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,jr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,fs(this.dataFormat),this.activation=tc(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=Kn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ms(t.biasConstraint),this.biasRegularizer=Zn(t.biasRegularizer),this.activityRegularizer=Zn(t.activityRegularizer),this.dilationRate=qd(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ne(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ne(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ne(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ra("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!W_(e.kernelSize,"number",1,3))throw new ne(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ec(this.activation),useBias:this.useBias,biasInitializer:ss(this.biasInitializer),biasRegularizer:Dn(this.biasRegularizer),activityRegularizer:Dn(this.activityRegularizer),biasConstraint:ks(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class zf extends vw{constructor(e,t){super(e,t),this.kernel=null,zf.verifyArgs(t),this.filters=t.filters,zs(this.filters,"filters"),this.kernelInitializer=Kn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ms(t.kernelConstraint),this.kernelRegularizer=Zn(t.kernelRegularizer)}build(e){e=An(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ne(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return le(()=>{e=Lt(e);let s;const i=this.bias==null?null:this.bias.read(),r=FL(this.activation.getClassName());if(r!=null&&this.rank===2)s=JN(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(this.rank===1)s=ooe(e,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=JN(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=aoe(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new jt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=An(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<s.length;++r){const o=Fo(s[r],this.kernelSize[r],this.padding,this.strides[r],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[r]);t.push(o)}let i=[e[0]];return this.dataFormat==="channelsLast"?(i=i.concat(t),i.push(this.filters)):(i.push(this.filters),i=i.concat(t)),i}getConfig(){const e={filters:this.filters,kernelInitializer:ss(this.kernelInitializer),kernelRegularizer:Dn(this.kernelRegularizer),kernelConstraint:ks(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new ne(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Uf extends zf{constructor(e){super(2,e),Uf.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!W_(e.kernelSize,"number",1,2))throw new ne(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Uf.className="Conv2D";Le(Uf);class Qf extends zf{constructor(e){super(3,e),Qf.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new ne(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Qf.className="Conv3D";Le(Qf);class xT extends Uf{constructor(e){if(super(e),this.inputSpec=[new xs({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ne(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=An(e),e.length!==4)throw new ne("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ne("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new xs({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return le(()=>{let s=Lt(e);if(s.shape.length!==4)throw new ne(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=i[o],c=i[a],u=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=oa(l,d,u,this.padding),g=oa(c,p,h,this.padding),m=[r,f,g,this.filters];this.dataFormat!=="channelsLast"&&(s=on(s,[0,2,3,1]));let A=uC(s,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(A=on(A,[0,3,1,2])),this.bias!=null&&(A=Yo(A,this.bias.read(),this.dataFormat)),this.activation!=null&&(A=this.activation.apply(A)),A})}computeOutputShape(e){e=An(e);const t=e.slice();let s,i,r;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3):(s=3,i=1,r=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[s]=this.filters,t[i]=oa(t[i],l,o,this.padding),t[r]=oa(t[r],c,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}xT.className="Conv2DTranspose";Le(xT);class bT extends Qf{constructor(e){if(super(e),this.inputSpec=[new xs({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ne(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=An(e),e.length!==5)throw new ne("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ne("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new xs({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return le(()=>{let s=Lt(e);if(s.shape.length!==5)throw new ne(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=i[l],u=i[o],h=i[a],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],g=this.strides[0],m=this.strides[1],A=this.strides[2],y=oa(c,g,d,this.padding),b=oa(u,m,p,this.padding),x=oa(h,A,f,this.padding),C=[r,y,b,x,this.filters];this.dataFormat!=="channelsLast"&&(s=on(s,[0,2,3,4,1]));let w=H2(s,this.kernel.read(),C,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=on(w,[0,4,1,2,3])),this.bias!==null&&(w=Yo(w,this.bias.read(),this.dataFormat)),this.activation!==null&&(w=this.activation.apply(w)),w})}computeOutputShape(e){e=An(e);const t=e.slice();let s,i,r,o;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3,o=4):(s=4,i=1,r=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[0],h=this.strides[1],d=this.strides[2];return t[s]=this.filters,t[i]=oa(t[i],u,a,this.padding),t[r]=oa(t[r],h,l,this.padding),t[o]=oa(t[o],d,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}bT.className="Conv3DTranspose";Le(bT);class _O extends zf{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new ne("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new ne("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new ne(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Kn(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Zn(t.depthwiseRegularizer),this.depthwiseConstraint=Ms(t.depthwiseConstraint),this.pointwiseInitializer=Kn(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Zn(t.pointwiseRegularizer),this.pointwiseConstraint=Ms(t.pointwiseConstraint)}build(e){if(e=An(e),e.length<this.rank+2)throw new ne(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new ne(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],i=this.kernelSize.concat([s,this.depthMultiplier]),r=[];for(let a=0;a<this.rank;++a)r.push(1);r.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new xs({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return le(()=>{e=Lt(e);let s;if(this.rank===1)throw new jt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=on(e,[0,2,3,1])),s=SC(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Yo(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=on(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ss(this.depthwiseInitializer),e.pointwiseInitializer=ss(this.pointwiseInitializer),e.depthwiseRegularizer=Dn(this.depthwiseRegularizer),e.pointwiseRegularizer=Dn(this.pointwiseRegularizer),e.depthwiseConstraint=ks(this.depthwiseConstraint),e.pointwiseConstraint=ks(this.pointwiseConstraint),e}}_O.className="SeparableConv";class IT extends _O{constructor(e){super(2,e)}}IT.className="SeparableConv2D";Le(IT);class Qy extends zf{constructor(e){super(1,e),Qy.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!W_(e.kernelSize,"number",1,1))throw new ne(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Qy.className="Conv1D";Le(Qy);class CT extends sn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return le(()=>{if(e=Lt(e),this.dataFormat==="channelsLast"){const s=n0(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return n0(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=n0(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return n0(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}CT.className="Cropping2D";Le(CT);class wT extends sn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,fs(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,fie(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return le(()=>{let s=Lt(e);const i=s.shape;if(this.dataFormat==="channelsFirst"){s=on(s,[0,2,3,1]);const r=this.size[0]*i[2],o=this.size[1]*i[3],a=this.interpolation==="nearest"?ii.resizeNearestNeighbor(s,[r,o]):ii.resizeBilinear(s,[r,o]);return on(a,[0,3,1,2])}else{const r=this.size[0]*i[1],o=this.size[1]*i[2];return this.interpolation==="nearest"?ii.resizeNearestNeighbor(s,[r,o]):ii.resizeBilinear(s,[r,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}wT.className="UpSampling2D";Le(wT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function loe(n,e,t=[1,1],s="valid",i,r){return le(()=>{i==null&&(i=Oo()),fs(i);let o=yT(n,i);if(n.rank!==4)throw new ne(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new ne(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=Mf(o,e,t,s==="same"?"same":"valid","NHWC",r),i==="channelsFirst"&&(o=on(o,[0,3,1,2])),o})}class vT extends vw{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Kn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ms(e.depthwiseConstraint),this.depthwiseRegularizer=Zn(e.depthwiseRegularizer)}build(e){if(e=An(e),e.length<4)throw new ne(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new ne(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],i=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return le(()=>{e=Lt(e);let s=loe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Yo(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=An(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Fo(t,this.kernelSize[0],this.padding,this.strides[0]),o=Fo(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],i,r,o]:[e[0],r,o,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ss(this.depthwiseInitializer),e.depthwiseRegularizer=Dn(this.depthwiseRegularizer),e.depthwiseConstraint=ks(this.depthwiseRegularizer),e}}vT.className="DepthwiseConv2D";Le(vT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function TO(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new ne("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function i(r){return r==null||Array.isArray(r)?r:[r]}return e=i(e),t=i(t),{inputs:n,initialState:e,constants:t}}function BO(n,e,t,s=!1,i,r,o=!1,a=!1){return le(()=>{const l=e.shape.length;if(l<3)throw new ne(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Lo(2,l));e=on(e,c),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=We(We(i,"bool"),"float32"),i.rank===l-1&&(i=rs(i,-1)),i=on(i,c)),s&&(e=qr(e,0),i!=null&&(i=qr(i,0)));const u=[];let h,d=t;const p=e.shape[0],f=Yr(e);let g;i!=null&&(g=Yr(i));for(let A=0;A<p;++A){const y=f[A],b=le(()=>n(y,d));if(i==null)h=b[0],d=b[1];else{const x=le(()=>{const C=g[A],w=nt(Cr(C),C),E=Be(K(b[0],C),K(d[0],w)),T=d.map((v,S)=>Be(K(b[1][S],C),K(v,w)));return{output:E,newStates:T}});h=x.output,d=x.newStates}a&&u.push(h)}let m;return a&&(m=$i(u,1)),[h,m,d]})}class Xo extends sn{constructor(e){super(e);let t;if(e.cell==null)throw new ne("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new _w({cells:e.cell}):t=e.cell,t.stateSize==null)throw new ne("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new xs({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Lo(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){v1(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let i;if(this.returnSequences?i=[e[0],e[1],s]:i=[e[0],s],this.returnState){const r=[];for(const o of t)r.push([e[0],o]);return[i].concat(r)}else return i}computeMask(e,t){return le(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const i=this.states.map(r=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new jt("Constants support is not implemented in RNN yet.");v1(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new xs({shape:[t,null,...s]});const i=[e[0]].concat(e.slice(2));this.cell.build(i);let r;if(Array.isArray(this.cell.stateSize)?r=this.cell.stateSize:r=[this.cell.stateSize],this.stateSpec!=null){if(!qt(this.stateSpec.map(o=>o.shape[o.shape.length-1]),r))throw new ne(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(o=>new xs({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){le(()=>{if(!this.stateful)throw new ia("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new ne("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>as([s,i])):this.states_=[as([s,this.cell.stateSize])];else if(e==null)Et(this.states_),this.keptStates!=null&&(Et(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>as([s,i])):this.states_[0]=as([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ne(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Et(this.states_);for(let i=0;i<this.states_.length;++i){const r=e[i],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,a=[s,o];if(!qt(r.shape,a))throw new ne(`State ${i} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[i]=r}}this.states_=this.states_.map(i=>Ts(i.clone()))})}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=TO(e,s,i,this.numConstants);e=r.inputs,s=r.initialState,i=r.constants;let o=[],a=[];if(s!=null){t.initialState=s,o=o.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new xs({shape:c.shape}));a=a.concat(this.stateSpec)}if(i!=null&&(t.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof zo){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const d=super.apply(c,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return le(()=>{const s=t==null?null:t.mask,i=t==null?null:t.training;let r=t==null?null:t.initialState;e=Lt(e),r==null&&(this.stateful?r=this.states_:r=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==o)throw new ne(`RNN Layer has ${o} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:i},c=BO((f,g)=>{const m=this.cell.call([f].concat(g),a);return[m[0],m.slice(1)]},e,r,this.goBackwards,s,null,this.unroll,this.returnSequences),u=c[0],h=c[1],d=c[2];this.stateful&&this.resetStates(d,i);const p=this.returnSequences?h:u;return this.returnState?[p].concat(d):p})}getInitialState(e){return le(()=>{let t=as(e.shape);return t=ft(t,[1,2]),t=Py(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?C1(t,[1,s]):t):this.cell.stateSize>1?[C1(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Xo.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const i=t.cell,r=Do(i,s);return new e(Object.assign(t,{cell:r}))}}Xo.className="RNN";Le(Xo);class Vy extends sn{}class Sw extends Vy{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,zs(this.units,"units"),this.activation=tc(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Kn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Kn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Kn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Zn(e.kernelRegularizer),this.recurrentRegularizer=Zn(e.recurrentRegularizer),this.biasRegularizer=Zn(e.biasRegularizer),this.kernelConstraint=Ms(e.kernelConstraint),this.recurrentConstraint=Ms(e.recurrentConstraint),this.biasConstraint=Ms(e.biasConstraint),this.dropout=mp([1,Zl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=mp([1,Zl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=An(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return le(()=>{if(e=e,e.length!==2)throw new ne(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=nc({ones:()=>Cr(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=nc({ones:()=>Cr(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let r;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?r=fa(K(e,o),this.kernel.read()):r=fa(e,this.kernel.read()),this.bias!=null&&(r=Yo(r,this.bias.read())),a!=null&&(s=K(s,a));let l=Be(r,fa(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ec(this.activation),useBias:this.useBias,kernelInitializer:ss(this.kernelInitializer),recurrentInitializer:ss(this.recurrentInitializer),biasInitializer:ss(this.biasInitializer),kernelRegularizer:Dn(this.kernelRegularizer),recurrentRegularizer:Dn(this.recurrentRegularizer),biasRegularizer:Dn(this.biasRegularizer),activityRegularizer:Dn(this.activityRegularizer),kernelConstraint:ks(this.kernelConstraint),recurrentConstraint:ks(this.recurrentConstraint),biasConstraint:ks(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Sw.className="SimpleRNNCell";Le(Sw);class ST extends Xo{constructor(e){e.cell=new Sw(e),super(e)}call(e,t){return le(()=>{this.cell.dropoutMask!=null&&(Et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return new e(t)}}ST.className="SimpleRNN";Le(ST);class Ew extends Vy{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ne("GRUCell does not support reset_after parameter set to true.");this.units=e.units,zs(this.units,"units"),this.activation=tc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=tc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Kn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Kn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Kn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Zn(e.kernelRegularizer),this.recurrentRegularizer=Zn(e.recurrentRegularizer),this.biasRegularizer=Zn(e.biasRegularizer),this.kernelConstraint=Ms(e.kernelConstraint),this.recurrentConstraint=Ms(e.recurrentConstraint),this.biasConstraint=Ms(e.biasConstraint),this.dropout=mp([1,Zl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=mp([1,Zl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=An(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return le(()=>{if(e=e,e.length!==2)throw new ne(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=nc({ones:()=>Cr(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=nc({ones:()=>Cr(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(e=K(e,r[0]));let u=fa(e,this.kernel.read());this.useBias&&(u=Yo(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=K(i,o[0]));const h=this.recurrentKernel.read(),[d,p]=Ki(h,[2*this.units,this.units],h.rank-1),f=fa(i,d),[g,m,A]=Ki(u,3,u.rank-1),[y,b]=Ki(f,2,f.rank-1);a=this.recurrentActivation.apply(Be(g,y)),l=this.recurrentActivation.apply(Be(m,b));const x=fa(K(l,i),p);c=this.activation.apply(Be(A,x));const C=Be(K(a,i),K(Be(1,zn(a)),c));return[C,C]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ec(this.activation),recurrentActivation:ec(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ss(this.kernelInitializer),recurrentInitializer:ss(this.recurrentInitializer),biasInitializer:ss(this.biasInitializer),kernelRegularizer:Dn(this.kernelRegularizer),recurrentRegularizer:Dn(this.recurrentRegularizer),biasRegularizer:Dn(this.biasRegularizer),activityRegularizer:Dn(this.activityRegularizer),kernelConstraint:ks(this.kernelConstraint),recurrentConstraint:ks(this.recurrentConstraint),biasConstraint:ks(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Ew.className="GRUCell";Le(Ew);class ET extends Xo{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Ew(e),super(e)}call(e,t){return le(()=>{this.cell.dropoutMask!=null&&(Et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}ET.className="GRU";Le(ET);class Gy extends Vy{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,zs(this.units,"units"),this.activation=tc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=tc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Kn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Kn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Kn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Zn(e.kernelRegularizer),this.recurrentRegularizer=Zn(e.recurrentRegularizer),this.biasRegularizer=Zn(e.biasRegularizer),this.kernelConstraint=Ms(e.kernelConstraint),this.recurrentConstraint=Ms(e.recurrentConstraint),this.biasConstraint=Ms(e.biasConstraint),this.dropout=mp([1,Zl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=mp([1,Zl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=An(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const r=this.biasInitializer,o=this.units;i=new(t=class extends fo{apply(l,c){const u=r.apply([o]),h=new pw().apply([o]),d=r.apply([o*2]);return FN(FN(u,h),d)}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return le(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new ne(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=nc({ones:()=>Cr(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=nc({ones:()=>Cr(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,u,h;0<this.dropout&&this.dropout<1&&(e=K(e,o[0]));let d=fa(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=K(i,a[0])),d=Be(d,fa(i,this.recurrentKernel.read())),this.useBias&&(d=Yo(d,this.bias.read()));const[p,f,g,m]=Ki(d,4,d.rank-1);l=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(f),u=Be(K(c,r),K(l,this.activation.apply(g))),h=this.recurrentActivation.apply(m);const A=K(h,this.activation.apply(u));return[A,A,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ec(this.activation),recurrentActivation:ec(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ss(this.kernelInitializer),recurrentInitializer:ss(this.recurrentInitializer),biasInitializer:ss(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Dn(this.kernelRegularizer),recurrentRegularizer:Dn(this.recurrentRegularizer),biasRegularizer:Dn(this.biasRegularizer),activityRegularizer:Dn(this.activityRegularizer),kernelConstraint:ks(this.kernelConstraint),recurrentConstraint:ks(this.recurrentConstraint),biasConstraint:ks(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Gy.className="LSTMCell";Le(Gy);class _T extends Xo{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Gy(e),super(e)}call(e,t){return le(()=>{this.cell.dropoutMask!=null&&(Et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}_T.className="LSTM";Le(_T);class _w extends Vy{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return le(()=>{e=e;let s=e.slice(1);const i=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?i.push(s.splice(0,a.stateSize.length)):i.push(s.splice(0,1));i.reverse();const r=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=i[a],a===0?o=[e[0]].concat(s):o=[o[0]].concat(s),o=l.call(o,t),r.push(o.slice(1))}s=[];for(const a of r.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(e){v1(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,i)=>{fu(`RNNCell_${i}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),i={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),i)}static fromConfig(e,t,s={}){const i=[];for(const r of t.cells)i.push(Do(r,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return S1(e)}setWeights(e){const t=[];for(const s of this.cells){const i=s.weights.length,r=e.splice(i);for(let o=0;o<s.weights.length;++o)t.push([s.weights[o],r[o]])}eT(t)}}_w.className="StackedRNNCells";Le(_w);function nc(n){const{ones:e,rate:t,training:s=!1,count:i=1,dropoutFunc:r}=n,o=()=>r!=null?r(e(),t):QL(e(),t),a=()=>Oy(o,e,s);return!i||i<=1?Ts(a().clone()):Array(i).fill(void 0).map(a).map(c=>Ts(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var coe=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)e.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(t[s[i]]=n[s[i]]);return t};class kO extends Xo{constructor(e){if(e.unroll)throw new jt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new jt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new xs({ndim:5})]}call(e,t){return le(()=>{if(this.cell.dropoutMask!=null&&(Et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ne("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return le(()=>{const{stateSize:t}=this.cell,s=e.shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)],o=as(r);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){le(()=>{if(!this.stateful)throw new ia("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)];if(s[0]==null)throw new ne("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>as(r)):this.states_=[as(r)];else if(e==null)Et(this.states_),this.keptStates!=null&&(Et(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>as(r)):this.states_[0]=as(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ne(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Et(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],c=r;if(!qt(l.shape,c))throw new ne(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Ts(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:i,padding:r,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",c=e[l?3:2],u=e[l?4:3],h=Fo(c,i[0],r,o[0],a[0]),d=Fo(u,i[1],r,o[1],a[1]);return[...e.slice(0,2),...l?[s,h,d]:[h,d,s]]}}kO.className="ConvRNN2D";class Tw extends Gy{constructor(e){const{filters:t,kernelSize:s,strides:i,padding:r,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,zs(this.filters,"filters"),this.kernelSize=qd(s,2,"kernelSize"),this.kernelSize.forEach(l=>zs(l,"kernelSize")),this.strides=qd(i||1,2,"strides"),this.strides.forEach(l=>zs(l,"strides")),this.padding=r||"valid",jr(this.padding),this.dataFormat=o||"channelsLast",fs(this.dataFormat),this.dilationRate=qd(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>zs(l,"dilationRate"))}build(e){var t;e=An(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new ne(`The channel dimension of the input should be defined. Found ${e[s]}`);const i=e[s],r=4,o=this.kernelSize.concat([i,this.filters*r]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,u=this.filters;l=new(t=class extends fo{apply(d,p){const f=c.apply([u]),g=Xi([u]),m=c.apply([u*2]);return H_([f,g,m])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return le(()=>{if(e.length!==3)throw new ne(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,i=e[0],r=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=nc({ones:()=>Cr(i),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(te,se,fe)=>!se||!se[fe]?te:K(se[fe],te);let u=c(i,l,0),h=c(i,l,1),d=c(i,l,2),p=c(i,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=nc({ones:()=>Cr(r),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let g=c(r,f,0),m=c(r,f,1),A=c(r,f,2),y=c(r,f,3);const b=3,[x,C,w,E]=Ki(this.kernel.read(),a,b),[T,v,S,_]=this.useBias?Ki(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,x,T,this.padding),h=this.inputConv(h,C,v,this.padding),d=this.inputConv(d,w,S,this.padding),p=this.inputConv(p,E,_,this.padding);const[N,D,P,L]=Ki(this.recurrentKernel.read(),a,b);g=this.recurrentConv(g,N),m=this.recurrentConv(m,D),A=this.recurrentConv(A,P),y=this.recurrentConv(y,L);const z=this.recurrentActivation.apply(Be(u,g)),q=this.recurrentActivation.apply(Be(h,m)),V=Be(K(q,o),K(z,this.activation.apply(Be(d,A)))),X=K(this.recurrentActivation.apply(Be(p,y)),this.activation.apply(V));return[X,X,V]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=coe(e,["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(e,t,s,i){const r=il(e,t,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Yo(r,s,this.dataFormat):r}recurrentConv(e,t){return il(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}Tw.className="ConvLSTM2DCell";Le(Tw);class TT extends kO{constructor(e){const t=new Tw(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}TT.className="ConvLSTM2D";Le(TT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Bw extends sn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]==null?t[i]:this.noiseShape[i]);return s}call(e,t){return le(()=>{this.invokeCallHook(e,t);const s=Lt(e);if(0<this.rate&&this.rate<1){const i=t.training==null?!1:t.training,r=this.getNoiseShape(s);return Oy(()=>QL(s,this.rate,r,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}Bw.className="Dropout";Le(Bw);class BT extends Bw{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}BT.className="SpatialDropout1D";Le(BT);class kT extends sn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,zs(this.units,"units"),this.activation=tc(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Kn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Kn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ms(e.kernelConstraint),this.biasConstraint=Ms(e.biasConstraint),this.kernelRegularizer=Zn(e.kernelRegularizer),this.biasRegularizer=Zn(e.biasRegularizer),this.activityRegularizer=Zn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=An(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=An(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return le(()=>{this.invokeCallHook(e,t);const s=Lt(e),i=FL(this.activation.getClassName());let r;return i!=null?r=fa(s,this.kernel.read(),i,this.bias?this.bias.read():null):(r=fa(s,this.kernel.read()),this.bias!=null&&(r=Yo(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){const e={units:this.units,activation:ec(this.activation),useBias:this.useBias,kernelInitializer:ss(this.kernelInitializer),biasInitializer:ss(this.biasInitializer),kernelRegularizer:Dn(this.kernelRegularizer),biasRegularizer:Dn(this.biasRegularizer),activityRegularizer:Dn(this.activityRegularizer),kernelConstraint:ks(this.kernelConstraint),biasConstraint:ks(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}kT.className="Dense";Le(kT);class MT extends sn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=An(e);for(const t of e.slice(1))if(t==null)throw new ne(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ql(e,1)]}call(e,t){return le(()=>{this.invokeCallHook(e,t);let s=Lt(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const i=[0];for(let r=2;r<s.rank;++r)i.push(r);i.push(1),s=on(s,i)}return bie(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}MT.className="Flatten";Le(MT);class NT extends sn{constructor(e){super(e),this.supportsMasking=!0,this.activation=tc(e.activation)}call(e,t){return le(()=>{this.invokeCallHook(e,t);const s=Lt(e);return this.activation.apply(s)})}getConfig(){const e={activation:ec(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}NT.className="Activation";Le(NT);class RT extends sn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return le(()=>(e=Lt(e),yie(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}RT.className="RepeatVector";Le(RT);class DT extends sn{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",i=t.slice();let r=1,o=null;for(let l=0;l<i.length;++l){const c=i[l];if(this.isUnknown(c))if(o===null)o=l;else throw new ne("Can only specifiy one unknown dimension.");else r*=c}const a=Ql(e);if(o!==null){if(r===0||a%r!==0)throw new ne(s);i[o]=a/r}else if(a!==r)throw new ne(s);return i}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return le(()=>{this.invokeCallHook(e,t);const s=Lt(e),i=s.shape,r=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return ee(s,r)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}DT.className="Reshape";Le(DT);class FT extends sn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Lo(1,e.dims.length+1);if(!qt(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new xs({ndim:this.dims.length+1})]}computeOutputShape(e){e=An(e);const t=e.slice();return this.dims.forEach((s,i)=>{t[i+1]=e[s]}),t}call(e,t){return on(Lt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}FT.className="Permute";Le(FT);class $T extends sn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=Lt(e);return Ng(Tu(s,this.maskValue),-1)}call(e,t){return le(()=>{this.invokeCallHook(e,t);const s=Lt(e),o=Ng(Tu(s,this.maskValue),-1,!0);return K(s,We(o,s.dtype))})}}$T.className="Masking";Le($T);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class PT extends sn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(wn(e.inputLength))}this.inputDim=e.inputDim,zs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,zs(this.outputDim,"outputDim"),this.embeddingsInitializer=Kn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Zn(e.embeddingsRegularizer),this.activityRegularizer=Zn(e.activityRegularizer),this.embeddingsConstraint=Ms(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return le(()=>this.maskZero?(e=Lt(e),Tu(e,an(e))):null)}computeOutputShape(e){if(e=An(e),this.inputLength==null)return[...e,this.outputDim];const t=wn(this.inputLength);if(t.length!==e.length-1)throw new ne(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<t.length;++i){const r=t[i],o=e[i+1];if(r!=null&&o!=null&&r!==o)throw new ne(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[s]=o),s++}}return[e[0],...t,this.outputDim]}call(e,t){return le(()=>{this.invokeCallHook(e,t);let s=Lt(e);s.dtype!=="int32"&&(s=pa(s,"int32"));const i=UL(this.embeddings.read(),ee(s,[s.size]));return ee(i,An(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ss(this.embeddingsInitializer),embeddingsRegularizer:Dn(this.embeddingsRegularizer),activityRegularizer:Dn(this.activityRegularizer),embeddingsConstraint:ks(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}PT.className="Embedding";Le(PT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Kh extends sn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new jt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let i=0;i<t.length;++i){const r=e[e.length-t.length+i],o=t[i];if(r==null||o==null||r<0||o<0)s.push(null);else if(r===1)s.push(o);else if(o===1)s.push(r);else{if(r!==o)throw new ne("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(r)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[An(e)]),e=e,e.length<2)throw new ne(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=Ul(t),t.length>1)throw new ne(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){const o=e[r]==null?null:e[r].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const i=e.map(r=>r.length);e.indexOf(null)===-1&&Ul(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return le(()=>{if(e=e,this.reshapeRequired){const s=[],i=e.map(r=>r.rank);if(i.indexOf(null)===-1){const r=Zl(i);for(let o of e){const a=o.rank;for(let l=0;l<r-a;++l)o=Py(o,1);s.push(o)}return this.mergeFunction(s)}else{let r=!1;for(const l of e){const c=l.rank;if(c==null){const u=l.shape,h=u[0],d=u.slice(1).concat([h]);let p=ee(l,[h].concat(Ql(u.slice(1))));p=on(p,[1,0]),p=ee(p,d),s.push(p),r=!0}else if(c>1){const u=Lo(1,c).concat([0]);s.push(on(l,u)),r=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(r){if(a==null){const l=o.shape,c=l.length,u=l[c-1],h=[u].concat(l.slice(0,l.length-1));o=ee(on(ee(o,[-1,u]),[1,0]),h)}else if(a>1){const l=[a-1].concat(Lo(0,a-1));o=on(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let i=1;i<e.length;++i){const r=e[i]==null?null:e[i].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let s=[];for(const i of e)i!=null&&i[0]!==null&&s.push(i[0]);return s=Ul(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return le(()=>{if(t==null)return null;if(!Array.isArray(t))throw new ne("`mask` should be an Array");if(!Array.isArray(e))throw new ne("`inputs` should be an Array");if(t.length!==e.length)throw new ne(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(i=>i==null))return null;t=t.map(i=>i==null?i:rs(i,0));let s=t[0];for(let i=1;i<t.length-1;++i)s=uo(s,t[i]);return s})}}let LT=class extends Kh{constructor(e){super(e)}mergeFunction(e){return le(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Be(t,e[s]);return t})}};LT.className="Add";Le(LT);class OT extends Kh{constructor(e){super(e)}mergeFunction(e){return le(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=K(t,e[s]);return t})}}OT.className="Multiply";Le(OT);class zT extends Kh{constructor(e){super(e)}mergeFunction(e){return le(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Be(t,e[s]);return K(1/e.length,t)})}}zT.className="Average";Le(zT);class UT extends Kh{constructor(e){super(e)}mergeFunction(e){return le(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Ea(t,e[s]);return t})}}UT.className="Maximum";Le(UT);class QT extends Kh{constructor(e){super(e)}mergeFunction(e){return le(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=ol(t,e[s]);return t})}}QT.className="Minimum";Le(QT);class VT extends Kh{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ne("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const i of e)if(i!=null){t=!1;break}if(t)return;const s=[];for(let i=0;i<e.length;++i){const r=e[i].slice();r.splice(this.axis,1);let o=!1;for(const a of s)if(qt(a,r)){o=!0;break}o||s.push(r)}if(s.length>1)throw new ne("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return le(()=>H_(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ne("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const r of t.slice(1)){if(s[i]==null||r[i]==null){s[i]=null;break}s[i]+=r[i]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new ne("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ne("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ne(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return le(()=>{let s=!0;if(t.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const i=[];for(let o=0;o<e.length;++o)t[o]==null?i.push(We(Cr(e[o]),"bool")):t[o].rank<e[o].rank?i.push(rs(t[o],-1)):i.push(t[o]);const r=Jn(i,this.axis);return lC(r,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}VT.className="Concatenate";Le(VT);function Sm(n,e){for(;n<0;)n+=e;return n}function uoe(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new jt("batchDot is not implemented for tensors of 4D or higher rank yet");if(R(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),R(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new jt("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,i=e.shape.length;t==null&&(t=[s-1,i-2]);const r=t;return le(()=>{let o;if(s>i){o=s-i;const l=[];for(let c=0;c<o;++c)l.push(1);e=ee(e,e.shape.concat(l))}else if(i>s){o=i-s;const l=[];for(let c=0;c<o;++c)l.push(1);n=ee(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)r[0]===r[1]?a=ft(K(n,e),r[0]):a=ft(K(on(n,[1,0]),e),r[1]);else{const l=r[0]!==n.shape.length-1,c=r[1]===e.shape.length-1;a=tn(n,e,l,c)}if(o>0){let l;s>i?l=s+i-3:l=s-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=mn(a,c)}return a.shape.length===1&&(a=rs(a,1)),a})}class GT extends Kh{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){R(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new jt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);if(t[i[0]]!==s[i[1]])throw new ne(`Dimension incompatibility: ${t[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ne(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],i;return Array.isArray(this.axes)?i=this.axes.map((r,o)=>Sm(r,e[o].shape.length)):i=[Sm(this.axes,t.shape.length),Sm(this.axes,s.shape.length)],this.normalize&&(t=Vb(t,i[0]),s=Vb(s,i[1])),uoe(t,s,i)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Sm(this.axes,e.length),Sm(this.axes,t.length)],s}computeOutputShape(e){R(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new jt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);t.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const r=t.concat(s);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}GT.className="Dot";Le(GT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class WT extends sn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return le(()=>{this.invokeCallHook(e,t);const s=Lt(e);return Oy(()=>Be(dw(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}WT.className="GaussianNoise";Le(WT);class HT extends sn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return le(()=>{this.invokeCallHook(e,t);const s=Lt(e);return this.rate>0&&this.rate<1?Oy(()=>{const r=Math.sqrt(this.rate/(1-this.rate));return K(s,dw(s.shape,1,r))},()=>s,t.training||!1):s})}}HT.className="GaussianDropout";Le(HT);class qT extends sn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Lt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return le(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Oy(()=>{const r=Lt(e),a=-1.6732632423543772*1.0507009873554805;let l=dl(fc(s),this.rate);l=pa(l,"float32");const c=((1-this.rate)*(1+this.rate*a**2))**-.5,u=-c*a*this.rate,h=Be(K(r,l),K(Be(l,-1),a));return Be(K(h,c),u)},()=>Lt(e),t.training||!1)}return e})}}qT.className="AlphaDropout";Le(qT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lg(n,e,t,s,i,r=.001){let o;if(n.rank===2)o=F2(n,e,t,s,i,r);else if(n.rank===3)o=$2(n,e,t,s,i,r);else if(n.rank===4)o=P2(n,e,t,s,i,r);else throw new jt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function hoe(n,e,t,s,i=.001){return le(()=>{const r=Cy(n,s),o=r.mean,a=r.variance;return[Lg(n,o,a,t,e,i),o,a]})}function doe(n,e,t,s,i=.001){return le(()=>{const r=Cy(n,s),o=r.mean,a=r.variance,l=[];for(const f of Lo(0,n.rank))s.indexOf(f)!==-1?l.push(1):l.push(n.shape[f]);const c=ee(o,l),u=ee(a,l),h=e==null?null:ee(e,l),d=t==null?null:ee(t,l);return[Lg(n,c,u,d,h,i),o,a]})}function poe(n,e,t,s,i=.001){return qt(s.slice().sort(),Lo(0,n.rank-1))?hoe(n,e,t,s,i):doe(n,e,t,s,i)}class YT extends sn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Kn(e.betaInitializer||"zeros"),this.gammaInitializer=Kn(e.gammaInitializer||"ones"),this.movingMeanInitializer=Kn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Kn(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ms(e.betaConstraint),this.gammaConstraint=Ms(e.gammaConstraint),this.betaRegularizer=Zn(e.betaRegularizer),this.gammaRegularizer=Zn(e.gammaRegularizer)}build(e){e=An(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new ne(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new xs({ndim:e.length,axes:{[t]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return le(()=>{const s=t.training==null?!1:t.training,i=Lt(e),r=i.shape,o=r.length,a=Lo(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=Mu(1,o);c[l]=r[l];const u=a.slice();u.sort();const h=!qt(u,Lo(0,o).slice(0,o-1)),d=()=>{if(h){const y=ee(this.movingMean.read(),c),b=ee(this.movingVariance.read(),c),x=this.center?ee(this.beta.read(),c):null,C=this.scale?ee(this.gamma.read(),c):null;return Lg(i,y,b,x,C,this.epsilon)}else return Lg(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[p,f,g]=poe(i,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(y,b,x)=>{le(()=>{const C=1-x,w=y.read(),E=K(nt(w,b),C);y.write(nt(w,E))})};return(()=>{m(this.movingMean,f,this.momentum),m(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ss(this.betaInitializer),gammaInitializer:ss(this.gammaInitializer),movingMeanInitializer:ss(this.movingMeanInitializer),movingVarianceInitializer:ss(this.movingVarianceInitializer),betaRegularizer:Dn(this.betaRegularizer),gammaRegularizer:Dn(this.gammaRegularizer),betaConstraint:ks(this.betaConstraint),gammaConstraint:ks(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}YT.className="BatchNormalization";Le(YT);class XT extends sn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Kn(e.betaInitializer||"zeros"),this.gammaInitializer=Kn(e.gammaInitializer||"ones"),this.betaRegularizer=Zn(e.betaRegularizer),this.gammaRegularizer=Zn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=An(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==Ul(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(r=>e[r]),i=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(e,t){const s=Lt(e),i=s.shape,r=i.length;return le(()=>{let{mean:a,variance:l}=Cy(s,this.axis,!0);const c=Mu(1,r);for(const g of this.axis)c[g]=i[g];const u=g=>g!=null&&g.shape.length!==r?ee(g,c):g;let h=this.scale?u(this.gamma.read()):null,d=this.center?u(this.beta.read()):null;const p=[],f=[];for(let g=0;g<r;++g)this.axis.indexOf(g)!==-1?(p.push(i[g]),f.push(1)):(p.push(1),f.push(i[g]));return a=Or(a,p),l=Or(l,p),h!=null&&(h=Or(h,f)),d!=null&&(d=Or(d,f)),Lg(s,a,l,d,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ss(this.betaInitializer),gammaInitializer:ss(this.gammaInitializer),betaRegularizer:Dn(this.betaRegularizer),gammaRegularizer:Dn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}XT.className="LayerNormalization";Le(XT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function foe(n,e,t){return le(()=>{if(n.rank!==4)throw new ne(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new ne("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Oo()),t!=="channelsLast"&&t!=="channelsFirst")throw new ne(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],ho(n,s)})}class jT extends sn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Oo():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ne(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ne(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new ne(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new xs({ndim:4})]}computeOutputShape(e){e=An(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return le(()=>foe(Lt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}jT.className="ZeroPadding2D";Le(jT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kw(n,e,t,s,i,r){return le(()=>{fs(i),PL(r),jr(s),t==null&&(t=[1,1]),s==null&&(s="valid"),i==null&&(i=Oo()),r==null&&(r="max"),n=yT(n,i);let o;const a=s==="same"?"same":"valid";return r==="max"?o=Iy(n,e,t,a):o=py(n,e,t,a),i==="channelsFirst"&&(o=on(o,[0,3,1,2])),o})}function MO(n,e,t,s,i,r){return le(()=>{fs(i),PL(r),jr(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),i==null&&(i=Oo()),r==null&&(r="max"),n=EO(n,i);let o;const a=s==="same"?"same":"valid";return r==="max"?o=o_(n,e,t,a):o=D2(n,e,t,a),i==="channelsFirst"&&(o=on(o,[0,4,1,2,3])),o})}class NO extends sn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ne(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(zs(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ne(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);zs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,jr(this.padding),this.inputSpec=[new xs({ndim:3})]}computeOutputShape(e){e=An(e);const t=Fo(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return le(()=>{this.invokeCallHook(e,t),e=Py(Lt(e),2);const s=this.poolingFunction(Lt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return mn(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class KT extends NO{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return fs(r),jr(i),kw(e,t,s,i,r,"max")}}KT.className="MaxPooling1D";Le(KT);class JT extends NO{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return fs(r),jr(i),kw(e,t,s,i,r,"avg")}}JT.className="AveragePooling1D";Le(JT);class RO extends sn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ne(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];zs(this.poolSize,"poolSize"),zs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,fs(this.dataFormat),jr(this.padding),this.inputSpec=[new xs({ndim:4})]}computeOutputShape(e){e=An(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Fo(t,this.poolSize[0],this.padding,this.strides[0]),s=Fo(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return le(()=>(this.invokeCallHook(e,t),this.poolingFunction(Lt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class ZT extends RO{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return fs(r),jr(i),kw(e,t,s,i,r,"max")}}ZT.className="MaxPooling2D";Le(ZT);class eB extends RO{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return fs(r),jr(i),kw(e,t,s,i,r,"avg")}}eB.className="AveragePooling2D";Le(eB);class DO extends sn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ne(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];zs(this.poolSize,"poolSize"),zs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,fs(this.dataFormat),jr(this.padding),this.inputSpec=[new xs({ndim:5})]}computeOutputShape(e){e=An(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Fo(t,this.poolSize[0],this.padding,this.strides[0]),s=Fo(s,this.poolSize[1],this.padding,this.strides[1]),i=Fo(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,i]:[e[0],t,s,i,e[4]]}call(e,t){return le(()=>(this.invokeCallHook(e,t),this.poolingFunction(Lt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class tB extends DO{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return fs(r),jr(i),MO(e,t,s,i,r,"max")}}tB.className="MaxPooling3D";Le(tB);class nB extends DO{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return fs(r),jr(i),MO(e,t,s,i,r,"avg")}}nB.className="AveragePooling3D";Le(nB);class FO extends sn{constructor(e){super(e),this.inputSpec=[new xs({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new jt}}class sB extends FO{constructor(e){super(e||{})}call(e,t){return le(()=>{const s=Lt(e);return ts(s,1)})}}sB.className="GlobalAveragePooling1D";Le(sB);class iB extends FO{constructor(e){super(e||{})}call(e,t){return le(()=>{const s=Lt(e);return Gr(s,1)})}}iB.className="GlobalMaxPooling1D";Le(iB);class $O extends sn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,fs(this.dataFormat),this.inputSpec=[new xs({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new jt}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class rB extends $O{call(e,t){return le(()=>{const s=Lt(e);return this.dataFormat==="channelsLast"?ts(s,[1,2]):ts(s,[2,3])})}}rB.className="GlobalAveragePooling2D";Le(rB);class oB extends $O{call(e,t){return le(()=>{const s=Lt(e);return this.dataFormat==="channelsLast"?Gr(s,[1,2]):Gr(s,[2,3])})}}oB.className="GlobalMaxPooling2D";Le(oB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class PO extends sn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const i=t.layer,r=Do(i,s);delete t.layer;const o={layer:r};return Object.assign(o,t),new e(o)}}class aB extends PO{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=An(e),e.length<3)throw new ne(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=An(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),i=e[1];return[s[0],i].concat(s.slice(1))}call(e,t){return le(()=>(e=Lt(e),BO((o,a)=>[Lt(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}aB.className="TimeDistributed";Le(aB);function moe(n){Xh(pie,"BidirectionalMergeMode",n)}const goe="concat";class lB extends PO{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=Do(s),t.goBackwards=t.goBackwards!==!0;const i={};if(i.className=e.layer.getClassName(),i.config=t,this.backwardLayer=Do(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?goe:e.mergeMode,moe(this.mergeMode),e.weights)throw new jt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,i,r;return this.returnState&&(r=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,i=[s]):this.mergeMode==null?i=[s,s.slice()]:i=[s],this.returnState?this.mergeMode==null?i.concat(r).concat(r.slice()):[s].concat(r).concat(r.slice()):qi(i)}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=TO(e,s,i,this.numConstants);if(e=r.inputs,s=r.initialState,i=r.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&i==null)return super.apply(e,t);const o=[],a=[];if(s!=null){const c=s.length;if(c%2>0)throw new ne("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,o.push(...s);const u=s.map(h=>new xs({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),a.push(...u)}if(i!=null)throw new jt("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof zo;for(const c of o)if(c instanceof zo!==l)throw new ne("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const d=super.apply(c,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return le(()=>{const s=t.initialState;let i,r;if(s==null)i=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let o;this.returnState&&(Array.isArray(i)&&(o=i.slice(1).concat(r.slice(1))),i=i[0],r=r[0]),this.returnSequences&&(r=qr(r,1));let a;return this.mergeMode==="concat"?a=H_([i,r]):this.mergeMode==="sum"?a=Be(i,r):this.mergeMode==="ave"?a=K(.5,Be(i,r)):this.mergeMode==="mul"?a=K(i,r):this.mergeMode==null&&(a=[i,r]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){fu(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),fu(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const r=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(r).concat(r):[s].concat(r).concat(r)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=Do(t.layer);if(delete t.layer,t.numConstants!=null)throw new jt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=t;return i.layer=s,new e(i)}}lB.className="Bidirectional";Le(lB);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cB extends sn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return le(()=>(e=Lt(e),e.dtype!=="float32"&&(e=pa(e,"float32")),Be(K(e,this.scale),this.offset)))}}cB.className="Rescaling";Le(cB);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:Aoe,cropAndResize:yoe}=ii;class uB extends sn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,i,r,o,a,l){return le(()=>{let c,u=!1;const h=t/o,d=s/a,p=(i+t)/o,f=(r+s)/a,g=[h,d,p,f],m=[];e.rank===3?(u=!0,c=$i([e])):c=e;for(let C=0;C<c.shape[0];C++)m.push(g);const A=Ar(m,[m.length,4]),y=Bu(0,m.length,1,"int32"),x=yoe(c,A,y,[i,r],"nearest");return pa(u?Lt(Yr(x)):x,l)})}upsize(e,t,s,i){return le(()=>{const r=Aoe(e,[t,s]);return pa(r,i)})}call(e,t){return le(()=>{const s=Lt(e),i=s.dtype,r=s.shape,o=r[r.length-3],a=r[r.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,o,a,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=An(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}uB.className="CenterCrop";Le(uB);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function xoe(n,e,t,s){let i=Lt(n);if(i.dtype!=="int32"&&(i=pa(i,"int32")),e==="int")return i;const r=i.shape;if(i.rank===0&&(i=rs(i,-1)),e==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=rs(i,-1)),i.rank>2)throw new ne(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${r} which would result in output rank ${i.rank}.`);const o=["multiHot","oneHot"].includes(e),a=i;let l;if(typeof s<"u"&&e==="count"?l=Pb(a,s,t,o):l=Pb(a,[],t,o),e!=="tfIdf")return l;if(s)return K(l,s);throw new ne("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hB extends sn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=An(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return le(()=>{e=Lt(e),e.dtype!=="int32"&&(e=pa(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new ne(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=Lt(t.countWeights)}const i=Gr(e),r=cp(e),o=zi(this.numTokens,i).bufferSync().get(0),a=dl(r,0).bufferSync().get(0);if(!(o&&a))throw new ne(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return xoe(e,this.outputMode,this.numTokens,s)})}}hB.className="CategoryEncoding";Le(hB);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const boe=["bilinear","nearest"],ZN=new Set(boe);class dB extends sn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(ZN.has(e.interpolation))this.interpolation=e.interpolation;else throw new ne(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=An(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return le(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return ii.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return ii.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ZN]} are supported`)})}}dB.className="Resizing";Le(dB);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class LO{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}LO.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class OO extends sn{constructor(e){super(e),this.randomGenerator=new LO(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}OO.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ioe=["bilinear","nearest"],eR=new Set(Ioe);class pB extends OO{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ne(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ne(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ne(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(eR.has(s))this.interpolation=s;else throw new ne(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=An(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return le(()=>{const s=Lt(e);this.imgHeight=s.shape[s.shape.length-3];const i=s.shape[s.shape.length-2];this.widthFactor=fc([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*i;r=Math.round(r);const o=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return ii.resizeBilinear(e,o);case"nearest":return ii.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...eR]} are supported`)}})}}pB.className="RandomWidth";Le(pB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Coe(n){return new Lf(n)}function woe(n){return new mT(n)}function voe(n){return new dT(n)}function Soe(n){return new pT(n)}function Eoe(n){return new fT(n)}function _oe(n){return new AT(n)}function Toe(n){return new gT(n)}function Boe(n){return new Qy(n)}function koe(n){return new Uf(n)}function Moe(n){return new xT(n)}function Noe(n){return new Qf(n)}function Roe(n){return new bT(n)}function Doe(n){return new IT(n)}function Foe(n){return new CT(n)}function $oe(n){return new wT(n)}function Poe(n){return new vT(n)}function Loe(n){return new NT(n)}function Ooe(n){return new kT(n)}function zoe(n){return new Bw(n)}function Uoe(n){return new BT(n)}function Qoe(n){return new MT(n)}function Voe(n){return new RT(n)}function Goe(n){return new DT(n)}function Woe(n){return new FT(n)}function Hoe(n){return new PT(n)}function qoe(n){return new LT(n)}function Yoe(n){return new zT(n)}function Xoe(n){return new VT(n)}function joe(n){return new UT(n)}function Koe(n){return new QT(n)}function Joe(n){return new OT(n)}function Zoe(n){return new GT(n)}function eae(n){return new YT(n)}function tae(n){return new XT(n)}function nae(n){return new jT(n)}function fB(n){return new JT(n)}function sae(n){return fB(n)}function iae(n){return fB(n)}function mB(n){return new eB(n)}function rae(n){return mB(n)}function oae(n){return mB(n)}function gB(n){return new nB(n)}function aae(n){return gB(n)}function lae(n){return gB(n)}function cae(n){return new sB(n)}function uae(n){return new rB(n)}function zO(n){return new iB(n)}function UO(n){return new oB(n)}function QO(n){return new KT(n)}function VO(n){return new ZT(n)}function hae(n){return new tB(n)}function dae(n){return new ET(n)}function pae(n){return new Ew(n)}function fae(n){return new _T(n)}function mae(n){return new Gy(n)}function gae(n){return new ST(n)}function Aae(n){return new Sw(n)}function yae(n){return new TT(n)}function xae(n){return new Tw(n)}function bae(n){return new Xo(n)}function Iae(n){return new _w(n)}function Cae(n){return new lB(n)}function wae(n){return new aB(n)}const vae=zO,Sae=UO,Eae=QO,_ae=VO;function Tae(n){return new WT(n)}function Bae(n){return new HT(n)}function kae(n){return new qT(n)}function Mae(n){return new $T(n)}function Nae(n){return new cB(n)}function Rae(n){return new uB(n)}function Dae(n){return new dB(n)}function Fae(n){return new hB(n)}function $ae(n){return new pB(n)}const Pae=Object.freeze(Object.defineProperty({__proto__:null,Layer:sn,RNN:Xo,RNNCell:Vy,activation:Loe,add:qoe,alphaDropout:kae,average:Yoe,averagePooling1d:fB,averagePooling2d:mB,averagePooling3d:gB,avgPool1d:sae,avgPool2d:rae,avgPool3d:aae,avgPooling1d:iae,avgPooling2d:oae,avgPooling3d:lae,batchNormalization:eae,bidirectional:Cae,categoryEncoding:Fae,centerCrop:Rae,concatenate:Xoe,conv1d:Boe,conv2d:koe,conv2dTranspose:Moe,conv3d:Noe,conv3dTranspose:Roe,convLstm2d:yae,convLstm2dCell:xae,cropping2D:Foe,dense:Ooe,depthwiseConv2d:Poe,dot:Zoe,dropout:zoe,elu:woe,embedding:Hoe,flatten:Qoe,gaussianDropout:Bae,gaussianNoise:Tae,globalAveragePooling1d:cae,globalAveragePooling2d:uae,globalMaxPool1d:vae,globalMaxPool2d:Sae,globalMaxPooling1d:zO,globalMaxPooling2d:UO,gru:dae,gruCell:pae,input:cO,inputLayer:Coe,layerNormalization:tae,leakyReLU:Soe,lstm:fae,lstmCell:mae,masking:Mae,maxPool1d:Eae,maxPool2d:_ae,maxPooling1d:QO,maxPooling2d:VO,maxPooling3d:hae,maximum:joe,minimum:Koe,multiply:Joe,permute:Woe,prelu:Eoe,randomWidth:$ae,reLU:voe,repeatVector:Voe,rescaling:Nae,reshape:Goe,resizing:Dae,rnn:bae,separableConv2d:Doe,simpleRNN:gae,simpleRNNCell:Aae,softmax:_oe,spatialDropout1d:Uoe,stackedRNNCells:Iae,thresholdedReLU:Toe,timeDistributed:wae,upSampling2d:$oe,zeroPadding2d:nae},Symbol.toStringTag,{value:"Module"}));function Lae(n,e){return aT(n,e)}function Oae(n,e){return eO(n,e)}function zae(n,e){return tO(n,e)}function Uae(n,e){return lT(n,e)}function Qae(n,e){return cT(n,e)}function Vae(n,e){return ZL(n,e)}function Gae(n,e){return Ire(n,e)}function Wae(n,e){return oT(n,e)}function Hae(n,e){return Iw(n,e)}function qae(n,e){return Of(n,e)}function Yae(n,e){return Of(n,e)}function Xae(n,e){return Of(n,e)}function jae(n,e){return jh(n,e)}function Kae(n,e){return jh(n,e)}function Jae(n,e){return jh(n,e)}function Zae(n,e){return Cre(n,e)}const ele=Object.freeze(Object.defineProperty({__proto__:null,MAPE:Yae,MSE:Kae,binaryAccuracy:Lae,binaryCrossentropy:Oae,categoricalAccuracy:Uae,categoricalCrossentropy:Qae,cosineProximity:Wae,mape:Xae,meanAbsoluteError:Hae,meanAbsolutePercentageError:qae,meanSquaredError:jae,mse:Jae,precision:Vae,r2Score:Zae,recall:Gae,sparseCategoricalAccuracy:zae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const tle=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:Kre},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nle(n){return new Uy(n)}function sle(n){return ioe(n)}function ile(n){return roe(n)}const rle=Object.freeze(Object.defineProperty({__proto__:null,l1:sle,l1l2:nle,l2:ile},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class GO extends gp{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof ja))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function i0(n,e){return n<e}function tR(n,e){return n>e}class WO extends GO{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new jt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=i0:this.mode==="max"?this.monitorFunc=tR:this.monitor.indexOf("acc")!==-1?this.monitorFunc=tR:this.monitorFunc=i0,this.monitorFunc===i0&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===i0?1/0:-1/0}async onEpochEnd(e,t){await Tl(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function ole(n){return new WO(n)}const ale={earlyStopping:ole};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lle=ae();lle.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var hr;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(hr||(hr={}));var nR;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(nR||(nR={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AB={};function cle(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};AB[n]=t}function HO(n){return AB[n]}function ule(n){delete AB[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k(n,e,t,s,i){const r=e.inputParams[n];if(r&&r.inputIndexStart!==void 0){const a=r.inputIndexStart,l=r.inputIndexEnd===0?void 0:r.inputIndexEnd===void 0?a+1:r.inputIndexEnd,c=a<0?e.inputNames.length+a:a;if(r.type==="tensor")return ti(e.inputNames[c],t,s,i);if(r.type==="tensors"){const d=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((f,g)=>{var m;return((m=d[g])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(f=>ti(f,t,s,i))}const u=ti(e.inputNames[c],t,s,i),h=u.dataSync();return r.type==="number"?h[0]:Vr(u.shape,h)}const o=e.attrParams[n];return o&&o.value}function ti(n,e,t,s){const[i,r]=pr(n,t);if(s!=null){const a=s.getHashTableHandleByName(i);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[Yb(i,a)]);return o!==void 0?e[Yb(i,o)][r]:void 0}function sR(n,e,t){return e[Yb(n,t.currentContextId)]}function za(n,e){const[t,s,i]=pr(n,e);return[Yb(t,e&&e.currentContextId),s,i]}function Yb(n,e){return e?`${n}-${e}`:n}function pr(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const r=e.parseNodeNameCache.get(n);if(r!=null)return r}const s=n.split(":");let i;if(s.length===1)i=[n,0,void 0];else{const r=s[0],o=s.length===3?s[1]:void 0,a=Number(s[s.length-1]);i=[r,a,o]}return t&&e.parseNodeNameCache.set(n,i),i}function k0(n,e,t){let s=k("pad",n,e,t);if(s==="explicit"){s=k("explicitPaddings",n,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let r=0;r<4;r++)i[r][0]=s[r*2],i[r][1]=s[r*2+1];return i}return s}function Ua(n){return n.kept?n:da(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hle=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dle=Object.freeze(Object.defineProperty({__proto__:null,json:hle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ple=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],fle=Object.freeze(Object.defineProperty({__proto__:null,json:ple},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mle=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],gle=Object.freeze(Object.defineProperty({__proto__:null,json:mle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ale=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],yle=Object.freeze(Object.defineProperty({__proto__:null,json:Ale},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xle=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],ble=Object.freeze(Object.defineProperty({__proto__:null,json:xle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ile=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Cle=Object.freeze(Object.defineProperty({__proto__:null,json:Ile},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wle=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],vle=Object.freeze(Object.defineProperty({__proto__:null,json:wle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sle=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ele=Object.freeze(Object.defineProperty({__proto__:null,json:Sle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _le=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Tle=Object.freeze(Object.defineProperty({__proto__:null,json:_le},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ble=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],kle=Object.freeze(Object.defineProperty({__proto__:null,json:Ble},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mle=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Nle=Object.freeze(Object.defineProperty({__proto__:null,json:Mle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rle=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Dle=Object.freeze(Object.defineProperty({__proto__:null,json:Rle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fle=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],$le=Object.freeze(Object.defineProperty({__proto__:null,json:Fle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ple=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Lle=Object.freeze(Object.defineProperty({__proto__:null,json:Ple},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ole=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],zle=Object.freeze(Object.defineProperty({__proto__:null,json:Ole},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ule=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Qle=Object.freeze(Object.defineProperty({__proto__:null,json:Ule},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vle=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Gle=Object.freeze(Object.defineProperty({__proto__:null,json:Vle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wle=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Hle=Object.freeze(Object.defineProperty({__proto__:null,json:Wle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qle=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Yle=Object.freeze(Object.defineProperty({__proto__:null,json:qle},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iR{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[dle,fle,gle,yle,ble,Cle,vle,Ele,Tle,kle,Nle,Dle,$le,Lle,zle,Qle,Gle,Hle,Yle],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,i)=>(s[i.tfOpName]=i,s),{})}transformGraph(e,t={}){const s=e.node,i=[],r=[],o=[],a=s.reduce((g,m)=>(g[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?i.push(g[m.name]):m.op==="Const"?r.push(g[m.name]):(m.input==null||m.input.length===0)&&o.push(g[m.name]),g),{});let l=[];const c=[];let u={},h={};t!=null&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(a);d.forEach(g=>{const m=a[g];m.inputNames.forEach((A,y)=>{const[b,,x]=za(A),C=a[b];if(C.outputs!=null){const w=C.outputs.indexOf(x);if(w!==-1){const E=`${b}:${w}`;m.inputNames[y]=E}}m.inputs.push(C),C.children.push(m)})}),Object.keys(h).length===0?d.forEach(g=>{const m=a[g];m.children.length===0&&c.push(m)}):Object.keys(h).forEach(g=>{const[m]=za(g),A=a[m];A!=null&&(A.signatureKey=h[g],c.push(A))}),Object.keys(u).length>0?Object.keys(u).forEach(g=>{const[m]=za(g),A=a[m];A&&(A.signatureKey=u[g],l.push(A))}):l=i;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((g,m)=>(g[m.signature.name]=this.mapFunction(m),g),{}));const f={nodes:a,inputs:l,outputs:c,weights:r,placeholders:i,signature:t,functions:p};return o.length>0&&(f.initNodes=o),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=HO(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((i,r)=>(i[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},i),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((i,r)=>{const o=r.type;let a;switch(r.type){case"string":a=k1(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=k1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":a=P1(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=P1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":a=N1(e.attr,r.tfName,r.defaultValue||0),a===void 0&&r.tfDeprecatedName&&(a=N1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":a=$1(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=$1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":a=M1(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=M1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":a=O1(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=O1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":a=F1(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=F1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":a=L1(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=L1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":a=R1(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=R1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":a=D1(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=D1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":a=rR(e.attr,r.tfName,r.defaultValue),a===void 0&&r.tfDeprecatedName&&(a=rR(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return i[r.name]={value:a,type:o},i},{})),s}mapFunction(e){const t=e.nodeDef,s=[],i=[];let r={};t!=null&&(r=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&i.push(h[d.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[d]=za(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:yB(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,o.push(p),r[d]=p}),Object.keys(r).forEach(h=>{const d=r[h];d.inputNames.forEach((p,f)=>{const[g,,m]=za(p),A=r[g];if(A.outputs!=null){const y=A.outputs.indexOf(m);if(y!==-1){const b=`${g}:${y}`;d.inputNames[f]=b}}d.inputs.push(A),A.children.push(d)})});const c=e.ret;e.signature.outputArg.forEach(h=>{const[d,p]=za(c[h.name]),f=r[d];f!=null&&(f.defaultOutput=p,a.push(f))});const u=this.mapArgsToSignature(e);return{nodes:r,inputs:o,outputs:a,weights:i,placeholders:s,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function Xle(n){const e=ae().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function qO(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):Xle(n);return e?t:t.toLowerCase()}function k1(n,e,t,s=!1){const i=n[e];return i!=null?qO(i.s,s):t}function M1(n,e,t){const s=n[e];return s?s.b:t}function N1(n,e,t){const s=n[e]||{},i=s.i!=null?s.i:s.f!=null?s.f:t;return typeof i=="number"?i:parseInt(i,10)}function yB(n){switch(typeof n=="string"&&(n=hr[n]),n){case hr.DT_FLOAT:case hr.DT_HALF:return"float32";case hr.DT_INT32:case hr.DT_INT64:case hr.DT_INT8:case hr.DT_UINT8:return"int32";case hr.DT_BOOL:return"bool";case hr.DT_DOUBLE:return"float32";case hr.DT_STRING:return"string";case hr.DT_COMPLEX64:case hr.DT_COMPLEX128:return"complex64";default:return null}}function rR(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function R1(n,e,t){const s=n[e];return s&&s.type?yB(s.type):t}function D1(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(i=>yB(i)):t}function YO(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function F1(n,e,t){const s=n[e];return s&&s.shape?YO(s.shape):t}function $1(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function P1(n,e,t,s=!1){const i=n[e];return i&&i.list&&i.list.s?i.list.s.map(r=>qO(r,s)):t}function L1(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(i=>YO(i)):t}function O1(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jle{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,r)=>(i[r]=this.getAttr(r),i),{}))}getInput(e){return ti(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return ti(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return N1(this.node.rawAttrs,e,t);if(s.s!=null)return k1(this.node.rawAttrs,e,t);if(s.b!=null)return M1(this.node.rawAttrs,e,t);if(s.shape!=null)return F1(this.node.rawAttrs,e,t);if(s.type!=null)return R1(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return $1(this.node.rawAttrs,e,t);if(s.list.s!=null)return P1(this.node.rawAttrs,e,t);if(s.list.shape!=null)return L1(this.node.rawAttrs,e,t);if(s.list.b!=null)return O1(this.node.rawAttrs,e,t);if(s.list.type!=null)return D1(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ri=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:x2,abs:As,acos:S2,acosh:E2,add:Be,addN:P$,all:lC,any:Ng,argMax:jl,argMin:_2,asin:T2,asinh:B2,atan:k2,atan2:M2,atanh:N2,avgPool:py,avgPool3d:D2,basicLSTMCell:L$,batchNorm:kf,batchNorm2d:F2,batchNorm3d:$2,batchNorm4d:P2,batchToSpaceND:fy,bincount:L2,bitwiseAnd:O$,booleanMaskAsync:wP,broadcastArgs:z$,broadcastTo:pu,buffer:zt,cast:We,ceil:O2,clipByValue:Fi,clone:da,complex:sl,concat:Jn,concat1d:z2,concat2d:U2,concat3d:Q2,concat4d:V2,conv1d:cC,conv2d:il,conv2dTranspose:uC,conv3d:W2,conv3dTranspose:H2,cos:my,cosh:hC,cosineWindow:FC,cumprod:Fg,cumsum:dC,denseBincount:Pb,depthToSpace:q2,depthwiseConv2d:Mf,diag:Q$,dilation2d:Y2,div:et,divNoNan:X2,dot:j2,dropout:w_,einsum:Gc,elu:Nf,enclosingPowerOfTwo:v_,ensureShape:V$,equal:br,erf:pC,euclideanNorm:J2,exp:fi,expandDims:rs,expm1:Z2,eye:fC,fft:Ty,fill:Qh,floor:Df,floorDiv:aC,fused:NP,gather:Ff,gatherND:_P,greater:zi,greaterEqual:dl,ifft:fp,imag:gy,image:ii,inTopKAsync:TP,irfft:BC,isFinite:e_,isInf:t_,isNaN:n_,leakyRelu:Ay,less:up,lessEqual:pc,linalg:__,linspace:H$,localResponseNormalization:s_,log:Ir,log1p:yy,logSigmoid:i_,logSoftmax:gC,logSumExp:xy,logicalAnd:uo,logicalNot:by,logicalOr:AC,logicalXor:r_,losses:OP,lowerBound:Y$,matMul:tn,max:Gr,maxPool:Iy,maxPool3d:o_,maxPoolWithArgmax:X$,maximum:Ea,mean:ts,meshgrid:j$,min:cp,minimum:ol,mirrorPad:xC,mod:a_,moments:Cy,movingAverage:vP,mul:K,multiRNNCell:K$,multinomial:J$,neg:zn,norm:Rf,notEqual:Tu,oneHot:hp,ones:Xi,onesLike:Cr,op:Z,outerProduct:Z$,pad:ho,pad1d:eP,pad2d:tP,pad3d:nP,pad4d:sP,pool:l_,pow:Aa,prelu:vy,print:v2,prod:c_,raggedGather:iP,raggedRange:rP,raggedTensorToTensor:oP,rand:aP,randomGamma:uP,randomNormal:bC,randomStandardNormal:hP,randomUniform:fc,randomUniformInt:dP,range:Bu,real:dp,reciprocal:p_,relu:Ho,relu6:IC,reshape:ee,reverse:qr,reverse1d:pP,reverse2d:fP,reverse3d:mP,reverse4d:gP,rfft:By,round:CC,rsqrt:wC,scalar:wt,scatterND:SP,searchSorted:yC,selu:vC,separableConv2d:SC,setdiff1dAsync:AP,sigmoid:yr,sign:f_,signal:LP,sin:EC,sinh:_C,slice:$t,slice1d:Sy,slice2d:TC,slice3d:Ey,slice4d:pp,softmax:_y,softplus:Vh,spaceToBatchND:wy,sparse:zP,sparseToDense:EP,spectral:PP,split:Ki,sqrt:Hs,square:vn,squaredDifference:kC,squeeze:mn,stack:$i,step:Gh,stridedSlice:m_,string:UP,sub:nt,sum:ft,tan:g_,tanh:Jl,tensor:Ar,tensor1d:ls,tensor2d:Ji,tensor3d:A_,tensor4d:yP,tensor5d:xP,tensor6d:bP,tensorScatterUpdate:IP,tile:Or,topk:x_,transpose:on,truncatedNormal:NC,unique:b_,unsortedSegmentSum:RC,unstack:Yr,upperBound:CP,variable:I_,where:Qs,whereAsync:C_,zeros:as,zerosLike:an},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kle=(n,e,t,s=ri)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(k("a",n,e,t),k("b",n,e,t))];case"AddN":return[s.addN(k("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(k("a",n,e,t),k("b",n,e,t))];case"Mul":return[s.mul(k("a",n,e,t),k("b",n,e,t))];case"RealDiv":case"Div":return[s.div(k("a",n,e,t),k("b",n,e,t))];case"DivNoNan":return[s.divNoNan(k("a",n,e,t),k("b",n,e,t))];case"FloorDiv":return[s.floorDiv(k("a",n,e,t),k("b",n,e,t))];case"Sub":return[s.sub(k("a",n,e,t),k("b",n,e,t))];case"Minimum":return[s.minimum(k("a",n,e,t),k("b",n,e,t))];case"Maximum":return[s.maximum(k("a",n,e,t),k("b",n,e,t))];case"Pow":return[s.pow(k("a",n,e,t),k("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(k("a",n,e,t),k("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jle=(n,e,t,s=ri)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(k("x",n,e,t))];case"Acos":return[s.acos(k("x",n,e,t))];case"Acosh":return[s.acosh(k("x",n,e,t))];case"Asin":return[s.asin(k("x",n,e,t))];case"Asinh":return[s.asinh(k("x",n,e,t))];case"Atan":return[s.atan(k("x",n,e,t))];case"Atan2":return[s.atan2(k("x",n,e,t),k("y",n,e,t))];case"Atanh":return[s.atanh(k("x",n,e,t))];case"Ceil":return[s.ceil(k("x",n,e,t))];case"Complex":return[s.complex(k("real",n,e,t),k("imag",n,e,t))];case"Cos":return[s.cos(k("x",n,e,t))];case"Cosh":return[s.cosh(k("x",n,e,t))];case"Elu":return[s.elu(k("x",n,e,t))];case"Erf":return[s.erf(k("x",n,e,t))];case"Exp":return[s.exp(k("x",n,e,t))];case"Expm1":return[s.expm1(k("x",n,e,t))];case"Floor":return[s.floor(k("x",n,e,t))];case"Log":return[s.log(k("x",n,e,t))];case"Log1p":return[s.log1p(k("x",n,e,t))];case"Imag":return[s.imag(k("x",n,e,t))];case"Neg":return[s.neg(k("x",n,e,t))];case"Reciprocal":return[s.reciprocal(k("x",n,e,t))];case"Real":return[s.real(k("x",n,e,t))];case"Relu":return[s.relu(k("x",n,e,t))];case"Round":return[s.round(k("x",n,e,t))];case"Selu":return[s.selu(k("x",n,e,t))];case"Sigmoid":return[s.sigmoid(k("x",n,e,t))];case"Sin":return[s.sin(k("x",n,e,t))];case"Sign":return[s.sign(k("x",n,e,t))];case"Sinh":return[s.sinh(k("x",n,e,t))];case"Softplus":return[s.softplus(k("x",n,e,t))];case"Sqrt":return[s.sqrt(k("x",n,e,t))];case"Square":return[s.square(k("x",n,e,t))];case"Tanh":return[s.tanh(k("x",n,e,t))];case"Tan":return[s.tan(k("x",n,e,t))];case"ClipByValue":return[s.clipByValue(k("x",n,e,t),k("clipValueMin",n,e,t),k("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(k("x",n,e,t))];case"Rsqrt":return[s.rsqrt(ti(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(k("x",n,e,t),k("alpha",n,e,t))];case"Prelu":return[s.prelu(k("x",n,e,t),k("alpha",n,e,t))];case"IsNan":return[s.isNaN(ti(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(ti(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(ti(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function so(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){R(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const i=n[s],r=e[s];R(i<0||r<0||i===r,()=>t+` Shapes ${n} and ${e} must match`)}}}function oR(n){return!(typeof n=="number"||n.some(e=>e<0))}function Em(n,e,t){let s=z1(n,t);const i=!oR(s);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&e.forEach(r=>{s=z1(r.shape,s)}),!oR(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function z1(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const i=n[s],r=e[s];if(i>=0&&r>=0&&i!==r)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=i>=0?i:r}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zle{constructor(e,t,s,i,r,o,a){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=i,this.identicalElementShapes=r,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=wt(0),Ts(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),so(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,Ts(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,i)=>this.write(s,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return Ar([],[0].concat(this.elementShape));const s=this.readMany(e);return so(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),$i(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ar([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const s=this.readMany(t);return so(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Jn(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Yr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const i=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const r=s===0?0:t.size/s,o=[];le(()=>{t=ee(t,[1,s,r]);for(let l=0;l<e.length;++l){const u=[0,l===0?0:i[l-1],0],h=[1,e[l],r];o[l]=ee($t(t,u,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ru{get id(){return this.idTensor.id}constructor(e,t,s,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(r=>{if(s!==r.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${r.dtype}`);so(t,r.shape,"TensorList shape mismatch: "),Ts(r)}),this.idTensor=wt(0),this.maxNumElements=i,Ts(this.idTensor)}copy(){return new Ru([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);so(e,this.elementShape,"TensorList shape mismatch: ");const i=Em(this.elementShape,this.tensors,e);return le(()=>{const r=this.tensors.map(o=>ee(o,i));return $i(r,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Em(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,so(i.shape,e,"TensorList shape mismatch: "),ee(i,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(so(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ts(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Ru([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);so(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=Em(this.elementShape,this.tensors,t);return ee(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);so(this.elementShape,t.shape,"TensorList shape mismatch: "),Ts(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);so(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=Em(this.elementShape,this.tensors,s);return e.length===0?Ar([],[0].concat(i)):le(()=>{const r=e.map(o=>ee(this.tensors[o],i));return $i(r,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);so(this.elementShape,t,"TensorList shape mismatch: ");const s=Em(this.elementShape,this.tensors,t);return this.size()===0?Ar([],[0].concat(s)):le(()=>{const i=this.tensors.map(r=>ee(r,s));return Jn(i,0)})}}function ece(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const i=n.shape.slice(1);so(i,e,"TensorList shape mismatch: ");const r=Yr(n);return new Ru(r,e,s)}function tce(n,e,t,s){return new Ru([],n,e,s)}function nce(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const i=Math.max(...e);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);const r=new Ru([],t,n.dtype,s),o=Yr(n,0);return e.forEach((a,l)=>{r.setItem(a,o[l])}),r}function sce(n,e,t){let s=0;const i=e.map(u=>(s+=u,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const r=n.shape.slice(1),o=z1(r,t),a=s===0?0:n.size/s,l=le(()=>{const u=[];n=ee(n,[1,s,a]);for(let h=0;h<e.length;++h){const p=[0,h===0?0:i[h-1],0],f=[1,e[h],a];u[h]=ee($t(n,p,f),o)}return n.dispose(),u}),c=new Ru([],t,n.dtype,e.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ice=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=k("thenBranch",n,e,t),i=k("elseBranch",n,e,t),r=k("cond",n,e,t),o=k("args",n,e,t);return(await r.data())[0]?t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=k("body",n,e,t),i=k("cond",n,e,t),r=k("args",n,e,t),o=await t.functionMap[i].executeFunctionAsync(r,t.tensorArrayMap,t.tensorListMap),a=r.map(u=>u.id);let l=await o[0].data();o.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=r;for(;l[0];){const u=c;c=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const h=c.map(p=>p.id);u.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await t.functionMap[i].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return c}case"LoopCond":{const s=k("pred",n,e,t);return[Ua(s)]}case"Switch":{const s=k("pred",n,e,t);let i=k("data",n,e,t);return i.kept||(i=Ua(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=n.inputNames.find(i=>ti(i,e,t)!==void 0);if(s){const i=ti(s,e,t);return[Ua(i)]}return}case"Enter":{const s=k("frameName",n,e,t),i=k("tensor",n,e,t);return t.enterFrame(s),[Ua(i)]}case"Exit":{const s=k("tensor",n,e,t);return t.exitFrame(),[Ua(s)]}case"NextIteration":{const s=k("tensor",n,e,t);return t.nextIteration(),[Ua(s)]}case"TensorArrayV3":{const s=k("size",n,e,t),i=k("dtype",n,e,t),r=k("elementShape",n,e,t),o=k("dynamicSize",n,e,t),a=k("clearAfterRead",n,e,t),l=k("identicalElementShapes",n,e,t),c=k("name",n,e,t),u=new Zle(c,i,s,r,l,o,a);return t.addTensorArray(u),[u.idTensor,wt(1)]}case"TensorArrayWriteV3":{const s=k("tensorArrayId",n,e,t),i=k("index",n,e,t),r=k("tensor",n,e,t),o=t.getTensorArray(s.id);return o.write(i,r),[o.idTensor]}case"TensorArrayReadV3":{const s=k("tensorArrayId",n,e,t),i=k("index",n,e,t);return[t.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=k("tensorArrayId",n,e,t),i=k("indices",n,e,t),r=k("dtype",n,e,t);return[t.getTensorArray(s.id).gather(i,r)]}case"TensorArrayScatterV3":{const s=k("tensorArrayId",n,e,t),i=k("indices",n,e,t),r=k("tensor",n,e,t),o=t.getTensorArray(s.id);return o.scatter(i,r),[o.idTensor]}case"TensorArrayConcatV3":{const s=k("tensorArrayId",n,e,t),i=t.getTensorArray(s.id),r=k("dtype",n,e,t);return[i.concat(r)]}case"TensorArraySplitV3":{const s=k("tensorArrayId",n,e,t),i=k("tensor",n,e,t),r=k("lengths",n,e,t),o=t.getTensorArray(s.id);return o.split(r,i),[o.idTensor]}case"TensorArraySizeV3":{const s=k("tensorArrayId",n,e,t),i=t.getTensorArray(s.id);return[wt(i.size(),"int32")]}case"TensorArrayCloseV3":{const s=k("tensorArrayId",n,e,t),i=t.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=k("tensorListId",n,e,t),i=k("index",n,e,t),r=k("tensor",n,e,t),o=t.getTensorList(s.id);return o.setItem(i,r),[o.idTensor]}case"TensorListGetItem":{const s=k("tensorListId",n,e,t),i=k("index",n,e,t),r=k("elementShape",n,e,t),o=k("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(i,r,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=k("indices",n,e,t),i=k("tensor",n,e,t),r=k("elementShape",n,e,t),o=k("numElements",n,e,t),a=nce(i,s,r,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=k("elementShape",n,e,t),i=k("elementDType",n,e,t);let r;n.op==="TensorListReserve"?r="numElements":r="maxNumElements";const o=k(r,n,e,t),a=n.op==="TensorListReserve"?-1:o,l=tce(s,i,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=k("tensorListId",n,e,t),i=k("indices",n,e,t),r=k("elementShape",n,e,t),o=k("elementDType",n,e,t);return[t.getTensorList(s.id).gather(i,o,r)]}case"TensorListStack":{const s=k("tensorListId",n,e,t),i=k("elementShape",n,e,t),r=k("elementDType",n,e,t),o=k("numElements",n,e,t);return[t.getTensorList(s.id).stack(i,r,o)]}case"TensorListFromTensor":{const s=k("tensor",n,e,t),i=k("elementShape",n,e,t),r=k("elementDType",n,e,t),o=ece(s,i,r);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=k("tensorListId",n,e,t),i=t.getTensorList(s.id),r=k("dtype",n,e,t),o=k("elementShape",n,e,t);return[i.concat(r,o)]}case"TensorListPushBack":{const s=k("tensorListId",n,e,t),i=k("tensor",n,e,t),r=t.getTensorList(s.id);return r.pushBack(i),[r.idTensor]}case"TensorListPopBack":{const s=k("tensorListId",n,e,t),i=k("elementShape",n,e,t),r=k("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(i,r)]}case"TensorListSplit":{const s=k("tensor",n,e,t),i=k("elementShape",n,e,t),r=k("lengths",n,e,t),o=sce(s,r,i);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const s=k("tensorListId",n,e,t),i=t.getTensorList(s.id);return[wt(i.size(),"int32")]}case"TensorListResize":{const s=k("tensorListId",n,e,t),i=k("size",n,e,t),o=t.getTensorList(s.id).resize(i);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(n,e,t){const[s,i]=k("fusedOps",n,e,t),r=s==="biasadd",o=!r,a=i==="prelu",l=s==="fusedbatchnorm",c=k("numArgs",n,e,t);if(r){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&r&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=k("strides",n,e,t),h=k0(n,e,t),d=k("dataFormat",n,e,t).toUpperCase(),p=k("dilations",n,e,t);let[f,g]=k("args",n,e,t);o&&(g=f,f=void 0);const m=k("leakyreluAlpha",n,e,t);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:g,activationFunc:i,leakyreluAlpha:m}}const rce=(n,e,t,s=ri)=>{switch(n.op){case"Conv1D":{const i=k("stride",n,e,t),r=k("pad",n,e,t),o=k("dataFormat",n,e,t).toUpperCase(),a=k("dilation",n,e,t);return[s.conv1d(k("x",n,e,t),k("filter",n,e,t),i,r,o,a)]}case"Conv2D":{const i=k("strides",n,e,t),r=k0(n,e,t),o=k("dataFormat",n,e,t).toUpperCase(),a=k("dilations",n,e,t);return[s.conv2d(k("x",n,e,t),k("filter",n,e,t),[i[1],i[2]],r,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:i,pad:r,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=aR(n,e,t);return[s.fused.conv2d({x:k("x",n,e,t),filter:k("filter",n,e,t),strides:[i[1],i[2]],pad:r,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:r,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=aR(n,e,t);return[s.fused.depthwiseConv2d({x:k("x",n,e,t),filter:k("filter",n,e,t),strides:[i[1],i[2]],pad:r,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=k("outputShape",n,e,t),r=k("strides",n,e,t),o=k0(n,e,t);return[s.conv2dTranspose(k("x",n,e,t),k("filter",n,e,t),i,[r[1],r[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=k("strides",n,e,t),r=k0(n,e,t),o=k("dilations",n,e,t),a=k("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(k("input",n,e,t),k("filter",n,e,t),[i[1],i[2]],r,a,[o[1],o[2]])]}case"Conv3D":{const i=k("strides",n,e,t),r=k("pad",n,e,t),o=k("dataFormat",n,e,t).toUpperCase(),a=k("dilations",n,e,t);return[s.conv3d(k("x",n,e,t),k("filter",n,e,t),[i[1],i[2],i[3]],r,o,[a[1],a[2],a[3]])]}case"AvgPool":{const i=k("strides",n,e,t),r=k("pad",n,e,t),o=k("kernelSize",n,e,t);return[s.avgPool(k("x",n,e,t),[o[1],o[2]],[i[1],i[2]],r)]}case"MaxPool":{const i=k("strides",n,e,t),r=k("pad",n,e,t),o=k("kernelSize",n,e,t);return[s.maxPool(k("x",n,e,t),[o[1],o[2]],[i[1],i[2]],r)]}case"MaxPoolWithArgmax":{const i=k("strides",n,e,t),r=k("pad",n,e,t),o=k("kernelSize",n,e,t),a=k("includeBatchInIndex",n,e,t),{result:l,indexes:c}=s.maxPoolWithArgmax(k("x",n,e,t),[o[1],o[2]],[i[1],i[2]],r,a);return[l,c]}case"AvgPool3D":{const i=k("strides",n,e,t),r=k("pad",n,e,t),o=k("kernelSize",n,e,t);return[s.avgPool3d(k("x",n,e,t),[o[1],o[2],o[3]],[i[1],i[2],i[3]],r)]}case"MaxPool3D":{const i=k("strides",n,e,t),r=k("pad",n,e,t),o=k("kernelSize",n,e,t);return[s.maxPool3d(k("x",n,e,t),[o[1],o[2],o[3]],[i[1],i[2],i[3]],r)]}case"Dilation2D":{const i=k("strides",n,e,t),r=k("pad",n,e,t),o=k("dilations",n,e,t),a=i[1],l=i[2],c=o[1],u=o[2];return[s.dilation2d(k("x",n,e,t),k("filter",n,e,t),[a,l],r,[c,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oce=(n,e,t,s=ri)=>{switch(n.op){case"Fill":{const i=k("shape",n,e,t),r=k("dtype",n,e,t),o=k("value",n,e,t);return[s.fill(i,o,r)]}case"LinSpace":{const i=k("start",n,e,t),r=k("stop",n,e,t),o=k("num",n,e,t);return[s.linspace(i,r,o)]}case"Multinomial":{const i=k("logits",n,e,t),r=k("numSamples",n,e,t),o=k("seed",n,e,t);return[s.multinomial(i,r,o)]}case"OneHot":{const i=k("indices",n,e,t),r=k("depth",n,e,t),o=k("onValue",n,e,t),a=k("offValue",n,e,t),l=k("dtype",n,e,t);return[s.oneHot(i,r,o,a,l)]}case"Ones":return[s.ones(k("shape",n,e,t),k("dtype",n,e,t))];case"OnesLike":return[s.onesLike(k("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(k("shape",n,e,t),k("dtype",n,e,t),k("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(k("shape",n,e,t),k("minval",n,e,t),k("maxval",n,e,t),k("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(k("shape",n,e,t),k("minval",n,e,t),k("maxval",n,e,t),k("seed",n,e,t))];case"Range":{const i=k("start",n,e,t),r=k("stop",n,e,t),o=k("step",n,e,t);return[s.range(i,r,o,k("dtype",n,e,t))]}case"TruncatedNormal":{const i=k("shape",n,e,t),r=k("mean",n,e,t),o=k("stdDev",n,e,t),a=k("seed",n,e,t);return[s.truncatedNormal(i,r,o,k("dtype",n,e,t),a)]}case"Zeros":return[s.zeros(k("shape",n,e,t),k("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(k("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aS(n,e,t){const s=k("boxes",n,e,t),i=k("scores",n,e,t),r=k("maxOutputSize",n,e,t),o=k("iouThreshold",n,e,t),a=k("scoreThreshold",n,e,t),l=k("softNmsSigma",n,e,t);return{boxes:s,scores:i,maxOutputSize:r,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const ace=async(n,e,t,s,i=ri)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=aS(n,e,t),h=await i.image.nonMaxSuppressionWithScoreAsync(r,o,a,l,c,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=aS(n,e,t),u=k("padToMaxOutputSize",n,e,t),h=await i.image.nonMaxSuppressionPaddedAsync(r,o,a,l,c,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=aS(n,e,t);return[await i.image.nonMaxSuppressionAsync(r,o,a,l,c)]}case"Where":{const r=i.cast(k("condition",n,e,t),"bool"),o=[await i.whereAsync(r)];return r.dispose(),o}case"ListDiff":return i.setdiff1dAsync(k("x",n,e,t),k("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lce=(n,e,t,s=ri)=>{switch(n.op){case"LowerBound":{const i=k("sortedSequence",n,e,t),r=k("values",n,e,t);return[s.lowerBound(i,r)]}case"TopKV2":{const i=k("x",n,e,t),r=k("k",n,e,t),o=k("sorted",n,e,t),a=s.topk(i,r,o);return[a.values,a.indices]}case"UpperBound":{const i=k("sortedSequence",n,e,t),r=k("values",n,e,t);return[s.upperBound(i,r)]}case"Unique":{const i=k("x",n,e,t),r=s.unique(i);return[r.values,r.indices]}case"UniqueV2":{const i=k("x",n,e,t),r=k("axis",n,e,t),o=s.unique(i,r);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cce=(n,e,t,s=ri)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const i=k("default",n,e,t);return[ti(n.name,e,t)||i];case"Placeholder":return[ti(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const u=k("x",n,e,t);return[Ua(u)]}case"IdentityN":return k("x",n,e,t).map(u=>Ua(u));case"Snapshot":const r=k("x",n,e,t);return[Ua(r)];case"Shape":return[s.tensor1d(k("x",n,e,t).shape,"int32")];case"ShapeN":return k("x",n,e,t).map(u=>s.tensor1d(u.shape));case"Size":return[s.scalar(k("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(k("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const o=k("x",n,e,t),a=k("data",n,e,t),l=k("message",n,e,t),c=k("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uce{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=wt(0),this.tensorMap=new Map,Ts(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return wt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),le(()=>{const i=Yr(t),r=s.length,o=i.length;R(r===o,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${o} elements.`);for(let a=0;a<r;a++){const l=s[a],c=i[a];Ts(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return le(()=>{const i=[];for(let r=0;r<s.length;r++){const o=s[r],a=this.findWithDefault(o,t);i.push(a)}return $i(i)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hce=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(n.name);if(i!=null)return[i];{const r=k("keyDType",n,e,t),o=k("valueDType",n,e,t),a=new uce(r,o);return s.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=k("tableHandle",n,e,t,s),r=k("keys",n,e,t),o=k("values",n,e,t);return[await s.getHashTableById(i.id).import(r,o)]}case"LookupTableFind":case"LookupTableFindV2":{const i=k("tableHandle",n,e,t,s),r=k("keys",n,e,t),o=k("defaultValue",n,e,t);return[await s.getHashTableById(i.id).find(r,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=k("tableHandle",n,e,t,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dce=(n,e,t,s=ri)=>{switch(n.op){case"ResizeBilinear":{const i=k("images",n,e,t),r=k("size",n,e,t),o=k("alignCorners",n,e,t),a=k("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(i,[r[0],r[1]],o,a)]}case"ResizeNearestNeighbor":{const i=k("images",n,e,t),r=k("size",n,e,t),o=k("alignCorners",n,e,t),a=k("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(i,[r[0],r[1]],o,a)]}case"CropAndResize":{const i=k("image",n,e,t),r=k("boxes",n,e,t),o=k("boxInd",n,e,t),a=k("cropSize",n,e,t),l=k("method",n,e,t),c=k("extrapolationValue",n,e,t);return[s.image.cropAndResize(i,r,o,a,l,c)]}case"ImageProjectiveTransformV3":{const i=k("images",n,e,t),r=k("transforms",n,e,t),o=k("outputShape",n,e,t),a=k("fillValue",n,e,t),l=k("interpolation",n,e,t),c=k("fillMode",n,e,t);return[s.image.transform(i,r,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pce=(n,e,t,s=ri)=>{switch(n.op){case"Equal":return[s.equal(k("a",n,e,t),k("b",n,e,t))];case"NotEqual":return[s.notEqual(k("a",n,e,t),k("b",n,e,t))];case"Greater":return[s.greater(k("a",n,e,t),k("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(k("a",n,e,t),k("b",n,e,t))];case"Less":return[s.less(k("a",n,e,t),k("b",n,e,t))];case"LessEqual":return[s.lessEqual(k("a",n,e,t),k("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(k("a",n,e,t),k("b",n,e,t))];case"LogicalNot":return[s.logicalNot(k("a",n,e,t))];case"LogicalOr":return[s.logicalOr(k("a",n,e,t),k("b",n,e,t))];case"Select":case"SelectV2":return[s.where(k("condition",n,e,t),k("a",n,e,t),k("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(k("a",n,e,t),k("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fce=(n,e,t,s=ri)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(k("a",n,e,t),k("b",n,e,t),k("transposeA",n,e,t),k("transposeB",n,e,t))];case"Einsum":return[s.einsum(k("equation",n,e,t),...k("tensors",n,e,t))];case"Transpose":return[s.transpose(k("x",n,e,t),k("perm",n,e,t))];case"_FusedMatMul":const[i,r]=k("fusedOps",n,e,t),o=i==="biasadd",a=r==="prelu",l=k("numArgs",n,e,t),c=k("leakyreluAlpha",n,e,t);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=k("args",n,e,t);return[s.fused.matMul({a:k("a",n,e,t),b:k("b",n,e,t),transposeA:k("transposeA",n,e,t),transposeB:k("transposeB",n,e,t),bias:u,activation:r,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(k("a",n,e,t),k("numLower",n,e,t),k("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mce=(n,e,t,s=ri)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(k("x",n,e,t),k("axis",n,e,t),k("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(k("x",n,e,t),k("mean",n,e,t),k("variance",n,e,t),k("offset",n,e,t),k("scale",n,e,t),k("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(k("x",n,e,t),k("mean",n,e,t),k("variance",n,e,t),k("offset",n,e,t),k("scale",n,e,t),k("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(k("x",n,e,t),k("radius",n,e,t),k("bias",n,e,t),k("alpha",n,e,t),k("beta",n,e,t))];case"Softmax":return[s.softmax(k("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(k("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gce=(n,e,t,s=ri)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:r}=s.raggedGather(k("paramsNestedSplits",n,e,t),k("paramsDenseValues",n,e,t),k("indices",n,e,t),k("outputRaggedRank",n,e,t));return i.concat(r)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:r}=s.raggedRange(k("starts",n,e,t),k("limits",n,e,t),k("splits",n,e,t));return[i,r]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(k("shape",n,e,t),k("values",n,e,t),k("defaultValue",n,e,t),k("rowPartitionTensors",n,e,t),k("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ace=(n,e,t,s=ri)=>{switch(n.op){case"Max":{const a=k("axis",n,e,t),l=k("keepDims",n,e,t);return[s.max(k("x",n,e,t),a,l)]}case"Mean":{const a=k("axis",n,e,t),l=k("keepDims",n,e,t);return[s.mean(k("x",n,e,t),a,l)]}case"Min":{const a=k("axis",n,e,t),l=k("keepDims",n,e,t);return[s.min(k("x",n,e,t),a,l)]}case"Sum":{const a=k("axis",n,e,t),l=k("keepDims",n,e,t);return[s.sum(k("x",n,e,t),a,l)]}case"All":{const a=k("axis",n,e,t),l=k("keepDims",n,e,t);return[s.all(k("x",n,e,t),a,l)]}case"Any":{const a=k("axis",n,e,t),l=k("keepDims",n,e,t);return[s.any(k("x",n,e,t),a,l)]}case"ArgMax":{const a=k("axis",n,e,t);return[s.argMax(k("x",n,e,t),a)]}case"ArgMin":{const a=k("axis",n,e,t);return[s.argMin(k("x",n,e,t),a)]}case"Prod":{const a=k("axis",n,e,t),l=k("keepDims",n,e,t);return[s.prod(k("x",n,e,t),a,l)]}case"Cumprod":{const a=k("axis",n,e,t),l=k("exclusive",n,e,t),c=k("reverse",n,e,t);return[s.cumprod(k("x",n,e,t),a,l,c)]}case"Cumsum":{const a=k("axis",n,e,t),l=k("exclusive",n,e,t),c=k("reverse",n,e,t);return[s.cumsum(k("x",n,e,t),a,l,c)]}case"Bincount":const i=k("x",n,e,t),r=k("weights",n,e,t),o=k("size",n,e,t);return[s.bincount(i,r,o)];case"DenseBincount":{const a=k("x",n,e,t),l=k("weights",n,e,t),c=k("size",n,e,t),u=k("binaryOutput",n,e,t);return[s.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yce=(n,e,t,s=ri)=>{switch(n.op){case"ConcatV2":case"Concat":{const i=k("n",n,e,t),r=k("axis",n,e,t);let o=k("tensors",n,e,t);return o=o.slice(0,i),[s.concat(o,r)]}case"Gather":{const i=k("x",n,e,t),r=k("indices",n,e,t);return[s.gather(i,s.cast(r,"int32"),0)]}case"GatherV2":{const i=k("axis",n,e,t),r=k("batchDims",n,e,t),o=k("x",n,e,t),a=k("indices",n,e,t);return[s.gather(o,s.cast(a,"int32"),i,r)]}case"Reverse":{const i=k("dims",n,e,t),r=[];for(let a=0;a<i.length;a++)i[a]&&r.push(a);const o=k("x",n,e,t);return[s.reverse(o,r)]}case"ReverseV2":{const i=k("axis",n,e,t),r=k("x",n,e,t);return[s.reverse(r,i)]}case"Slice":{const i=k("begin",n,e,t),r=k("size",n,e,t);return[s.slice(k("x",n,e,t),i,r)]}case"StridedSlice":{const i=k("begin",n,e,t),r=k("end",n,e,t),o=k("strides",n,e,t),a=k("beginMask",n,e,t),l=k("endMask",n,e,t),c=k("ellipsisMask",n,e,t),u=k("newAxisMask",n,e,t),h=k("shrinkAxisMask",n,e,t),d=k("x",n,e,t);return[s.stridedSlice(d,i,r,o,a,l,c,u,h)]}case"Pack":return le(()=>{const i=k("axis",n,e,t),r=k("tensors",n,e,t),o=r[0].shape,a=s.squeeze(r[0]).shape,l=r.map(c=>{const u=qt(c.shape,o);if(!u&&!qt(s.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:s.reshape(c,o)});return[s.stack(l,i)]});case"Unpack":{const i=k("axis",n,e,t),r=k("tensor",n,e,t);return s.unstack(r,i)}case"Tile":{const i=k("reps",n,e,t);return[s.tile(k("x",n,e,t),i)]}case"Split":case"SplitV":{const i=k("axis",n,e,t),r=k("numOrSizeSplits",n,e,t),o=k("x",n,e,t);return s.split(o,r,i)}case"ScatterNd":{const i=k("indices",n,e,t),r=k("values",n,e,t),o=k("shape",n,e,t);return[s.scatterND(i,r,o)]}case"GatherNd":{const i=k("x",n,e,t),r=k("indices",n,e,t);return[s.gatherND(i,r)]}case"SparseToDense":{const i=k("sparseIndices",n,e,t),r=k("outputShape",n,e,t),o=k("sparseValues",n,e,t),a=k("defaultValue",n,e,t);return[s.sparseToDense(i,o,r,o.dtype===a.dtype?a:s.cast(a,o.dtype))]}case"TensorScatterUpdate":{const i=k("indices",n,e,t),r=k("values",n,e,t),o=k("tensor",n,e,t);return[s.tensorScatterUpdate(o,i,r)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xce=(n,e,t,s=ri)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:r,emptyRowIndicator:o,reverseIndexMap:a}=s.sparse.sparseFillEmptyRows(k("indices",n,e,t),k("values",n,e,t),k("denseShape",n,e,t),k("defaultValue",n,e,t));return[i,r,o,a]}case"SparseReshape":{const{outputIndices:i,outputShape:r}=s.sparse.sparseReshape(k("inputIndices",n,e,t),k("inputShape",n,e,t),k("newShape",n,e,t));return[i,r]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(k("data",n,e,t),k("indices",n,e,t),k("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(k("data",n,e,t),k("indices",n,e,t),k("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bce=(n,e,t,s=ri)=>{switch(n.op){case"FFT":return[s.fft(k("x",n,e,t))];case"IFFT":return[s.ifft(k("x",n,e,t))];case"RFFT":return[s.rfft(k("x",n,e,t))];case"IRFFT":return[s.irfft(k("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ice=(n,e,t,s=ri)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(k("input",n,e,t),k("pattern",n,e,t),k("rewrite",n,e,t),k("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:i,nGramsSplits:r}=s.string.stringNGrams(k("data",n,e,t),k("dataSplits",n,e,t),k("separator",n,e,t),k("nGramWidths",n,e,t),k("leftPad",n,e,t),k("rightPad",n,e,t),k("padWidth",n,e,t),k("preserveShortSequences",n,e,t));return[i,r]}case"StringSplit":{const{indices:i,values:r,shape:o}=s.string.stringSplit(k("input",n,e,t),k("delimiter",n,e,t),k("skipEmpty",n,e,t));return[i,r,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(k("input",n,e,t),k("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cce=(n,e,t,s=ri)=>{switch(n.op){case"Cast":return[s.cast(k("x",n,e,t),k("dtype",n,e,t))];case"ExpandDims":{const i=k("axis",n,e,t);return[s.expandDims(k("x",n,e,t),i)]}case"Squeeze":{const i=k("axis",n,e,t);return[s.squeeze(k("x",n,e,t),i)]}case"Reshape":return[s.reshape(k("x",n,e,t),k("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(k("x",n,e,t),k("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(k("x",n,e,t),k("padding",n,e,t),k("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(k("x",n,e,t),k("padding",n,e,t),k("constantValue",n,e,t))];case"SpaceToBatchND":{const i=k("blockShape",n,e,t),r=k("paddings",n,e,t);return[s.spaceToBatchND(k("x",n,e,t),i,r)]}case"BatchToSpaceND":{const i=k("blockShape",n,e,t),r=k("crops",n,e,t);return[s.batchToSpaceND(k("x",n,e,t),i,r)]}case"DepthToSpace":{const i=k("blockSize",n,e,t),r=k("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(k("x",n,e,t),i,r)]}case"BroadcastTo":return[s.broadcastTo(k("x",n,e,t),k("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(k("s0",n,e,t),k("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lR(n,e,t,s,i=le){const r=((o,a,l)=>{switch(o.category){case"arithmetic":return i(()=>Kle(o,a,l));case"basic_math":return i(()=>Jle(o,a,l));case"control":return ice(o,a,l);case"convolution":return i(()=>rce(o,a,l));case"creation":return i(()=>oce(o,a,l));case"dynamic":return ace(o,a,l);case"evaluation":return i(()=>lce(o,a,l));case"image":return i(()=>dce(o,a,l));case"graph":return i(()=>cce(o,a,l));case"logical":return i(()=>pce(o,a,l));case"matrices":return i(()=>fce(o,a,l));case"normalization":return i(()=>mce(o,a,l));case"ragged":return i(()=>gce(o,a,l));case"reduction":return i(()=>Ace(o,a,l));case"slice_join":return i(()=>yce(o,a,l));case"sparse":return i(()=>xce(o,a,l));case"spectral":return i(()=>bce(o,a,l));case"string":return i(()=>Ice(o,a,l));case"transformation":return i(()=>Cce(o,a,l));case"hash_table":return hce(o,a,l,s);case"custom":const c=HO(o.op);if(c&&c.customExecutor)return c.customExecutor(new jle(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return tl(r)?r.then(o=>[].concat(o)):[].concat(r)}class cR{constructor(e={},t={},s={},i={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=i,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(n,e,t,s){const i=new Set,r=[];let o=null,a=null;const l=new Set,c=new Set(Object.keys(n).map(d=>pr(d)[0]));s=s||[];const u=new Set(s.map(d=>pr(d.name)[0])),h=[...e];for(;h.length>0;){const d=h.pop();if((Hc(d)||kce(d)||Mce(d))&&o==null&&(o=d,a=o.children.map(p=>p.name).filter(p=>i.has(p))),i.add(d.name),t[d.name]==null&&!c.has(d.name)&&!u.has(d.name)){if(d.inputs.length===0){r.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:e,usedNodes:i,missingInputs:r,dynamicNode:o,syncInputs:a}}function wce(n,e){const{usedNodes:t,inputs:s}=e,i=Object.keys(s).map(m=>pr(m)[0]).map(m=>n.nodes[m]),r=n.initNodes||[],o=m=>t.has(typeof m=="string"?m:m.name);function a(m){return[...new Map(m.map(A=>[A.name,A])).values()]}const l=a([...i,...n.weights,...r]).filter(o),c=a([...l,...Object.values(n.nodes)]).filter(o),u=new Map(c.map(m=>[m.name,m])),h={};for(const m of c){h[m.name]=h[m.name]||0;for(const A of m.children)o(A)||(h[A.name]=Number.POSITIVE_INFINITY),h[A.name]=(h[A.name]||0)+1}const d=Object.entries(h).filter(([,m])=>m===0).map(([m])=>m),p=[...d];for(;d.length>0;){const m=d.pop(),A=u.get(m);for(const y of A.children.filter(o))--h[y.name]===0&&(p.push(y.name),d.push(y.name))}const f=p.map(m=>u.get(m)),g=vce(f,l);return Sce(g,l),g}function vce(n,e){const t=new Map(n.map(o=>[o.name,o])),s=e.map(o=>o.name),i=new Set(s);for(;s.length>0;){const o=s.pop(),a=t.get(o);for(const l of a.children)!t.has(l.name)||i.has(l.name)||(i.add(l.name),s.push(l.name))}return n.filter(o=>i.has(o.name))}class r0 extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function Sce(n,e){const t=new Map(n.map((a,l)=>[a.name,l])),s=new Set(e.map(a=>a.name)),i=a=>s.has(typeof a=="string"?a:a.name),r=new Set(n.map(a=>a.name)),o=a=>r.has(typeof a=="string"?a:a.name);for(const a of n){for(const l of a.children.filter(o)){if(!t.has(l.name))throw new r0(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new r0(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!i(a))for(const l of a.inputs){if(!t.has(l.name))throw new r0(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new r0(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function Ece(n){const e=new Map(n.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,s=n.map((a,l)=>Hc(a)?t:l),i=a=>{const l=s[e.get(a.name)];return l??-1},r=n.map((a,l)=>a.children.map(i).reduce((c,u)=>Math.max(c,u),s[l])),o=new Map;for(let a=0;a<n.length;++a){const l=r[a];if(l===t)continue;const c=n[a],u=n[l];o.has(u.name)||o.set(u.name,[]),o.get(u.name).push(c)}return o}const _ce=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Tce=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Bce=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Hc(n){return _ce.has(n.op)}function kce(n){return Tce.has(n.op)}function Mce(n){return Bce.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xb{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Xb(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(r=>r.name).sort(),i=t.map(r=>r.name).sort();return s.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(e,t){const s=uR(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:r,syncInputs:o}=s;if(r!=null)throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(i.length>0){const c=t.map(h=>h.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${u}]. Missing the following inputs: [${i}]`)}const a=wce(this.graph,s),l=Ece(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Ts(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=s.map(d=>this.graph.nodes[pr(d)[0]]),r=t.map(d=>pr(d)[0]),o=new Set(r);let a=r.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(i,a);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=ae().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const u={},h={};return le(()=>{const d=new cR(this.weightMap,u,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(A=>{const[y,b]=pr(A,d),x=[];x[b]=e[A],p[y]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(x))});const f=this.getFrozenTensorIds(p),{orderedNodes:g,nodeLiveUntilMap:m}=c;for(const A of g){if(p[A.name])continue;const y=lR(A,p,d,this._resourceManager);if(tl(y))throw new Error(`The execution of the op '${A.op}' returned a promise. Please use model.executeAsync() instead.`);p[A.name]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[A.name]=this.cloneTensorList(y)),this.checkTensorForDisposalWithNodeLiveUntilInfo(A,p,d,f,o,m.get(A.name))}return this.parent==null&&d.dispose(f),t.map(A=>ti(A,p,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,s,i,r,o,a){if(!(Hc(t)||o.has(e))){for(const l of s[e])l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if(Hc(l))continue;const c=sR(l.name,s,i);if(c!=null)for(const u of c){if(!u||u.kept||r.has(u.id))continue;const h=a[u.id];h===1?(u.dispose(),delete a[u.id]):h!=null&&a[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,i,r,o){function a(l){return Hc(l)||r.has(l.name)}if(!(Hc(e)||o==null))for(const l of o){if(a(l))continue;const c=sR(l.name,t,s);for(const u of c)!u||u.kept||i.has(u.id)||u.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,i={},r={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ae().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const o=new cR(this.weightMap,i,r,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,t,s),l=t.map(d=>ti(d,a,o)),c=l.map(d=>d.id),u=Object.keys(e).map(d=>e[d].id),h=new Set([...c,...u,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,s){const i=e.reduce((r,o,a)=>(r[this.inputs[a].name]=o,r),{});return this._executeAsync(i,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,i){const r=Object.keys(e),o=r.map(x=>this.graph.nodes[pr(x)[0]]),a=s.map(x=>pr(x)[0]),l=new Set(a);let c=a.map(x=>this.graph.nodes[x]);c.length===0&&(c=this._outputs);const{usedNodes:u,missingInputs:h,dynamicNode:d,syncInputs:p}=uR(e,c,this.weightMap,this._initNodes),f=[...o,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:t.currentContext})),g=Object.assign({},this.weightMap);Object.keys(e).forEach(x=>{const[C,w]=pr(x),E=[];E[w]=e[x],g[C]=E});const m={},A=this.getFrozenTensorIds(g),y={};for(;f.length>0;){const x=this.processStack(o,f,t,g,y,A,l,m,u);await Promise.all(x)}d==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=c.filter(x=>!Hc(x)&&!ti(x.name,g,t)).map(x=>x.name);if(b.length>0){let x="";throw d!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${r}]. Consider providing the following inputs: [${h}]. ${x}`)}return g}processStack(e,t,s,i,r,o,a,l,c){const u=[];for(;t.length>0;){const h=t.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&k("isConstant",h.node,i,s)&&([d]=za(h.node.name,s)),i[h.node.name]==null){const p=lR(h.node,i,s,this._resourceManager);d||([d]=za(h.node.name,s));const f=s.currentContext;tl(p)?u.push(p.then(g=>(i[d]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(g)),s.currentContext=f,this.checkTensorForDisposal(d,h.node,i,s,o,a,l),this.processChildNodes(h.node,t,s,i,r,c),g))):(i[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,i,s,o,a,l),this.processChildNodes(h.node,t,s,i,r,c))}else this.processChildNodes(h.node,t,s,i,r,c)}return u}processChildNodes(e,t,s,i,r,o){e.children.forEach(a=>{const[l]=za(a.name,s);r[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!ti(c,i,s))&&(r[l]=!0,t.push({contexts:s.currentContext,node:a})):a.inputNames.every(c=>!!ti(c,i,s))&&(r[l]=!0,t.push({contexts:s.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[i]=pr(t),r=this.graph.nodes[i];if(r.attrParams.shape&&r.attrParams.shape.value){const o=r.attrParams.shape.value,a=o.length===s.shape.length&&s.shape.every((l,c)=>o[c]===-1||o[c]===l);R(a,()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&R(s.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const i={};for(const r in e){const o=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[r];o!=null?i[o.name]=e[r]:i[r]=e[r]}return i}checkInputs(e){const t=Object.keys(e).filter(s=>{const[i]=pr(s);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,i;const r=(i=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||i===void 0?void 0:i[t];return r!=null?r.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=pr(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class Nce{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rce="?tfjs-format=file",Dce="model.json";class xB{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=$_){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new Nce}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return tl(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await S$(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let i=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const r=this.artifacts.userDefinedMetadata;r.signature!=null&&(i=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=i,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Xb(iR.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const r=iR.Instance.transformGraph(e.modelInitializer);this.initializer=new Xb(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof nn?[e]:e,s={};return t.forEach((i,r)=>s[this.structuredOutputKeys[r]]=i),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof nn)&&!Array.isArray(e)){const r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(const o in r){const a=r[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((r,o)=>{var a,l,c;const u=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||c===void 0?void 0:c.resourceId;return u!=null?r[o]=this.resourceIdToCapturedInput[u]:r[o]=e[i++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let i=0;i<s.length;i++){const r=s[i],o=t[r];this.resourceIdToCapturedInput[o.resourceId]=e[i]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Et(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Du(n,e={},t=$_){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=$ce(n));const s=new xB(n,e,t);return await s.load(),s}function Fce(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,i]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!i||!(i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const r=$b(s.weightsManifest),o=C2(s,r,i);e=Lb(o)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=Lb(n);else throw new Error("Unknown model format");const t=new xB(e);return t.load(),t}function $ce(n){return n.endsWith("/")||(n=n+"/"),`${n}${Dce}${Rce}`}/** @license See the LICENSE file. */const XO="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Pce(n,e){return jb(n,e)}function jb(n,e,t=new Map,s=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(s.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const i=e(n);if(i.recurse&&i.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse)if(Ap(n)){const r=Array.isArray(n)?[]:{};s.add(n);for(const o in n){const a=n[o],l=jb(a,e,t,s);r[o]=l}return s.delete(n),n.__proto__&&(r.__proto__=n.__proto__),r}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,i.value),i.value}function Lce(n,e=KO){return jO(n,e)}function jO(n,e,t=new Set){const s=n[0];if(t.has(s))throw new Error("Circular references are not supported.");const i=e(n);if(i.recurse&&i.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse)if(Ap(s)){const r=Array.isArray(s)?[]:{};t.add(s);for(const o in s){const a=n.map(c=>c[o]),l=jO(a,e,t);r[o]=l}return t.delete(s),r}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return i.value}function KO(n){return n===null?null:Ap(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function JO(n,e){const t=new Map;jb(n,e,t);for(const i of Array.from(t.keys())){const r=t.get(i);if(tl(r)){const o=await r;t.set(i,o)}}return jb(n,e,t)}function Ap(n){let e=!1;if(ae().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof nn)&&!(n instanceof Promise)&&!e)}function Oce(n){return n==null||zce(n)||Array.isArray(n)||typeof n=="object"&&n instanceof nn||_s(n)}function zce(n){return n===null||typeof n!="object"&&typeof n!="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Uce(n){return Pce(n,Qce)}function Qce(n){return n instanceof nn?{value:n.clone(),recurse:!1}:Ap(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class ZO{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),s=this.get(t);return this.set(t,this.pop()),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Mw extends ZO{constructor(){super(Mw.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),s=this.length();for(let i=0;i<s;i++)t[i]=this.get(this.wrap(this.begin+i));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}Mw.INITIAL_CAPACITY=32;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function ez(n){return new Wce(n)}function bB(n){return new Hce(n)}function Vce(n,e){return new tz(n,e)}function Gce(n,e=$l.FAIL){return new tue(n,e)}class qs{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let s=await e.next();for(;!s.done;)t.push(s.value),s=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),s=e(t.value);for(;!t.done&&s;)t=await this.next(),s=e(t.value)}handleErrors(e){return new Zce(this,e)}filter(e){return new Kce(this,e)}map(e){return new Jce(this,e)}mapAsync(e){return new hR(this,e)}serialMapAsync(e){return new hR(this,e).serial()}flatmap(e){return new eue(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new jce(this,e,t)}columnMajorBatch(e,t=!0,s=KO){return this.rowMajorBatch(e,t).map(r=>Lce(r,s))}concatenate(e,t){return new tz(ez([this,e]),t)}take(e){return e<0||e==null?this:new Xce(this,e)}skip(e){return e<0||e==null?this:new Yce(this,e)}prefetch(e){return new nz(this,e)}shuffle(e,t){return new nue(this,e,t)}serial(){return new qce(this)}}class Wce extends qs{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:Uce(e),done:!1}}}class Hce extends qs{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class qce extends qs{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class Yce extends qs{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Et(e.value)}return this.upstream.next()}}class Xce extends qs{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class jce extends qs{constructor(e,t,s=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class Kce extends qs{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Et(e.value)}}}class Jce extends qs{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=nl(e.value),s=this.transform(e.value),i=nl(s);for(const r of t)rC(r,i)||r.dispose();return{value:s,done:!1}}}class Zce extends qs{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class hR extends qs{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=nl(e.value),s=await this.transform(e.value),i=nl(s);for(const r of t)rC(r,i)||r.dispose();return{value:s,done:!1}}}class IB extends qs{constructor(){super(),this.outputQueue=new Mw,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class eue extends IB{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=nl(e.value),s=this.transform(e.value),i=nl(s);this.outputQueue.pushAll(s);for(const r of t)rC(r,i)||r.dispose();return!0}}class tz extends qs{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var $l;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})($l||($l={}));class tue extends qs{constructor(e,t=$l.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,s=0;function i(o){return o instanceof qs?{value:o.next().then(l=>(t++,l.done&&s++,l.value)),recurse:!1}:{value:null,recurse:!0}}const r=await JO(this.iterators,i);if(t===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case $l.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case $l.SHORTEST:return{value:null,done:!0};case $l.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class nz extends qs{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new ZO(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class nue extends nz{constructor(e,t,s){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=$f.alea(s||Zs().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Vf{constructor(){this.size=null}batch(e,t=!0){const s=this;R(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let i;return this.size===1/0||this.size==null?i=this.size:t?i=Math.ceil(this.size/e):i=Math.floor(this.size/e),dr(async()=>(await s.iterator()).columnMajorBatch(e,t,rue),i)}concatenate(e){const t=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,dr(async()=>(await t.iterator()).concatenate(await e.iterator()),s)}filter(e){const t=this;let s;return this.size===1/0?s=1/0:s=null,dr(async()=>(await t.iterator()).filter(i=>le(()=>e(i))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return dr(async()=>(await t.iterator()).map(s=>le(()=>e(s))),this.size)}mapAsync(e){const t=this;return dr(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return dr(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,dr(async()=>{const i=bB(async()=>({value:await t.iterator(),done:!1}));return Vce(i.take(e))},s)}skip(e){const t=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,dr(async()=>(await t.iterator()).skip(e),s)}shuffle(e,t,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const i=this,r=$f.alea(t||Zs().toString());return dr(async()=>{let o=r.int32();return s&&(o+=r.int32()),(await i.iterator()).shuffle(e,o.toString())},this.size)}take(e){const t=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,dr(async()=>(await t.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}Vf.MAX_BUFFER_SIZE=1e4;function dr(n,e=null){return new class extends Vf{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function sue(n){return dr(async()=>ez(n),n.length)}function iue(n){if(!Ap(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return dr(async()=>{const t=await JO(n,s=>{if(s instanceof Vf)return{value:s.iterator(),recurse:!1};if(Ap(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return Gce(t,$l.SHORTEST)},e)}function rue(n){if(n===null)return null;const e=n[0];return Oce(e)?{value:oue(n),recurse:!1}:{value:null,recurse:!0}}function oue(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof nn?$i(n):Ar(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class sz extends Vf{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(i=>(i.endsWith("\r")&&(i=i.slice(0,-1)),i))}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */const o0='"',_m=Symbol("out"),dR=Symbol("field"),a0=Symbol("quote"),lS=Symbol("quoteafterquote"),pR=Symbol("quoteinquote");class iz extends Vf{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&R(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((i,r)=>(i[r]=i[r]+1||1,i),{}),s=Object.keys(t).filter(i=>t[i]>1);if(R(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const i of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(i)===-1)throw new Error('The key "'+i+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new sz(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(R(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},i={};for(let r=0;r<this.fullColumnNames.length;r++){const o=this.fullColumnNames[r],a=this.columnConfigs?this.columnConfigs[o]:null;if(!(this.configuredColumnsOnly&&!a)){const l=t[r];let c=null;if(l==="")if(a&&a.default!==void 0)c=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${o} is empty in this line: ${e}`);c=void 0}else{const u=Number(l);if(isNaN(u))a&&a.dtype==="bool"?c=this.getBoolean(l):c=l;else if(!a||!a.dtype)c=u;else switch(a.dtype){case"float32":c=u;break;case"int32":c=Math.floor(u);break;case"bool":c=this.getBoolean(l);break;default:c=u}}a&&a.isLabel?i[o]=c:s[o]=c}}return Object.keys(i).length===0?s:{xs:s,ys:i}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let i=0;const r=e.length;let o=_m;for(let a=0;a<r;a++)switch(o){case _m:switch(e.charAt(a)){case o0:i=a+1,o=a0;break;case this.delimiter:if(i=a+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),o=_m;break;default:o=dR,i=a;break}break;case dR:switch(e.charAt(a)){case this.delimiter:s.push(e.substring(i,a)),o=_m,i=a+1;break}break;case a0:switch(e.charAt(a)){case o0:o=lS;break}break;case lS:switch(e.charAt(a)){case this.delimiter:s.push(e.substring(i,a-1)),o=_m,i=a+1;break;case o0:o=a0;break;default:o=pR;break}break;case pR:switch(e.charAt(a)){case o0:o=a0;break}break}if(o===lS?s.push(e.substring(i,r-1)):s.push(e.substring(i)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class CB extends qs{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!ae().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new CB(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const i=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(i,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const i=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(i,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(i=>{const r=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&i({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(r),i({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((i,r)=>s.set(i,r*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(ce(t));return s.set(e,s.length-e.length),Ar(s,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class wB extends qs{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=ls([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,i=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,r=(1-s)/2,o=(1-i)/2,a=r+s,l=i+o;this.cropBox=Ji([o,r,l,a],[1,4])}else this.cropBox=Ji([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!ae().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new wB(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&R(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=VC(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return le(()=>{const t=rs(We(e,"float32"),0);let s;s=ii.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const i=s.shape;return ee(s,i.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class rz{}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class oz extends qs{split(e){return new aue(this,e)}}class aue extends oz{constructor(e,t){super(),this.upstream=e,this.impl=new lue(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class lue extends IB{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class cue extends qs{decodeUTF8(){return new uue(this)}}class uue extends oz{constructor(e){super(),this.upstream=e,this.impl=new hue(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class hue extends IB{constructor(e){if(super(),this.upstream=e,ae().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return ae().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class az extends cue{constructor(e,t={}){super(),this.file=e,this.options=t,R(e instanceof Uint8Array||(ae().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,s)=>{const i=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,i)));else{const r=new FileReader;r.onload=a=>{let l=r.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));t(l)},r.onabort=a=>s(new Error("Aborted")),r.onerror=a=>s(new Error(a.type));const o=this.file.slice(this.offset,i);r.readAsArrayBuffer(o)}this.offset=i}),done:!1}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */async function due(n,e={},t){let s,i;typeof n=="string"?s=n:(s=n.url,i=pue(n));const r=await f$(s,i);if(r.ok){const o=new Uint8Array(await r.arrayBuffer());return new az(o,e)}else throw new Error(r.statusText)}const pue=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function lz(n){return typeof n=="string"&&n.slice(0,7)==="file://"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class cz extends rz{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(lz(this.input)&&ae().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new az(this.input,this.options)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class uz extends rz{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return lz(this.url)?new cz(this.url,this.fileOptions).iterator():due(this.url,this.fileOptions)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function fue(n,e={}){return new iz(new uz(n),e)}function mue(n){const e=bB(n);return dr(async()=>e)}function gue(n){return dr(async()=>{const e=await n();return bB(()=>e.next())})}async function Aue(n,e){return wB.create(n,e)}async function yue(n){return CB.create(n)}/** @license See the LICENSE file. */const hz="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xue=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:iz,Dataset:Vf,FileDataSource:cz,TextLineDataset:sz,URLDataSource:uz,array:sue,csv:fue,func:mue,generator:gue,microphone:yue,version_data:hz,webcam:Aue,zip:iue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function It(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&R(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bue=DC;class Wy extends uA{nextDataId(){return Wy.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new WI(this,hi())}write(e,t,s){this.firstUse&&(this.firstUse=!1,ae().get("IS_NODE")&&Dr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&To(s[0])){const r=s.map(o=>Ro(o));i=this.write(r,e,t)}else i=this.write(s,e,t);return{dataId:i,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,i,r){this.data.set(e,{values:t,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const i=this.readSync(s.real.dataId),r=this.readSync(s.imag.dataId);return $o(i,r)}return Zm(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>lo(i));return zt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zt(e.shape,e.dtype,t)}makeOutput(e,t,s){return hi().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Zs();return e(),{kernelMs:Zs()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){It([e],"where");const t=this.readSync(e.dataId);return bue(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Wy.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dz(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const Iue=n=>{const{x:e}=n.inputs,t=n.backend;It(e,"abs");let s=new Float32Array(ce(e.shape));const i=t.data.get(e.dataId).values;return s=dz(i),t.makeOutput(s,e.shape,e.dtype)},Cue={kernelName:Tp,backendName:"cpu",kernelFunc:Iue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(n){return(e,t,s,i,r)=>{const o=Mt(e,t),a=o.length,l=vt(o),c=ce(o),u=Cs(r,c),h=e.length,d=t.length,p=vt(e),f=vt(t),g=rl(e,o),m=rl(t,o);if(g.length+m.length===0)for(let A=0;A<u.length;++A)u[A]=n(s[A%s.length],i[A%i.length]);else for(let A=0;A<u.length;++A){const y=Hu(A,a,l),b=y.slice(-h);g.forEach(E=>b[E]=0);const x=No(b,h,p),C=y.slice(-d);m.forEach(E=>C[E]=0);const w=No(C,d,f);u[A]=n(s[x],i[w])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mr(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,a=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",r),imag:t.makeTensorInfo(i.shape,"float32",o)},a}const wue={kernelName:yA,backendName:"cpu",kernelFunc:mr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kb(n,e,t="float32"){if(t==="complex64"){const i=Kb(n,e,"float32"),r=Kb(n,e,"float32");return mr({inputs:{real:i,imag:r},backend:n})}const s=Ws(ce(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xa(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const vue={kernelName:ph,backendName:"cpu",kernelFunc:xa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fu(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.real,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const Sue={kernelName:qA,backendName:"cpu",kernelFunc:Fu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pz(n,e,t,s){if(s==="int32"){const i=Int32Array.from(n);return[e,"int32",i]}if(s==="bool"){const i=uc([0],t),[r,o]=ms((a,l)=>a!==l?1:0)(e,[],n,i,"bool");return[o,"bool",r]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function sc(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return xa({inputs:{x:i},backend:t});const u=Kb(t,i.shape,i.dtype),h=sc({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),d=mr({inputs:{real:h,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),d}if(i.dtype==="complex64"){const u=Fu({inputs:{input:i},backend:t}),h=sc({inputs:{x:u},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(u),h}if(!YI(i.dtype,r)){const u=xa({inputs:{x:i},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:r}}const o=t.data.get(i.dataId).values,[a,l,c]=pz(o,i.shape,i.dtype,r);return t.makeTensorInfo(a,l,c)}const Eue={kernelName:eh,backendName:"cpu",kernelFunc:sc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ds(n,e,t,s){return t==null?({inputs:i,backend:r})=>{const{a:o,b:a}=i,l=r;It([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=o.dtype==="string"?Po(c):c,d=o.dtype==="string"?Po(u):u,p=s||o.dtype,[f,g]=e(o.shape,a.shape,h,d,p);return l.makeTensorInfo(g,p,f)}:({inputs:i,backend:r})=>{const{a:o,b:a}=i,l=r;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=sc({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,g=sc({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),A=m.complexTensorInfos.real,y=m.complexTensorInfos.imag,b=l.data.get(A.dataId).values,x=l.data.get(y.dataId).values,[C,w,E]=t(o.shape,a.shape,p,f,b,x),T=l.makeTensorInfo(E,"float32",C),v=l.makeTensorInfo(E,"float32",w),S=mr({inputs:{real:T,imag:v},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(T),l.disposeIntermediateTensorInfo(v),S}else{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=s||o.dtype,[d,p]=e(o.shape,a.shape,c,u,h);return l.makeTensorInfo(p,h,d)}}}function vB(n){return(e,t,s,i,r,o)=>{const a=Mt(e,t),l=ce(a),c=a.length,u=vt(a),h=Cs("float32",l),d=Cs("float32",l),p=rl(e,a),f=rl(t,a),g=$o(s,i),m=$o(r,o),A=e.length,y=vt(e),b=t.length,x=vt(t);if(p.length+f.length===0)for(let C=0;C<h.length;C++){const w=C%g.length,E=C%m.length,T=n(g[w*2],g[w*2+1],m[E*2],m[E*2+1]);h[C]=T.real,d[C]=T.imag}else for(let C=0;C<h.length;C++){const w=Hu(C,c,u),E=w.slice(-A);p.forEach(N=>E[N]=0);const T=No(E,A,y),v=w.slice(-b);f.forEach(N=>v[N]=0);const S=No(v,b,x),_=n(g[T*2],g[T*2+1],m[S*2],m[S*2+1]);h[C]=_.real,d[C]=_.imag}return[h,d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fz=ms(((n,e)=>n+e)),_ue=vB(((n,e,t,s)=>({real:n+t,imag:e+s}))),yp=Ds(cc,fz,_ue),Tue={kernelName:cc,backendName:"cpu",kernelFunc:yp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SB(n,e,t,s,i){const r=ce(s),o=Ws(i,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(r>0?o[l]+=e[a]:o[l]+=1)}return o}function mz(n,e,t,s=!1){const i=n.shape[0],r=n.shape[1],o=zt([i,t],e.dtype);for(let a=0;a<i;a++)for(let l=0;l<r;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gz=ms(((n,e)=>n&e)),Bue=Ds(gA,gz),kue={kernelName:gA,backendName:"cpu",kernelFunc:Bue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _a(n){return(e,t,s)=>{const i=ns(t,e.length);for(let r=0;r<e.length;++r)i[r]=n(e[r],s);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function En(n,e,t){const s=_a(e);return mc(n,s,t)}function mc(n,e,t){return({inputs:s,attrs:i,backend:r})=>{const{x:o}=s;It(o,n);const a=r,l=a.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=Po(l)}else c=l;const u=t||o.dtype,h=e(c,u,i);return a.makeTensorInfo(o.shape,u,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Az=_a(n=>Math.ceil(n)),Mue=mc(th,Az),Nue={kernelName:th,backendName:"cpu",kernelFunc:Mue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yz(n,e,t,s){const i=ns(t,ce(e));if(s&&t!=="string"){let r=0;n.forEach(o=>{const a=ce(o.shape);i.set(o.vals,r),r+=a})}else{let r=0;n.forEach(o=>{const a=t==="string"?Po(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+r;for(let h=0;h<o.shape[1];++h)i[u+h]=a[l++]}r+=o.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xz=ms((n,e)=>n===e?1:0),bz=Ds(Gp,xz,null,"bool"),Rue={kernelName:Gp,backendName:"cpu",kernelFunc:bz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iz=_a(n=>Math.exp(n)),Cz=mc(lh,Iz,"float32"),Due={kernelName:lh,backendName:"cpu",kernelFunc:Cz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wz=_a(n=>Math.expm1(n)),Fue=mc(ch,wz),$ue={kernelName:ch,backendName:"cpu",kernelFunc:Fue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vz=_a(n=>Math.floor(n)),Pue=mc(uh,vz),Lue={kernelName:uh,backendName:"cpu",kernelFunc:Pue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sz=ms((n,e)=>Math.floor(n/e)),Oue=Ds(hh,Sz,null,"int32"),zue={kernelName:hh,backendName:"cpu",kernelFunc:Oue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ez(n,e,t,s,i,r,o,a,l){const c=zt([s,r],t);for(let u=0;u<s;u++){const h=[];let d=0;for(let p=0;p<i;p++){const f=n[u*i+p];d+=f*o[p],h.push(f)}if(d<0||d>=l/r)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let p=0;p<r;p++)c.values[u*r+p]=e.get(...e.indexToLoc(d*r+p))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _z(n,e,t){const s=zt(t,n.dtype);for(let i=0;i<s.size;++i){const o=s.indexToLoc(i).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(s.values[i]=n.values[u])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tz=ms((n,e)=>n>e?1:0),Uue=Ds(Yp,Tz,null,"bool"),Que={kernelName:Yp,backendName:"cpu",kernelFunc:Uue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bz=ms((n,e)=>n>=e?1:0),Vue=Ds(dh,Bz,null,"bool"),Gue={kernelName:dh,backendName:"cpu",kernelFunc:Vue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kz=ms((n,e)=>n<e?1:0),Wue=Ds(jp,kz,null,"bool"),Hue={kernelName:jp,backendName:"cpu",kernelFunc:Wue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mz=ms((n,e)=>n<=e?1:0),que=Ds(Kp,Mz,null,"bool"),Yue={kernelName:Kp,backendName:"cpu",kernelFunc:que};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nz(n,e,t){const s=(e-n)/(t-1),i=Ws(t,"float32");i[0]=n;for(let r=1;r<i.length;r++)i[r]=i[r-1]+s;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rz=_a(n=>Math.log(n)),Xue=mc(Ah,Rz),jue={kernelName:Ah,backendName:"cpu",kernelFunc:Xue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dz(n,e,t,s){const i=Cs(s,ce(t));for(let r=0;r<i.length;++r){const o=r*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}i[r]=a}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fz=ms(((n,e)=>Math.max(n,e))),Kue=Ds(xh,Fz),Jue={kernelName:xh,backendName:"cpu",kernelFunc:Kue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $z=ms(((n,e)=>Math.min(n,e))),Zue=Ds(bh,$z),ehe={kernelName:bh,backendName:"cpu",kernelFunc:Zue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EB=ms(((n,e)=>n*e)),the=vB(((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t}))),Nw=Ds(Ch,EB,the),nhe={kernelName:Ch,backendName:"cpu",kernelFunc:Nw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pz(n,e,t){const s=hl(-1,t);return EB([],e,s,n,t)}function she(n){const{inputs:e,backend:t}=n,{x:s}=e;It(s,"neg");const i=t.data.get(s.dataId).values,[r,o]=Pz(i,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,r)}const ihe={kernelName:cf,backendName:"cpu",kernelFunc:she};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lz=ms(((n,e)=>n!==e?1:0)),rhe=Ds(uf,Lz,null,"bool"),ohe={kernelName:uf,backendName:"cpu",kernelFunc:rhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _B(n,e,t,s,i){const r=e.length,o=ce(e),a=vt(e),l=vt(i),c=Cs(t,ce(i));for(let u=0;u<o;++u){const h=Hu(u,r,a),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[s[f]];const p=No(d,r,l);c[p]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sr(n){const{inputs:e,attrs:t,backend:s}=n,{x:i}=e,{perm:r}=t;It(i,"transpose");const o=i.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=i.shape[r[h]];const l=s.data.get(i.dataId).values,c=_B(l,i.shape,i.dtype,r,a);return{dataId:s.write(c,a,i.dtype),shape:a,dtype:i.dtype}}const ahe={kernelName:Ol,backendName:"cpu",kernelFunc:sr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oz(n,e,t,s){const[i,r]=ps(n,s),o=Ns(e,"int32"),a=Ws(ce(i),o),l=ce(r);for(let c=0;c<a.length;++c){const u=c*l;let h=1;for(let d=0;d<l;++d)h*=t[u+d];a[c]=h}return{outVals:a,outShape:i,outDtype:o}}function lhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;It(i,"prod");const a=i.shape.length,l=Vt(r,i.shape),c=Nn(l,a);let u=l,h=i;const d=[];c!=null&&(h=sr({inputs:{x:i},backend:t,attrs:{perm:c}}),d.push(h),u=Vn(u.length,a));const p=t.data.get(h.dataId).values,{outVals:f,outShape:g,outDtype:m}=Oz(h.shape,h.dtype,p,u);let A=g;return o&&(A=us(g,l)),d.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(A,m,f)}const che={kernelName:gf,backendName:"cpu",kernelFunc:lhe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uhe(n,e,t){n.forEach((s,i)=>{if(s<0||s>=t){const r=Hu(i,e.length,vt(e)).join(",");throw new Error(`indices[${r}] = ${s} is not in [0, ${t})`)}})}function hhe(n,e){for(let t=0;t<n.length;++t){const s=n[t],i=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>i)throw new Error("Ragged splits must not point past values");for(let r=1;r<s.length;++r)if(s[r-1]>s[r])throw new Error("Ragged splits must be sorted in ascending order")}}function dhe(n,e,t,s){const i=[];let r=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);hhe(t,s);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const u=e[c+1];for(let h=1;h<l+1;++h)a[c].push(h*u)}for(let c=0;c<n.length;++c){let u=n[c],h=n[c]+1;for(let d=0;d<t.length;++d){const p=t[d],f=d+e.length-1;if(f>=0){const g=a[f],m=g[g.length-1]-p[u];for(let A=u;A<h;++A)a[f].push(p[A+1]+m)}u=p[u],h=p[h]}h!==u&&(i.push([u,h]),r+=h-u)}return{outSplits:a,valueSlices:i,numValues:r}}function phe(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,i=ns("int32",s);e.push(i),n[t].forEach((r,o)=>i[o]=r)}return e}function fR(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function fhe(n,e,t,s,i,r){const o=fR(e,2)[1],a=fR(r,2)[1];let l=0;for(const c of t)for(let u=c[0];u<c[1];++u){for(let h=0;h<s;++h)i[l*a+h]=n[u*o+h];++l}}function mhe(n,e,t,s,i){const r=e.slice();r[0]=i;const o=ns(t,ce(r)),a=n.length,l=a===0?0:a/e[0];return fhe(n,e,s,l,o,r),[o,r]}function zz(n,e,t,s,i,r,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(uhe(r,o,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:u,valueSlices:h,numValues:d}=dhe(r,o,n,c),p=phe(u),f=mhe(t,s,i,h,d);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mR=2147483647;function Uz(n,e,t,s,i,r,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=i.length===0,c=o.length===0,u=[];a||u.push(e[0]),l||u.push(i[0]),c||u.push(o[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=u.length===0?1:u[0],d=ns("int32",h+1);d[0]=0;for(let m=0;m<h;++m){const A=a?n[0]:n[m],y=l?s[0]:s[m],b=c?r[0]:r[m];if(b===0)throw new Error("Requires delta != 0");let x;if(b>0&&y<A||b<0&&y>A)x=0;else if(x=Math.ceil(Math.abs((y-A)/b)),x>mR)throw new Error(`Requires ((limit - start) / delta) <= ${mR}`);d[m+1]=d[m]+x}const p=d[h],f=ns(t,p);let g=0;for(let m=0;m<h;++m){const A=d[m+1]-d[m];let y=a?n[0]:n[m];const b=c?r[0]:r[m];for(let x=0;x<A;++x)f[g++]=y,y+=b}return[d,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var no=So;class Jb{constructor(e,t,s,i,r,o,a,l,c,u){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=i,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=lL(u),this.raggedRank=cL(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===no.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===no.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case no.VALUE_ROWIDS:return Jb.getMaxWidthValueRowID(t);case no.ROW_SPLITS:return Jb.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${no[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let i=0;i<t-1;++i){const r=e[i+1]-e[i];r>s&&(s=r)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,i=e[0],r=0;for(let o=1;o<t;++o){const a=e[o];a!==i&&(i=a,r=Math.max(o-s,r),s=o)}return Math.max(t-s,r)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return AR(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;uL(s,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=aL(this.raggedRank,i,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,s){const i=Math.min(e,s),r=[];let o=0;for(let a=0;a<i;++a,o+=t)r.push(o);for(let a=i;a<e;++a)r.push(-1);return R(r.length===e,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(e,t,s,i){const r=e.length,o=[];for(let a=0;a<r-1;++a){const l=e[a+1]-e[a];let c=Math.min(i,l),u=t[a];u===-1&&(c=0);for(let h=0;h<c;++h)o.push(u),u+=s;for(let h=0;h<l-c;++h)o.push(-1)}if(r>0&&o.length!==e[r-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,s,i){const r=e.length,o=[];if(r===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];o.push(c);for(let u=1;u<r;++u){const h=e[u];if(h===l)c>=0&&(++a,a<i?c+=s:c=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);c=t[h]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,s,i){const r=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case no.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,s,i);case no.ROW_SPLITS:if(r.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(r,t,s,i);default:throw new Error(`Unsupported partition type: ${no[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case no.FIRST_DIM_SIZE:return e[0];case no.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case no.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${no[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*s[l+1];const r=AR(s,!1),o=ns(this.valuesDType,ce(r));if(i[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,i[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,i[c],s[c]);this.setOutput(this.raggedRank,l,o,r)}return[r,o]}setOutput(e,t,s,i){if(s.length===0)return;const r=this.values,o=s;let a=i.slice();a=a.slice(e+1);const l=ce(a),c=t.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const f=this.defaultValueShape;le(()=>{const g=ee(u,f);u=pu(g,a).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=c;++f){let g=f<c?t[f]:-1;if(g===p){++p;continue}if(d<p){const m=r.subarray(h*l),A=o.subarray(d*l),y=(p-d)*l;gR(A,m,y)}if(f>=c){const m=s.length;g=Math.floor(m/l)}if(g>p)if(this.defaultValue.length===1)o.subarray(p*l,g*l).fill(this.defaultValue[0]),p=g;else for(;g>p;){const m=o.slice(p*l);gR(m,u,l),++p}g<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}}function gR(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function AR(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function Qz(n,e,t,s,i,r,o,a,l,c){return new Jb(n,e,t,s,i,r,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vz(n,e,t,s){const i=n===e,r=n<e&&t<0,o=e<n&&t>1;if(i||r||o)return Ws(0,s);const a=Math.abs(Math.ceil((e-n)/t)),l=Ws(a,s);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gz=_a(n=>1/Math.sqrt(n)),ghe=mc(Th,Gz),Ahe={kernelName:Th,backendName:"cpu",kernelFunc:ghe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(n,e,t,s,i,r,o,a,l,c){const u=[s/i,i],h=n.values,d=e.values;if(s===0)return zt(t,e.dtype);const p=l instanceof Is?l:zt(u,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<r;f++){const g=[];let m=0;for(let A=0;A<o;A++){const y=h[f*o+A];g.push(y),m+=y*a[A]}if(m<0||m>=s/i)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let A=0;A<i;A++)c?p.values[m*i+A]+=d[f*i+A]:p.values[m*i+A]=e.rank===0?d[0]:d[f*i+A]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yhe=_a(n=>1/(1+Math.exp(-n))),Wz=En(Rh,n=>1/(1+Math.exp(-n))),xhe={kernelName:Rh,backendName:"cpu",kernelFunc:Wz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hz(n,e,t,s,i){const r=P_(s,e,t),o=ce(t),a=vt(s);if(r){const h=L_(e,a);return i==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=i==="string"?Po(n):n,c=zt(s,i,l),u=zt(t,i);for(let h=0;h<u.size;++h){const d=u.indexToLoc(h),p=d.map((f,g)=>f+e[g]);u.set(c.get(...p),...d)}return i==="string"?BL(u.values):u.values}function $u(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:o}=s;It(i,"slice");const[a,l]=Ry(i,r,o);GC(i,a,l);const c=t.data.get(i.dataId).values,u=Hz(c,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,u)}const bhe={kernelName:Cf,backendName:"cpu",kernelFunc:$u};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qz(n,e,t,s,i,r,o){const a=e[0],l=r[0],c=new Array(l),u=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(AL(a));const m=ns(t,0),A=ns(i,0);return[m,[0,h],A,c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<a;++m){const A=n[m*h];if(A<0)throw new Error(yL(m,A));if(A>=l)throw new Error(xL(m,A,l));++f[A],d=d&&A>=p,p=A}let g=!0;for(let m=0;m<l;++m){const A=f[m]===0;c[m]=A,g=g&&!A,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){const m=n,A=s;for(let y=0;y<a;++y)u[y]=y;return[m,[a,h],A,c,u]}else{const m=f[l-1],A=ns(t,m*h),y=ns(i,m),b=new Array(l).fill(0);for(let x=0;x<a;++x){const C=n[x*h],w=b[C],E=(C===0?0:f[C-1])+w;b[C]++;for(let T=0;T<h;++T)A[E*h+T]=n[x*h+T];y[E]=s[x],u[x]=E}for(let x=0;x<l;++x)if(b[x]===0){const w=x===0?0:f[x-1];A[w*h+0]=x;for(let E=1;E<h;++E)A[w*h+E]=0;y[w]=o}return[A,[m,h],y,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yz(n,e,t,s,i){const r=ce(s),o=e[0],a=i.length,l=[];let c=1,u=-1;for(let m=0;m<a;++m){const A=i[m];if(A===-1){if(u!==-1)throw new Error(bL(u,m));u=m,l.push(1)}else{if(A<0)throw new Error(IL(m,A));c*=A,l.push(A)}}if(u!==-1){if(c<=0)throw new Error(CL());const m=Math.trunc(r/c);if(c*m!==r)throw new Error(wL(s,l));l[u]=m}if(ce(l)!==r)throw new Error(vL(s,l));const d=s.length,p=[];if(d>0){p[d-1]=1;for(let m=d-2;m>=0;--m)p[m]=p[m+1]*s[m+1]}const f=[];if(a>0){f[a-1]=1;for(let m=a-2;m>=0;--m)f[m]=f[m+1]*l[m+1]}const g=ns(t,o*a);for(let m=0;m<o;++m){let A=0;for(let y=0;y<d;++y)A+=n[m*d+y]*p[y];for(let y=0;y<a;++y)g[m*a+y]=Math.trunc(A/f[y]),A%=f[y]}return[g,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TB(n,e,t,s,i,r=!1,o=0){const a=s.length,l=[e[0],n.length/e[0]],c=l[1],h=a>0?i[a-1]+1:0;if(h<0)throw new Error(b1());const d=e.slice();d[0]=h;const p=d.reduce((b,x)=>b*x,1),f=ns(t,p);if(a===0)return h>0&&f.fill(o),[f,d];if(h<=0)throw new Error(b1());let g=0,m=1,A=0,y=i[g];for(;;){let b=0;if(m<a){if(b=i[m],y===b){++m;continue}if(y>=b)throw new Error(SL())}if(y<0||y>=h)throw new Error(EL(y,h));y>A&&f.fill(o,A*c,y*c);for(let x=g;x<m;++x){const C=s[x];if(C<0||C>=l[0])throw new Error(_L(x,s[x],l[0]));for(let w=0;w<c;w++)f[y*c+w]+=n[C*c+w]}if(r)for(let x=0;x<c;x++)f[y*c+x]/=m-g;if(g=m,++m,A=y+1,y=b,m>a)break}return A<h&&f.fill(o,A*c,h*c),[f,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ihe=_a(n=>Math.sqrt(n)),Che=En(Fh,n=>Math.sqrt(n)),whe={kernelName:Fh,backendName:"cpu",kernelFunc:Che};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xz=ms(((n,e)=>{const t=n-e;return t*t})),vhe=Ds($h,Xz),She={kernelName:$h,backendName:"cpu",kernelFunc:vhe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jz=_a((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:i}=e;return n.replace(new RegExp(t,s?"g":""),i)}),Ehe=mc(sy,jz),_he={kernelName:sy,backendName:"cpu",kernelFunc:Ehe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kz(n,e,t,s){const i=zt(n,e.dtype);for(let r=0;r<i.size;r++){const o=i.indexToLoc(r),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+s[l];i.set(e.get(...a),...o)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class The{constructor(e,t,s,i,r,o){this.separator=Ro(e),this.nGramWidths=t,this.leftPad=Ro(s),this.rightPad=Ro(i),this.padWidth=r,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,i,r,o){for(let a=0;a<r;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(r-(a+1))),h=o-(c+u),d=t+(c>0?0:a-l);let p=0;p+=c*this.leftPad.length;for(let y=0;y<h;++y)p+=e[d+y].length;p+=u*this.rightPad.length;const f=c+u+h-1;p+=f*this.separator.length,s[i+a]=new Uint8Array(p);const g=s[i+a];let m=0;const A=y=>y.forEach(b=>g[m++]=b);for(let y=0;y<c;++y)A(this.leftPad),A(this.separator);for(let y=0;y<h-1;++y)A(e[d+y]),A(this.separator);if(h>0){A(e[d+h-1]);for(let y=0;y<u;++y)A(this.separator),A(this.rightPad)}else{for(let y=0;y<u-1;++y)A(this.rightPad),A(this.separator);A(this.rightPad)}}}compute(e,t){const s=e.length,i=t.length;if(i>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<i;++c){let u=t[c]>=l;if(u=u&&t[c]<=s,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${s}]`);l=t[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const r=i-1,o=ns("int32",i);if(s===0||i===0){const l=new Array(s);for(let c=0;c<=r;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=r;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[r]);for(let l=0;l<r;++l){const c=t[l];let u=o[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],p=this.getNumNGrams(d,h);this.createNGrams(e,c,a,u,p,h),u+=p}),this.preserveShort&&u===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth;this.createNGrams(e,c,a,u,1,d)}}return[a,o]}}function Jz(n,e,t,s,i,r,o,a){return new The(t,s,i,r,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bhe(n,e,t,s){if(!n.length)return;if(e.length===0){for(let r=0;r<n.length;++r)s.push(n.subarray(r,r+1));return}if(e.length===1){const r=e[0];let o=n.indexOf(r);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&s.push(a),n=n.subarray(o+1),o=n.indexOf(r)}(!t||n.length!==0)&&s.push(n);return}let i=0;for(let r=0;r<n.length+1;r++)if(r===n.length||e.indexOf(n[r])!==-1){const o=n.subarray(i,r);(!t||o.length!==0)&&s.push(o),i=r+1}}function Zz(n,e,t){const s=n.length,i=[];let r=0,o=0;const a=new Array(s);for(let d=0;d<s;++d){const p=i.length;Bhe(n[d],e,t,i);const f=i.length-p;a[d]=f,r+=f,o=Math.max(o,f)}const l=ns("int32",r*2),c=new Array(r),u=[s,o];let h=0;for(let d=0;d<s;++d)for(let p=0;p<a[d];++p)l[h*2]=d,l[h*2+1]=p,c[h]=i[h],++h;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eU(n,e){const t=ns("int32",n.length);for(let s=0;s<n.length;++s)t[s]=p$(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tU=ms(((n,e)=>n-e)),khe=vB(((n,e,t,s)=>({real:n-t,imag:e-s}))),BB=Ds(Ph,tU,khe),Mhe={kernelName:Ph,backendName:"cpu",kernelFunc:BB};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nU(n,e){const t=new Array(n.rank);for(let i=0;i<t.length;i++)t[i]=n.shape[i]*e[i];const s=zt(t,n.dtype);for(let i=0;i<s.values.length;++i){const r=s.indexToLoc(i),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=r[l]%n.shape[l];const a=n.locToIndex(o);s.values[i]=n.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fm=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function sU(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,l=e-t+1,c=Math.log(a),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),d=Math.max(t,Math.floor(e-l*u/a+h)),p=Math.min(s,Math.floor(e+(a-l)*u/a+h));sU(n,e,d,p)}const i=n[e];let r=t,o=s;for(Ga(n,t,e),Fm(n[s],i)>0&&Ga(n,t,s);r<o;){for(Ga(n,r,o),r++,o--;Fm(n[r],i)<0;)r=r+1;for(;Fm(n[o],i)>0;)o=o-1}Fm(n[t],i)===0?Ga(n,t,o):(o=o+1,Ga(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function iU(n,e,t,s,i){const r=e[e.length-1],[o,a]=[n.length/r,r],l=Cs(t,o*s),c=Cs("int32",o*s);for(let h=0;h<o;h++){const d=h*a,p=n.subarray(d,d+a);let f=new Array(p.length);p.forEach((y,b)=>f[b]={value:y,index:b}),s<f.length&&(sU(f,s),f=f.slice(0,s)),i&&f.sort(Fm);const g=h*s,m=l.subarray(g,g+s),A=c.subarray(g,g+s);for(let y=0;y<s;y++)m[y]=f[y].value,A[y]=f[y].index}const u=e.slice();return u[u.length-1]=s,[zt(u,t,l),zt(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rU(n,e,t,s){const i=Vt(e,t)[0],r=[1,t[0],1];for(let f=0;f<i;f++)r[0]*=t[f];r[1]=t[i];for(let f=i+1;f<t.length;f++)r[2]*=t[f];const o=new Map,a=new Int32Array(t[i]),l=new Is(r,s,n),c=[],u=r[0]===1&&r[2]===1;for(let f=0;f<t[i];f++){let g;if(u)g=n[f].toString();else{const A=[];for(let y=0;y<r[0];y++)for(let b=0;b<r[2];b++)A.push(l.get(y,f,b));g=A.join(",")}const m=o.get(g);if(m!=null)a[f]=m;else{const A=o.size;o.set(g,A),a[f]=A,c.push(f)}}const h=r.slice();h[1]=o.size;const d=new Is(h,s);c.forEach((f,g)=>{for(let m=0;m<r[0];m++)for(let A=0;A<r[2];A++)d.set(l.get(m,f,A),m,g,A)});const p=t.slice();return p[i]=h[1],{outputValues:d.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kB=Object.freeze(Object.defineProperty({__proto__:null,addImpl:fz,bincountImpl:SB,bincountReduceImpl:mz,bitwiseAndImpl:gz,castImpl:pz,ceilImpl:Az,concatImpl:yz,equalImpl:xz,expImpl:Iz,expm1Impl:wz,floorDivImpl:Sz,floorImpl:vz,gatherNdImpl:Ez,gatherV2Impl:_z,greaterEqualImpl:Bz,greaterImpl:Tz,lessEqualImpl:Mz,lessImpl:kz,linSpaceImpl:Nz,logImpl:Rz,maxImpl:Dz,maximumImpl:Fz,minimumImpl:$z,multiplyImpl:EB,negImpl:Pz,notEqualImpl:Lz,prodImpl:Oz,raggedGatherImpl:zz,raggedRangeImpl:Uz,raggedTensorToTensorImpl:Qz,rangeImpl:Vz,rsqrtImpl:Gz,scatterImpl:tu,sigmoidImpl:yhe,simpleAbsImpl:dz,sliceImpl:Hz,sparseFillEmptyRowsImpl:qz,sparseReshapeImpl:Yz,sparseSegmentReductionImpl:TB,sqrtImpl:Ihe,squaredDifferenceImpl:Xz,staticRegexReplaceImpl:jz,stridedSliceImpl:Kz,stringNGramsImpl:Jz,stringSplitImpl:Zz,stringToHashBucketFastImpl:eU,subImpl:tU,tileImpl:nU,topKImpl:iU,transposeImpl:_B,uniqueImpl:rU},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const oU="4.22.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */oC("cpu",()=>new Wy,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aU=En(oh,n=>n>=0?n:Math.exp(n)-1),Nhe={kernelName:oh,backendName:"cpu",kernelFunc:aU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lU(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s;It([i],"leakyRelu");const o=ce(i.shape),a=t.data.get(i.dataId).values,l=Cs("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?r*a[c]:a[c];return t.makeTensorInfo(i.shape,"float32",l)}const Rhe={kernelName:Xp,backendName:"cpu",kernelFunc:lU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dhe=ms((n,e)=>n<0?e*n:n);function cU(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e;It([s,i],"prelu");const r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,[a,l]=Dhe(s.shape,i.shape,r,o,"float32");return t.makeTensorInfo(l,"float32",a)}const Fhe={kernelName:mf,backendName:"cpu",kernelFunc:cU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uU=En(Sh,n=>Math.max(0,n)),$he={kernelName:Sh,backendName:"cpu",kernelFunc:uU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hU=En(Eh,n=>Math.min(Math.max(0,n),6)),Phe={kernelName:Eh,backendName:"cpu",kernelFunc:hU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zb(n,e,t,s,i){if(t==="linear")return xa({inputs:{x:e},backend:n});if(t==="relu")return uU({inputs:{x:e},backend:n});if(t==="elu")return aU({inputs:{x:e},backend:n});if(t==="relu6")return hU({inputs:{x:e},backend:n});if(t==="prelu")return cU({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return lU({inputs:{x:e},backend:n,attrs:{alpha:i}});if(t==="sigmoid")return Wz({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Un(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:r}=s,o=ce(i.shape),a=qI(r,o),l=ce(a);R(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(i.dataId);const c=t.data.get(i.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=a,h.shape=a}return{dataId:i.dataId,shape:a,dtype:i.dtype}}const Lhe={kernelName:Af,backendName:"cpu",kernelFunc:Un};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dU(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:o,transposeB:a}=s;It([i,r],"matMul");const l=i.shape.length,c=r.shape.length,u=o?i.shape[l-2]:i.shape[l-1],h=a?r.shape[c-1]:r.shape[c-2],d=o?i.shape[l-1]:i.shape[l-2],p=a?r.shape[c-2]:r.shape[c-1],f=i.shape.slice(0,-2),g=r.shape.slice(0,-2),m=ce(f),A=ce(g),b=Mt(i.shape.slice(0,-2),r.shape.slice(0,-2)).concat([d,p]);R(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${i.shape} and ${r.shape} and transposeA=${o} and transposeB=${a} must match.`);const x=o?[m,u,d]:[m,d,u],C=a?[A,p,h]:[A,h,p],w=Un({inputs:{x:i},backend:t,attrs:{shape:x}}),E=Un({inputs:{x:r},backend:t,attrs:{shape:C}}),T=o?w.shape[1]:w.shape[2],v=o?w.shape[2]:w.shape[1],S=a?E.shape[1]:E.shape[2],_=Math.max(m,A),N=t.data.get(w.dataId).values,D=t.data.get(E.dataId).values,P=vt(w.shape),L=vt(E.shape),[z,q,V]=o?[P[0],1,P[1]]:[P[0],P[1],1],[X,te,se]=a?[1,L[1],L[0]]:[L[1],1,L[0]],fe=v*S,me=zt([_,v,S],w.dtype),Te=me.values,Ee=t.blockSize;for(let re=0;re<_;re++){const ue=re%m,_e=re%A;for(let ke=0;ke<v;ke+=Ee){const Ne=Math.min(ke+Ee,v);for(let Ue=0;Ue<S;Ue+=Ee){const ht=Math.min(Ue+Ee,S);for(let W=0;W<T;W+=Ee){const Ce=Math.min(W+Ee,T);for(let be=ke;be<Ne;be++)for(let ge=Ue;ge<ht;ge++){let ye=0;for(let Re=W;Re<Ce;Re++){const De=N[ue*z+be*q+Re*V],Me=D[Re*X+ge*te+_e*se];ye+=De*Me}Te[re*fe+(be*S+ge)]+=ye}}}}}return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(E),t.makeTensorInfo(b,me.dtype,me.values)}const Ohe={kernelName:Dp,backendName:"cpu",kernelFunc:dU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zhe(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s;let d,p,f;const g=[];d=dU({inputs:{a:i,b:r},attrs:{transposeA:l,transposeB:c},backend:t}),o&&(p=yp({inputs:{a:d,b:o},backend:t}),g.push(d),d=p),u&&(f=Zb(t,d,u,a,h),g.push(d),d=f);for(const A of g)t.disposeIntermediateTensorInfo(A);return d}const Uhe={kernelName:ip,backendName:"cpu",kernelFunc:zhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qhe=En(qu,n=>Math.acos(n)),Vhe={kernelName:qu,backendName:"cpu",kernelFunc:Qhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ghe=En(Yu,n=>Math.acosh(n)),Whe={kernelName:Yu,backendName:"cpu",kernelFunc:Ghe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hhe(n){const{inputs:e,backend:t}=n,s=e;It(e,"addN");const i=s.map(a=>t.data.get(a.dataId).values),r=zt(s[0].shape,s[0].dtype),o=r.values;for(let a=0;a<s.length;a++){const l=i[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return t.makeTensorInfo(r.shape,r.dtype,r.values)}const qhe={kernelName:Bp,backendName:"cpu",kernelFunc:Hhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;It(i,"all");const a=Vt(r,i.shape);let l=a;const c=Nn(l,i.shape.length);let u=i;c!=null&&(u=sr({inputs:{x:i},backend:t,attrs:{perm:c}}),l=Vn(l.length,i.shape.length)),vs("all",l,u.shape.length);const[h,d]=ps(u.shape,l),p=ce(d),f=Ws(ce(h),u.dtype),g=t.data.get(u.dataId).values;for(let A=0;A<f.length;++A){const y=A*p;let b=g[y];for(let x=0;x<p;++x){const C=g[y+x];b=b&&C}f[A]=b}c!=null&&t.disposeIntermediateTensorInfo(u);const m=t.makeTensorInfo(h,u.dtype,f);if(o){const A=us(h,a),y=Un({inputs:{x:m},backend:t,attrs:{shape:A}});return t.disposeIntermediateTensorInfo(m),y}return m}const Xhe={kernelName:hA,backendName:"cpu",kernelFunc:Yhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;It(i,"any");const a=Vt(r,i.shape);let l=a;const c=Nn(l,i.shape.length);let u=i;c!=null&&(u=sr({inputs:{x:i},backend:t,attrs:{perm:c}}),l=Vn(l.length,i.shape.length)),vs("any",l,u.shape.length);const[h,d]=ps(u.shape,l),p=ce(d),f=Ws(ce(h),u.dtype),g=t.data.get(u.dataId).values;for(let A=0;A<f.length;++A){const y=A*p;let b=g[y];for(let x=0;x<p;++x){const C=g[y+x];b=b||C}f[A]=b}c!=null&&t.disposeIntermediateTensorInfo(u);const m=t.makeTensorInfo(h,u.dtype,f);if(o){const A=us(h,a),y=Un({inputs:{x:m},backend:t,attrs:{shape:A}});return t.disposeIntermediateTensorInfo(m),y}return m}const Khe={kernelName:dA,backendName:"cpu",kernelFunc:jhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;It(i,"argMax");let o=Vt(r,i.shape);const a=Nn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=sr({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Vn(o.length,l.shape.length)),o=[o[0]],vs("argMax",o,l.shape.length);const[u,h]=ps(l.shape,o),d=ce(u),p=Ws(d,"int32"),f=ce(h),g=t.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const A=m*f;let y=g[A],b=0;for(let x=0;x<f;++x){const C=g[A+x];C>y&&(y=C,b=x)}p[m]=b}return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.makeTensorInfo(u,"int32",p)}const Zhe={kernelName:kp,backendName:"cpu",kernelFunc:Jhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ede(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;It(i,"argMin");let o=Vt(r,i.shape);const a=Nn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=sr({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Vn(o.length,l.shape.length)),o=[o[0]],vs("argMin",o,l.shape.length);const[u,h]=ps(l.shape,o),d=ce(u),p=Ws(d,"int32"),f=ce(h),g=t.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const A=m*f;let y=g[A],b=0;for(let x=0;x<f;++x){const C=g[A+x];C<y&&(y=C,b=x)}p[m]=b}return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.makeTensorInfo(u,"int32",p)}const tde={kernelName:Mp,backendName:"cpu",kernelFunc:ede};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nde=En(Xu,n=>Math.asin(n)),sde={kernelName:Xu,backendName:"cpu",kernelFunc:nde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ide=En(ju,n=>Math.asinh(n)),rde={kernelName:ju,backendName:"cpu",kernelFunc:ide};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ode=En(Ku,n=>Math.atan(n)),ade={kernelName:Ku,backendName:"cpu",kernelFunc:ode};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lde=ms((n,e)=>Math.atan2(n,e)),cde=Ds(Zu,lde),ude={kernelName:Zu,backendName:"cpu",kernelFunc:cde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hde=En(Ju,n=>Math.atanh(n)),dde={kernelName:Ju,backendName:"cpu",kernelFunc:hde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MB(n,e,t,s,i,r){const o=i.strideHeight,a=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,u=i.effectiveFilterHeight,h=i.effectiveFilterWidth,d=i.padInfo.top,p=i.padInfo.left,f=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=zt(i.outShape,t),m=g.values,A=i.outShape[1]*i.outShape[2]*i.outShape[3],y=i.outShape[2]*i.outShape[3],b=i.outShape[3];for(let x=0;x<i.batchSize;++x){const C=x*A,w=x*s[0];for(let E=0;E<i.inChannels;++E)for(let T=0;T<i.outHeight;++T){const v=T*o-d,S=Math.max(0,v),_=Math.min(i.inHeight,u+v),N=C+T*y;for(let D=0;D<i.outWidth;++D){const P=D*a-p,L=Math.max(0,P),z=Math.min(i.inWidth,h+P);let q=f,V=0,X=0;for(let se=S;se<_;se+=l){const fe=w+se*s[1];for(let me=L;me<z;me+=c){const Te=fe+me*s[2],Ee=n[Te+E];r==="max"&&Ee>q?q=Ee:r==="avg"&&(V+=Ee,X++)}if(isNaN(q))break}const te=N+D*b+E;m[te]=r==="avg"?V/X:q}}}return g}function pU(n,e,t,s,i=!1,r=!1){const o=zt(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,u=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,g=zt(e,t,n);for(let m=0;m<s.batchSize;++m)for(let A=0;A<s.inChannels;++A)for(let y=0;y<s.outHeight;++y){const b=y*a-p;let x=b;for(;x<0;)x+=c;const C=Math.min(s.inHeight,h+b);for(let w=0;w<s.outWidth;++w){const E=w*l-f;let T=E;for(;T<0;)T+=u;const v=Math.min(s.inWidth,d+E);let S=Number.NEGATIVE_INFINITY,_=-1;for(let N=x;N<C;N+=c){const D=N-b;for(let P=T;P<v;P+=u){const L=P-E,z=g.get(m,N,P,A);z>S&&(S=z,i?_=r?((m*s.inHeight+N)*s.inWidth+P)*s.inChannels+A:(N*s.inWidth+P)*s.inChannels+A:_=D*d+L)}}o.set(_,m,y,w,A)}}return o}function fU(n,e,t,s,i,r){const o=i.strideDepth,a=i.strideHeight,l=i.strideWidth,c=i.dilationDepth,u=i.dilationHeight,h=i.dilationWidth,d=i.effectiveFilterDepth,p=i.effectiveFilterHeight,f=i.effectiveFilterWidth,g=i.padInfo.front,m=i.padInfo.top,A=i.padInfo.left,y=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=zt(i.outShape,t),x=b.values,C=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],w=i.outShape[2]*i.outShape[3]*i.outShape[4],E=i.outShape[3]*i.outShape[4],T=i.outShape[4];for(let v=0;v<i.batchSize;++v){const S=v*C,_=v*s[0];for(let N=0;N<i.inChannels;++N)for(let D=0;D<i.outDepth;++D){const P=D*o-g;let L=P;for(;L<0;)L+=c;const z=Math.min(i.inDepth,d+P),q=S+D*w;for(let V=0;V<i.outHeight;++V){const X=V*a-m;let te=X;for(;te<0;)te+=u;const se=Math.min(i.inHeight,p+X),fe=q+V*E;for(let me=0;me<i.outWidth;++me){const Te=me*l-A;let Ee=Te;for(;Ee<0;)Ee+=h;const re=Math.min(i.inWidth,f+Te),ue=fe+me*T;let _e=y,ke=0,Ne=0;for(let ht=L;ht<z;ht+=c){const W=_+ht*s[1];for(let Ce=te;Ce<se;Ce+=u){const be=W+Ce*s[2];for(let ge=Ee;ge<re;ge+=h){const ye=be+ge*s[3],Re=n[ye+N];if(r==="max"&&Re>_e?_e=Re:r==="avg"&&(ke+=Re,Ne++),isNaN(_e))break}if(isNaN(_e))break}if(isNaN(_e))break}const Ue=ue+N;x[Ue]=r==="avg"?ke/Math.max(Ne,1):_e}}}}return b}function pde(n,e){const t=zt(e.outShape,"int32"),s=e.strideDepth,i=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let m=0;m<e.inChannels;++m)for(let A=0;A<e.outDepth;++A){const y=A*s-d;let b=y;for(;b<0;)b+=o;const x=Math.min(e.inDepth,c+y);for(let C=0;C<e.outHeight;++C){const w=C*i-p;let E=w;for(;E<0;)E+=a;const T=Math.min(e.inHeight,u+w);for(let v=0;v<e.outWidth;++v){const S=v*r-f;let _=S;for(;_<0;)_+=l;const N=Math.min(e.inWidth,h+S);let D=Number.NEGATIVE_INFINITY,P=-1;for(let L=b;L<x;L+=o){const z=L-y;for(let q=E;q<T;q+=a){const V=q-w;for(let X=_;X<N;X+=l){const te=X-S,se=n.get(g,L,q,X,m);se>=D&&(D=se,P=z*u*h+V*u+te)}}}t.set(P,g,A,C,v,m)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;It(i,"avgPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;R(Rs(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=mi(i.shape,r,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&qt(u.inShape,u.outShape))h=xa({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,p=vt(i.shape),f=MB(d,i.shape,i.dtype,p,u,"avg");h=t.makeTensorInfo(u.outShape,i.dtype,f.values)}return h}const mde={kernelName:Np,backendName:"cpu",kernelFunc:fde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;It(i,"avgPool3d");const u=Xr(i.shape,r,o,1,a,l,c),h=t.data.get(i.dataId).values,d=fU(h,i.shape,i.dtype,vt(i.shape),u,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const Ade={kernelName:Rp,backendName:"cpu",kernelFunc:gde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;It([i,r],"avgPool3DGrad");const u=Xr(r.shape,o,a,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,g=u.filterHeight,m=u.filterWidth,A=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,x=u.effectiveFilterDepth,C=u.effectiveFilterHeight,w=u.effectiveFilterWidth,E=x-1-u.padInfo.front,T=w-1-u.padInfo.left,v=C-1-u.padInfo.top,S=zt(r.shape,"float32"),_=1/(f*g*m),N=t.bufferSync(i);for(let D=0;D<u.batchSize;++D)for(let P=0;P<u.inChannels;++P)for(let L=0;L<u.inDepth;++L)for(let z=0;z<u.inHeight;++z)for(let q=0;q<u.inWidth;++q){const V=L-E,X=z-v,te=q-T;let se=0;for(let fe=0;fe<x;fe+=A){const me=(V+fe)/h;if(!(me<0||me>=u.outDepth||Math.floor(me)!==me))for(let Te=0;Te<C;Te+=y){const Ee=(X+Te)/d;if(!(Ee<0||Ee>=u.outHeight||Math.floor(Ee)!==Ee))for(let re=0;re<w;re+=b){const ue=(te+re)/p;if(ue<0||ue>=u.outWidth||Math.floor(ue)!==ue)continue;const _e=N.get(D,me,Ee,ue,P);se+=_e}}}S.set(se*_,D,L,z,q,P)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const xde={kernelName:fA,backendName:"cpu",kernelFunc:yde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r;It([i,r],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,u=mi(o.shape,a,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,g=u.dilationHeight,m=u.dilationWidth,A=u.effectiveFilterHeight,y=u.effectiveFilterWidth,b=y-1-u.padInfo.left,x=A-1-u.padInfo.top,C=zt(o.shape,"float32"),w=1/(p*f),E=t.data.get(i.dataId).values,T=zt(i.shape,"float32",E);for(let v=0;v<u.batchSize;++v)for(let S=0;S<u.inChannels;++S)for(let _=0;_<u.inHeight;++_)for(let N=0;N<u.inWidth;++N){const D=_-x,P=N-b;let L=0;for(let z=0;z<A;z+=g){const q=(D+z)/h;if(!(q<0||q>=u.outHeight||Math.floor(q)!==q))for(let V=0;V<y;V+=m){const X=(P+V)/d;if(X<0||X>=u.outWidth||Math.floor(X)!==X)continue;const te=T.get(v,q,X,S);L+=te}}C.set(L*w,v,_,N,S)}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const Ide={kernelName:pA,backendName:"cpu",kernelFunc:bde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,scale:r,offset:o,mean:a,variance:l}=e;R(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(r==null||a.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),It([i,a,l,r,o],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const u=t.data.get(i.dataId).values,h=t.data.get(a.dataId).values,d=t.data.get(l.dataId).values,p=r?t.data.get(r.dataId).values:new Float32Array([1]),f=o?t.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),m=f.length,A=p.length,y=d.length,b=h.length;let x=0,C=0,w=0,E=0;for(let T=0;T<u.length;++T)g[T]=f[x++]+(u[T]-h[C++])*p[w++]/Math.sqrt(d[E++]+c),x>=m&&(x=0),C>=b&&(C=0),w>=A&&(w=0),E>=y&&(E=0);return t.makeTensorInfo(i.shape,i.dtype,g)}const wde={kernelName:Hp,backendName:"cpu",kernelFunc:Cde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:o}=s;It([i],"batchToSpaceND");const a=r.reduce((A,y)=>A*y),l=Hh(i.shape,r,a),c=qh(l.length,r.length),u=Yh(i.shape,r,a),h=jC(o,r.length),d=KC(u,o,r.length),p=Un({inputs:{x:i},backend:t,attrs:{shape:l}}),f=sr({inputs:{x:p},backend:t,attrs:{perm:c}}),g=Un({inputs:{x:f},backend:t,attrs:{shape:u}}),m=$u({inputs:{x:g},backend:t,attrs:{begin:h,size:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),m}const Sde={kernelName:Fp,backendName:"cpu",kernelFunc:vde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ede(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o}=s,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,c=SB(a,l,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,c)}const _de={kernelName:mA,backendName:"cpu",kernelFunc:Ede};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tde(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,a=Mt(Array.from(r),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const Bde={kernelName:AA,backendName:"cpu",kernelFunc:Tde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kde=En(nh,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),Mde={kernelName:nh,backendName:"cpu",kernelFunc:kde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nde=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(ce(e.shape)),i=t.data.get(e.dataId),r=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const u=a[c],h=l[c];s[c]=Math.hypot(u,h)}return t.makeOutput(s,e.shape,"float32")},Rde={kernelName:$p,backendName:"cpu",kernelFunc:Nde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xp(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.imag,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const Dde={kernelName:PA,backendName:"cpu",kernelFunc:xp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bp(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=Vt(i,e[0].shape)[0],o=e.map(g=>g.shape);qC(o,r);let a=Zi(e.map(g=>g.shape),r);if(ce(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(g=>ce(g.shape)>0);if(l.length===1)return xa({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const g=l.map(x=>Fu({inputs:{input:x},backend:t})),m=l.map(x=>xp({inputs:{input:x},backend:t})),A=bp({inputs:g,backend:t,attrs:{axis:r}}),y=bp({inputs:m,backend:t,attrs:{axis:r}}),b=mr({inputs:{real:A,imag:y},backend:t});return g.forEach(x=>t.disposeIntermediateTensorInfo(x)),m.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(y),b}const c=l.map(g=>{const A=[-1,ce(g.shape.slice(r))];return Un({inputs:{x:g},backend:t,attrs:{shape:A}})}),u=c.map(g=>({vals:t.data.get(g.dataId).values,shape:g.shape}));a=Zi(c.map(g=>g.shape),1);const h=c[0].shape[0]===1,d=yz(u,a,e[0].dtype,h),p=Zi(l.map(g=>g.shape),r),f=t.makeTensorInfo(p,e[0].dtype,d);return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const Fde={kernelName:Pp,backendName:"cpu",kernelFunc:bp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mU(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s;It([i,r],"conv2d");const h=Er(l),d=Qn(i.shape,r.shape,o,c,a,u,!1,h),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,A=d.padInfo.left,y=d.padInfo.top,b=d.dataFormat==="channelsLast",x=new Is(d.outShape,i.dtype),C=vt(i.shape),w=vt(r.shape),E=C[0],T=b?C[1]:C[2],v=b?C[2]:1,S=b?1:C[1],_=x.strides[0],N=b?x.strides[1]:x.strides[2],D=b?x.strides[2]:1,P=b?1:x.strides[1],L=t.data.get(i.dataId).values,z=t.data.get(r.dataId).values,q=x.values;for(let V=0;V<d.batchSize;++V){const X=V*E,te=V*_;for(let se=0;se<d.outHeight;++se){const fe=te+se*N,me=se*d.strideHeight-y;for(let Te=0;Te<p;++Te){const Ee=me+Te*g;if(Ee<0||Ee>=d.inHeight)continue;const re=Te*w[0],ue=X+Ee*T;for(let _e=0;_e<d.outWidth;++_e){const ke=fe+_e*D,Ne=_e*d.strideWidth-A;for(let Ue=0;Ue<f;++Ue){const ht=Ne+Ue*m;if(ht<0||ht>=d.inWidth)continue;const W=re+Ue*w[1],Ce=ue+ht*v;let be=W;for(let ge=0;ge<d.inChannels;++ge){const ye=L[Ce+ge*S];for(let Re=0;Re<d.outChannels;++Re)q[ke+Re*P]+=ye*z[be+Re];be+=d.outChannels}}}}}}return t.makeTensorInfo(x.shape,x.dtype,q)}const $de={kernelName:Lp,backendName:"cpu",kernelFunc:mU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s;It([i,r],"conv2dBackpropFilter");const h=Er(l),d=Qn(i.shape,u,o,1,a,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=d,A=d.dataFormat==="channelsLast",y=new Is(d.filterShape,"float32"),b=d.padInfo.left,x=d.padInfo.top,C=t.data.get(i.dataId).values,w=t.data.get(r.dataId).values,E=new Is(i.shape,i.dtype,C),T=new Is(r.shape,r.dtype,w);for(let v=0;v<g;++v){const S=Math.max(0,Math.ceil((x-v)/p)),_=Math.min(d.outHeight,(d.inHeight+x-v)/p);for(let N=0;N<m;++N){const D=Math.max(0,Math.ceil((b-N)/f)),P=Math.min(d.outWidth,(d.inWidth+b-N)/f);for(let L=0;L<d.inChannels;++L)for(let z=0;z<d.outChannels;++z){let q=0;for(let V=0;V<d.batchSize;++V)for(let X=S;X<_;++X){const te=v+X*p-x;for(let se=D;se<P;++se){const fe=N+se*f-b;A?q+=E.get(V,te,fe,L)*T.get(V,X,se,z):q+=E.get(V,L,te,fe)*T.get(V,z,X,se)}}y.set(q,v,N,L,z)}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const Lde={kernelName:xA,backendName:"cpu",kernelFunc:Pde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ode(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s;It([i,r],"conv2dBackpropInput");const h=vt(r.shape),d=vt(i.shape);let p=Er(c);const f=Qn(o,r.shape,a,1,l,u,!1,p),g=new Is(f.inShape,"float32"),m=g.values,A=t.data.get(i.dataId).values,y=t.data.get(r.dataId).values,[b,x,C]=h,{batchSize:w,filterHeight:E,filterWidth:T,inChannels:v,inHeight:S,inWidth:_,outChannels:N,outHeight:D,outWidth:P,strideHeight:L,strideWidth:z}=f;p=f.dataFormat;const q=E-1-f.padInfo.top,V=T-1-f.padInfo.left,X=p==="channelsLast",te=g.strides[0],se=X?g.strides[1]:g.strides[2],fe=X?g.strides[2]:1,me=X?1:g.strides[1],Te=d[0],Ee=X?d[1]:d[2],re=X?d[2]:1,ue=X?1:d[1];for(let _e=0;_e<w;++_e)for(let ke=0;ke<v;++ke)for(let Ne=0;Ne<S;++Ne){const Ue=Ne-q,ht=Math.max(0,Math.ceil(Ue/L)),W=Math.min(D,(E+Ue)/L);for(let Ce=0;Ce<_;++Ce){const be=Ce-V,ge=Math.max(0,Math.ceil(be/z)),ye=Math.min(P,(T+be)/z);let Re=0;for(let Me=ht;Me<W;++Me){const Tt=Me*L-Ue;for(let At=ge;At<ye;++At){const G=At*z-be,$=Te*_e+Ee*Me+re*At,de=b*(E-1-Tt)+x*(T-1-G)+C*ke;for(let xe=0;xe<N;++xe){const Fe=A[$+ue*xe],ve=y[de+xe];Re+=Fe*ve}}}const De=te*_e+se*Ne+fe*Ce+me*ke;m[De]=Re}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const zde={kernelName:Op,backendName:"cpu",kernelFunc:Ode};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ude(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s;It([i,r],"conv3d");const c=Wo(i.shape,r.shape,o,l,a),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=c,A=m.front,y=m.left,b=m.top,x=new Is(c.outShape,i.dtype),C=t.data.get(i.dataId).values,w=t.data.get(r.dataId).values,E=x.values,T=vt(i.shape),v=vt(r.shape);for(let S=0;S<c.batchSize;++S){const _=S*T[0],N=S*x.strides[0];for(let D=0;D<c.outDepth;++D){const P=N+D*x.strides[1],L=D*c.strideDepth-A;for(let z=0;z<u;++z){const q=L+z*p;if(q<0||q>=c.inDepth)continue;const V=z*v[0],X=_+q*T[1];for(let te=0;te<c.outHeight;++te){const se=P+te*x.strides[2],fe=te*c.strideHeight-b;for(let me=0;me<h;++me){const Te=fe+me*f;if(Te<0||Te>=c.inHeight)continue;const Ee=V+me*v[1],re=X+Te*T[2];for(let ue=0;ue<c.outWidth;++ue){const _e=se+ue*c.outChannels,ke=ue*c.strideWidth-y;for(let Ne=0;Ne<d;++Ne){const Ue=ke+Ne*g;if(Ue<0||Ue>=c.inWidth)continue;const ht=Ee+Ne*v[2],W=re+Ue*c.inChannels;let Ce=ht;for(let be=0;be<c.inChannels;++be){const ge=C[W+be];for(let ye=0;ye<c.outChannels;++ye)E[_e+ye]+=ge*w[Ce+ye];Ce+=c.outChannels}}}}}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const Qde={kernelName:zp,backendName:"cpu",kernelFunc:Ude};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,filterShape:l}=s;It([i,r],"conv3dBackpropFilterV2");const c=vt(i.shape),u=vt(r.shape),h=Wo(i.shape,l,o,1,a),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,g=h.filterDepth,m=h.filterHeight,A=h.filterWidth,y=new Is(h.filterShape,"float32"),b=y.values,[x,C,w,E]=y.strides,T=t.data.get(r.dataId).values,[v,S,_,N]=u,D=t.data.get(i.dataId).values,[P,L,z,q]=c,V=h.padInfo.front,X=h.padInfo.left,te=h.padInfo.top;for(let se=0;se<g;++se){const fe=Math.max(0,Math.ceil((V-se)/d)),me=Math.min(h.outDepth,(h.inDepth+V-se)/d),Te=se*x;for(let Ee=0;Ee<m;++Ee){const re=Math.max(0,Math.ceil((te-Ee)/p)),ue=Math.min(h.outHeight,(h.inHeight+te-Ee)/p),_e=Ee*C+Te;for(let ke=0;ke<A;++ke){const Ne=Math.max(0,Math.ceil((X-ke)/f)),Ue=Math.min(h.outWidth,(h.inWidth+X-ke)/f),ht=ke*w+_e;for(let W=0;W<h.inChannels;++W){const Ce=W*E+ht;for(let be=0;be<h.outChannels;++be){let ge=0;for(let ye=0;ye<h.batchSize;++ye){const Re=ye*P,De=ye*v;for(let Me=fe;Me<me;++Me){const At=(se+Me*d-V)*L+Re,G=Me*S+De;for(let $=re;$<ue;++$){const xe=(Ee+$*p-te)*z+At,Fe=$*_+G;for(let ve=Ne;ve<Ue;++ve){const He=(ke+ve*f-X)*q+xe,pt=ve*N+Fe;ge+=D[He+W]*T[pt+be]}}}}b[Ce+be]=ge}}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const Gde={kernelName:bA,backendName:"cpu",kernelFunc:Vde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{pad:o,strides:a,inputShape:l}=s;It([i],"conv3dBackpropInputV2");const c=vt(i.shape),u=vt(r.shape),h=Wo(l,r.shape,a,1,o),d=new Is(h.inShape,"float32"),p=d.values,[f,g,m,A]=d.strides,y=t.data.get(i.dataId).values,[b,x,C,w]=c,E=t.data.get(r.dataId).values,[T,v,S,_]=u,{batchSize:N,filterDepth:D,filterHeight:P,filterWidth:L,inChannels:z,inDepth:q,inHeight:V,inWidth:X,outChannels:te,outDepth:se,outHeight:fe,outWidth:me,strideDepth:Te,strideHeight:Ee,strideWidth:re}=h,ue=D-1-h.padInfo.front,_e=P-1-h.padInfo.top,ke=L-1-h.padInfo.left;for(let Ne=0;Ne<N;++Ne)for(let Ue=0;Ue<z;++Ue)for(let ht=0;ht<q;++ht){const W=ht-ue,Ce=Math.max(0,Math.ceil(W/Te)),be=Math.min(se,(D+W)/Te);for(let ge=0;ge<V;++ge){const ye=ge-_e,Re=Math.max(0,Math.ceil(ye/Ee)),De=Math.min(fe,(P+ye)/Ee);for(let Me=0;Me<X;++Me){const Tt=Me-ke,At=Math.max(0,Math.ceil(Tt/re)),G=Math.min(me,(L+Tt)/re);let $=0;for(let de=Ce;de<be;++de){const xe=de*Te-W;for(let Fe=Re;Fe<De;++Fe){const ve=Fe*Ee-ye;for(let ut=At;ut<G;++ut){const He=ut*re-Tt,pt=b*Ne+x*de+C*Fe+w*ut,yt=T*(D-1-xe)+v*(P-1-ve)+S*(L-1-He)+_*Ue;for(let Oe=0;Oe<te;++Oe){const tt=y[pt+Oe],Nt=E[yt+Oe];$+=tt*Nt}}}}p[f*Ne+g*ht+m*ge+A*Me+Ue]=$}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const Hde={kernelName:IA,backendName:"cpu",kernelFunc:Wde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qde=En(sh,n=>Math.cos(n)),Yde={kernelName:sh,backendName:"cpu",kernelFunc:qde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xde=En(ih,n=>Math.cosh(n)),jde={kernelName:ih,backendName:"cpu",kernelFunc:Xde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kde(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,[u,h,d,p]=i.shape,f=r.shape[0],[g,m]=a,A=zt([f,g,m,p],"float32"),y=t.data.get(r.dataId).values,b=t.data.get(o.dataId).values,x=t.data.get(i.dataId).values,C=vt(i.shape),w=vt(A.shape);for(let E=0;E<f;E++){const T=E*4,v=y[T],S=y[T+1],_=y[T+2],N=y[T+3],D=b[E];if(D>=u)continue;const P=g>1?(_-v)*(h-1)/(g-1):0,L=m>1?(N-S)*(d-1)/(m-1):0;for(let z=0;z<g;z++){const q=g>1?v*(h-1)+z*P:.5*(v+_)*(h-1);if(q<0||q>h-1){for(let V=0;V<m;V++)for(let X=0;X<p;X++){const te=X+V*w[2]+z*w[1]+E*w[0];A.values[te]=c}continue}if(l==="bilinear"){const V=Math.floor(q),X=Math.ceil(q),te=q-V;for(let se=0;se<m;se++){const fe=m>1?S*(d-1)+se*L:.5*(S+N)*(d-1);if(fe<0||fe>d-1){for(let re=0;re<p;re++){const ue=re+se*w[2]+z*w[1]+E*w[0];A.values[ue]=c}continue}const me=Math.floor(fe),Te=Math.ceil(fe),Ee=fe-me;for(let re=0;re<p;re++){let ue=re+me*C[2]+V*C[1]+D*C[0];const _e=x[ue];ue=re+Te*C[2]+V*C[1]+D*C[0];const ke=x[ue];ue=re+me*C[2]+X*C[1]+D*C[0];const Ne=x[ue];ue=re+Te*C[2]+X*C[1]+D*C[0];const Ue=x[ue],ht=_e+(ke-_e)*Ee,W=Ne+(Ue-Ne)*Ee;ue=re+se*w[2]+z*w[1]+E*w[0],A.values[ue]=ht+(W-ht)*te}}}else for(let V=0;V<m;++V){const X=m>1?S*(d-1)+V*L:.5*(S+N)*(d-1);if(X<0||X>d-1){for(let fe=0;fe<p;fe++){const me=fe+V*w[2]+z*w[1]+E*w[0];A.values[me]=c}continue}const te=Math.round(X),se=Math.round(q);for(let fe=0;fe<p;fe++){const me=fe+te*C[2]+se*C[1]+D*C[0],Te=fe+V*w[2]+z*w[1]+E*w[0];A.values[Te]=x[me]}}}}return t.makeTensorInfo(A.shape,A.dtype,A.values)}const Jde={kernelName:wA,backendName:"cpu",kernelFunc:Kde};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;It(i,"cumprod");const l=Nn([r],i.shape.length);let c=i;l!=null&&(c=sr({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=Vn(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Ns(c.dtype,"int32"),d=XI(ce(c.shape),h),p=t.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=a?(A,y)=>A+f-y-1:(A,y)=>A+y;for(let A=0;A<p.length;A+=f)for(let y=0;y<f;y++){const b=g(A,y);if(y===0)d[b]=o?1:p[b];else{const x=g(A,y-1);d[b]=o?p[x]*d[x]:p[b]*d[x]}}const m=t.makeTensorInfo(c.shape,h,d);if(l!=null){const A=Sa(l),y=sr({inputs:{x:m},backend:t,attrs:{perm:A}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),y}return m}const epe={kernelName:CA,backendName:"cpu",kernelFunc:Zde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;It(i,"cumsum");const l=Nn([r],i.shape.length);let c=i;l!=null&&(c=sr({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=Vn(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Ns(c.dtype,"int32"),d=Ws(ce(c.shape),h),p=t.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=a?(A,y)=>A+f-y-1:(A,y)=>A+y;for(let A=0;A<p.length;A+=f)for(let y=0;y<f;y++){const b=g(A,y);if(y===0)d[b]=o?0:p[b];else{const x=g(A,y-1);d[b]=o?p[x]+d[x]:p[b]+d[x]}}const m=t.makeTensorInfo(c.shape,h,d);if(l!=null){const A=Sa(l),y=sr({inputs:{x:m},backend:t,attrs:{perm:A}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),y}return m}const npe={kernelName:Up,backendName:"cpu",kernelFunc:tpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function spe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o,binaryOutput:a}=s;if(i.shape.length===1){const l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=SB(l,c,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(r),u=mz(l,c,o,a);return t.makeTensorInfo(u.shape,r.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const ipe={kernelName:vA,backendName:"cpu",kernelFunc:spe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:o}=s;R(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=i.shape[0],l=i.shape[1],c=i.shape[2],u=i.shape[3],h=l*r,d=c*r,p=u/(r*r),f=t.data.get(i.dataId).values,g=new Float32Array(a*h*d*p);let m=0;for(let A=0;A<a;++A)for(let y=0;y<h;++y){const b=Math.floor(y/r),x=y%r;for(let C=0;C<d;++C){const w=Math.floor(C/r),E=C%r,T=(x*r+E)*p;for(let v=0;v<p;++v){const _=v+T+u*(w+c*(b+l*A));g[m++]=f[_]}}}return t.makeTensorInfo([a,h,d,p],i.dtype,g)}const ope={kernelName:SA,backendName:"cpu",kernelFunc:rpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gU(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;It([i,r],"depthwiseConv2DNative");const u=vt(i.shape),h=vt(r.shape);let d=l;d==null&&(d=[1,1]),R(Rs(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=Qn(i.shape,r.shape,o,d,a,c,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:A,padInfo:y}=p,b=y.left,x=y.top,C=p.outChannels/p.inChannels,w=new Is(p.outShape,i.dtype),E=t.data.get(i.dataId).values,T=t.data.get(r.dataId).values,v=w.values;for(let S=0;S<p.batchSize;++S){const _=S*u[0],N=S*w.strides[0];for(let D=0;D<p.outHeight;++D){const P=N+D*w.strides[1],L=D*p.strideHeight-x;for(let z=0;z<f;++z){const q=L+z*m;if(q<0||q>=p.inHeight)continue;const V=z*h[0],X=_+q*u[1];for(let te=0;te<p.outWidth;++te){const se=P+te*w.strides[2],fe=te*p.strideWidth-b;for(let me=0;me<g;++me){const Te=fe+me*A;if(Te<0||Te>=p.inWidth)continue;const Ee=V+me*h[1],re=X+Te*p.inChannels;let ue=se,_e=Ee;for(let ke=0;ke<p.inChannels;++ke){const Ne=E[re+ke];for(let Ue=0;Ue<C;++Ue)v[ue+Ue]+=Ne*T[_e+Ue];ue+=C,_e+=C}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const ape={kernelName:Qp,backendName:"cpu",kernelFunc:gU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s;It([i,r],"depthwiseConv2dNativeBackpropFilter");const h=Qn(i.shape,u,o,a,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=h,m=new Is(h.filterShape,"float32"),A=h.padInfo.left,y=h.padInfo.top,b=h.outChannels/h.inChannels,x=t.data.get(i.dataId).values,C=new Is(i.shape,i.dtype,x),w=t.data.get(r.dataId).values,E=new Is(r.shape,r.dtype,w);for(let T=0;T<f;++T){const v=Math.max(0,Math.ceil((y-T)/d)),S=Math.min(h.outHeight,(h.inHeight+y-T)/d);for(let _=0;_<g;++_){const N=Math.max(0,Math.ceil((A-_)/p)),D=Math.min(h.outWidth,(h.inWidth+A-_)/p);for(let P=0;P<h.outChannels;++P){const L=Math.trunc(P/b),z=P%b;let q=0;for(let V=0;V<h.batchSize;++V)for(let X=v;X<S;++X){const te=T+X*d-y;for(let se=N;se<D;++se){const fe=_+se*p-A;q+=C.get(V,te,fe,L)*E.get(V,X,se,P)}}m.set(q,T,_,L,z)}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const cpe={kernelName:EA,backendName:"cpu",kernelFunc:lpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function upe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s;It([i,r],"depthwiseConv2DNativeBackpropInput");const h=vt(i.shape),d=vt(r.shape),p=Qn(u,r.shape,o,a,l,c,!0),f=new Is(p.inShape,"float32"),g=f.values,[m,A,y]=f.strides,b=t.data.get(i.dataId).values,[x,C,w]=h,E=t.data.get(r.dataId).values,[T,v,S]=d,{batchSize:_,filterHeight:N,filterWidth:D,inChannels:P,inHeight:L,inWidth:z,outChannels:q,outHeight:V,outWidth:X,strideHeight:te,strideWidth:se}=p,fe=N-1-p.padInfo.top,me=D-1-p.padInfo.left,Te=q/P;for(let Ee=0;Ee<_;++Ee)for(let re=0;re<P;++re)for(let ue=0;ue<L;++ue){const _e=ue-fe,ke=Math.max(0,Math.ceil(_e/te)),Ne=Math.min(V,(N+_e)/te);for(let Ue=0;Ue<z;++Ue){const ht=Ue-me,W=Math.max(0,Math.ceil(ht/se)),Ce=Math.min(X,(D+ht)/se);let be=0;for(let ge=ke;ge<Ne;++ge){const ye=ge*te-_e;for(let Re=W;Re<Ce;++Re){const De=Re*se-ht,Me=x*Ee+C*ge+w*Re,Tt=T*(N-1-ye)+v*(D-1-De)+S*re;for(let At=0;At<Te;++At){const G=re*Te+At,$=b[Me+G],de=E[Tt+At];be+=$*de}}}g[m*Ee+A*ue+y*Ue+re]=be}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const hpe={kernelName:_A,backendName:"cpu",kernelFunc:upe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dpe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=ce(s.shape),r=t.data.get(s.dataId).values,o=zt([i,i],s.dtype),a=o.values;for(let c=0;c<r.length;c++)a[c*i+c]=r[c];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const ppe={kernelName:TA,backendName:"cpu",kernelFunc:dpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fpe={kernelName:Vp,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i}=n,{strides:r,pad:o,dilations:a}=t,l=e,c=l.data.get(s.dataId).values,u=s.shape.length,h=l.data.get(i.dataId).values,d=i.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:A,outWidth:y,padInfo:b,strideHeight:x,strideWidth:C,filterHeight:w,filterWidth:E,dilationHeight:T,dilationWidth:v,outShape:S}=dc(s.shape,i.shape,r,o,"NHWC",a),_=ce(S),N=S.length,D=ns(s.dtype,_);for(let L=0;L<p;++L)for(let z=0;z<A;++z){const q=z*x-b.top;for(let V=0;V<y;++V){const X=V*C-b.left;for(let te=0;te<m;++te){let se=Number.MIN_SAFE_INTEGER;for(let me=0;me<w;++me){const Te=q+me*T;if(Te>=0&&Te<f)for(let Ee=0;Ee<E;++Ee){const re=X+Ee*v;if(re>=0&&re<g){const ue=No([L,Te,re,te],u,vt(s.shape)),_e=No([me,Ee,te],d,vt(i.shape)),ke=c[ue]+h[_e];ke>se&&(se=ke)}}}const fe=No([L,z,V,te],N,vt(S));D[fe]=se}}}return{dataId:l.write(uc(D,s.dtype),S,s.dtype),shape:S,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mpe={kernelName:Eg,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:r}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Vr(s.shape,c.data.get(s.dataId).values),h=Vr(i.shape,c.data.get(i.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:A,padInfo:y,strideHeight:b,strideWidth:x,filterHeight:C,filterWidth:w,dilationHeight:E,dilationWidth:T,outShape:v}=dc(s.shape,i.shape,o,a,"NHWC",l);R(r.rank===v.length,()=>`Error in ${Eg}, dy must have the same rank as output ${v.length}, but got ${r.rank}`);const S=Vr(v,c.data.get(r.dataId).values),_=p2(i.shape,i.dtype);for(let D=0;D<d;++D)for(let P=0;P<m;++P){const L=P*b-y.top;for(let z=0;z<A;++z){const q=z*x-y.left;for(let V=0;V<g;++V){let X=Number.MIN_SAFE_INTEGER,te=0,se=0;for(let fe=0;fe<C;++fe){const me=L+fe*E;if(me>=0&&me<p)for(let Te=0;Te<w;++Te){const Ee=q+Te*T;if(Ee>=0&&Ee<f){const re=u[D][me][Ee][V]+h[fe][Te][V];re>X&&(X=re,te=fe,se=Te)}}}_[te][se][V]+=S[D][P][z][V]}}}return{dataId:c.write(uc(_,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gpe={kernelName:Sg,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:r}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Vr(s.shape,c.data.get(s.dataId).values),h=Vr(i.shape,c.data.get(i.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:A,padInfo:y,strideHeight:b,strideWidth:x,filterHeight:C,filterWidth:w,dilationHeight:E,dilationWidth:T,outShape:v}=dc(s.shape,i.shape,o,a,"NHWC",l);R(r.rank===v.length,()=>`Error in ${Sg}, dy must have the same rank as output ${v.length}, but got ${r.rank}`);const S=Vr(v,c.data.get(r.dataId).values),_=p2(s.shape,s.dtype);for(let D=0;D<d;++D)for(let P=0;P<m;++P){const L=P*b-y.top;for(let z=0;z<A;++z){const q=z*x-y.left;for(let V=0;V<g;++V){let X=Number.MIN_SAFE_INTEGER,te=L<0?0:L,se=q<0?0:q;for(let fe=0;fe<C;++fe){const me=L+fe*E;if(me>=0&&me<p)for(let Te=0;Te<w;++Te){const Ee=q+Te*T;if(Ee>=0&&Ee<f){const re=u[D][me][Ee][V]+h[fe][Te][V];re>X&&(X=re,te=me,se=Ee)}}}_[D][te][se][V]+=S[D][P][z][V]}}}return{dataId:c.write(uc(_,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ape(n){const{inputs:e,backend:t,attrs:s}=n,{image:i}=e,{canvas:r,options:o}=s,{contextOptions:a,imageOptions:l}=o||{},c=l?.alpha||1,u=a?.contextType||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=r.getContext(u,a?.contextAttributes||{});if(h==null)throw new Error(`Could not get the context with ${u} type.`);const[d,p]=i.shape.slice(0,2),f=i.shape.length===2?1:i.shape[2],g=t.data.get(i.dataId).values,m=i.dtype==="float32"?255:1,A=new Uint8ClampedArray(p*d*4);for(let b=0;b<d*p;++b){const x=[0,0,0,255*c];for(let w=0;w<f;w++){const E=g[b*f+w];if(i.dtype==="float32"){if(E<0||E>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${E}.`)}else if(i.dtype==="int32"&&(E<0||E>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${E}.`);f===1?(x[0]=E*m,x[1]=E*m,x[2]=E*m):x[w]=E*m}const C=b*4;A[C+0]=Math.round(x[0]),A[C+1]=Math.round(x[1]),A[C+2]=Math.round(x[2]),A[C+3]=Math.round(x[3])}r.width=p,r.height=d;const y=new ImageData(A,p,d);return h.putImageData(y,0,0),i}const ype={kernelName:BA,backendName:"cpu",kernelFunc:Ape};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hy(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;It(i,"sum");let a;i.dtype==="bool"?a=sc({inputs:{x:i},backend:t,attrs:{dtype:"int32"}}):a=xa({inputs:{x:i},backend:t});const l=a.shape.length,c=Vt(r,a.shape),u=Nn(c,l);let h=c,d=a;u!=null&&(d=sr({inputs:{x:a},backend:t,attrs:{perm:u}}),h=Vn(h.length,l)),vs("sum",h,d.shape.length);const[p,f]=ps(d.shape,h),g=Ns(d.dtype,"int32");let m=Kb(t,p,g);const A=ce(f),y=t.data.get(m.dataId).values,b=t.data.get(d.dataId).values;for(let x=0;x<y.length;++x){const C=x*A;let w=0;for(let E=0;E<A;++E)w+=b[C+E];y[x]=w}if(o){const x=us(m.shape,c),C=m;m=Un({inputs:{x:m},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(C)}return t.disposeIntermediateTensorInfo(a),u!=null&&t.disposeIntermediateTensorInfo(d),m}const xpe={kernelName:wf,backendName:"cpu",kernelFunc:Hy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bpe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:o,summedDims:a,idDims:l}=iw(i,r.length);ow(o.length,l,r);const{path:c,steps:u}=aw(a,l),h=u.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const m of u[g]){const{permutationIndices:A,expandDims:y}=rw(p,l[m]);let b;lw(A)?b=r[m]:(b=sr({inputs:{x:r[m]},backend:t,attrs:{perm:A}}),f.push(b));const x=b.shape.slice();for(let C=0;C<y.length;++C)x.splice(y[C],0,1);qt(b.shape,x)||(b=Un({inputs:{x:b},backend:t,attrs:{shape:x}}),f.push(b)),d===null?d=b:(d=Nw({inputs:{a:b,b:d},backend:t}),f.push(d))}g<h-1&&(c[g]>=0&&(d=Hy({inputs:{x:d},backend:t,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const Ipe={kernelName:kA,backendName:"cpu",kernelFunc:bpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cpe(n){const{inputs:e,backend:t}=n,{dy:s,y:i}=e;It([s,i],"eluGrad");const r=new Float32Array(ce(i.shape)),o=t.data.get(i.dataId).values,a=t.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=0?r[l]=a[l]:r[l]=a[l]*(c+1)}return t.makeTensorInfo(i.shape,"float32",r)}const wpe={kernelName:MA,backendName:"cpu",kernelFunc:Cpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vpe=JC,Spe=ZC,Epe=ew,_pe=tw,Tpe=nw,Bpe=sw,kpe=En(ah,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+vpe*t);return e*(1-((((Bpe*s+Tpe)*s+_pe)*s+Epe)*s+Spe)*s*Math.exp(-t*t))}),Mpe={kernelName:ah,backendName:"cpu",kernelFunc:kpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eI(n){const{inputs:e,backend:t,attrs:s}=n,{input:i}=e,{dim:r}=s,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(R(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),Un({inputs:{x:i},backend:t,attrs:{shape:a}})}const Npe={kernelName:Wp,backendName:"cpu",kernelFunc:eI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rpe=ms((n,e)=>n/e),NB=Ds(rh,Rpe),U1={kernelName:rh,backendName:"cpu",kernelFunc:NB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AU(n,e,t){const s=n.shape,i=s[0],r=s[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[i,r],u=ce(c),h=Cs("float32",u),d=Cs("float32",u);for(let m=0;m<i;m++){const A=$u({inputs:{x:a},backend:t,attrs:{begin:[m,0],size:[1,r]}}),y=$u({inputs:{x:l},backend:t,attrs:{begin:[m,0],size:[1,r]}}),b=mr({inputs:{real:A,imag:y},backend:t}),{real:x,imag:C}=Dpe(b,e,t),w=$o(x,C);for(let E=0;E<r;E++){const T=U_(w,E);h[m*r+E]=T.real,d[m*r+E]=T.imag}t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b)}const p=t.makeTensorInfo(c,"float32",h),f=t.makeTensorInfo(c,"float32",d),g=mr({inputs:{real:p,imag:f},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),g}function Dpe(n,e,t){const s=ce(n.shape),i=t.data.get(n.dataId),r=t.data.get(i.complexTensorInfos.real.dataId).values,o=t.data.get(i.complexTensorInfos.imag.dataId).values;if(Fpe(s)){const a=Q1(r,o,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",a.real),u=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",hl(s,"float32")),d=xa({inputs:{x:h},backend:t}),p=U1.kernelFunc({inputs:{a:c,b:h},backend:t}),f=U1.kernelFunc({inputs:{a:u,b:d},backend:t}),g=t.data.get(p.dataId).values,m=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),{real:g,imag:m}}return a}else{const a=$o(r,o),l=$pe(a,s,e);return hL(l)}}function Fpe(n){return(n&n-1)===0}function Q1(n,e,t,s,i){if(t===1)return{real:n,imag:e};const r=$o(n,e),o=t/2,a=dL(r),l=a.real,c=a.imag,u=[l.length],h=i.makeTensorInfo(u,"float32",l),d=i.makeTensorInfo(u,"float32",c),p=mr({inputs:{real:h,imag:d},backend:i}),f=pL(r),g=f.real,m=f.imag,A=[g.length],y=i.makeTensorInfo(A,"float32",g),b=i.makeTensorInfo(A,"float32",m),x=mr({inputs:{real:y,imag:b},backend:i}),C=Q1(l,c,o,s,i),w=C.real,E=C.imag,T=[w.length],v=i.makeTensorInfo(T,"float32",w),S=i.makeTensorInfo(T,"float32",E),_=mr({inputs:{real:v,imag:S},backend:i}),N=Q1(g,m,o,s,i),D=N.real,P=N.imag,L=[D.length],z=i.makeTensorInfo(L,"float32",D),q=i.makeTensorInfo(L,"float32",P),V=mr({inputs:{real:z,imag:q},backend:i}),X=mL(t,s),te=[X.real.length],se=i.makeTensorInfo(te,"float32",X.real),fe=i.makeTensorInfo(te,"float32",X.imag),me=mr({inputs:{real:se,imag:fe},backend:i}),Te=Nw({inputs:{a:me,b:V},backend:i}),Ee=yp({inputs:{a:_,b:Te},backend:i}),re=BB({inputs:{a:_,b:Te},backend:i}),ue=Fu({inputs:{input:Ee},backend:i}),_e=Fu({inputs:{input:re},backend:i}),ke=xp({inputs:{input:Ee},backend:i}),Ne=xp({inputs:{input:re},backend:i}),Ue=bp({inputs:[ue,_e],backend:i,attrs:{axis:0}}),ht=bp({inputs:[ke,Ne],backend:i,attrs:{axis:0}}),W=i.data.get(Ue.dataId).values,Ce=i.data.get(ht.dataId).values;return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(z),i.disposeIntermediateTensorInfo(q),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(se),i.disposeIntermediateTensorInfo(fe),i.disposeIntermediateTensorInfo(me),i.disposeIntermediateTensorInfo(Te),i.disposeIntermediateTensorInfo(Ee),i.disposeIntermediateTensorInfo(re),i.disposeIntermediateTensorInfo(ue),i.disposeIntermediateTensorInfo(ke),i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(Ne),i.disposeIntermediateTensorInfo(Ue),i.disposeIntermediateTensorInfo(ht),{real:W,imag:Ce}}function $pe(n,e,t){const s=new Float32Array(e*2);for(let i=0;i<e;i++){let r=0,o=0;for(let a=0;a<e;a++){const l=gL(i*a,e,t),c=U_(n,a);r+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}t&&(r/=e,o/=e),fL(s,r,o,i)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ppe(n){const{inputs:e,backend:t}=n,{input:s}=e,i=ce(s.shape),r=s.shape[s.shape.length-1],o=i/r,a=Un({inputs:{x:s},backend:t,attrs:{shape:[o,r]}}),l=AU(a,!1,t),c=Un({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const Lpe={kernelName:NA,backendName:"cpu",kernelFunc:Ppe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RB(n){const{backend:e,attrs:t}=n,{shape:s,value:i,dtype:r}=t,o=r||lc(i),a=ns(o,ce(s));return zpe(a,i,o),e.makeTensorInfo(s,o,a)}const Ope={kernelName:RA,backendName:"cpu",kernelFunc:RB};function zpe(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Upe={kernelName:DA,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,i=t,r=Cs(s.dtype,ce(s.shape)),[o,a,l,c]=s.shape,u=i.data.get(s.dataId).values;for(let d=0;d<o;d++){const p=d*l*a*c;for(let f=0;f<a;f++){const g=f*(l*c);for(let m=0;m<l;m++){const A=m*c;for(let y=0;y<c;y++){const b=Math.round(l-m-1),x=p+g+A+y;let C=u[x];if(b>=0&&b<l){const w=b*c,E=p+g+w+y;C=u[E]}r[x]=C}}}}return{dataId:i.write(r,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=mU({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const m=g;if(u==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const A=Un({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});g=yp({inputs:{a:g,b:A},backend:t}),t.disposeIntermediateTensorInfo(A)}else g=yp({inputs:{a:g,b:o},backend:t});t.disposeIntermediateTensorInfo(m)}if(p){const m=g;if(u==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const A=Un({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});g=Zb(t,g,p,A,f),t.disposeIntermediateTensorInfo(A)}else g=Zb(t,g,p,a,f);t.disposeIntermediateTensorInfo(m)}return g}const Vpe={kernelName:rp,backendName:"cpu",kernelFunc:Qpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=gU({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const m=g;g=yp({inputs:{a:g,b:o},backend:t}),t.disposeIntermediateTensorInfo(m)}if(p){const m=g;g=Zb(t,g,p,a,f),t.disposeIntermediateTensorInfo(m)}return g}const Wpe={kernelName:op,backendName:"cpu",kernelFunc:Gpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hpe(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=ce(s.shape),o=i.shape,a=o[o.length-1],[l,c,u,h]=Ny(s,i);if(c===0)return t.makeTensorInfo(l,s.dtype,[]);const d=t.data.get(i.dataId).values,p=t.bufferSync(s),f=Ez(d,p,s.dtype,c,a,u,h,s.shape,r);return t.makeTensorInfo(l,s.dtype,f.values)}const qpe={kernelName:FA,backendName:"cpu",kernelFunc:Hpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ype(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:o,batchDims:a}=s;It([i,r],"gatherV2");const l=Vt(o,i.shape)[0],c=t.data.get(r.dataId).values,u=i.shape[l];for(let x=0;x<c.length;++x){const C=c[x];R(C<=u-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${u-1}]`)}let h=a;a==null&&(h=0);const d=ce(r.shape),p=uw(i,r,l,h),f=Un({inputs:{x:i},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=Un({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],A=t.bufferSync(g),y=t.bufferSync(f),b=_z(y,A,m);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.makeTensorInfo(p.outputShape,b.dtype,b.values)}const Xpe={kernelName:qp,backendName:"cpu",kernelFunc:Ype};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jpe(n){const{inputs:e,backend:t}=n,{input:s}=e,i=ce(s.shape),r=s.shape[s.shape.length-1],o=i/r,a=Un({inputs:{x:s},backend:t,attrs:{shape:[o,r]}}),l=AU(a,!0,t),c=Un({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const Kpe={kernelName:$A,backendName:"cpu",kernelFunc:jpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jpe=En(fh,n=>Number.isFinite(n)?1:0,"bool"),Zpe={kernelName:fh,backendName:"cpu",kernelFunc:Jpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const efe=En(mh,n=>Math.abs(n)===1/0?1:0,"bool"),tfe={kernelName:mh,backendName:"cpu",kernelFunc:efe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nfe=En(gh,n=>Number.isNaN(n)?1:0,"bool"),sfe={kernelName:gh,backendName:"cpu",kernelFunc:nfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ife(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,o=Nz(s,i,r);return e.makeTensorInfo([o.length],"float32",o)}const rfe={kernelName:LA,backendName:"cpu",kernelFunc:ife};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ofe=En(yh,n=>Math.log1p(n)),afe={kernelName:yh,backendName:"cpu",kernelFunc:ofe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lfe=ms((n,e)=>n&&e),cfe=Ds(Jp,lfe,null,"bool"),ufe={kernelName:Jp,backendName:"cpu",kernelFunc:cfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hfe=En(Zp,n=>n?0:1,"bool"),dfe={kernelName:Zp,backendName:"cpu",kernelFunc:hfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pfe=ms((n,e)=>n||e),ffe=Ds(ef,pfe,null,"bool"),mfe={kernelName:ef,backendName:"cpu",kernelFunc:ffe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:o,alpha:a,beta:l}=s;It(i,"LRN");const c=i.shape[3],u=c-1,h=t.data.get(i.dataId).values,d=ce(i.shape),p=new Float32Array(d);function f(g){const m=g%c;let A=g-m+Math.max(0,m-r);const y=g-m+Math.min(m+r,u);let b=0;for(;A<=y;A++){const x=h[A];b+=x*x}return b}for(let g=0;g<d;g++){const m=f(g),A=h[g]*Math.pow(o+a*m,-l);p[g]=A}return t.makeTensorInfo(i.shape,i.dtype,p)}const Afe={kernelName:tf,backendName:"cpu",kernelFunc:gfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=s;It(o,"LRNGrad");const h=ce(o.shape),d=o.shape[3],p=t.data.get(o.dataId).values,f=t.data.get(i.dataId).values,g=t.data.get(r.dataId).values,m=new Float32Array(h),A=h;for(let y=0;y<A;y++){const b=y%d,x=y-b+Math.max(0,b-a),C=y-b+Math.min(d,b+a+1);let w=0;for(let E=x;E<C;E++)w+=Math.pow(f[E],2);w=c*w+l;for(let E=x;E<C;E++){let T=-2*c*u*f[E]*g[y]/w;y===E&&(T+=Math.pow(w,-u)),T*=p[y],m[E]+=T}}return t.makeTensorInfo(o.shape,i.dtype,m)}const xfe={kernelName:OA,backendName:"cpu",kernelFunc:yfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yU(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:o}=s,a=t;let l=i.shape;const c=l.length,u=Vt(r,l);let h=u;const d=Nn(h,c);let p=a.data.get(i.dataId).values;if(d!=null){const x=new Array(c);for(let C=0;C<x.length;C++)x[C]=l[d[C]];p=_B(p,l,i.dtype,d,x),h=Vn(h.length,c),l=x}It(i,"max"),vs("max",h,c);const[f,g]=ps(l,h),m=ce(g),A=Dz(p,m,f,i.dtype),y=a.write(A,f,i.dtype);let b=f;return o&&(b=us(f,u)),{dataId:y,shape:b,dtype:i.dtype}}const bfe={kernelName:nf,backendName:"cpu",kernelFunc:yU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ife(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;It(i,"maxPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;R(Rs(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=mi(i.shape,r,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&qt(u.inShape,u.outShape))h=xa({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,p=vt(i.shape),f=MB(d,i.shape,i.dtype,p,u,"max");h=t.makeTensorInfo(u.outShape,i.dtype,f.values)}return h}const Cfe={kernelName:sf,backendName:"cpu",kernelFunc:Ife};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;It(i,"maxPool3d");const u=Xr(i.shape,r,o,1,a,l,c),h=t.data.get(i.dataId).values,d=fU(h,i.shape,i.dtype,vt(i.shape),u,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const vfe={kernelName:rf,backendName:"cpu",kernelFunc:wfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;It([i,r],"maxPool3DGrad");const u=Xr(r.shape,o,a,1,l,c),h=t.bufferSync(r),d=pde(h,u),p=u.strideDepth,f=u.strideHeight,g=u.strideWidth,m=u.dilationDepth,A=u.dilationHeight,y=u.dilationWidth,b=u.effectiveFilterDepth,x=u.effectiveFilterHeight,C=u.effectiveFilterWidth,w=b-1-u.padInfo.front,E=C-1-u.padInfo.left,T=x-1-u.padInfo.top,v=zt(r.shape,"float32"),S=t.bufferSync(i);for(let _=0;_<u.batchSize;++_)for(let N=0;N<u.inChannels;++N)for(let D=0;D<u.inDepth;++D)for(let P=0;P<u.inHeight;++P)for(let L=0;L<u.inWidth;++L){const z=D-w,q=P-T,V=L-E;let X=0;for(let te=0;te<b;te+=m){const se=(z+te)/p;if(!(se<0||se>=u.outDepth||Math.floor(se)!==se))for(let fe=0;fe<x;fe+=A){const me=(q+fe)/f;if(!(me<0||me>=u.outHeight||Math.floor(me)!==me))for(let Te=0;Te<C;Te+=y){const Ee=(V+Te)/g;if(Ee<0||Ee>=u.outWidth||Math.floor(Ee)!==Ee)continue;const re=b*x*C-1-d.get(_,se,me,Ee,N),ue=te*x*C+fe*C+Te,_e=re===ue?1:0;if(_e===0)continue;const ke=S.get(_,se,me,Ee,N);X+=ke*_e}}}v.set(X,_,D,P,L,N)}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const Efe={kernelName:UA,backendName:"cpu",kernelFunc:Sfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:o}=e,a=r;It([r,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=mi(a.shape,l,c,1,u,h),p=t.data.get(a.dataId).values,f=zt(d.outShape,a.dtype,pU(p,a.shape,a.dtype,d).values),g=d.strideHeight,m=d.strideWidth,A=d.dilationHeight,y=d.dilationWidth,b=d.effectiveFilterHeight,x=d.effectiveFilterWidth,C=x-1-d.padInfo.left,w=b-1-d.padInfo.top,E=zt(a.shape,"float32"),T=t.data.get(i.dataId).values,v=zt(i.shape,"float32",T);for(let S=0;S<d.batchSize;++S)for(let _=0;_<d.inChannels;++_)for(let N=0;N<d.inHeight;++N)for(let D=0;D<d.inWidth;++D){const P=N-w,L=D-C;let z=0;for(let q=0;q<b;q+=A){const V=(P+q)/g;if(!(V<0||V>=d.outHeight||Math.floor(V)!==V))for(let X=0;X<x;X+=y){const te=(L+X)/m;if(te<0||te>=d.outWidth||Math.floor(te)!==te)continue;const se=b*x-1-f.get(S,V,te,_),fe=q*x+X,me=se===fe?1:0;if(me===0)continue;const Te=v.get(S,V,te,_);z+=Te*me}}E.set(z,S,N,D,_)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const Tfe={kernelName:zA,backendName:"cpu",kernelFunc:_fe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bfe(n,e,t,s,i){const r=vt(e),o=MB(n,e,t,r,i,"max"),a=pU(n,e,t,i,!0,s);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kfe={kernelName:QA,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:a}=e,l=t;It(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,u=mi(s.shape,i,r,[1,1],o),[h,d]=Bfe(c,s.shape,s.dtype,a,u),p=l.write(h,u.outShape,s.dtype),f=l.write(d,u.outShape,s.dtype);return[{dataId:p,shape:u.outShape,dtype:s.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=Vt(r,i.shape),c=ps(i.shape,a)[1],u=ce(c),h=[],d=t.makeTensorInfo([],"float32",new Float32Array([u]));h.push(d);const p=sc({inputs:{x:i},backend:t,attrs:{dtype:"float32"}});h.push(p);const f=NB({inputs:{a:p,b:d},backend:t});h.push(f);const g=Hy({inputs:{x:f},backend:t,attrs:{axis:r,keepDims:o}});return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),g}const Nfe={kernelName:of,backendName:"cpu",kernelFunc:Mfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;It(i,"min");const a=Vt(r,i.shape);let l=a;const c=Nn(l,i.shape.length);let u=i;c!=null&&(u=sr({inputs:{x:i},backend:t,attrs:{perm:c}}),l=Vn(l.length,i.shape.length)),vs("min",l,u.shape.length);const[h,d]=ps(u.shape,l),p=ce(d),f=Ws(ce(h),u.dtype),g=t.data.get(u.dataId).values;for(let A=0;A<f.length;++A){const y=A*p;let b=g[y];for(let x=0;x<p;++x){const C=g[y+x];(Number.isNaN(C)||C<b)&&(b=C)}f[A]=b}c!=null&&t.disposeIntermediateTensorInfo(u);const m=t.makeTensorInfo(h,u.dtype,f);if(o){const A=us(h,a),y=Un({inputs:{x:m},backend:t,attrs:{shape:A}});return t.disposeIntermediateTensorInfo(m),y}return m}const Dfe={kernelName:af,backendName:"cpu",kernelFunc:Rfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ffe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,mode:o}=s;It(i,"mirrorPad");const a=r.map((b,x)=>b[0]+i.shape[x]+b[1]),l=r.map(b=>b[0]),c=r.map((b,x)=>b[0]+i.shape[x]),u=o==="reflect"?0:1,h=t.data.get(i.dataId).values,d=i.shape.length,p=vt(i.shape),f=ce(a),g=a.length,m=vt(a),A=Cs(i.dtype,f);for(let b=0;b<f;b++){let x=Hu(b,g,m);for(let w=0;w<g;w++)x[w]<l[w]?x[w]=l[w]*2-x[w]-u:x[w]>=c[w]&&(x[w]=(c[w]-1)*2-x[w]+u);x=x.map((w,E)=>w-l[E]);const C=No(x,d,p);A[b]=h[C]}return{dataId:t.write(A,a,i.dtype),shape:a,dtype:i.dtype}}const $fe={kernelName:lf,backendName:"cpu",kernelFunc:Ffe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pfe=ms(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),Lfe=Ds(Ih,Pfe),Ofe={kernelName:Ih,backendName:"cpu",kernelFunc:Lfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xU(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,o=i.shape.length;let a=r;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=Vt([a],i.shape),c=yU({inputs:{x:i},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),u=us(c.shape,l),h=Un({inputs:{x:c},backend:t,attrs:{shape:u}}),d=BB({inputs:{a:i,b:h},backend:t}),p=Cz({inputs:{x:d},backend:t}),f=Hy({inputs:{x:p},backend:t,attrs:{axis:l,keepDims:!1}}),g=Un({inputs:{x:f},backend:t,attrs:{shape:u}}),m=NB({inputs:{a:p,b:g},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),m}const zfe={kernelName:Ef,backendName:"cpu",kernelFunc:xU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ufe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:o,normalized:a}=s;It(i,"multinomial");const l=a?i:xU({inputs:{logits:i},backend:t,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=t.data.get(l.dataId).values,d=[c,r],p=Ws(ce(d),"int32");for(let f=0;f<c;++f){const g=f*u,m=new Float32Array(u-1);m[0]=h[g];for(let b=1;b<m.length;++b)m[b]=m[b-1]+h[g+b];const A=$f.alea(o.toString()),y=f*r;for(let b=0;b<r;++b){const x=A();p[y+b]=m.length;for(let C=0;C<m.length;C++)if(x<m[C]){p[y+b]=C;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(d,"int32",p)}const Qfe={kernelName:VA,backendName:"cpu",kernelFunc:Ufe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vfe=ky;function Gfe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;It(i,"NonMaxSuppression");const c=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,{selectedIndices:h}=Vfe(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const Wfe={kernelName:GA,backendName:"cpu",kernelFunc:Gfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hfe=zC;function qfe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s;It(i,"NonMaxSuppressionPadded");const u=t.data.get(i.dataId).values,h=t.data.get(r.dataId).values,{selectedIndices:d,validOutputs:p}=Hfe(u,h,o,a,l,c);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const Yfe={kernelName:jI,backendName:"cpu",kernelFunc:qfe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xfe=My;function jfe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s;It(i,"NonMaxSuppressionWithScore");const u=t.data.get(i.dataId).values,h=t.data.get(r.dataId).values,d=o,p=a,f=l,g=c,{selectedIndices:m,selectedScores:A}=Xfe(u,h,d,p,f,g);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([A.length],"float32",new Float32Array(A))]}const Kfe={kernelName:WA,backendName:"cpu",kernelFunc:jfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jfe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:o,onValue:a,offValue:l}=s;It(i,"oneHot");const c=ce(i.shape),u=new Float32Array(c*o);u.fill(l);const h=t.data.get(i.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<o&&(u[d*o+h[d]]=a);return t.makeTensorInfo([...i.shape,o],r,u)}const Zfe={kernelName:df,backendName:"cpu",kernelFunc:Jfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tI(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const i=Fu({inputs:{input:s},backend:t}),r=tI({inputs:{x:i},backend:t}),o=xp({inputs:{input:s},backend:t}),a=tI({inputs:{x:o},backend:t}),l=mr({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return RB({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const eme={kernelName:Bf,backendName:"cpu",kernelFunc:tI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bU(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const i=Fu({inputs:{input:s},backend:t}),r=bU({inputs:{x:i},backend:t}),o=xp({inputs:{input:s},backend:t}),a=tI({inputs:{x:o},backend:t}),l=mr({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return RB({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const tme={kernelName:hf,backendName:"cpu",kernelFunc:bU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IU(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return eI({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,o=e[0].dtype;e.forEach(u=>{Xs(r,u.shape,"All tensors passed to stack must have matching shapes"),R(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=eI({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(h),h}),c=bp({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const nme={kernelName:pf,backendName:"cpu",kernelFunc:IU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sme(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:o}=s;It(i,"pad");const a=r.map((y,b)=>y[0]+i.shape[b]+y[1]),l=r.map(y=>y[0]),c=t.data.get(i.dataId).values,u=ce(i.shape),h=i.shape.length,d=vt(i.shape),p=ce(a),f=a.length,g=vt(a),m=Cs(i.dtype,p);o!==0&&m.fill(o);for(let y=0;y<u;y++){const x=Hu(y,h,d).map((w,E)=>w+l[E]),C=No(x,f,g);m[C]=c[y]}return{dataId:t.write(m,a,i.dtype),shape:a,dtype:i.dtype}}const CU={kernelName:ff,backendName:"cpu",kernelFunc:sme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ime=ms((n,e)=>Math.pow(n,e)),rme=Ds(wh,ime),ome={kernelName:wh,backendName:"cpu",kernelFunc:rme};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ame(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:o}=e,{outputRaggedRank:a}=s,l=i.map(A=>t.data.get(A.dataId).values),c=i.map(A=>A.shape),u=t.data.get(r.dataId).values,h=t.data.get(o.dataId).values,[d,p,f]=zz(l,c,u,r.shape,r.dtype,h,o.shape),g=d.map(A=>t.makeTensorInfo([A.length],"int32",A)),m=t.makeTensorInfo(f,r.dtype,p);return g.concat([m])}const lme={kernelName:KI,backendName:"cpu",kernelFunc:ame};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cme(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:r}=e,o=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=Uz(o,s.shape,s.dtype,a,i.shape,l,r.shape),h=t.makeTensorInfo([c.length],"int32",c),d=t.makeTensorInfo([u.length],s.dtype,u);return[h,d]}const ume={kernelName:JI,backendName:"cpu",kernelFunc:cme};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hme(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:r,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,c=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,h=t.data.get(o.dataId).values,d=a.map(m=>t.data.get(m.dataId).values),p=a.map(m=>m.shape),[f,g]=Qz(c,i.shape,u,r.shape,r.dtype,h,o.shape,d,p,l);return t.makeTensorInfo(f,r.dtype,g)}const dme={kernelName:ZI,backendName:"cpu",kernelFunc:hme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pme(n){const{backend:e,attrs:t}=n,{start:s,stop:i,dtype:r,step:o}=t,a=Vz(s,i,o,r);return e.makeTensorInfo([a.length],r,a)}const fme={kernelName:HA,backendName:"cpu",kernelFunc:pme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mme=En(vh,n=>1/n),gme={kernelName:vh,backendName:"cpu",kernelFunc:mme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ame(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s;It(i,"resizeBilinear");const l=vt(i.shape),[c,u]=a,[h,d,p,f]=i.shape,g=t.data.get(i.dataId).values,m=new Float32Array(ce([h,c,u,f])),A=[r&&c>1?d-1:d,r&&u>1?p-1:p],y=[r&&c>1?c-1:c,r&&u>1?u-1:u];let b=0;const x=A[0]/y[0],C=A[1]/y[1];for(let w=0;w<h;w++)for(let E=0;E<c;E++){let T;o?T=x*(E+.5)-.5:T=x*E;const v=Math.max(0,Math.floor(T)),S=T-v,_=Math.min(d-1,Math.ceil(T)),N=w*l[0]+v*l[1],D=w*l[0]+_*l[1];for(let P=0;P<u;P++){let L;o?L=C*(P+.5)-.5:L=C*P;const z=Math.max(0,Math.floor(L)),q=L-z,V=Math.min(p-1,Math.ceil(L)),X=N+z*l[2],te=D+z*l[2],se=N+V*l[2],fe=D+V*l[2];for(let me=0;me<f;me++){const Te=g[X+me],Ee=g[te+me],re=g[se+me],ue=g[fe+me],_e=Te+(re-Te)*q,ke=Ee+(ue-Ee)*q,Ne=_e+(ke-_e)*S;m[b++]=Ne}}}return t.makeTensorInfo([h,c,u,f],"float32",m)}const yme={kernelName:xf,backendName:"cpu",kernelFunc:Ame};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xme(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s;It([r,i],"resizeBilinearGrad");const a=vt(i.shape),[l,c,u,h]=i.shape,[,d,p]=r.shape,f=new Float32Array(l*c*u*h),g=[o&&d>1?c-1:c,o&&p>1?u-1:u],m=[o&&d>1?d-1:d,o&&p>1?p-1:p],A=g[0]/m[0],y=g[1]/m[1],b=t.data.get(r.dataId).values;let x=0;for(let C=0;C<l;C++){const w=C*a[0];for(let E=0;E<d;E++){const T=E*A,v=Math.floor(T),S=Math.min(Math.ceil(T),c-1),_=w+v*a[1],N=w+S*a[1],D=T-v,P=1-D;for(let L=0;L<p;L++){const z=L*y,q=Math.floor(z),V=Math.min(Math.ceil(z),u-1),X=z-q,te=1-X,se=_+q*a[2],fe=_+V*a[2],me=N+q*a[2],Te=N+V*a[2],Ee=P*te,re=P*X,ue=D*te,_e=D*X;for(let ke=0;ke<h;ke++){const Ne=b[x++];f[se+ke]+=Ne*Ee,f[fe+ke]+=Ne*re,f[me+ke]+=Ne*ue,f[Te+ke]+=Ne*_e}}}}return t.makeTensorInfo([l,u,c,h],"float32",f)}const bme={kernelName:XA,backendName:"cpu",kernelFunc:xme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ime(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s;It(i,"resizeNearestNeighbor");const l=vt(i.shape),[c,u]=a,[h,d,p,f]=i.shape,g=t.data.get(i.dataId).values,m=new Float32Array(h*c*u*f),A=[r&&c>1?d-1:d,r&&u>1?p-1:p],y=[r&&c>1?c-1:c,r&&u>1?u-1:u],b=A[0]/y[0],x=A[1]/y[1];let C=0;for(let w=0;w<h;w++){const E=w*l[0];for(let T=0;T<c;T++){const v=o?b*(T+.5):b*T;let S=Math.min(d-1,r?Math.round(v):Math.floor(v));o&&(S=Math.max(0,S));const _=E+S*l[1];for(let N=0;N<u;N++){const D=o?x*(N+.5):x*N;let P=Math.min(p-1,r?Math.round(D):Math.floor(D));o&&(P=Math.max(0,P));const L=_+P*l[2];for(let z=0;z<f;z++){const q=g[L+z];m[C++]=q}}}}return t.makeTensorInfo([h,c,u,f],i.dtype,m)}const Cme={kernelName:yf,backendName:"cpu",kernelFunc:Ime};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wme(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s;It([r,i],"resizeNearestNeighborGrad");const a=vt(i.shape),l=vt(r.shape),[c,u,h,d]=i.shape,[,p,f]=r.shape,g=new Float32Array(c*u*h*d),m=t.data.get(r.dataId).values,A=[o&&p>1?u-1:u,o&&f>1?h-1:h],y=[o&&p>1?p-1:p,o&&f>1?f-1:f],b=A[0]/y[0],x=A[1]/y[1],C=1/b,w=1/x,E=Math.ceil(C)*2+2,T=Math.ceil(w)*2+2;for(let v=0;v<c;v++){const S=v*a[0];for(let _=0;_<u;_++){const N=S+_*a[1],D=Math.floor(_*C),P=Math.floor(D-E/2);for(let L=0;L<h;L++){const z=N+L*a[2],q=Math.floor(L*w),V=Math.floor(q-T/2);for(let X=0;X<d;X++){let te=0;for(let se=0;se<E;se++){const fe=se+P;if(fe<0||fe>=p)continue;const me=S+fe*l[1],Te=fe*b,Ee=Math.min(u-1,o?Math.round(Te):Math.floor(Te));if(_===Ee)for(let re=0;re<T;re++){const ue=re+V;if(ue<0||ue>=f)continue;const _e=me+ue*l[2],ke=ue*x,Ne=Math.min(h-1,o?Math.round(ke):Math.floor(ke));L===Ne&&(te+=m[_e+X])}}g[z+X]=te}}}}return t.makeTensorInfo(i.shape,i.dtype,g)}const vme={kernelName:YA,backendName:"cpu",kernelFunc:wme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sme(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s;It(i,"reverse");const o=i.shape.length,a=Vt(r,i.shape);if(o===0)return xa({inputs:{x:i},backend:t});const l=new Is(i.shape,i.dtype),c=t.bufferSync(i);for(let u=0;u<l.size;u++){const h=l.indexToLoc(u),d=h.slice();a.forEach(p=>d[p]=i.shape[p]-1-d[p]),l.set(c.get(...d),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const Eme={kernelName:bf,backendName:"cpu",kernelFunc:Sme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _me={kernelName:ly,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=e,a=t,l=Cs(s.dtype,ce(s.shape)),[c,u,h,d]=s.shape,[p,f]=XC(o,u,h),g=255,m=Math.sin(i),A=Math.cos(i),y=a.data.get(s.dataId).values;for(let x=0;x<c;x++){const C=x*h*u*d;for(let w=0;w<u;w++){const E=w*(h*d);for(let T=0;T<h;T++){const v=T*d;for(let S=0;S<d;S++){const _=[c,w,T,S],N=_[2],D=_[1];let P=(N-p)*A-(D-f)*m,L=(N-p)*m+(D-f)*A;P=Math.round(P+p),L=Math.round(L+f);let z=r;if(typeof r!="number"&&(S===3?z=g:z=r[S]),P>=0&&P<h&&L>=0&&L<u){const V=L*(h*d),X=P*d,te=C+V+X+S;z=y[te]}const q=C+E+v+S;l[q]=z}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tme=En(_h,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),Bme={kernelName:_h,backendName:"cpu",kernelFunc:Tme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kme(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=qo(r,i,o),d=!0,p=t.bufferSync(i),f=t.bufferSync(r),g=tu(p,f,o,h,c,l,a,u,0,d);return t.makeTensorInfo(o,g.dtype,g.values)}const Mme={kernelName:jA,backendName:"cpu",kernelFunc:kme};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nme(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<e?t=i+1:s=i;return s}function Rme(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<=e?t=i+1:s=i;return s}function Dme(n,e,t,s,i,r){const o=ns("int32",t*i);for(let a=0;a<t;++a){const l=n.slice(a*s,(a+1)*s),c=a*i;for(let u=0;u<i;++u)o[c+u]=r==="left"?Nme(l,e[u+c]):Rme(l,e[u+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fme(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:o}=s,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,c=Dme(a,l,i.shape[0],i.shape[1],r.shape[1],o);return t.makeTensorInfo(r.shape,"int32",c)}const $me={kernelName:JA,backendName:"cpu",kernelFunc:Fme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pme(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e;It([s,i,r],"select");const o=s.shape.length,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=Ns(i.dtype,r.dtype),h=Ws(ce(i.shape),u);let d=0;const p=o===0||o>1||i.shape.length===1?1:ce(i.shape.slice(1));for(let f=0;f<a.length;f++)for(let g=0;g<p;g++)a[f]===1?h[d++]=l[f]:h[d++]=c[f];return t.makeTensorInfo(i.shape,u,h)}const Lme={kernelName:If,backendName:"cpu",kernelFunc:Pme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ome=Dy,zme=Fy,Ume=En(Bh,n=>n>=0?zme*n:Ome*(Math.exp(n)-1)),Qme={kernelName:Bh,backendName:"cpu",kernelFunc:Ume};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vme=En(Nh,n=>n<0?-1:n>0?1:0),Gme={kernelName:Nh,backendName:"cpu",kernelFunc:Vme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wme=En(kh,n=>Math.sin(n)),Hme={kernelName:kh,backendName:"cpu",kernelFunc:Wme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qme=En(Mh,n=>Math.sinh(n)),Yme={kernelName:Mh,backendName:"cpu",kernelFunc:qme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xme=11920928955078125e-23,yR=Math.log(Xme)+2,jme=En(Dh,n=>{const e=n>-yR,t=n<yR,s=Math.exp(n);let i;return t?i=s:e?i=n:i=Math.log(1+s),i}),Kme={kernelName:Dh,backendName:"cpu",kernelFunc:jme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jme(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:o}=s;It([i],"spaceToBatchND");const a=ce(r),l=[[0,0]];l.push(...o);for(let w=1+r.length;w<i.shape.length;++w)l.push([0,0]);const c=CU.kernelFunc({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),u=Hh(c.shape,r,a,!1),h=qh(u.length,r.length,!1),d=Yh(c.shape,r,a,!1),g=Un({inputs:{x:c},backend:t,attrs:{shape:u}}),y=sr({inputs:{x:g},backend:t,attrs:{perm:h}}),C=Un({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),C}const Zme={kernelName:vf,backendName:"cpu",kernelFunc:Jme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ege(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:r,defaultValue:o}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values[0],[h,d,p,f,g]=qz(a,s.shape,s.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],i.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const tge={kernelName:eC,backendName:"cpu",kernelFunc:ege};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nge(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:r}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const o=Array.from(t.data.get(i.dataId).values),a=t.data.get(s.dataId).values,l=Array.from(t.data.get(r.dataId).values),[c,u,h]=Yz(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(u,s.dtype,c),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}const sge={kernelName:tC,backendName:"cpu",kernelFunc:nge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ige(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=TB(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(u,s.dtype,c)}const rge={kernelName:ZA,backendName:"cpu",kernelFunc:ige};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oge(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=TB(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(u,s.dtype,c)}const age={kernelName:ey,backendName:"cpu",kernelFunc:oge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lge(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=qo(r,i,a),p=!1,f=t.bufferSync(i);let g;switch(r.dtype){case"bool":{const m=t.bufferSync(r),A=!!t.data.get(o.dataId).values[0];g=tu(f,m,a,d,u,c,l,h,A,p);break}case"float32":{const m=t.bufferSync(r),A=t.data.get(o.dataId).values[0];g=tu(f,m,a,d,u,c,l,h,A,p);break}case"int32":{const m=t.bufferSync(r),A=t.data.get(o.dataId).values[0];g=tu(f,m,a,d,u,c,l,h,A,p);break}case"string":{const m=t.bufferSync(r),A=lo(t.data.get(o.dataId).values[0]);g=tu(f,m,a,d,u,c,l,h,A,p);break}default:throw new Error(`Unsupported type ${r.dtype}`)}return t.makeTensorInfo(a,g.dtype,g.values)}const cge={kernelName:ty,backendName:"cpu",kernelFunc:lge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uge(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:o}=s,a=Vt(o,i.shape)[0],l=cw(i,r,a),c=new Array(i.shape.length).fill(0),u=i.shape.slice();return l.map(h=>{const d=[...u];d[a]=h;const p=$u({inputs:{x:i},backend:t,attrs:{begin:c,size:d}});return c[a]+=h,p})}const hge={kernelName:Sf,backendName:"cpu",kernelFunc:uge};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dge={kernelName:ny,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;It(t,"square");const i=s.data.get(t.dataId).values,r=new Float32Array(i.length);for(let a=0;a<i.length;++a){const l=i[a];r[a]=l*l}return{dataId:s.write(r,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pge=En(Uh,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),fge={kernelName:Uh,backendName:"cpu",kernelFunc:pge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mge(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s;It(i,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:A,begin:y,end:b,strides:x}=HC(i.shape,r,o,a,l,c,u,h,d);let C;if(g)C=Un({inputs:{x:i},backend:t,attrs:{shape:f}});else if(m||A){R(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const w=WC(y,b,x),E=$u({inputs:{x:i},backend:t,attrs:{begin:y,size:w}});C=Un({inputs:{x:E},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(E)}else{const w=t.bufferSync(i),E=Kz(p,w,x,y);C=t.makeTensorInfo(f,E.dtype,E.values)}return C}const gge={kernelName:iy,backendName:"cpu",kernelFunc:mge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Age(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:h}=e,d=t.data.get(u.dataId).values,p=t.data.get(h.dataId).values,[f,g]=Jz(d,p,i,r,o,a,l,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",g)]}const yge={kernelName:ry,backendName:"cpu",kernelFunc:Age};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xge(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:o}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values[0],[c,u,h]=Zz(a,l,i),d=u.length;return[t.makeTensorInfo([d,2],"int32",c),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const bge={kernelName:nC,backendName:"cpu",kernelFunc:xge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ige(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(r.dataId).values,a=eU(o,i);return t.makeTensorInfo(r.shape,"int32",a)}const Cge={kernelName:sC,backendName:"cpu",kernelFunc:Ige};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wge=En(Lh,n=>Math.tan(n)),vge={kernelName:Lh,backendName:"cpu",kernelFunc:wge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sge=En(Oh,n=>Math.tanh(n)),Ege={kernelName:Oh,backendName:"cpu",kernelFunc:Sge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ge(n){const{inputs:e,backend:t}=n,{tensor:s,indices:i,updates:r}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=qo(r,i,s.shape),h=!1,d=t.bufferSync(i),p=t.bufferSync(r),f=t.bufferSync(s),g=tu(d,p,s.shape,u,l,a,o,c,f,h);return t.makeTensorInfo(s.shape,g.dtype,g.values)}const Tge={kernelName:KA,backendName:"cpu",kernelFunc:_ge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bge(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;It(i,"tile");const o=nU(t.bufferSync(i),r);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const kge={kernelName:zh,backendName:"cpu",kernelFunc:Bge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mge(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:o}=s;It(i,"topk");const a=t.data.get(i.dataId).values,[l,c]=iU(a,i.shape,i.dtype,r,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const Nge={kernelName:oy,backendName:"cpu",kernelFunc:Mge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rge(n){const{inputs:e,attrs:t,backend:s}=n,{image:i,transforms:r}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=t,[u,h,d,p]=i.shape,[f,g]=c??[h,d],m=[u,f,g,p],A=vt(i.shape),y=A[0],b=A[1],x=A[2],C=vt(m),w=C[0],E=C[1],T=C[2],v=Cs(i.dtype,ce(m));v.fill(l);const S=s.data.get(i.dataId).values,_=s.data.get(r.dataId).values;for(let D=0;D<u;++D){const P=r.shape[0]===1?_:_.subarray(D*8,D*8+8);for(let L=0;L<f;++L)for(let z=0;z<g;++z)for(let q=0;q<p;++q){let V;const X=P[6]*z+P[7]*L+1;if(X===0)continue;const te=(P[0]*z+P[1]*L+P[2])/X,se=(P[3]*z+P[4]*L+P[5])/X,fe=xR(te,d,a),me=xR(se,h,a);switch(o){case"nearest":V=Oge(S,h,d,y,b,x,D,me,fe,q,l);break;case"bilinear":V=zge(S,h,d,y,b,x,D,me,fe,q,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const Te=D*w+L*E+z*T+q;v[Te]=V}return s.makeTensorInfo(m,i.dtype,v)}return{dataId:s.write(v,m,i.dtype),shape:i.shape,dtype:i.dtype}}const Dge={kernelName:ay,backendName:"cpu",kernelFunc:Rge};function xR(n,e,t){switch(t){case"reflect":return Fge(n,e);case"wrap":return $ge(n,e);case"nearest":return Lge(n,e);case"constant":default:return Pge(n)}}function Fge(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Hl(0,t,e-1)}function $ge(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Hl(0,t,e-1)}function Pge(n,e){return n}function Lge(n,e){return Hl(0,n,e-1)}function $m(n,e,t,s,i,r,o,a,l,c,u){const h=o*s+a*i+l*r+c;return 0<=a&&a<e&&0<=l&&l<t?n[h]:u}function Oge(n,e,t,s,i,r,o,a,l,c,u){const h=Math.round(a),d=Math.round(l);return $m(n,e,t,s,i,r,o,h,d,c,u)}function zge(n,e,t,s,i,r,o,a,l,c,u){const h=Math.floor(a),d=Math.floor(l),p=h+1,f=d+1,g=(f-l)*$m(n,e,t,s,i,r,o,h,d,c,u)+(l-d)*$m(n,e,t,s,i,r,o,h,f,c,u),m=(f-l)*$m(n,e,t,s,i,r,o,p,d,c,u)+(l-d)*$m(n,e,t,s,i,r,o,p,f,c,u);return(p-a)*g+(a-h)*m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uge(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:r}=e;It(r,"unique");const o=s.data.get(r.dataId).values,{outputValues:a,outputShape:l,indices:c}=rU(o,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const Qge={kernelName:iC,backendName:"cpu",kernelFunc:Uge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vge(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i.shape.length,a=i.shape[r],l=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==r&&(l[c++]=i.shape[p]);const u=new Array(o).fill(0),h=i.shape.slice();h[r]=1;const d=new Array(a);for(let p=0;p<d.length;p++){u[r]=p;const f=$u({inputs:{x:i},backend:t,attrs:{begin:u,size:h}});d[p]=Un({inputs:{x:f},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(f)}return d}const Gge={kernelName:_f,backendName:"cpu",kernelFunc:Vge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wge(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:o}=s;It(i,"unsortedSegmentSum");const a=i.shape.length,l=r.shape.length,c=[],u=[],h=a-l;let d=r;for(let f=0;f<h;++f){const g=eI({inputs:{input:d},backend:t,attrs:{dim:f+1}});d=g,u.push(g)}for(let f=0;f<o;++f){const g=hl(f,"int32"),m=t.makeTensorInfo([],"int32",g),A=bz({inputs:{a:m,b:d},backend:t}),y=sc({inputs:{x:A},backend:t,attrs:{dtype:"float32"}}),b=Nw({inputs:{a:y,b:i},backend:t}),x=Hy({inputs:{x:b},backend:t,attrs:{axis:0,keepDims:!1}});c.push(x),u.push(m),u.push(A),u.push(y),u.push(b),u.push(x)}const p=IU({inputs:c,backend:t,attrs:{axis:0}});return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const Hge={kernelName:Tf,backendName:"cpu",kernelFunc:Wge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qge=[Uhe,Cue,Vhe,Whe,Tue,qhe,Xhe,Khe,Zhe,tde,sde,rde,ade,ude,dde,mde,Ade,xde,Ide,Ohe,wde,Sde,_de,kue,Bde,Eue,Nue,Mde,wue,Rde,Fde,$de,Lde,zde,Qde,Gde,Hde,Yde,jde,Jde,epe,npe,ipe,ope,ape,cpe,hpe,ppe,fpe,mpe,gpe,ype,Ipe,Nhe,wpe,Rue,Mpe,Due,Npe,$ue,Lpe,Ope,Upe,Lue,zue,Vpe,Wpe,qpe,Xpe,Que,Gue,vue,Kpe,Dde,Zpe,tfe,sfe,Rhe,Hue,Yue,rfe,jue,afe,ufe,dfe,mfe,Afe,xfe,bfe,Jue,Cfe,vfe,Efe,Tfe,kfe,Nfe,Dfe,ehe,$fe,Ofe,Qfe,nhe,ihe,Wfe,Yfe,Kfe,ohe,Zfe,tme,nme,CU,ome,Fhe,che,lme,ume,dme,fme,Sue,U1,gme,$he,Phe,Lhe,yme,bme,Cme,vme,Eme,_me,Bme,Ahe,Mme,$me,Lme,Qme,xhe,Gme,Hme,Yme,bhe,zfe,Kme,Zme,tge,sge,rge,age,cge,hge,whe,dge,She,_he,fge,gge,yge,bge,Cge,Mhe,xpe,vge,Ege,Tge,kge,Nge,Dge,ahe,Qge,Gge,Hge,eme];for(const n of qge)cy(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qc={},l0={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function wU(n,e){qc[n]=e}function Uo(n,e){if(!(n in qc)||e!=null){const s=Xge(n,e);if(s!==null)qc[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=qc[n];return t==null||t.isContextLost()?(delete qc[n],Uo(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),qc[n])}function Yge(n){if(!ae().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Xge(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??Yge(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete qc[n]},!1),ae().getBool("SOFTWARE_WEBGL_ENABLED")&&(l0.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",l0)||t.getContext("experimental-webgl",l0):t.getContext("webgl2",l0)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Og;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Og||(Og={}));var zr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(zr||(zr={}));var ni;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(ni||(ni={}));function qy(n,e){return[e,n]}function jge(n,e){return n*e}function c0(n){const e=ce(n),t=Math.ceil(e/4);return Nb(t)}function Gf(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function Kge(n,e){const[t,s]=Gf(n,e);return t*s*4}function DB(n,e){const t=n;let s,i,r,o,a,l,c,u,h,d;return ae().getNumber("WEBGL_VERSION")===2?(s=t.R32F,i=t.R16F,r=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,u=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(s=n.RGBA,i=n.RGBA,r=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,u=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(n,e){const t=e();return ae().getBool("DEBUG")&&Jge(n),t}function Jge(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+SU(n,e))}const Zge=596e-10,eAe=65504;function vU(n){return!!(ae().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Zge<Math.abs(n)&&Math.abs(n)<eAe)}function SU(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Pm(n,e){return ml(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function EU(n,e){const t=ml(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ze(n,()=>n.shaderSource(t,e)),Ze(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function _U(n,e){const t=ml(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ze(n,()=>n.shaderSource(t,e)),Ze(n,()=>n.compileShader(t)),ae().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw FB(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const tAe=/ERROR: [0-9]+:([0-9]+):/g;function FB(n,e){const t=tAe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],i=n.split(`
`),r=i.length.toString().length+2,o=i.map((h,d)=>du((d+1).toString(),r)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,s-1),c=o.slice(s-1,s),u=o.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${du(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function TU(n){return ml(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function BU(n,e){if(Ze(n,()=>n.linkProgram(e)),!ae().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function M0(n,e){if(Ze(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function kU(n,e){const t=ml(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ze(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Ze(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function MU(n,e){const t=ml(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ze(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Ze(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function nAe(){return ae().getNumber("WEBGL_VERSION")===2?1:4}function NU(n){return ml(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function RU(n,e){const t=ae().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,i=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+i+".")}}function DU(n){return ml(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function V1(n,e,t,s,i,r,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(Ze(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Ze(n,()=>n.vertexAttribPointer(a,i,n.FLOAT,!1,r,o)),Ze(n,()=>n.enableVertexAttribArray(a)),!0)}function FU(n,e,t){zU(n,t),Ze(n,()=>n.activeTexture(n.TEXTURE0+t)),Ze(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function sAe(n,e){zU(n,e),Ze(n,()=>n.activeTexture(n.TEXTURE0+e)),Ze(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function $U(n,e,t){return ml(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function PU(n,e,t){return n.getUniformLocation(e,t)}function LU(n,e,t,s){Ze(n,()=>FU(n,e,s)),Ze(n,()=>n.uniform1i(t,s))}function iAe(n){Ze(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),Ze(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),Ze(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function N0(n,e,t){Ze(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Ze(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function G1(n,e){Ze(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Ze(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Lm(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+OU(n,e))}function OU(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function ml(n,e,t){const s=Ze(n,()=>e());if(s==null)throw new Error(t);return s}function zU(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const i=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${i}.`)}}function Pu(n,e=2){return ce(n.slice(0,n.length-e))}function Lu(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Om(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Pu(n),...Lu(n)]),e}function UU(n,e=!1){let t=ae().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ae().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ae().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((a,l)=>l>=n.length-2?HI(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=ul(n).newShape);let i=ce(n),r=null;n.length<=1&&i<=t?r=[1,i]:n.length===2&&n[0]<=t&&n[1]<=t?r=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?r=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?r=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?r=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(r=[n[0],n[1]*n[2]*n[3]]);const o=r!=null&&Math.max(...r)>s&&Math.min(...r)<=(e?2:1)&&Math.min(...r)>0;if(r==null||o)if(e){const a=Pu(n);let l=2,c=2;n.length&&([l,c]=Lu(n)),i=a*(l/2)*(c/2),r=Nb(i).map(u=>u*2)}else r=Nb(i);return r}function u0(n){return n%2===0}function zg(n,e){if(n=n.slice(-2),e=e.slice(-2),qt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||u0(t)&&u0(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&u0(n[0])&&u0(e[0])}let R0,D0;function QU(n){if(R0==null){const e=Uo(n);R0=e.getParameter(e.MAX_TEXTURE_SIZE)}return R0}function rAe(){R0=null}function oAe(){D0=null}function VU(n){if(D0==null){const e=Uo(n);D0=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,D0)}function GU(n){if(n===0)return 0;let e;const t=Uo(n);return Ur(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Ur(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Ur(n,e){return n.getExtension(e)!=null}function W1(n){try{if(Uo(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function WU(n){if(n===0)return!1;const e=Uo(n);if(n===1){if(!Ur(e,"OES_texture_float"))return!1}else if(!Ur(e,"EXT_color_buffer_float"))return!1;return H1(e)}function HU(n){if(n===0)return!1;const e=Uo(n);if(n===1){if(!Ur(e,"OES_texture_float")||!Ur(e,"WEBGL_color_buffer_float"))return!1}else{if(Ur(e,"EXT_color_buffer_float"))return H1(e);const s="EXT_color_buffer_half_float";if(Ur(e,s)){const i=e.getExtension(s);return aAe(e,i)}return!1}return H1(e)}function H1(n){const e=DB(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(r),o}function aAe(n,e){const t=DB(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),a}function qU(n){return n!==2?!1:Uo(n).fenceSync!=null}function Wf(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&R(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const lAe=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:Wf,bindCanvasToFramebuffer:iAe,bindColorTextureToFramebuffer:N0,bindTextureToProgramUniformSampler:LU,bindTextureUnit:FU,bindVertexBufferToProgramAttribute:V1,callAndCheck:Ze,canBeRepresented:vU,createFragmentShader:_U,createFramebuffer:DU,createProgram:TU,createStaticIndexBuffer:MU,createStaticVertexBuffer:kU,createTexture:NU,createVertexShader:EU,getBatchDim:Pu,getExtensionOrThrow:Pm,getFramebufferErrorMessage:OU,getMaxTexturesInShader:VU,getNumChannels:nAe,getProgramUniformLocation:PU,getProgramUniformLocationOrThrow:$U,getRowsCols:Lu,getShapeAs3D:Om,getTextureShapeFromLogicalShape:UU,getWebGLDisjointQueryTimerVersion:GU,getWebGLErrorMessage:SU,getWebGLMaxTextureSize:QU,hasExtension:Ur,isCapableOfRenderingToFloatTexture:WU,isDownloadFloatTextureEnabled:HU,isReshapeFree:zg,isWebGLFenceEnabled:qU,isWebGLVersionEnabled:W1,linkProgram:BU,logShaderSourceAndInfoLog:FB,resetMaxTextureSize:rAe,resetMaxTexturesInShader:oAe,unbindColorTextureFromFramebuffer:G1,unbindTextureUnit:sAe,validateFramebuffer:Lm,validateProgram:M0,validateTextureSize:RU},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const St=ae();St.registerFlag("HAS_WEBGL",()=>St.getNumber("WEBGL_VERSION")>0);St.registerFlag("WEBGL_VERSION",()=>W1(2)?2:W1(1)?1:0);St.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);St.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>St.get("WEBGL_VERSION")===2);St.registerFlag("WEBGL_CPU_FORWARD",()=>!0);St.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);St.registerFlag("WEBGL_PACK",()=>St.getBool("HAS_WEBGL"));St.registerFlag("WEBGL_PACK_NORMALIZATION",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_CLIP",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_REDUCE",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_LAZILY_UNPACK",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_CONV_IM2COL",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>QU(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>VU(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=St.getNumber("WEBGL_VERSION");return n===0?0:GU(n)});St.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>St.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!A2());St.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>WU(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>St.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:St.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));St.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>HU(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_FENCE_API_ENABLED",()=>qU(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>St.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);St.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});St.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>A2()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});St.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);St.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);St.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);St.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);St.registerFlag("WEBGL_EXP_CONV",()=>!1);St.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>St.getBool("IS_TEST"));St.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);St.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);St.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);St.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ui(){let n,e,t,s,i,r,o,a,l,c;return ae().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",i="texture",r="outputColor",o="out vec4 outputColor;",a=ae().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",i="texture2D",r="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:i,output:r,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jh(n,e,t="index"){const s=vt(e);return s.map((i,r)=>{const o=`int ${n[r]} = ${t} / ${i}`,a=r===s.length-1?`int ${n[r+1]} = ${t} - ${n[r]} * ${i}`:`index -= ${n[r]} * ${i}`;return`${o}; ${a};`}).join("")}function Rw(n,e,t="index"){const s=vt(e);return s.map((i,r)=>{const o=`int ${n[r]} = ${t} / outShapeStrides[${r}]`,a=r===s.length-1?`int ${n[r+1]} = ${t} - ${n[r]} * outShapeStrides[${r}]`:`index -= ${n[r]} * outShapeStrides[${r}]`;return`${o}; ${a};`}).join("")}function cAe(n,e){const t=n.length,s=n.map(r=>`${e}[${r}]`),i=new Array(t-1);i[t-2]=s[t-1];for(let r=t-3;r>=0;--r)i[r]=`(${i[r+1]} * ${s[r+1]})`;return i}function uAe(n,e,t="index"){const s=n.map((r,o)=>o),i=cAe(s,e);return i.map((r,o)=>{const a=`int ${n[o]} = ${t} / ${i[o]}`,l=o===i.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${i[o]}`:`index -= ${n[o]} * ${i[o]}`;return`${a}; ${l};`}).join("")}function $B(n){const e=vt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function PB(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const YU=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:XU}=kL;function hAe(n,e,t){const s=[];if(n.forEach(p=>{const f=ce(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:g}=LB(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const i=s.join(`
`),r=n.map(p=>dAe(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Ui(),l=mAe(a);let c,u,h=yAe(a);return e.isPacked?(c=pAe(e.logicalShape,o,t.enableShapeUniforms),u=AAe(a)):(c=fAe(e.logicalShape,o,t.enableShapeUniforms),u=gAe(a)),t.packedInputs&&(h+=CAe),[h,l,u,i,c,r,t.userCode].join(`
`)}function Hf(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return DAe(n,e);case 1:return $Ae(n,e);case 2:return LAe(n,e);case 3:return zAe(n,e);case 4:return QAe(n,e);case 5:return VAe(n);case 6:return GAe(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function jU(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return RAe(n);case 1:return FAe(n,e);case 2:return PAe(n,e);case 3:return OAe(n,e);default:return UAe(n,e)}}function dAe(n,e,t=!1,s){let i="";t?i+=jU(n,s):i+=Hf(n,s);const r=n.shapeInfo.logicalShape,o=e.logicalShape;return r.length<=o.length&&(t?i+=WAe(n,e):i+=HAe(n,e)),i}function pAe(n,e,t){switch(n.length){case 0:return KU();case 1:return wAe(n,e,t);case 2:return MAe(n,e,t);case 3:return SAe(n,e,t);default:return _Ae(n,e,t)}}function fAe(n,e,t){switch(n.length){case 0:return KU();case 1:return vAe(n,e,t);case 2:return NAe(n,e,t);case 3:return EAe(n,e,t);case 4:return TAe(n,e,t);case 5:return BAe(n,e);case 6:return kAe(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function mAe(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function gAe(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function AAe(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function yAe(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${xAe}
    ${bAe}
    ${IAe}
  `}const xAe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,bAe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,IAe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,CAe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function KU(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function wAe(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function vAe(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function SAe(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[2]/2),r=i*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function EAe(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Rw(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Jh(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function _Ae(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[n.length-1]/2),r=i*Math.ceil(n[n.length-2]/2);let o=r,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${l});
    }
  `}function TAe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Rw(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Jh(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function BAe(n,e){const t=Jh(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function kAe(n,e){const t=Jh(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function MAe(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(qt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const i=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function NAe(n,e,t){return qt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Zh(n){return`offset${n}`}function RAe(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Ui();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function DAe(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[i,r]=n.shapeInfo.texShape;if(i===1&&r===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Zh(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function FAe(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n.shapeInfo.texShape,r=Ui();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${r.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${r.texture2D}(${t}, uv);
    }
  `}function $Ae(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${qf(n)}
      }
    `;const i=n.shapeInfo.texShape,r=i[0],o=i[1];if(o===1&&r===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Zh(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);
        return sampleTexture(${t}, uv);
      }
    `:r===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${r}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function PAe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,o=r[0],a=r[1],l=Ui();if(r!=null&&qt(t,r))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function LAe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape;if(r!=null&&qt(t,r)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=r[0],p=r[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=ul(t),l=o;if(l.length<t.length){const d=Yf(n,l),p=["row","col"];return`
      ${Hf(d,e)}
      float ${i}(int row, int col) {
        return ${i}(${Xf(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${qf(n)}
      }
    `;const c=r[0],u=r[1],h=Zh(s);return u===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${s}, uv);
  }
`}function OAe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(t[0]===1){const d=t.slice(1),p=[1,2],f=Yf(n,d),g=["b","row","col"];return`
        ${jU(f,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Xf(g,p)});
        }
      `}const a=Ui();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(t[2]/2),h=u*Math.ceil(t[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function zAe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=ul(t),c=a;if(c.length<t.length){const g=Yf(n,c),m=["row","col","depth"];return`
        ${Hf(g,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Xf(m,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${o}, 1)));
        ${qf(n)}
      }
    `;const u=n.shapeInfo.texShape,h=u[0],d=u[1],p=n.shapeInfo.flatOffset;if(d===r&&p==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===o&&p==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=Zh(s);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function UAe(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=Ui();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);
    }
  `;const r=n.shapeInfo.logicalShape,o=r.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(r[o-1]/2);let d=h*Math.ceil(r[o-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let g=2;g<o-1;g++)p=`int b${g}, `+p,d*=r[o-g-1],f=`b${g} * ${d} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${i.texture2D}(${t}, uv);
    }
  `}function QAe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=t[3],o=t[2]*r,a=t[1]*o,{newShape:l,keptDims:c}=ul(t);if(l.length<t.length){const y=Yf(n,l),b=["row","col","depth","depth2"];return`
      ${Hf(y,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Xf(b,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${r}, 1)));
        ${qf(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,m=`int stride0 = ${s}Shape[1] * stride1;`;if(p===a&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===r&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const A=Zh(s);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${A});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${A});
      return sampleTexture(${s}, uv);
    }
  `}function VAe(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e[4],r=e[3]*i,o=e[2]*r,a=e[1]*o,{newShape:l,keptDims:c}=ul(e);if(l.length<e.length){const g=Yf(n,l),m=["row","col","depth","depth2","depth3"];return`
      ${Hf(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Xf(m,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${r}, ${i})) +
          depth3;
        ${qf(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1];if(p===a&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${r}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===i&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Zh(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${r} +
          depth2 * ${i} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function GAe(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:r}=ul(e);if(i.length<e.length){const m=Yf(n,i),A=["row","col","depth","depth2","depth3","depth4"];return`
      ${Hf(m)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Xf(A,r)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${qf(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=Zh(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function qf(n){const e=n.name,t=ce(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function WAe(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",r=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=XU(n.shapeInfo.logicalShape,e.logicalShape),l=Mn(o),c=o-r;let u;const h=["x","y","z","w","u","v"];r===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(y=>`coords.${h[y+c]} = 0;`).join(`
`);let d="";o<2&&r>0?d="coords":d=n.shapeInfo.logicalShape.map((y,b)=>`coords.${h[b+c]}`).join(", ");let p="return outputValue;";const g=ce(n.shapeInfo.logicalShape)===1,A=ce(e.logicalShape)===1;if(r===1&&!g&&!A)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!A)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const y=r-2,b=r-1;a.indexOf(y)>-1&&a.indexOf(b)>-1?p="return vec4(outputValue.x);":a.indexOf(y)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(b)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${s}(${d});
      ${p}
    }
  `}function HAe(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",r=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&qt(o,r))return`
      float ${i}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Mn(l),u=XU(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const p=["x","y","z","w","u","v"];a===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(g=>`coords.${p[g+h]} = 0;`).join(`
`);let f="";return l<2&&a>0?f="coords":f=n.shapeInfo.logicalShape.map((g,m)=>`coords.${p[m+h]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${s}(${f});
    }
  `}function Mn(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function LB(n,e,t){const{newShape:s,keptDims:i}=ul(e),r=e.length,o=n&&r===3&&e[0]===1,a=o?e.slice(1):s,l=!n&&r>1&&!qt(e,t)&&s.length<r||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:i}}function Yf(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Xf(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qAe(n,e,t,s){const i=t.map((u,h)=>{const d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),r=i.map(u=>u.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=hAe(i,o,e),l=_U(n.gl,a),c=n.createProgram(l);return ae().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:r,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:r,outShapeInfo:o},JU(n,e,c)))}function JU(n,e,t){const s=[],i=[];let r,o,a,l=null,c=null;c=n.getUniformLocation(t,"NAN",!1),ae().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const u=!1;for(const h of e.variableNames){const d={name:h,uniform:n.getUniformLocation(t,h,u),offset:n.getUniformLocation(t,`offset${h}`,u)};e.enableShapeUniforms&&(d.shape=n.getUniformLocation(t,`${h}Shape`,u),d.texShape=n.getUniformLocation(t,`${h}TexShape`,u)),s.push(d)}if(e.enableShapeUniforms&&(r=n.getUniformLocation(t,"outShape",u),a=n.getUniformLocation(t,"outShapeStrides",u),o=n.getUniformLocation(t,"outTexShape",u)),e.customUniforms)for(const h of e.customUniforms)i.push(n.getUniformLocation(t,h.name,u));return{variablesLocations:s,customUniformLocations:i,infLoc:l,nanLoc:c,outShapeLocation:r,outShapeStridesLocation:a,outTexShapeLocation:o}}function bR(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const i=t.logicalShape,r=e[s],o=r.shape;if(!qt(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(t.isUniform&&r.isUniform)return;const a=t.texShape,l=r.isUniform?null:r.texData.texShape;if(!qt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function YAe(n,e,t,s,i){e.program.enableShapeUniforms||(bR(e.inShapeInfos,t),bR([e.outShapeInfo],[s]));const r=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(r.texture,o[0],o[1]):n.setOutputMatrixTexture(r.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),ae().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:u,offset:h,shape:d,texShape:p}=e.variablesLocations[l];if(d){const{uniformShape:f}=LB(e.program.packedInputs,c.shape,c.texData.texShape);switch(f.length){case 1:n.gl.uniform1iv(d,new Int32Array(f));break;case 2:n.gl.uniform2iv(d,new Int32Array(f));break;case 3:n.gl.uniform3iv(d,new Int32Array(f));break;case 4:n.gl.uniform4iv(d,new Int32Array(f));break}}if(p&&n.gl.uniform2i(p,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(ce(c.shape)<2)n.gl.uniform1f(u,c.uniformValues[0]);else{let f=c.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),n.gl.uniform1fv(u,f)}continue}c.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,u,l)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=vt(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&i)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],u=e.customUniformLocations[l],h=i[l];if(c.type==="float")n.gl.uniform1fv(u,h);else if(c.type==="vec2")n.gl.uniform2fv(u,h);else if(c.type==="vec3")n.gl.uniform3fv(u,h);else if(c.type==="vec4")n.gl.uniform4fv(u,h);else if(c.type==="int")n.gl.uniform1iv(u,h);else if(c.type==="ivec2")n.gl.uniform2iv(u,h);else if(c.type==="ivec3")n.gl.uniform3iv(u,h);else if(c.type==="ivec4")n.gl.uniform4iv(u,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function XAe(n,e,t){let s="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=LB(n.packedInputs,o.shape,l);let d="",p="",f="";if(u.length===1&&n.packedInputs){const C=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${C[0]>1}_${C[1]>1}`}else if(u.length===2&&!n.packedInputs)p=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const C=vt(u);f=`${C[0]===l[1]}_${C[C.length-1]===l[1]}`}const g=o.shape.length,m=u.length===2&&qt(o.shape,l),A=ce(o.shape)===1,y=rl(o.shape,t.shape),b=!n.packedInputs&&g===t.shape.length&&qt(l,t.texData.texShape),x=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${g}_${b}_${c?h:""}_${u.length}_${A}_${y}_${m}_${d}_${p}_${f}_${x}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${a}`}});const i=n.userCode;let r=n.constructor.name;return r+="_"+s+"_"+i+`${ae().getNumber("WEBGL_VERSION")}`,r}function Ai(n){return ae().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jAe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Og.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ui();this.outputShape=e,this.enableShapeUniforms=Ai(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Rw(["r","c","d"],e):Jh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KAe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Og.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ui();this.outputShape=e,this.enableShapeUniforms=Ai(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Rw(["r","c","d"],e):Jh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JAe{constructor(e){this.variableNames=["A"],this.outTexUsage=zr.DOWNLOAD;const t=Ui();this.outputShape=e,this.userCode=`
      ${YU}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZAe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=zr.DOWNLOAD;const t=Ui();this.outputShape=e,this.userCode=`
      ${YU}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eye={R:0,G:1,B:2,A:3};class IR{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Ui();this.outputShape=e,this.enableShapeUniforms=Ai(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++){const l=s[a];o+=`
          if(offset == ${a}) {
            result = values[${eye[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?PB():$B(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${o}
        }
        ${i.output} = vec4(${r}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tye{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ui();this.outputShape=e,this.enableShapeUniforms=Ai(this.outputShape.length);let i="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;i+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?PB():$B(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${s.output} = ${r};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZU(n){const e=Ui(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return EU(n,t)}function eQ(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return kU(n,e)}function tQ(n){const e=new Uint16Array([0,1,2,2,1,3]);return MU(n,e)}function Yy(n,e,t,s,i,r){RU(e,t);const o=NU(n),a=n.TEXTURE_2D;return Ze(n,()=>n.bindTexture(a,o)),Ze(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Ze(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Ze(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Ze(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),ae().getNumber("WEBGL_VERSION")===1?Ze(n,()=>n.texImage2D(a,0,s,e,t,0,i,r,null)):Ze(n,()=>n.texStorage2D(a,1,s,e,t)),Ze(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function OB(n){return n.internalFormatFloat}function nQ(n,e,t,s){const[i,r]=qy(e,t);return Yy(n,i,r,OB(s),s.textureFormatFloat,n.FLOAT)}function zB(n){return n.internalFormatHalfFloat}function sQ(n,e,t,s){const[i,r]=qy(e,t);return Yy(n,i,r,zB(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function UB(n){return n.downloadTextureFormat}function iQ(n,e,t,s){const[i,r]=qy(e,t);return Yy(n,i,r,UB(s),n.RGBA,n.UNSIGNED_BYTE)}function QB(n){return n.internalFormatPackedFloat}function rQ(n,e,t,s){const[i,r]=Gf(e,t);return Yy(n,i,r,QB(s),n.RGBA,n.FLOAT)}function VB(n){return n.internalFormatPackedHalfFloat}function oQ(n,e,t,s){const[i,r]=Gf(e,t);return Yy(n,i,r,VB(s),n.RGBA,s.textureTypeHalfFloat)}function aQ(n,e,t){return Ze(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),V1(n,e,"clipSpacePos",t,3,20,0)&&V1(n,e,"uv",t,2,20,12)}function lQ(n,e,t,s,i,r){Ze(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;i instanceof Uint8Array?(o=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*s*4),a=n.FLOAT,l=r.internalFormatPackedFloat),o.set(i),ae().getNumber("WEBGL_VERSION")===2?Ze(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,o)):Ze(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,a,o)),Ze(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function cQ(n,e,t){Ze(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ae().getNumber("WEBGL_VERSION")===2?Ze(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Ze(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ae().getNumber("WEBGL_VERSION")===2?Ze(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Ze(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Ze(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function uQ(n,e,t,s){const i=n.createBuffer();Ze(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const a=4*4*e*t;return Ze(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Ze(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Ze(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function hQ(n,e,t){const s=n,i=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,i),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),i}function dQ(n,e,t,s){const[i,r]=qy(e,t),o=4,a=new Uint8Array(jge(e*t,o));return Ze(n,()=>n.readPixels(0,0,i,r,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function pQ(n,e,t,s,i,r,o,a){const l=n,c=new Float32Array(Kge(r,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function fQ(n,e,t){const s=new Float32Array(e*t*4);return Ze(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}const nye=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:aQ,createBufferFromOutputTexture:uQ,createFloat16MatrixTexture:sQ,createFloat16PackedMatrixTexture:oQ,createFloat32MatrixTexture:nQ,createIndexBuffer:tQ,createPackedMatrixTexture:rQ,createUnsignedBytesMatrixTexture:iQ,createVertexBuffer:eQ,createVertexShader:ZU,downloadByteEncodedFloatMatrixFromOutputTexture:dQ,downloadFloat32MatrixFromBuffer:hQ,downloadMatrixFromPackedOutputTexture:fQ,downloadPackedMatrixFromBuffer:pQ,getInternalFormatForFloat16MatrixTexture:zB,getInternalFormatForFloat16PackedMatrixTexture:VB,getInternalFormatForFloat32MatrixTexture:OB,getInternalFormatForPackedMatrixTexture:QB,getInternalFormatForUnsignedBytesMatrixTexture:UB,uploadDenseMatrixToTexture:lQ,uploadPixelDataToTexture:cQ},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F0{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ae().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,wU(t,e)):this.gl=Uo(t),e=this.gl,ae().getNumber("WEBGL_VERSION")===2){const r=e;this.createVertexArray=()=>Ze(r,()=>r.createVertexArray()),this.bindVertexArray=o=>Ze(r,()=>r.bindVertexArray(o)),this.deleteVertexArray=o=>Ze(r,()=>r.deleteVertexArray(o)),this.getVertexArray=()=>Ze(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){const r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ze(e,()=>r.createVertexArrayOES()),this.bindVertexArray=o=>Ze(e,()=>r.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Ze(e,()=>r.deleteVertexArrayOES(o)),this.getVertexArray=()=>Ze(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ae().getNumber("WEBGL_VERSION")===1){const r="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Pm(this.gl,r),Ur(this.gl,o))this.textureHalfFloatExtension=Pm(this.gl,o);else if(ae().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Ur(this.gl,i))this.colorBufferHalfFloatExtension=Pm(this.gl,i);else if(ae().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Ur(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Ur(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=eQ(this.gl),this.indexBuffer=tQ(this.gl),this.framebuffer=DU(this.gl),this.textureConfig=DB(this.gl,this.textureHalfFloatExtension)}get debug(){return ae().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Ze(e,()=>e.finish()),Ze(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ze(e,()=>e.deleteFramebuffer(this.framebuffer)),Ze(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ze(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ze(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),nQ(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),sQ(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),iQ(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),cQ(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,i){this.throwIfDisposed(),lQ(this.gl,e,t,s,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),oQ(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),rQ(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(G1(this.gl,this.framebuffer),this.outputTexture=null),Ze(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>dQ(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,i,r,o){return pQ(this.gl,e,t,s,i,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return hQ(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const i=uQ(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ae().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=i.clientWaitSync(r,0,0);return o===i.ALREADY_SIGNALED||o===i.CONDITION_SATISFIED},t=r}else ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>fQ(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=ZU(t));const s=TU(t);Ze(t,()=>t.attachShader(s,this.vertexShader)),Ze(t,()=>t.attachShader(s,e)),BU(t,s);const i=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&M0(t,i),i}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Ze(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),aQ(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ze(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&M0(this.gl,this.program),Ze(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?$U(this.gl,e,t):PU(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ze(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),LU(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[i,r]=Gf(t,s);this.setOutputMatrixTextureDriver(e,i,r)}setOutputMatrixWriteRegion(e,t,s,i){this.setOutputMatrixWriteRegionDriver(s,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,s,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&M0(this.gl,this.program),Lm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ze(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ze(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Pm(this.gl,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.createQuery();return s.beginQuery(i.TIME_ELAPSED_EXT,r),r}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await e1(()=>this.disposed||this.isQueryAvailable(e,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),i=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=sye(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ae().platform&&(s=ae().platform.setTimeoutCustom.bind(ae().platform)),e1(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),N0(this.gl,e,this.framebuffer),this.debug&&Lm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(N0(this.gl,this.outputTexture,this.framebuffer),this.debug&&Lm(this.gl)):G1(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const i=this.gl;N0(i,e,this.framebuffer),this.debug&&Lm(i),this.outputTexture=e,Ze(i,()=>i.viewport(0,0,t,s)),Ze(i,()=>i.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,i){this.throwIfDisposed(),Ze(this.gl,()=>this.gl.scissor(e,t,s,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function sye(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:iye,bincountImpl:mQ,bincountReduceImpl:rye,bitwiseAndImpl:oye,castImpl:aye,ceilImpl:lye,concatImpl:cye,equalImpl:uye,expImpl:hye,expm1Impl:dye,floorImpl:pye,gatherNdImpl:fye,gatherV2Impl:mye,greaterImpl:gye,greaterEqualImpl:Aye,lessImpl:yye,lessEqualImpl:xye,linSpaceImpl:bye,logImpl:Iye,maxImpl:Cye,maximumImpl:wye,minimumImpl:vye,multiplyImpl:Sye,negImpl:Eye,notEqualImpl:_ye,prodImpl:Tye,raggedGatherImpl:Bye,raggedRangeImpl:kye,raggedTensorToTensorImpl:Mye,rangeImpl:Nye,rsqrtImpl:Rye,scatterImpl:Dye,sigmoidImpl:Fye,simpleAbsImpl:gQ,sliceImpl:$ye,sparseFillEmptyRowsImpl:Pye,sparseReshapeImpl:Lye,sparseSegmentReductionImpl:AQ,sqrtImpl:Oye,staticRegexReplaceImpl:zye,stridedSliceImpl:Uye,stringNGramsImpl:Qye,stringSplitImpl:Vye,stringToHashBucketFastImpl:Gye,subImpl:Wye,tileImpl:Hye,topKImpl:qye,transposeImpl:GB,uniqueImpl:Yye}=kB;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yQ(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Ni(n,e){return e===1?[n]:yQ(n,e)}function Xye(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jye{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ai(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Ni("rc",this.rank),s=Mn(this.rank),i=this.getOutOfBoundsCondition(t),r=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let r=`${s===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)r=`${e[e.length-1-o]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${i};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xQ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ai(this.outputShape.length);let s="";for(let i=0;i<4;i++){let r="thisRC = rc;";i%2===1&&(r+="thisRC.z += 1;"),i>1&&(r+="thisRC.y += 1;"),s+=`
        ${r}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${Kye(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?PB():$B(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function Kye(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?uAe(["r","c","d"],"inputShape"):Jh(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jye=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const i=wR(t,s),r=vR(e,i,s);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=CR(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[r].pop();return this.usedTextures[r].push(l),l}let a;return i===ni.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===ni.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===ni.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===ni.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===ni.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,s,i){if(this.freeTextures==null)return;const r=wR(s,i),o=vR(t,r,i);o in this.freeTextures||(this.freeTextures[o]=[]);const a=CR(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=ae().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c&&c.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[u]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Zye(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function CR(n,e,t,s,i){const r=exe(e,s);let o;if(i){const[l,c]=Gf(n[0],n[1]);o=l*c}else{const[l,c]=qy(n[0],n[1]);o=l*c}const a=Zye(t,r);return o*a}function exe(n,e){switch(n){case ni.PACKED_2X2_FLOAT32:return QB(e);case ni.PACKED_2X2_FLOAT16:return VB(e);case ni.UNPACKED_FLOAT32:return OB(e);case ni.UNPACKED_FLOAT16:return zB(e);case ni.PACKED_4X1_UNSIGNED_BYTE:return UB(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function txe(n){return ae().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?ni.PACKED_2X2_FLOAT32:ni.UNPACKED_FLOAT32:n?ni.PACKED_2X2_FLOAT16:ni.UNPACKED_FLOAT16}function wR(n,e){if(n===zr.UPLOAD)return ni.PACKED_2X2_FLOAT32;if(n===zr.RENDER||n==null)return txe(e);if(n===zr.DOWNLOAD||n===zr.PIXELS)return ni.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function vR(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ua=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ai(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const mo="if (isnan(x)) return x;",nxe="return x;",SR="return abs(x);",sxe="return (x >= 0.0) ? x : (exp(x) - 1.0);",ixe=mo+`
  return (x < 0.0) ? 0.0 : x;
`,rxe=mo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ml="return x;",oxe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const axe="return x;",lxe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,cxe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uxe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hxe="return 1.0 / (1.0 + exp(-1.0 * x));";class Pl{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ai(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dxe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ai(this.outputShape.length);const t=e.length,s=Ni("rc",t),i=Mn(t),r=Xye(t,s),o=s.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pxe=DC,fxe=1e-7,mxe=1e-4,h0={};function gxe(n){return n in h0||(h0[n]={}),h0[n]}const Axe=ae().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),yxe=600;function xxe(){return ae().global.screen==null?1024:ae().global.screen.height*ae().global.screen.width*window.devicePixelRatio*yxe/1024/1024}class Xy extends uA{nextDataId(){return Xy.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ae().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof F0)t=e;else{const s=Uo(ae().getNumber("WEBGL_VERSION"),e);t=new F0(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Uo(ae().getNumber("WEBGL_VERSION"));t=new F0(s),this.binaryCache=gxe(ae().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Jye(this.gpgpu),this.numMBBeforeWarning=xxe(),this.texData=new WI(this,hi())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,i,r,o){const a=this.makeTensorInfo(t,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[i,r]},l.texShape=[i,r];const c=Om(t),u=new IR(c,!1,o),h=this.runWebGLProgram(u,[a],s,[[i,r]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,s){if((ae().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ae().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:t,dtype:s,values:e,usage:zr.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,i,r){if(ae().getBool("DEBUG")&&this.checkNumericalProblems(t),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:t,usage:zr.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:r,slice:o,shape:a,isPacked:l}=t;if(o!=null){let d;l?d=new Pl(a,Ml):d=new ua(a,Ml);const p=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:i}],i),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return s;const c=this.activeTimers!=null;let u;c&&(u=Zs());let h;if(i==="complex64"){const d=this.readSync(r.real.dataId),p=this.readSync(r.imag.dataId);h=$o(d,p)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Zs()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(g=>f.push(g))}const t=this.texData.get(e),{values:s,shape:i,slice:r,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(r!=null){let f;l?f=new Pl(i,Ml):f=new ua(i,Ml);const g=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:o}],o),m=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),m}if(s!=null)return this.convertAndCacheOnCPU(e);if(ae().getBool("DEBUG")&&!ae().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ae().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&ae().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const f=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...c0(i))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),g=f[0],m=f[1];h=$o(g,m)}else if(c==null)h=this.getValuesFromTexture(e);else{const f=ce(i);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const f=this.gpgpu.gl;Ze(f,()=>f.deleteBuffer(c))}const d=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&hi().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const s=this.texData.get(e),{values:i,shape:r,slice:o,dtype:a,isPacked:l,texture:c}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let p;l?p=new Pl(r,Ml):p=new ua(r,Ml);const f=this.runWebGLProgram(p,[{dataId:e,shape:r,dtype:a}],a),g=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),g}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),h=hi().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>lo(i));return zt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zt(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!vU(s))throw ae().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:i}=this.texData.get(e),r=ce(t);if(ae().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...c0(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(d),f}const o=ae().getBool("WEBGL_PACK")&&i===!0,a=o?Om(t):t,l=o?new ZAe(a):new JAe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:e}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,e();const r=co(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=co(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(r);a.kernelMs=d2(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Zs(),endMs:null}}endTimer(e){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Zs(),e)}async getQueryTime(e){if(ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:i,usage:r,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(t,i,r,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Axe){return ae().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&ce(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Dr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return pxe(e.shape,t)}packedUnaryOp(e,t,s){const i=new Pl(e.shape,t),r=this.compileAndRun(i,[e],s);return hi().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=gQ(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(ae().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,SR,e.dtype);const t=new ua(e.shape,SR),s=this.compileAndRun(t,[e]);return hi().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&To(s[0])){const r=s.map(o=>Ro(o));i=this.write(r,e,t)}else i=this.write(s,e,t);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:t}}makeOutput(e,t,s){return hi().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new dxe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new jye(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[Pu(e.shape),...Lu(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},r=[Pu(t),...Lu(t)],o=new xQ(r,s),a=!0,l=[s],c=this.runWebGLProgram(o,[i],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:i,shape:r,dtype:o}=s;if(t!=null){const d=ce(r),p=t[0]*t[1]*4;R(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Om(r);let l;i?l=new KAe(a):l=new jAe(a);const c=!0,u=[t??c0(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,u,c,t);return{dtype:o,shape:r,dataId:h.dataId}}runWebGLProgram(e,t,s,i,r=!1,o){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Og.DENSE){const A=o??c0(e.outputShape);l.texShape=A.map(y=>y*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),ce(a.shape)===0)return l.values=Cs(a.dtype,0),a;const c=[],u=t.map(A=>{if(A.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(A.dataId);if(y.texture==null){if(!e.packedInputs&&ce(A.shape)<=ae().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:A.shape,texData:null,isUniform:!0,uniformValues:y.values};e.packedInputs&&(y.isPacked=!0,y.shape=A.shape)}if(this.uploadToGPU(A.dataId),!!y.isPacked!=!!e.packedInputs)A=y.isPacked?this.unpackTensor(A):this.packTensor(A),c.push(A),y=this.texData.get(A.dataId);else if(y.isPacked&&!zg(y.shape,A.shape)){const b=A,x=A.shape;A.shape=y.shape,A=this.packedReshape(A,x),c.push(A),y=this.texData.get(A.dataId),b.shape=x}return{shape:A.shape,texData:y,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},d=XAe(e,u,h),p=this.getAndSaveBinary(d,()=>qAe(this.gpgpu,e,u,h)),f=this.activeTimers!=null;let g;f&&(g=this.startTimer()),ae().get("ENGINE_COMPILE_ONLY")||YAe(this.gpgpu,p,u,h,i),c.forEach(A=>this.disposeIntermediateTensorInfo(A)),f&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const m=ae().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const A=Zs();A-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=A)}if(!ae().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&r===!1){const A=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),A}return a}compileAndRun(e,t,s,i,r=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,i,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ae().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=le(()=>{if(!ae().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ae().getBool("DEBUG");ae().set("DEBUG",!1);const t=this.abs(wt(1e-8)).dataSync()[0];if(ae().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?fxe:mxe}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:i,values:r,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=Zs());let h=t.texShape;if(h==null&&(h=UU(s,l),t.texShape=h),r!=null){const d=Om(s);let p,f=h[1],g=h[0];const m=r instanceof Uint8Array||r instanceof Uint8ClampedArray;(l||!m)&&([f,g]=Gf(h[0],h[1])),l?p=new tye(d,m):p=new IR(d,m);const A=m?[g,f]:h,y=this.makeTensorInfo(A,i),b=this.texData.get(y.dataId);m?b.usage=zr.PIXELS:b.usage=zr.UPLOAD,b.texShape=A,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),f,g,r);const x=[[g,f]],w=this.runWebGLProgram(p,[y],i,x,!0),E=this.texData.get(w.dataId);t.texShape=E.texShape,t.isPacked=E.isPacked,t.usage=E.usage,ae().get("ENGINE_COMPILE_ONLY")?this.disposeData(w.dataId):(t.texture=E.texture,t.values=null,this.texData.delete(w.dataId)),this.disposeIntermediateTensorInfo(y),c&&(this.uploadWaitMs+=Zs()-u)}else{const d=this.acquireTexture(h,a,i,l);t.texture=d}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:i}=s;return t!=null&&(s.values=bxe(t,i)),s.values}acquireTexture(e,t,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,i)}computeBytes(e,t){return e[0]*e[1]*vg(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(i=>{try{this.checkCompletion_(t),i(!0)}catch(r){throw r}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await O_(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(FB(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:i,nanLoc:r,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=JU(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=r,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:i,height:r,width:o,channels:a}=e,l=hi().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(i,t,s,r,o,a);return hi().makeTensorFromDataId(c,t,s,l)}}Xy.nextDataId=0;function bxe(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/** @license See the LICENSE file. */const bQ="4.22.0";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IQ(){ae().set("WEBGL_FORCE_F16_TEXTURES",!0)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */y2()&&oC("webgl",()=>new Xy,2);const Ixe={forceHalfFloat:IQ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WB=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let Ou=class{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Mt(t,s),this.enableShapeUniforms=Ai(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ed=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class jf{constructor(e,t,s,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Mt(t,s);const r=this.outputShape.length;this.enableShapeUniforms=Ai(r);let o="";if(i)if(r===0||ce(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Mn(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Ni("coords",r);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Cxe={kernelName:ph,backendName:"webgl",kernelFunc:wr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gc(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(r.dataId),a=wr({inputs:{x:s},backend:t}),l=wr({inputs:{x:i},backend:t});return o.complexTensorInfos={real:a,imag:l},r}const wxe={kernelName:yA,backendName:"webgl",kernelFunc:gc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CQ="return (a < 0.) ? b * a : a;",wQ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function vxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s,o=t.makeTensorInfo([],"float32",hl(r,"float32")),a=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new jf(wQ,i.shape,o.shape):new Ou(CQ,i.shape,o.shape),l=t.runWebGLProgram(a,[i,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const Sxe={kernelName:Xp,backendName:"webgl",kernelFunc:vxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vQ="return (a < 0.) ? b * a : a;",SQ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Exe(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e,r=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new jf(SQ,s.shape,i.shape):new Ou(vQ,s.shape,i.shape);return t.runWebGLProgram(r,[s,i],"float32")}const _xe={kernelName:mf,backendName:"webgl",kernelFunc:Exe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kf="if (isnan(x)) return x;";function pn({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:i,backend:r})=>{const{x:o}=i,a=r,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),d=t(h.values,l);return a.makeTensorInfo(o.shape,l,d)}const c=ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new Pl(o.shape,e):u=new ua(o.shape,n),a.runWebGLProgram(u,[o],l)}}function oi({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:i,dtype:r}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(s&&l.dtype==="complex64"){const f=u.texData.get(l.dataId),g=u.texData.get(c.dataId),[m,A]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(b=>{const[x,C]=b,w={dataId:x.dataId,dtype:x.dtype,shape:l.shape},E={dataId:C.dataId,dtype:C.dtype,shape:c.shape},T=new Ou(n,l.shape,c.shape);return u.runWebGLProgram(T,[w,E],Ns(x.dtype,C.dtype))}),y=gc({inputs:{real:m,imag:A},backend:u});return u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(A),y}const h=r||Ns(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&i!=null){const f=u.texData.get(l.dataId).values,g=u.texData.get(c.dataId).values,m=l.dtype==="string"?Po(f):f,A=l.dtype==="string"?Po(g):g,[y,b]=i(l.shape,c.shape,m,A,h),x=u.makeTensorInfo(b,h),C=u.texData.get(x.dataId);return C.values=y,x}const d=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new jf(e,l.shape,c.shape,t):p=new Ou(n,l.shape,c.shape),u.runWebGLProgram(p,[l,c],h)}}function Ug(n,e=!1){if(n==="linear")return e?axe:nxe;if(n==="relu")return e?cxe:ixe;if(n==="elu")return e?lxe:sxe;if(n==="relu6")return e?uxe:rxe;if(n==="prelu")return e?SQ:vQ;if(n==="leakyrelu")return e?wQ:CQ;if(n==="sigmoid")return e?hxe:oxe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EQ=class{constructor(e,t,s,i=!1,r=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Ai(this.outputShape.length);const u=i?e[1]:e[2],h=Math.ceil(u/2),d=i?"i * 2, rc.y":"rc.y, i * 2",p=r?"rc.z, i * 2":"i * 2, rc.z",f=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",A="";a&&(l?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:m=`vec4 activation(vec4 x) {
          ${a}
        }`,A="result = activation(result);");const y=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${x};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${g[0]});
          result += (${f[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${A}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ER={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let _R=class{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Mt(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TR="return a * b;";function HB(n){const{inputs:e,backend:t}=n,{a:s,b:i}=e,r=Ns(s.dtype,i.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),l=t.texData.get(i.dataId),c=new _R(ER.REAL,s.shape,i.shape),u=new _R(ER.IMAG,s.shape,i.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],d=t.runWebGLProgram(c,h,"float32"),p=t.runWebGLProgram(u,h,"float32"),f=gc({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([s,i])){const a=t.texData.get(s.dataId),l=t.texData.get(i.dataId),[c,u]=Sye(s.shape,i.shape,a.values,l.values,r),h=t.makeTensorInfo(u,r),d=t.texData.get(h.dataId);return d.values=c,h}let o;return ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new jf(TR,s.shape,i.shape):o=new Ou(TR,s.shape,i.shape),t.runWebGLProgram(o,[s,i],r)}const Txe={kernelName:Ch,backendName:"webgl",kernelFunc:HB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bxe(n,e,t){const s=[Pu(n.shape),...Lu(n.shape)],i={dtype:n.dtype,shape:s,dataId:n.dataId},r=[Pu(e),...Lu(e)],o=new xQ(r,s),a=!0,l=[s],c=t.runWebGLProgram(o,[i],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ke(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:r}=s,o=t,a=ce(i.shape),l=qI(r,a),c=ce(l);R(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(i.dataId);return u.isPacked&&!zg(i.shape,l)&&!(u.texture!==null&&zg(u.shape,l))?Bxe(i,l,o):(o.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const kxe={kernelName:Af,backendName:"webgl",kernelFunc:Ke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BR{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:o}=e;this.outputShape=[i,o];const a=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${Cu(h)?h.toPrecision(2):h}, ones);`}let u="";r%s>0&&(u=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Mxe=class{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:o}=e;this.outputShape=[i,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(s/4)*4,h=s%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";r%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${c});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=YC(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function td(n,e,t,s){const i=Nxe(n.shape);let r=n;for(let o=0;o<i.length;o++){const{inSize:a,windowSize:l,outSize:c}=i[o];let u,h;t==="mean"?u=o===0?new BR({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new BR({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):u=new Mxe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),h=r,r=s.runWebGLProgram(u,[r],e),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rxe=class{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const i=Mn(this.rank),r=Dxe(t);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}};function Dxe(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let i=0;i<n.length;i++)s[n[i]]=t[i];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fxe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let u=0;u<s.length;u++)s[u]=e[t[u]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Mn(this.rank),r=yQ("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=r[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${r[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dw(n,e,t){const s=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fxe(n.shape,e):new Rxe(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $xe(n,e,t,s){const i=e,r=n.shape.length,o=Vt(i,n.shape);let a=o;const l=Nn(a,r),c=l!=null;let u=n;c&&(u=Dw(n,l,s),a=Vn(a.length,r)),vs("sum",a,r);const[h,d]=ps(u.shape,a);let p=h;t&&(p=us(h,o));const f=ce(d),m=ce(n.shape)/f,A=Ke({inputs:{x:u},attrs:{shape:[m,f]},backend:s}),y=hy(n.dtype),b=td(A,y,"sum",s),x=Ke({inputs:{x:b},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(b),c&&s.disposeIntermediateTensorInfo(u),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fw(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;return $xe(i,r,o,t)}const Pxe={kernelName:wf,backendName:"webgl",kernelFunc:Fw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{perm:r}=s,o=t,a=i.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=i.shape[r[u]];let c;if(o.shouldExecuteOnCPU([i])){const h=o.texData.get(i.dataId).values,d=GB(h,i.shape,i.dtype,r,l);c=o.makeTensorInfo(l,i.dtype);const p=o.texData.get(c.dataId);p.values=d}else c=Dw(i,r,o);return c}const Lxe={kernelName:Ol,backendName:"webgl",kernelFunc:Pi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Q=1e3;function nI({a:n,b:e,transposeA:t,transposeB:s,backend:i,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],d=s?e.shape[u-1]:e.shape[u-2],p=t?n.shape[c-1]:n.shape[c-2],f=s?e.shape[u-2]:e.shape[u-1],g=n.shape.slice(0,-2),m=e.shape.slice(0,-2),A=ce(g),y=ce(m),x=Mt(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);R(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const C=t?[A,h,p]:[A,p,h],w=s?[y,f,d]:[y,d,f],E=Ke({inputs:{x:n},backend:i,attrs:{shape:C}}),T=Ke({inputs:{x:e},backend:i,attrs:{shape:w}}),v=[E,T],S=Math.max(A,y),_=t?E.shape[1]:E.shape[2],N=r!=null,D=o!=null,P=l==="leakyrelu",L=l!=null?Ug(l,!0):null,z=N||D||P||L!=null;let q;if((p===1||f===1)&&_>_Q&&z===!1){let X=E,te=T;t&&(X=Pi({inputs:{x:E},backend:i,attrs:{perm:[0,2,1]}}),v.push(X)),s&&(te=Pi({inputs:{x:T},backend:i,attrs:{perm:[0,2,1]}}),v.push(te));const se=f!==1,fe=f===1;let me=X;se&&(me=Ke({inputs:{x:X},backend:i,attrs:{shape:[S,_,1]}}),v.push(me));const Te=f===1?2:1;let Ee=te;fe&&(Ee=Ke({inputs:{x:te},backend:i,attrs:{shape:[S,1,_]}}),v.push(Ee));const re=HB({inputs:{a:me,b:Ee},backend:i});q=Fw({inputs:{x:re},backend:i,attrs:{axis:Te,keepDims:!0}}),v.push(re)}else{const X=Ns(n.dtype,e.dtype),te=new EQ(C,w,[S,p,f],t,s,N,L,D,P),se=[E,T];if(r!=null&&se.push(r),D&&se.push(o),P){const fe=i.makeTensorInfo([],"float32",hl(a,"float32"));se.push(fe),v.push(fe)}q=i.runWebGLProgram(te,se,X)}const V=Ke({inputs:{x:q},backend:i,attrs:{shape:x}});v.push(q);for(const X of v)i.disposeIntermediateTensorInfo(X);return V}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oxe(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s;return nI({a:i,b:r,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const zxe={kernelName:ip,backendName:"webgl",kernelFunc:Oxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kR="return abs(x);";function Uxe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const r=t.texData.get(s.dataId),o=gQ(r.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let i;return ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Pl(s.shape,kR):i=new ua(s.shape,kR),t.runWebGLProgram(i,[s],s.dtype)}const Qxe={kernelName:Tp,backendName:"webgl",kernelFunc:Uxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vxe=mo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Gxe=pn({opSnippet:Vxe}),Wxe={kernelName:qu,backendName:"webgl",kernelFunc:Gxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hxe=mo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,qxe=pn({opSnippet:Hxe}),Yxe={kernelName:Yu,backendName:"webgl",kernelFunc:qxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MR="return a + b;",Xxe=oi({opSnippet:MR,packedOpSnippet:MR,supportsComplex:!0,cpuKernelImpl:iye}),jxe={kernelName:cc,backendName:"webgl",kernelFunc:Xxe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kxe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,o)=>`T${o}`);const s=[];this.variableNames.forEach(r=>{s.push(`float v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jxe=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,o)=>`T${o}`);const s=[];this.variableNames.forEach(r=>{s.push(`vec4 v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return wr({inputs:{x:s[0]},backend:t});if(s.length>ae().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=$0({inputs:s.slice(0,l),backend:t}),u=$0({inputs:s.slice(l),backend:t});return $0({inputs:[c,u],backend:t})}const i=s.map(l=>l.dtype).reduce((l,c)=>Ns(l,c)),r=s.map(l=>l.shape),a=ae().getBool("WEBGL_PACK")?new Jxe(s[0].shape,r):new Kxe(s[0].shape,r);return t.runWebGLProgram(a,s,i)}const Zxe={kernelName:Bp,backendName:"webgl",kernelFunc:$0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=Vt(r,i.shape);let c=l;const u=Nn(c,a);let h=i;u!=null&&(h=Pi({inputs:{x:i},backend:t,attrs:{perm:u}}),c=Vn(c.length,a)),vs("all",c,a);const[d,p]=ps(h.shape,c),f=ce(p),g=Ke({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),m=td(g,g.dtype,"all",t);let A;if(o){const y=us(d,l);A=Ke({inputs:{x:m},backend:t,attrs:{shape:y}})}else A=Ke({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),u!=null&&t.disposeIntermediateTensorInfo(h),A}const t0e={kernelName:hA,backendName:"webgl",kernelFunc:e0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=Vt(r,i.shape);let c=l;const u=Nn(c,a);let h=i;u!=null&&(h=Pi({inputs:{x:i},backend:t,attrs:{perm:u}}),c=Vn(c.length,a)),vs("any",c,a);const[d,p]=ps(h.shape,c),f=ce(p),g=Ke({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),m=td(g,g.dtype,"any",t);let A;if(o){const y=us(d,l);A=Ke({inputs:{x:m},backend:t,attrs:{shape:y}})}else A=Ke({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),u!=null&&t.disposeIntermediateTensorInfo(h),A}const s0e={kernelName:dA,backendName:"webgl",kernelFunc:n0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let i0e=class{constructor(e,t,s){this.variableNames=["A"];const{windowSize:i,batchSize:r,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const a=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r0e{constructor(e,t,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,R(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const r=e[e.length-1],o=Math.ceil(r/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),i||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Mn(l),u=Ni("coords",l);let h,d;if(o===1){d=l+1;const T=Mn(d);h=`
        ${T} sourceLocR = ${T}(${u.join()}, 0);
        ++${u[l-1]};
        ${T} sourceLocG = ${T}(${u.join()}, 0);
        ++${u[l-2]};
        ${T} sourceLocA = ${T}(${u.join()}, 0);
        --${u[l-1]};
        ${T} sourceLocB = ${T}(${u.join()}, 0);
        --${u[l-2]};`}else d=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],g=p.map(T=>"int "+T),m=Ni("sourceLocR",d-1).concat("inIdx.r"),A=Ni("sourceLocG",d-1).concat("inIdx.g"),y=Ni("sourceLocB",d-1).concat("inIdx.b"),b=Ni("sourceLocA",d-1).concat("inIdx.a"),x=s==="max"?"greaterThan":"lessThan",C=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${A.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${A.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,E=i?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${E}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${C}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TQ(n,e,t,s=null){let i=e.shape[0],r=e.shape[1];s!=null&&(i=s.shape[0],r=s.shape[1]);const o=YC(r),a={windowSize:o,inSize:r,batchSize:i,outSize:Math.ceil(r/o)},l=new i0e(a,t,s==null),c=[e];s!=null&&c.push(s);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=TQ(n,e,t,u);return n.disposeIntermediateTensorInfo(u),h}function BQ(n,e,t,s=null){const i=s!=null?s.shape:e.shape,r=i[i.length-1],o=YC(r),a=new r0e(i,o,t,s==null),l=s==null?[e]:[e,s],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=BQ(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function kQ(n,e,t,s){const i=[t];if(vs("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,e.shape.length),!ae().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const r=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),r.push(l));const[c,u]=ps(l.shape,i),h=ce(u),d=Ke({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});r.push(d);const p=TQ(n,d,s);r.push(p);const f=Ke({inputs:{x:p},backend:n,attrs:{shape:c}});return r.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}return BQ(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Vt(r,i.shape);const a=Nn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Pi({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Vn(o.length,l.shape.length)),vs("argMax",[o[0]],l.shape.length);const u=kQ(t,l,o[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const a0e={kernelName:kp,backendName:"webgl",kernelFunc:o0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Vt(r,i.shape);const a=Nn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Pi({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Vn(o.length,l.shape.length)),vs("argMin",[o[0]],l.shape.length);const u=kQ(t,l,o[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const c0e={kernelName:Mp,backendName:"webgl",kernelFunc:l0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u0e=mo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,h0e=pn({opSnippet:u0e}),d0e={kernelName:Xu,backendName:"webgl",kernelFunc:h0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p0e=mo+"return log(x + sqrt(x * x + 1.0));",f0e=pn({opSnippet:p0e}),m0e={kernelName:ju,backendName:"webgl",kernelFunc:f0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g0e=mo+`
  return atan(x);
`,A0e=pn({opSnippet:g0e}),y0e={kernelName:Ku,backendName:"webgl",kernelFunc:A0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x0e=WB+`
  return atan(a, b);
`,b0e=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ed+`
  return result;
`,I0e=oi({opSnippet:x0e,packedOpSnippet:b0e}),C0e={kernelName:Zu,backendName:"webgl",kernelFunc:I0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w0e=mo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,v0e=pn({opSnippet:w0e}),S0e={kernelName:Ju,backendName:"webgl",kernelFunc:v0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qg=class{constructor(e,t,s,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,A=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(g||(y="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?r?m:A:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const b="max";let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(x="avgValue / max(count, 1.0)");const C=Math.floor(o/4)*4,w=o%4,E=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${E}
          }

          int xC = xCCorner + ${C};
          if (${w===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${w===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${w===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${E}
          }
        }
        setOutput(${x});
      }
    `}},qB=class{constructor(e,t,s,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,g=e.effectiveFilterWidth,m=e.padInfo.front,A=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b=t==="avg";let x="0.0";if(b||(x="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${m}, ${A}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const C="max";let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");const E=Math.floor(o/4)*4,T=o%4,v=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${m}, ${A}, ${y});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${E}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${v}
            }

            int xC = xCCorner + ${E};
            if (${T===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${v}
            } else if (${T===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${v}
            } else if (${T===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${v}
            }
          }
        }
        setOutput(${w});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;Wf(i,"avgPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;R(Rs(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=mi(i.shape,r,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&qt(u.inShape,u.outShape))return wr({inputs:{x:i},backend:t});const h=new Qg(u,"avg",!1);return t.runWebGLProgram(h,[i],"float32")}const _0e={kernelName:Np,backendName:"webgl",kernelFunc:E0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s,u=[1,1,1],h=Xr(i.shape,r,o,u,a,l,c),d=new qB(h,"avg",!1);return t.runWebGLProgram(d,[i],"float32")}const B0e={kernelName:Rp,backendName:"webgl",kernelFunc:T0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let k0e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,h=c-1-e.padInfo.left,d=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},M0e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=h-1-e.padInfo.front,g=d-1-e.padInfo.top,m=p-1-e.padInfo.left,A=1/(t*s*i);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${g}, ${m});
      const float avgMultiplier = float(${A});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=Xr(o.shape,a,l,h,c,u),p=new M0e(d);return t.runWebGLProgram(p,[i],o.dtype)}const R0e={kernelName:fA,backendName:"webgl",kernelFunc:N0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r;Wf([i,r],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,u=mi(o.shape,a,l,1,c),h=new k0e(u);return t.runWebGLProgram(h,[i],o.dtype)}const F0e={kernelName:pA,backendName:"webgl",kernelFunc:D0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0e(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:o,transposeB:a}=s;return nI({a:i,b:r,transposeA:o,transposeB:a,backend:t})}const P0e={kernelName:Dp,backendName:"webgl",kernelFunc:$0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let L0e=class{constructor(e,t,s,i,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Mt(e,t),Mt(e,s);let a="0.0";i!=null&&(Mt(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";r!=null&&(Mt(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O0e{constructor(e,t,s,i,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Mt(e,t),Mt(e,s);let a="vec4(0.0)";i!=null&&(Mt(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";r!=null&&(Mt(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z0e=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:i,variance:r,offset:o,scale:a}=n;R(i.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[s,i,r];let u=null;o!=null&&(u=o.shape,c.push(o));let h=null;a!=null&&(h=a.shape,c.push(a));const d=ae().getBool("WEBGL_PACK_NORMALIZATION")?new O0e(s.shape,i.shape,r.shape,u,h,l):new L0e(s.shape,i.shape,r.shape,u,h,l);return e.runWebGLProgram(d,c,c[0].dtype)},U0e={kernelName:Hp,backendName:"webgl",kernelFunc:z0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Q0e=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Mn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=V0e(this.rank);let i;const r=e.map((o,a)=>`sourceLoc.${q1[a]} = start[${a}] + coords.${q1[a]};`);i=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${s}));
      }
    `}};const q1=["x","y","z","w","u","v"];function V0e(n){if(n===1)return"sourceLoc";if(n<=6)return q1.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G0e{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Mn(this.rank),s=Ni("coords",this.rank),i=Ni("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,o=`getChannel(getSource(${i.join()}), ${r})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${o};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,h)=>`start[${h}]`).join()});`:e.map((u,h)=>`${i[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e(n,e,t,s){const i=s.texData.get(n.dataId),r=s.makeTensorInfo(t,n.dtype),o=s.texData.get(r.dataId);Object.assign(o,i),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=L_(e,vt(n.shape));i.slice&&(a+=i.slice.flatOffset),o.slice={flatOffset:a,origDataId:i.slice&&i.slice.origDataId||n.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),r}function Jf(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:o}=s,[a,l]=Ry(i,r,o);if(GC(i,a,l),ce(l)===0)return t.makeTensorInfo(l,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||i.dtype==="string"){const h=t.texData.get(i.dataId),d=$ye(h.values,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,d)}const{isPacked:c}=t.texData.get(i.dataId),u=P_(i.shape,a,l);if(c||!u){const h=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new G0e(l):new Q0e(l),d=[a];return t.runWebGLProgram(h,[i],i.dtype,d)}return t.uploadToGPU(i.dataId),W0e(i,a,l,t)}const H0e={kernelName:Cf,backendName:"webgl",kernelFunc:Jf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q0e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:o}=s;R(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=r.reduce((y,b)=>y*b),l=Hh(i.shape,r,a),c=qh(l.length,r.length),u=Yh(i.shape,r,a),h=jC(o,r.length),d=KC(u,o,r.length),p=[],f=Ke({inputs:{x:i},backend:t,attrs:{shape:l}}),g=Pi({inputs:{x:f},backend:t,attrs:{perm:c}}),m=Ke({inputs:{x:g},backend:t,attrs:{shape:u}}),A=Jf({inputs:{x:m},backend:t,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach(y=>t.disposeIntermediateTensorInfo(y)),A},Y0e={kernelName:Fp,backendName:"webgl",kernelFunc:q0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o}=s,a=t.readSync(i.dataId),l=t.readSync(r.dataId),c=mQ(a,l,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,c)}const j0e={kernelName:mA,backendName:"webgl",kernelFunc:X0e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K0e=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,J0e=`
  return float(int(a.r) & int(b.r));
`;function Z0e(n){const{inputs:e,backend:t}=n,{a:s,b:i}=e,r=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=ae().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,i])||o===1){const l=t.texData.get(s.dataId).values,c=t.texData.get(i.dataId).values,[u,h]=oye(s.shape,i.shape,l,c,s.dtype),d=t.makeTensorInfo(h,s.dtype),p=t.texData.get(d.dataId);return p.values=u,d}let a;return r?a=new jf(K0e,s.shape,i.shape,!1):a=new Ou(J0e,s.shape,i.shape),t.runWebGLProgram(a,[s,i],s.dtype)}const ebe={kernelName:gA,backendName:"webgl",kernelFunc:Z0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tbe(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,r=t.readSync(s.dataId),o=t.readSync(i.dataId),a=Mt(Array.from(r),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const nbe={kernelName:AA,backendName:"webgl",kernelFunc:tbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sbe="return float(a != b);",MQ=oi({opSnippet:sbe,cpuKernelImpl:_ye,dtype:"bool"}),ibe={kernelName:uf,backendName:"webgl",kernelFunc:MQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jy(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return wr({inputs:{x:i.complexTensorInfos.real},backend:t})}const rbe={kernelName:qA,backendName:"webgl",kernelFunc:jy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const obe="return float(int(x));";function abe(n,e){const t=new ua(n.shape,obe),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return wr({inputs:{x:i},backend:t});const o=as(i.shape),a=Y1({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=gc({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(i.dtype==="complex64"){const o=jy({inputs:{input:i},backend:t}),a=Y1({inputs:{x:o},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(o),a}if(!YI(i.dtype,r)){const o=wr({inputs:{x:i},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:r}}if(t.shouldExecuteOnCPU([i])){const o=t.texData.get(i.dataId).values,[a,l,c]=aye(o,i.shape,i.dtype,r);return t.makeTensorInfo(a,l,c)}if(r==="int32")return abe(i,t);if(r==="bool"){const o=t.makeTensorInfo([],"bool",Cs("bool",1)),l=MQ({inputs:{a:i,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}const lbe={kernelName:eh,backendName:"webgl",kernelFunc:Y1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NR="return ceil(x);",cbe=pn({opSnippet:NR,packedOpSnippet:NR,cpuKernelImpl:lye}),ube={kernelName:th,backendName:"webgl",kernelFunc:cbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hbe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dbe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{clipValueMin:r,clipValueMax:o}=s;let a;ae().getBool("WEBGL_PACK_CLIP")?a=new dbe(i.shape):a=new hbe(i.shape);const l=[[r],[o]];return t.runWebGLProgram(a,[i],i.dtype,l)}const fbe={kernelName:nh,backendName:"webgl",kernelFunc:pbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mbe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function gbe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=t.texData.get(s.dataId),r=new mbe(s.shape),o=[RR(s,i.complexTensorInfos.real),RR(s,i.complexTensorInfos.imag)];return t.runWebGLProgram(r,o,o[0].dtype)}const Abe={kernelName:$p,backendName:"webgl",kernelFunc:gbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ybe=class{constructor(e){this.outputShape=[],this.outputShape=Zi(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const i=t.length,r=t[t.length-1];s.push(`else setOutput(getT${i}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xbe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Zi(e,t);const s=this.outputShape,i=s.length,r=Mn(i),o=Ni("coords",i),a=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((g,m)=>`T${m}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let g=1;g<l.length;g++)l[g]=l[g-1]+e[g][t];const c=a[t],u=a.slice(-2),h=a.join();let d=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let g=1;g<l.length;g++){const m=l[g-1];d+=`
        if (${c} < ${l[g]}  && ${c} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${d0(a,c,m)}),
            vec2(${d0(u,c,m)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${d0(a,c,f)}),
          vec2(${d0(u,c,f)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${d}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[i-1]} = ${o[i-1]} + 1;
        if (${o[i-1]} < ${s[i-1]}) {
          result.g = getValue(${o});
        }

        ${o[i-2]} = ${o[i-2]} + 1;
        if (${o[i-2]} < ${s[i-2]}) {
          result.a = getValue(${o});
        }

        ${o[i-1]} = ${o[i-1]} - 1;
        if (${o[i-2]} < ${s[i-2]} &&
            ${o[i-1]} < ${s[i-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function d0(n,e,t){const s=n.indexOf(e);return n.map((r,o)=>o===s?`${r} - ${t}`:r).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $w(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return wr({inputs:{x:i.complexTensorInfos.imag},backend:t})}const bbe={kernelName:PA,backendName:"webgl",kernelFunc:$w};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zm(n,e,t){const s=n[0].dtype;if(s==="complex64"){const p=n.map(y=>jy({inputs:{input:y},backend:t})),f=n.map(y=>$w({inputs:{input:y},backend:t})),g=zm(p,e,t),m=zm(f,e,t),A=gc({inputs:{real:g,imag:m},backend:t});return p.forEach(y=>t.disposeIntermediateTensorInfo(y)),f.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),A}let i=t.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const p=n.map(x=>{const w=[-1,ce(x.shape.slice(e))];return Ke({inputs:{x},backend:t,attrs:{shape:w}})}),f=p.map(x=>({vals:t.readSync(x.dataId),shape:x.shape})),g=Zi(p.map(x=>x.shape),1),m=p[0].shape[0]===1,A=cye(f,g,s,m),y=Zi(n.map(x=>x.shape),e),b=t.makeTensorInfo(y,s,A);return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const r=n.filter(p=>ce(p.shape)>0),o=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const p=o?new ua(n[0].shape,Ml):new Pl(n[0].shape,Ml);return t.runWebGLProgram(p,n,s)}const a=ae().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>a){const p=[];for(let g=0;g<r.length;g+=a){const m=r.slice(g,g+a);p.push(zm(m,e,t))}const f=zm(p,e,t);for(const g of p)t.disposeIntermediateTensorInfo(g);return f}if(o){const p=new xbe(r.map(f=>f.shape),e);return t.runWebGLProgram(p,r,s)}const{tensors2D:l,outShape:c}=Ibe(r,e,t),u=new ybe(l.map(p=>p.shape)),h=t.runWebGLProgram(u,l,s);l.forEach(p=>t.disposeIntermediateTensorInfo(p));const d=Ke({inputs:{x:h},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(h),d}function Ibe(n,e,t){const s=Zi(n.map(r=>r.shape),e);return{tensors2D:n.map(r=>Ke({inputs:{x:r},attrs:{shape:[-1,ce(r.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NQ(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=Vt(i,e[0].shape)[0],o=e.map(c=>c.shape);qC(o,r);const a=Zi(e.map(c=>c.shape),r);if(ce(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>ce(c.shape)>0);return l.length===1?wr({inputs:{x:l[0]},backend:t}):zm(l,r,t)}const Cbe={kernelName:Pp,backendName:"webgl",kernelFunc:NQ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RQ{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,m=e.dataFormat==="channelsLast",A=m?1:2,y=m?2:3,b=m?3:1;let x="",C="";s&&(i?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:x=`
          float activation(float x) {
            ${s}
          }
        `,C="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${A}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${C}
        setOutput(result);
      }
    `}}class wbe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DQ{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ai(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<u;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<u;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(h+1)/2;m++){const A=m*2;if(d+=`
           xC = xCCorner + ${A*l};
           `,a===1){if(A<u&&(o%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${A}Ready == 0) {
                   xTexelC${A} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${A}.zw = vec2(0.0);
                   }
                   xTexelC${A}Ready = 1;
                 }
               `,l===1&&A>0?d+=`
                 xC${A} = vec4(xTexelC${A-2}.zw, xTexelC${A}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${A} = vec4(previous.zw, xTexelC${A}.xy);
                   } else {
                     xC${A} = vec4(0.0, 0.0, xTexelC${A}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${A}Ready == 0) {
                   xTexelC${A} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${A}.zw = vec2(0.0);
                   }
                   xTexelC${A}Ready = 1;
                 }

                 xC${A} = xTexelC${A};
                 `,A+1<u)){const y=o%2===0?HI(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${A+1}Ready == 0) {
                     xTexelC${A+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${A+1}.zw = vec2(0.0);
                     }
                     xTexelC${A+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${A+1} = vec4(previous.zw, xTexelC${A+1}.xy);
                     } else {
                      xC${A+1} = vec4(0.0, 0.0, xTexelC${A+1}.xy);
                     }
                     `:d+=`
                     xC${A+1} = vec4(xTexelC${A}.zw, xTexelC${A+1}.xy);
                     `):y===1?d+=`
                     xC${A+1} = xTexelC${A};
                     `:d+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${A+1}Ready == 0) {
                       xTexelC${A+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${A+1}.zw = vec2(0.0);
                       }
                       xTexelC${A+1}Ready = 1;
                     }

                     xC${A+1} = xTexelC${A+1};
                     `}}else A<u&&(o%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${A}Ready == 0) {
                   xTexelC${A} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${A}.zw = vec2(0.0);
                   }
                   xTexelC${A}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${A+1}Ready == 0) {
                   xTexelC${A+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${A+1}.zw = vec2(0.0);
                   }
                   xTexelC${A+1}Ready = 1;
                 }

                 xC${A} = vec4(xTexelC${A}.zw, xTexelC${A+1}.zw);
               `,A+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${A+1} = vec4(xTexelC${A+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${A}Ready == 0) {
                   xTexelC${A} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${A}.zw = vec2(0.0);
                   }
                   xTexelC${A}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${A+1}Ready == 0) {
                   xTexelC${A+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${A+1}.zw = vec2(0.);
                   }
                   xTexelC${A+1}Ready = 1;
                 }

                 xC${A} = vec4(
                   xTexelC${A}.xy, xTexelC${A+1}.xy);
               `,A+1<u&&(d+=`
                   xC${A+1} = vec4(xTexelC${A}.zw, xTexelC${A+1}.zw);
                 `)));A<u&&(d+=`
             wTexel = getW(r, ${A}, d1, d2);
             dotProd += xC${A}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${A}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,A+1<u&&(d+=`
               wTexel = getW(r, ${A+1}, d1, d2);
               dotProd += xC${A+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${A+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";s&&(i?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:r?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vbe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ai(this.outputShape.length);const{dataFormat:s}=t,i=Ui(),r=s==="channelsLast",o=r?1:2,a=r?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sI(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function FQ({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=s.texData.get(n.dataId),u=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,g=!1;let m;const A=[];if(r!=null){const x=sI(r.shape,p);x!=null&&(r=Ke({inputs:{x:r},backend:s,attrs:{shape:x}}),A.push(r))}if(i!=null){const x=sI(i.shape,p);x!=null&&(i=Ke({inputs:{x:i},backend:s,attrs:{shape:x}}),A.push(i))}if(!((h===1||d===1)&&u>_Q)&&c.isPacked&&p&&c.texture!=null&&l[2]%2!==0&&qt(c.shape.slice(-3),l.slice(-3))){const x=l[0]*l[1]*(l[2]+1),C={dataId:n.dataId,shape:[1,x,t.inChannels],dtype:n.dtype},w=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,R(zg(c.shape,C.shape),()=>`packed reshape ${c.shape} to ${C.shape} isn't free`);const E=Ke({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});A.push(E);const T=nI({a:C,b:E,backend:s,transposeA:f,transposeB:g,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o}),v=s.texData.get(T.dataId);R(v.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=w,v.shape=t.outShape,m=wr({inputs:{x:T},backend:s}),m.shape=t.outShape,A.push(T)}else{const x=t.outHeight*t.outWidth,C=Ke({inputs:{x:n},backend:s,attrs:{shape:p?[t.batchSize,x,t.inChannels]:[t.batchSize,t.inChannels,x]}}),w=Ke({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),E=nI({a:p?C:w,b:p?w:C,transposeA:!p,transposeB:g,backend:s,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o});m=Ke({inputs:{x:E},backend:s,attrs:{shape:t.outShape}}),A.push(C),A.push(w),A.push(E)}for(const x of A)s.disposeIntermediateTensorInfo(x);return m}function $Q({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:p}=t,f=p==="channelsLast",g=l*c*u,m=d*h,A=[t.batchSize,g,m],y=!0,b=!1,x=[];if(r!=null){const V=sI(r.shape,f);V!=null&&(r=Ke({inputs:{x:r},backend:s,attrs:{shape:V}}),x.push(r))}if(i!=null){const V=sI(i.shape,f);V!=null&&(i=Ke({inputs:{x:i},backend:s,attrs:{shape:V}}),x.push(i))}const C=Ke({inputs:{x:e},backend:s,attrs:{shape:[1,g,ce(e.shape)/g]}});x.push(C);const w=new vbe(A,t),E=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],T=s.runWebGLProgram(w,[n],"float32",E),v=Ke({inputs:{x:T},backend:s,attrs:{shape:A}});x.push(T),x.push(v);const S=i!=null,_=r!=null,N=a==="leakyrelu",D=a?Ug(a,!0):null,P=new EQ(f?v.shape:C.shape,f?C.shape:v.shape,f?[t.batchSize,m,t.outChannels]:[t.batchSize,t.outChannels,m],y,b,S,D,_,N),L=f?[v,C]:[C,v];if(i&&L.push(i),_&&L.push(r),N){const V=s.makeTensorInfo([],"float32",hl(o,"float32"));L.push(V),x.push(V)}const z=s.runWebGLProgram(P,L,"float32"),q=Ke({inputs:{x:z},backend:s,attrs:{shape:t.outShape}});x.push(z);for(const V of x)s.disposeIntermediateTensorInfo(V);return q}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sbe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s,h=Er(l),d=Qn(i.shape,r.shape,o,c,a,u,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=FQ({x:i,filter:r,convInfo:d,backend:t});else if(d.strideWidth<=2&&h==="channelsLast"&&ae().getBool("WEBGL_EXP_CONV")){const g=new DQ(d),m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=t.runWebGLProgram(g,[i,r],"float32",m)}else if(ae().getBool("WEBGL_CONV_IM2COL"))p=$Q({x:i,filter:r,convInfo:d,backend:t});else{const g=new RQ(d);p=t.runWebGLProgram(g,[i,r],"float32")}const f=Ke({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),f}const Ebe={kernelName:Lp,backendName:"webgl",kernelFunc:Sbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _be=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Tbe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=o?1:2,u=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Bbe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},kbe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=s-1-e.padInfo.top,u=i-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mbe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s,h=Er(l),d=Qn(i.shape,u,o,1,a,c,!1,h),p=new _be(d);return t.runWebGLProgram(p,[i,r],"float32")}const Nbe={kernelName:xA,backendName:"webgl",kernelFunc:Mbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rbe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Ai(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,i=t-1-e.padInfo.top,r=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s,h=Er(c),d=Qn(o,r.shape,a,1,l,u,!1,h);if(ae().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const p=[[d.strideHeight,d.strideWidth]],f=new Rbe(d);return t.runWebGLProgram(f,[i,r],"float32",p)}else{const p=new Tbe(d);return t.runWebGLProgram(p,[i,r],"float32")}}const Fbe={kernelName:Op,backendName:"webgl",kernelFunc:Dbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $be(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=Wo(i.shape,r.shape,o,l,a),u=new wbe(c);return t.runWebGLProgram(u,[i,r],"float32")}const Pbe={kernelName:zp,backendName:"webgl",kernelFunc:$be};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lbe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,filterShape:l}=s,c=Wo(i.shape,l,o,1,a),u=new Bbe(c);return t.runWebGLProgram(u,[i,r],"float32")}const Obe={kernelName:bA,backendName:"webgl",kernelFunc:Lbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zbe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{pad:o,strides:a,inputShape:l}=s,c=Wo(l,r.shape,a,1,o),u=new kbe(c);return t.runWebGLProgram(u,[i,r],"float32")}const Ube={kernelName:IA,backendName:"webgl",kernelFunc:zbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qbe=Kf+`
  return cos(x);
`,Vbe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${ed}
  return result;
`,Gbe=pn({opSnippet:Qbe,packedOpSnippet:Vbe}),Wbe={kernelName:sh,backendName:"webgl",kernelFunc:Gbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hbe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,qbe=pn({opSnippet:Hbe}),Ybe={kernelName:ih,backendName:"webgl",kernelFunc:qbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Xbe=class{constructor(e,t,s,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=t,[h,d]=s;this.outputShape=[u,h,d,c];const p=i==="bilinear"?1:0,[f,g]=[`${a-1}.0`,`${l-1}.0`],[m,A,y]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[b,x,C]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${A};
        float width_scale = ${x};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${C};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jbe=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,u=new Xbe(i.shape,r.shape,a,l,c);return t.runWebGLProgram(u,[i,r,o],"float32")},Kbe={kernelName:wA,backendName:"webgl",kernelFunc:jbe};var Vg;(function(n){n.Prod="*",n.Sum="+"})(Vg||(Vg={}));let DR=class{constructor(e,t,s,i){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,o=this.op===Vg.Prod?"1.0":"0.0",a=s?o:`getX(${FR(r,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";s?(c=i?`end != ${l-1}`:"end != 0",u=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${l}`:"end >= pow2",u=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Mn(r)} coords = getOutputCoords();
        int end = ${$R(r,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${$R(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${FR(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function FR(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function $R(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PQ(n,e,t,s,i,r){const o=e.shape.length,a=Nn([s],o);let l=e;a!=null&&(l=Pi({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=Vn(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const u=l.shape[c];let h=wr({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const p=new DR(n,l.shape,!1,r),f=[[d]],g=h;h=t.runWebGLProgram(p,[h],h.dtype,f),t.disposeIntermediateTensorInfo(g)}if(i){const d=new DR(n,l.shape,i,r),p=h;h=t.runWebGLProgram(d,[h],h.dtype),t.disposeIntermediateTensorInfo(p)}if(a!=null){const d=Sa(a),p=Pi({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),p}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jbe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return PQ(Vg.Prod,i,t,r,o,a)}const Zbe={kernelName:CA,backendName:"webgl",kernelFunc:Jbe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eIe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return PQ(Vg.Sum,i,t,r,o,a)}const tIe={kernelName:Up,backendName:"webgl",kernelFunc:eIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nIe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o,binaryOutput:a}=s;if(i.shape.length===1){const l=t.readSync(i.dataId),c=t.readSync(r.dataId),u=mQ(l,c,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(r),u=rye(l,c,o,a);return t.makeTensorInfo(u.shape,r.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const sIe={kernelName:vA,backendName:"webgl",kernelFunc:nIe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iIe=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rIe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:o}=s,a=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],u=o==="NHWC"?i.shape[3]:i.shape[1],h=l*r,d=c*r,p=u/(r*r),f=o==="NHWC"?[a,h,d,p]:[a,p,h,d],g=new iIe(f,r,o);return t.runWebGLProgram(g,[i],i.dtype)}const oIe={kernelName:SA,backendName:"webgl",kernelFunc:rIe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LQ=class{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ai(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";s&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,u="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OQ{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ai(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,h=e.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let A=0;A<h;A++)p+=`
          vec4 xTexelC${A*2};
          int xTexelC${A*2}Ready;
          vec4 xTexelC${A*2+1};
          int xTexelC${A*2+1}Ready;
          vec4 xC${A};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let A=0;A<h;A++)p+=`
          xTexelC${A*2} = vec4(0.0);
          xTexelC${A*2}Ready = 0;
          xTexelC${A*2+1} = vec4(0.0);
          xTexelC${A*2+1}Ready = 0;
          xC${A} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let A=0;A<(d+1)/2;A++){const y=A*2;if(p+=`
          xC = xCCorner + ${y*c};
          `,l===1){if(y<h&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,c===1&&y>0?p+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<h)){const b=a%2===0?HI(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,c>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:p+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):b===1?p+=`
                    xC${y+1} = xTexelC${y};
                    `:p+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<h&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<h&&(p+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<h&&(p+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<h&&(p+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",g="";s&&(i?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,g="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aIe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;let u=l;u==null&&(u=[1,1]),R(Rs(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=Qn(i.shape,r.shape,o,u,a,c,!0);let d;ae().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new OQ(h):d=new LQ(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[i,r],"float32",p)}const lIe={kernelName:Qp,backendName:"webgl",kernelFunc:aIe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cIe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},uIe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,o=t-1-e.padInfo.top,a=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hIe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s,h=Qn(i.shape,u,o,a,l,c,!0),d=new cIe(h);return t.runWebGLProgram(d,[i,r],"float32")}const dIe={kernelName:EA,backendName:"webgl",kernelFunc:hIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pIe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s,h=Qn(u,r.shape,o,a,l,c,!0),d=new uIe(h);return t.runWebGLProgram(d,[i,r],"float32")}const fIe={kernelName:_A,backendName:"webgl",kernelFunc:pIe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mIe=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gIe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=[...s.shape,...s.shape],r=ce(s.shape),o=Ke({inputs:{x:s},backend:t,attrs:{shape:[r]}}),a=new mIe(r),l=t.runWebGLProgram(a,[o],o.dtype),c=Ke({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const AIe={kernelName:TA,backendName:"webgl",kernelFunc:gIe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yIe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:i,strideHeight:r,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:h,left:d}=i;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${o});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xIe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=dc(i.shape,r.shape,o,a,"NHWC",l);let u;const h=new yIe(c);u=t.runWebGLProgram(h,[i,r],"float32");const d=Ke({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),d}const bIe={kernelName:Vp,backendName:"webgl",kernelFunc:xIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IIe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:o,summedDims:a,idDims:l}=iw(i,r.length);ow(o.length,l,r);const{path:c,steps:u}=aw(a,l),h=u.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const m of u[g]){const{permutationIndices:A,expandDims:y}=rw(p,l[m]);let b;lw(A)?b=r[m]:(b=Pi({inputs:{x:r[m]},backend:t,attrs:{perm:A}}),f.push(b));const x=b.shape.slice();for(let C=0;C<y.length;++C)x.splice(y[C],0,1);qt(b.shape,x)||(b=Ke({inputs:{x:b},backend:t,attrs:{shape:x}}),f.push(b)),d===null?d=b:(d=HB({inputs:{a:b,b:d},backend:t}),f.push(d))}g<h-1&&(c[g]>=0&&(d=Fw({inputs:{x:d},backend:t,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const CIe={kernelName:kA,backendName:"webgl",kernelFunc:IIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wIe="return (x >= 0.0) ? x : (exp(x) - 1.0);",vIe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,SIe=pn({opSnippet:wIe,packedOpSnippet:vIe}),EIe={kernelName:oh,backendName:"webgl",kernelFunc:SIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ie="return (b >= 0.0) ? a : a * (b + 1.0);",TIe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,BIe=n=>{const{inputs:e,backend:t}=n,{dy:s,y:i}=e,r=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new jf(TIe,s.shape,i.shape):new Ou(_Ie,s.shape,i.shape);return t.runWebGLProgram(r,[s,i],s.dtype)},kIe={kernelName:MA,backendName:"webgl",kernelFunc:BIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MIe=`
  return vec4(equal(a, b));
`,NIe="return float(a == b);",RIe=oi({opSnippet:NIe,packedOpSnippet:MIe,dtype:"bool",cpuKernelImpl:uye}),DIe={kernelName:Gp,backendName:"webgl",kernelFunc:RIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FIe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${JC};
  float a1 = ${ZC};
  float a2 = ${ew};
  float a3 = ${tw};
  float a4 = ${nw};
  float a5 = ${sw};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,$Ie=pn({opSnippet:FIe}),PIe={kernelName:ah,backendName:"webgl",kernelFunc:$Ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LIe=Kf+`
  return exp(x);
`,OIe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zQ=pn({opSnippet:LIe,packedOpSnippet:OIe,cpuKernelImpl:hye,dtype:"float32"}),zIe={kernelName:lh,backendName:"webgl",kernelFunc:zQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X1(n){const{inputs:e,attrs:t,backend:s}=n,{dim:i}=t,{input:r}=e,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(R(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Ke({inputs:{x:r},backend:s,attrs:{shape:a}})}const UIe={kernelName:Wp,backendName:"webgl",kernelFunc:X1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PR="return exp(x) - 1.0;",QIe=pn({opSnippet:PR,packedOpSnippet:PR,cpuKernelImpl:dye}),VIe={kernelName:ch,backendName:"webgl",kernelFunc:QIe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LR=class{constructor(e,t,s){this.variableNames=["real","imag"];const i=t[1];this.outputShape=t;const r=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${i}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UQ(n,e,t){const s=t.texData.get(n.dataId),i=ce(n.shape),r=n.shape[n.shape.length-1],o=i/r,a=Ke({inputs:{x:n},backend:t,attrs:{shape:[o,r]}}),l=a.shape,c=new LR("real",l,e),u=new LR("imag",l,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(c,h,"float32"),p=t.runWebGLProgram(u,h,"float32"),f=gc({inputs:{real:d,imag:p},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p);const g=Ke({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(f),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GIe(n){const{inputs:e,backend:t}=n,{input:s}=e;return UQ(s,!1,t)}const WIe={kernelName:NA,backendName:"webgl",kernelFunc:GIe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let HIe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ky(n){const{backend:e,attrs:t}=n,{shape:s,value:i}=t;let{dtype:r}=t;if(r=r||lc(i),r==="string"){const o=ns(r,ce(s));return o.fill(i),e.makeTensorInfo(s,r,o)}else{const o=new HIe(s,i),a=[[i]];return e.runWebGLProgram(o,[],r,a)}}const qIe={kernelName:RA,backendName:"webgl",kernelFunc:Ky};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let YIe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XIe={kernelName:DA,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,i=new YIe(t.shape);return s.runWebGLProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OR="return floor(x);",jIe=pn({opSnippet:OR,packedOpSnippet:OR,cpuKernelImpl:pye}),KIe={kernelName:uh,backendName:"webgl",kernelFunc:jIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JIe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,ZIe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,eCe=oi({opSnippet:JIe,packedOpSnippet:ZIe,dtype:"int32"}),tCe={kernelName:hh,backendName:"webgl",kernelFunc:eCe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nCe=class{constructor(e){this.variableNames=["A"];const t=Ui(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sCe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Ui(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iCe={kernelName:_g,backendName:"webgl",kernelFunc:rCe};let Bd,cS=ae().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function rCe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:i}=e;const{numChannels:r}=s,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[c,l],h=[c,l,r];if(a||o){const g=ae().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Bd==null||g!==cS)&&(cS=g,Bd=document.createElement("canvas").getContext("2d",{willReadFrequently:cS})),Bd.canvas.width=l,Bd.canvas.height=c,Bd.drawImage(i,0,0,l,c),i=Bd.canvas}const d=t.makeTensorInfo(u,"int32");t.texData.get(d.dataId).usage=zr.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),i);const p=ae().getBool("WEBGL_PACK")?new sCe(h):new nCe(h),f=t.runWebGLProgram(p,[d],"int32");return t.disposeData(d.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oCe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,g=Er(u),m=Qn(i.shape,r.shape,l,h,c,d,!1,g);let A;const y=[],b=o!=null,x=a!=null,C=p==="leakyrelu",w=()=>{const T=[i,r],v=(S,_)=>{if(_==="NCHW"&&S.shape.length===1&&S.shape[0]!==1){const N=Ke({inputs:{x:S},backend:t,attrs:{shape:[S.shape[0],1,1]}});return y.push(N),N}return S};if(b&&T.push(v(o,u)),x&&T.push(v(a,u)),C){const S=t.makeTensorInfo([],"float32",hl(f,"float32"));T.push(S),y.push(S)}return T};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))A=FQ({x:i,filter:r,convInfo:m,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else if(m.strideWidth<=2&&g==="channelsLast"&&ae().getBool("WEBGL_EXP_CONV")){const T=p?Ug(p,!0):null,v=new DQ(m,b,T,x,C),S=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],_=w();A=t.runWebGLProgram(v,_,"float32",S)}else if(ae().getBool("WEBGL_CONV_IM2COL"))A=$Q({x:i,filter:r,convInfo:m,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const T=p?Ug(p,!1):null,v=new RQ(m,b,T,x,C),S=w();A=t.runWebGLProgram(v,S,"float32")}const E=Ke({inputs:{x:A},backend:t,attrs:{shape:m.outShape}});return y.push(A),y.forEach(T=>t.disposeIntermediateTensorInfo(T)),E}const aCe={kernelName:rp,backendName:"webgl",kernelFunc:oCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lCe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let g=u;g==null&&(g=[1,1]),R(Rs(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const m=Qn(i.shape,r.shape,l,g,c,h,!0),A=ae().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,y=d?Ug(d,A):null,b=[i,r],x=o!=null,C=a!=null,w=d==="leakyrelu";if(x&&b.push(o),C&&b.push(a),w){const S=t.makeTensorInfo([],"float32",hl(p,"float32"));b.push(S),f.push(S)}let E;A?E=new OQ(m,x,y,C,w):E=new LQ(m,x,y,C,w);const T=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],v=t.runWebGLProgram(E,b,"float32",T);return f.forEach(S=>t.disposeIntermediateTensorInfo(S)),v}const cCe={kernelName:op,backendName:"webgl",kernelFunc:lCe};let uCe=class{constructor(e,t,s,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=s;const r=Mn(s.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hCe(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=i.shape,o=r[r.length-1],a=ce(s.shape),[l,c,u,h]=Ny(s,i),d=Ke({inputs:{x:i},backend:t,attrs:{shape:[c,o]}}),p=Ke({inputs:{x:s},backend:t,attrs:{shape:[ce(s.shape)/u,u]}});if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const A=t.readSync(i.dataId),y=t.bufferSync(s),b=fye(A,y,s.dtype,c,o,u,h,s.shape,a);return t.makeTensorInfo(l,s.dtype,b.values)}const f=new uCe(o,h,[c,u],s.shape),g=t.runWebGLProgram(f,[p,d],p.dtype),m=Ke({inputs:{x:g},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),m}const dCe={kernelName:FA,backendName:"webgl",kernelFunc:hCe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pCe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Mn(this.rank),i=fCe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}};function fCe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n.length;i++)i===2?s.push("index"):s.push(`${t[i]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:o,batchDims:a}=s,l=Vt(o,i.shape)[0];if(ae().get("DEBUG")){const y=t.readSync(r.dataId),b=i.shape[l];for(let x=0;x<y.length;++x){const C=y[x];R(C<=b-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${b-1}]`)}}const c=uw(i,r,l,a),u=ce(r.shape),h=[],d=Ke({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=Ke({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const y=t.bufferSync(p),b=t.bufferSync(d),x=mye(b,y,f);return h.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.makeTensorInfo(c.outputShape,x.dtype,x.values)}const g=new pCe(d.shape,f),m=t.runWebGLProgram(g,[d,p],d.dtype);h.push(m);const A=Ke({inputs:{x:m},backend:t,attrs:{shape:c.outputShape}});return h.forEach(y=>t.disposeIntermediateTensorInfo(y)),A}const mCe={kernelName:qp,backendName:"webgl",kernelFunc:QQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gCe="return float(a > b);",ACe=`
  return vec4(greaterThan(a, b));
`,yCe=oi({opSnippet:gCe,packedOpSnippet:ACe,cpuKernelImpl:gye,dtype:"bool"}),xCe={kernelName:Yp,backendName:"webgl",kernelFunc:yCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bCe="return float(a >= b);",ICe=`
  return vec4(greaterThanEqual(a, b));
`,CCe=oi({opSnippet:bCe,packedOpSnippet:ICe,dtype:"bool",cpuKernelImpl:Aye}),wCe={kernelName:dh,backendName:"webgl",kernelFunc:CCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vCe(n){const{inputs:e,backend:t}=n,{input:s}=e;return UQ(s,!0,t)}const SCe={kernelName:$A,backendName:"webgl",kernelFunc:vCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ECe="return float(!isnan(x) && !isinf(x));",_Ce=pn({opSnippet:ECe,dtype:"bool"}),TCe={kernelName:fh,backendName:"webgl",kernelFunc:_Ce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BCe="return float(isinf(x));",kCe=pn({opSnippet:BCe,dtype:"bool"}),MCe={kernelName:mh,backendName:"webgl",kernelFunc:kCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NCe="return float(isnan(x));",RCe=pn({opSnippet:NCe,dtype:"bool"}),DCe={kernelName:gh,backendName:"webgl",kernelFunc:RCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FCe="return float(a < b);",$Ce=`
  return vec4(lessThan(a, b));
`,PCe=oi({opSnippet:FCe,packedOpSnippet:$Ce,cpuKernelImpl:yye,dtype:"bool"}),LCe={kernelName:jp,backendName:"webgl",kernelFunc:PCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OCe="return float(a <= b);",zCe=`
  return vec4(lessThanEqual(a, b));
`,UCe=oi({opSnippet:OCe,packedOpSnippet:zCe,cpuKernelImpl:xye,dtype:"bool"}),QCe={kernelName:Kp,backendName:"webgl",kernelFunc:UCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VCe(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,o=bye(s,i,r);return e.makeTensorInfo([o.length],"float32",o)}const GCe={kernelName:LA,backendName:"webgl",kernelFunc:VCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WCe=Kf+`
  return x < 0.0 ? 0./0. : log(x);
`,HCe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,qCe=pn({opSnippet:WCe,packedOpSnippet:HCe,cpuKernelImpl:Iye}),YCe={kernelName:Ah,backendName:"webgl",kernelFunc:qCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XCe=Kf+`
  return log(1.0 + x);
`,jCe=pn({opSnippet:XCe}),KCe={kernelName:yh,backendName:"webgl",kernelFunc:jCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JCe="return float(a >= 1.0 && b >= 1.0);",ZCe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,ewe=oi({opSnippet:JCe,packedOpSnippet:ZCe,dtype:"bool"}),twe={kernelName:Jp,backendName:"webgl",kernelFunc:ewe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nwe="return float(!(x >= 1.0));",swe=pn({opSnippet:nwe}),iwe={kernelName:Zp,backendName:"webgl",kernelFunc:swe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rwe="return float(a >= 1.0 || b >= 1.0);",owe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,awe=oi({opSnippet:rwe,packedOpSnippet:owe,dtype:"bool"}),lwe={kernelName:ef,backendName:"webgl",kernelFunc:awe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cwe=class{constructor(e,t,s,i,r){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uwe{constructor(e,t,s,i,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hwe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:o,alpha:a,beta:l}=s,c=ae().getBool("WEBGL_PACK_NORMALIZATION")?new uwe(i.shape,r,o,a,l):new cwe(i.shape,r,o,a,l);return t.runWebGLProgram(c,[i],i.dtype)},dwe={kernelName:tf,backendName:"webgl",kernelFunc:hwe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pwe=class{constructor(e,t,s,i,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=i,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fwe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=s,h=new pwe(i.shape,a,l,c,u);return t.runWebGLProgram(h,[i,r,o],i.dtype)},mwe={kernelName:OA,backendName:"webgl",kernelFunc:fwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gwe(n,e,t,s){const i=ce(e),o=ce(n.shape)/i,a=Ke({inputs:{x:n},attrs:{shape:[o,i]},backend:s}),l=td(a,n.dtype,"max",s),c=Ke({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:o}=s,a=i.shape.length,l=Vt(r,i.shape);let c=l;const u=Nn(c,a),h=u!=null,d=t.shouldExecuteOnCPU([i]);let p=i;if(h){if(d){const b=t.texData.get(p.dataId).values,x=new Array(a);for(let E=0;E<x.length;E++)x[E]=i.shape[u[E]];const C=GB(b,i.shape,i.dtype,u,x);p=t.makeTensorInfo(x,i.dtype);const w=t.texData.get(p.dataId);w.values=C}else p=Dw(i,u,t);c=Vn(c.length,a)}vs("max",c,a);const[f,g]=ps(p.shape,c);let m=f;o&&(m=us(f,l));let A;if(d){const b=t.texData.get(p.dataId).values,x=Cye(b,ce(g),m,i.dtype);A=t.makeTensorInfo(m,i.dtype);const C=t.texData.get(A.dataId);C.values=x}else A=gwe(p,g,m,t);return h&&t.disposeIntermediateTensorInfo(p),A}const Awe={kernelName:nf,backendName:"webgl",kernelFunc:VQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ywe=WB+`
  return max(a, b);
`,xwe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ed+`
  return result;
`,bwe=oi({opSnippet:ywe,packedOpSnippet:xwe,cpuKernelImpl:wye}),Iwe={kernelName:xh,backendName:"webgl",kernelFunc:bwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;Wf(i,"maxPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;R(Rs(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=mi(i.shape,r,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&qt(u.inShape,u.outShape))return wr({inputs:{x:i},backend:t});const h=new Qg(u,"max",!1);return t.runWebGLProgram(h,[i],i.dtype)}const wwe={kernelName:sf,backendName:"webgl",kernelFunc:Cwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],h=Xr(i.shape,r,o,u,a,c,l),d=new qB(h,"max",!1);return t.runWebGLProgram(d,[i],i.dtype)}const Swe={kernelName:rf,backendName:"webgl",kernelFunc:vwe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ewe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=r-1-e.padInfo.top,l=o-1-e.padInfo.left,c=r*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},_we=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=c-1-e.padInfo.top,p=u-1-e.padInfo.left,f=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Twe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=Xr(o.shape,a,l,h,c,u),p=new qB(d,"max",!0),f=t.runWebGLProgram(p,[o],o.dtype),g=new _we(d),m=t.runWebGLProgram(g,[i,f],o.dtype);return t.disposeIntermediateTensorInfo(f),m}const Bwe={kernelName:UA,backendName:"webgl",kernelFunc:Twe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kwe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:o}=e,a=r;Wf([r,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=mi(a.shape,l,c,1,u,h),p=!0,f=new Qg(d,"max",p),g=t.runWebGLProgram(f,[a],a.dtype),m=new Ewe(d),A=t.runWebGLProgram(m,[i,g],a.dtype);return t.disposeIntermediateTensorInfo(g),A}const Mwe={kernelName:zA,backendName:"webgl",kernelFunc:kwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nwe(n,e,t,s){let i=new Qg(t,"max",!1);const r=s.runWebGLProgram(i,[n],"float32");i=new Qg(t,"max",!0,!0,e);const o=s.runWebGLProgram(i,[n],"float32");return[r,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rwe={kernelName:QA,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:a}=e,l=t;R(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];R(Rs(r,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const u=mi(s.shape,i,r,c,o),[h,d]=Nwe(s,a,u,l);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dwe(n,e,t,s){const i=ce(e),o=ce(n.shape)/i,a=Ke({inputs:{x:n},attrs:{shape:[o,i]},backend:s}),l=td(a,"float32","mean",s),c=Ke({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fwe={kernelName:of,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:i,axis:r}=e,o=t,a=s.shape.length,l=Vt(r,s.shape);let c=l;const u=Nn(c,a),h=u!=null,d=o.shouldExecuteOnCPU([s]),p=[];let f=s;if(h){if(d){const x=o.texData.get(f.dataId).values,C=new Array(a);for(let T=0;T<C.length;T++)C[T]=s.shape[u[T]];const w=GB(x,s.shape,s.dtype,u,C);f=o.makeTensorInfo(C,s.dtype);const E=o.texData.get(f.dataId);E.values=w}else f=Dw(s,u,o);p.push(f),c=Vn(c.length,a)}vs("sum",c,a);const[g,m]=ps(f.shape,c);let A=g;i&&(A=us(g,l));const y=Dwe(f,m,A,o);for(const b of p)o.disposeIntermediateTensorInfo(b);return y}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $we(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=Vt(r,i.shape);let c=l;const u=Nn(c,a);let h=i;u!=null&&(h=Pi({inputs:{x:i},backend:t,attrs:{perm:u}}),c=Vn(c.length,i.shape.length)),vs("min",c,a);const[d,p]=ps(h.shape,c),f=ce(p),g=Ke({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),m=td(g,g.dtype,"min",t);let A;if(o){const y=us(d,l);A=Ke({inputs:{x:m},backend:t,attrs:{shape:y}})}else A=Ke({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),u!=null&&t.disposeIntermediateTensorInfo(h),A}const Pwe={kernelName:af,backendName:"webgl",kernelFunc:$we};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lwe=WB+`
  return min(a, b);
`,Owe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ed+`
  return result;
`,zwe=oi({opSnippet:Lwe,packedOpSnippet:Owe,cpuKernelImpl:vye}),Uwe={kernelName:bh,backendName:"webgl",kernelFunc:zwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qwe=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((u,h)=>u[0]+e[h]+u[1]);const i=e.length,r=Mn(i),o=t.map(u=>u[0]).join(","),a=t.map((u,h)=>u[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c=s==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vwe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,g)=>f[0]+e[g]+f[1]);const i=e.length,r=Mn(i),o=t.map(f=>f[0]).join(","),a=t.map((f,g)=>f[0]+e[g]).join(","),l=Ni("rc",i),c=Ni("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,h=i===1?"source":`vec2(${c.slice(-2).join()})`,d=s==="reflect"?0:1;let p="";if(i===1){const f=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${r} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[i-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const f=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${r} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[i-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[i-1]} += 1;
          if(${u}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gwe=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:i,mode:r}=t,o=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vwe(s.shape,i,r):new Qwe(s.shape,i,r);return e.runWebGLProgram(o,[s],s.dtype)},Wwe={kernelName:lf,backendName:"webgl",kernelFunc:Gwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hwe=`if (b == 0.0) return NAN;
  return mod(a, b);`,qwe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+ed+`
  return result;
`,Ywe=oi({opSnippet:Hwe,packedOpSnippet:qwe}),Xwe={kernelName:Ih,backendName:"webgl",kernelFunc:Ywe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jwe=class{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kwe=`
if (a == b) {
  return 1.0;
};
return a / b;`,Jwe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,GQ=oi({opSnippet:Kwe,packedOpSnippet:Jwe,checkOutOfBounds:!0}),Zwe={kernelName:rh,backendName:"webgl",kernelFunc:GQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zR="return a - b;",WQ=oi({opSnippet:zR,packedOpSnippet:zR,supportsComplex:!0,cpuKernelImpl:Wye}),eve={kernelName:Ph,backendName:"webgl",kernelFunc:WQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HQ(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,o=Vt([r],i.shape),a=VQ({inputs:{x:i},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=us(a.shape,o),c=Ke({inputs:{x:a},backend:t,attrs:{shape:l}}),u=WQ({inputs:{a:i,b:c},backend:t}),h=zQ({inputs:{x:u},backend:t}),d=Fw({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),p=Ke({inputs:{x:d},backend:t,attrs:{shape:l}}),f=GQ({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}const tve={kernelName:Ef,backendName:"webgl",kernelFunc:HQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nve(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:o,normalized:a}=s,l=a?i:HQ({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new jwe(c,u,r),d=[[o]],p=t.runWebGLProgram(h,[l],"int32",d);return a||t.disposeIntermediateTensorInfo(l),p}const sve={kernelName:VA,backendName:"webgl",kernelFunc:nve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ive=mo+`
  return -x;
`,rve=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function ove(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const r=t.texData.get(s.dataId),[o,a]=Eye(r.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}let i;return ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Pl(s.shape,rve):i=new ua(s.shape,ive),t.runWebGLProgram(i,[s],s.dtype)}const ave={kernelName:cf,backendName:"webgl",kernelFunc:ove};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lve=ky;function cve(n){Dr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),{selectedIndices:h}=lve(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const uve={kernelName:GA,backendName:"webgl",kernelFunc:cve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hve=zC;function dve(n){Dr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s,u=t.readSync(i.dataId),h=t.readSync(r.dataId),{selectedIndices:d,validOutputs:p}=hve(u,h,o,a,l,c);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const pve={kernelName:jI,backendName:"webgl",kernelFunc:dve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fve=My;function mve(n){Dr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s,u=t.readSync(i.dataId),h=t.readSync(r.dataId),d=o,p=a,f=l,g=c,{selectedIndices:m,selectedScores:A}=fve(u,h,d,p,f,g);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([A.length],"float32",new Float32Array(A))]}const gve={kernelName:WA,backendName:"webgl",kernelFunc:mve};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ave=class{constructor(e,t,s,i){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${s}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yve=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:o,onValue:a,offValue:l}=s,c=ce(i.shape),u=new Ave(c,o,a,l),h=Ke({inputs:{x:i},backend:t,attrs:{shape:[c]}}),d=t.runWebGLProgram(u,[h],r);t.disposeIntermediateTensorInfo(h);const p=[...i.shape,o],f=Ke({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(d),f},xve={kernelName:df,backendName:"webgl",kernelFunc:yve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iI(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const i=jy({inputs:{input:s},backend:t}),r=iI({inputs:{x:i},backend:t}),o=$w({inputs:{input:s},backend:t}),a=iI({inputs:{x:o},backend:t}),l=gc({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return Ky({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const bve={kernelName:Bf,backendName:"webgl",kernelFunc:iI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qQ(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=jy({inputs:{input:s},backend:t}),r=qQ({inputs:{x:i},backend:t}),o=$w({inputs:{input:s},backend:t}),a=iI({inputs:{x:o},backend:t}),l=gc({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return Ky({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const Ive={kernelName:hf,backendName:"webgl",kernelFunc:qQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cve(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return X1({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,o=e[0].dtype;e.forEach(u=>{Xs(r,u.shape,"All tensors passed to stack must have matching shapes"),R(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=X1({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(h),h}),c=NQ({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const wve={kernelName:pf,backendName:"webgl",kernelFunc:Cve};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vve=class{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const i=e.length,r=Mn(i),o=t.map(c=>c[0]).join(","),a=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sve{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,m)=>g[0]+e[m]+g[1]);const i=e.length,r=Mn(i),o=t.map(g=>g[0]).join(","),a=t.map((g,m)=>g[0]+e[m]).join(","),l=Ni("rc",i),c=Ni("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,h=i===1?"source":`vec2(${c.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${u}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${u}) {`],p=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,m=i===1?2:4;g<m;g++)f+=`
        ${d[g]}
        if (${p}) {
          result[${g}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${g}] = getChannel(getX(${c.join()}), ${h});
        }
      `;f+=i===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YQ=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:o}=s;if(ce(i.shape)===0){const c=r.map((u,h)=>u[0]+i.shape[h]+u[1]);return Ky({backend:t,attrs:{shape:c,value:o,dtype:i.dtype}})}const a=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sve(i.shape,r,o):new vve(i.shape,r,o),l=[[o]];return t.runWebGLProgram(a,[i],i.dtype,l)},Eve={kernelName:ff,backendName:"webgl",kernelFunc:YQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ve=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Tve=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+ed+`
  return result;
`,Bve=oi({opSnippet:_ve,packedOpSnippet:Tve}),kve={kernelName:wh,backendName:"webgl",kernelFunc:Bve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mve(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=[],c=Vt(r,i.shape);let u=c;const h=Nn(u,a);let d=i;h!=null&&(d=Pi({inputs:{x:i},backend:t,attrs:{perm:h}}),u=Vn(u.length,a),l.push(d)),vs("prod",u,a);let p;if(t.shouldExecuteOnCPU([d])){const f=t.texData.get(d.dataId).values,{outVals:g,outShape:m,outDtype:A}=Tye(d.shape,d.dtype,f,u);p=t.makeTensorInfo(m,A,g)}else{const[f,g]=ps(d.shape,u),m=ce(g),A=Ke({inputs:{x:d},backend:t,attrs:{shape:[-1,m]}}),y=hy(i.dtype),b=td(A,y,"prod",t);p=Ke({inputs:{x:b},backend:t,attrs:{shape:f}}),l.push(A),l.push(b)}if(o){l.push(p);const f=us(p.shape,c);p=Ke({inputs:{x:p},backend:t,attrs:{shape:f}})}return l.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const Nve={kernelName:gf,backendName:"webgl",kernelFunc:Mve};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rve(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:o}=e,{outputRaggedRank:a}=s,l=i.map(A=>t.readSync(A.dataId)),c=i.map(A=>A.shape),u=t.readSync(r.dataId),h=t.readSync(o.dataId),[d,p,f]=Bye(l,c,u,r.shape,r.dtype,h,o.shape,a),g=d.map(A=>t.makeTensorInfo([A.length],"int32",A)),m=t.makeTensorInfo(f,r.dtype,p);return g.concat([m])}const Dve={kernelName:KI,backendName:"webgl",kernelFunc:Rve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fve(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:r}=e,o=t.readSync(s.dataId),a=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=kye(o,s.shape,s.dtype,a,i.shape,l,r.shape),h=t.makeTensorInfo([c.length],"int32",c),d=t.makeTensorInfo([u.length],s.dtype,u);return[h,d]}const $ve={kernelName:JI,backendName:"webgl",kernelFunc:Fve};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pve(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:r,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),h=t.readSync(o.dataId),d=a.map(m=>t.readSync(m.dataId)),p=a.map(m=>m.shape),[f,g]=Mye(c,i.shape,u,r.shape,r.dtype,h,o.shape,d,p,l);return t.makeTensorInfo(f,r.dtype,g)}const Lve={kernelName:ZI,backendName:"webgl",kernelFunc:Pve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XQ=n=>{const{backend:e,attrs:t}=n,{start:s,stop:i,step:r,dtype:o}=t,a=Nye(s,i,r,o);return e.makeTensorInfo([a.length],o,a)},Ove={kernelName:HA,backendName:"webgl",kernelFunc:XQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zve="return 1.0 / x;",Uve=pn({opSnippet:zve}),Qve={kernelName:vh,backendName:"webgl",kernelFunc:Uve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vve=mo+`
  return (x < 0.0) ? 0.0 : x;
`,Gve=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Wve=pn({opSnippet:Vve,packedOpSnippet:Gve}),Hve={kernelName:Sh,backendName:"webgl",kernelFunc:Wve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qve=mo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Yve=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Xve=pn({opSnippet:qve,packedOpSnippet:Yve}),jve={kernelName:Eh,backendName:"webgl",kernelFunc:Xve};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kve=class{constructor(e,t,s,i,r){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s];let d;r?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jve{constructor(e,t,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s];let d;r?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zve(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s,[l,c]=a,u=ae().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Jve(i.shape,l,c,r,o):new Kve(i.shape,l,c,r,o);return t.runWebGLProgram(u,[i],"float32")}const eSe={kernelName:xf,backendName:"webgl",kernelFunc:Zve};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tSe=class{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,o,a]=e,l=[s&&o>1?i-1:i,s&&a>1?r-1:r],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nSe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,a=new tSe(r.shape,i.shape,o);return t.runWebGLProgram(a,[r],r.dtype)}const sSe={kernelName:XA,backendName:"webgl",kernelFunc:nSe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iSe=class{constructor(e,t,s,i,r){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s],d=i?"0.5":"0.0";let p;r?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rSe{constructor(e,t,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s],d=i?"0.5":"0.0";let p;r?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oSe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s,[l,c]=a,u=ae().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new rSe(i.shape,l,c,r,o):new iSe(i.shape,l,c,r,o);return t.runWebGLProgram(u,[i],i.dtype)}const aSe={kernelName:yf,backendName:"webgl",kernelFunc:oSe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lSe=class{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,o,a]=e,l=[s&&o>1?i-1:i,s&&a>1?r-1:r],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cSe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,a=new lSe(r.shape,i.shape,o);return t.runWebGLProgram(a,[r],r.dtype)}const uSe={kernelName:YA,backendName:"webgl",kernelFunc:cSe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hSe=class{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const i=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,r=e.map((a,l)=>i(l)).join(","),o=Mn(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dSe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const i=Ni("rc",s),r=`${i[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${i[s-2]} + 1 < ${this.outputShape[s-2]}`,a=Mn(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${r}){
            result.g = ${c(i.slice())};
          }
          if(${o}) {
            result.b = ${u(i.slice())};
            if(${r}) {
              result.a = ${h(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function c(f){return f[s-1]="("+f[s-1]+" + 1)",d(f)}function u(f){return f[s-2]="("+f[s-2]+" + 1)",d(f)}function h(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",d(f)}function d(f){const g=e.map((y,b)=>p(b,f)),m=g.join(","),A=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${A}))`}function p(f,g){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${g[f]} - 1`:`${g[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s,o=i.shape.length,a=Vt(r,i.shape);if(o===0)return wr({inputs:{x:i},backend:t});const l=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dSe(i.shape,a):new hSe(i.shape,a);return t.runWebGLProgram(l,[i],i.dtype)}const fSe={kernelName:bf,backendName:"webgl",kernelFunc:pSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mSe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],i=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gSe={kernelName:ly,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=e,a=t,l=new mSe(s.shape,r),[c,u]=XC(o,s.shape[1],s.shape[2]),h=[[c,u,Math.sin(i),Math.cos(i)]];return a.runWebGLProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ASe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,ySe=pn({opSnippet:ASe}),xSe={kernelName:_h,backendName:"webgl",kernelFunc:ySe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bSe="return inversesqrt(x);",ISe=pn({opSnippet:bSe,cpuKernelImpl:Rye}),CSe={kernelName:Th,backendName:"webgl",kernelFunc:ISe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let YB=class{constructor(e,t,s,i,r,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Mn(r.length),u=Mn(o.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let p="";i===1?p="i":i===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let g="";l&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,A=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${r});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${A};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wSe{constructor(e,t,s,i,r,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=Mn(r.length),u=Mn(o.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let p="";i===1?p="i":i===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let g="";l&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,A=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${r});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${A};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vSe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=qo(r,i,o),d=[h/c,c];if(h===0)return t.makeTensorInfo(o,i.dtype);const p=Ke({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),f=Ke({inputs:{x:r},backend:t,attrs:{shape:[l,c]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0]));let m;ae().getBool("WEBGL_PACK")?m=new wSe(l,a,p.shape.length,f.shape.length,u,d):m=new YB(l,a,p.shape.length,f.shape.length,u,d);const A=t.runWebGLProgram(m,[f,p,g],f.dtype),y=Ke({inputs:{x:A},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(g),y}const SSe={kernelName:jA,backendName:"webgl",kernelFunc:vSe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ESe=class{constructor(e,t,s,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const r="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=ae().getNumber("WEBGL_VERSION")===2?r:o,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Se(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:o}=s,a=new ESe(i.shape[0],i.shape[1],r.shape[1],o),l=[[i.shape[1]]];return t.runWebGLProgram(a,[i,r],"int32",l)}const TSe={kernelName:JA,backendName:"webgl",kernelFunc:_Se};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BSe=class{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let i,r;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)r="resRC",i="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);i=l.join(),r=c.join()}const o=Mn(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kSe(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e,o=new BSe(s.shape.length,i.shape,i.shape.length);return t.runWebGLProgram(o,[s,i,r],Ns(i.dtype,r.dtype))}const MSe={kernelName:If,backendName:"webgl",kernelFunc:kSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NSe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Dy};
  float scale = ${Fy};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,RSe=pn({opSnippet:NSe}),DSe={kernelName:Bh,backendName:"webgl",kernelFunc:RSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FSe=Kf+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,$Se=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,PSe=pn({opSnippet:FSe,packedOpSnippet:$Se,cpuKernelImpl:Fye}),LSe={kernelName:Rh,backendName:"webgl",kernelFunc:PSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OSe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,zSe=pn({opSnippet:OSe}),USe={kernelName:Nh,backendName:"webgl",kernelFunc:zSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QSe=Kf+`
  return sin(x);
`,VSe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${ed}
  return result;
`,GSe=pn({opSnippet:QSe,packedOpSnippet:VSe}),WSe={kernelName:kh,backendName:"webgl",kernelFunc:GSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HSe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,qSe=pn({opSnippet:HSe}),YSe={kernelName:Mh,backendName:"webgl",kernelFunc:qSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XSe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,jSe=pn({opSnippet:XSe}),KSe={kernelName:Dh,backendName:"webgl",kernelFunc:jSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JSe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:o}=s;R(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=r.reduce((A,y)=>A*y),l=[[0,0]];l.push(...o);for(let A=1+r.length;A<i.shape.length;++A)l.push([0,0]);const c=[],u=YQ({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),h=Hh(u.shape,r,a,!1),d=qh(h.length,r.length,!1),p=Yh(u.shape,r,a,!1),f=Ke({inputs:{x:u},backend:t,attrs:{shape:h}}),g=Pi({inputs:{x:f},backend:t,attrs:{perm:d}}),m=Ke({inputs:{x:g},backend:t,attrs:{shape:p}});return c.push(u),c.push(f),c.push(g),c.forEach(A=>t.disposeIntermediateTensorInfo(A)),m},ZSe={kernelName:vf,backendName:"webgl",kernelFunc:JSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e1e(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:r,defaultValue:o}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(i.dataId),c=t.readSync(r.dataId),u=t.readSync(o.dataId)[0],[h,d,p,f,g]=Pye(a,s.shape,s.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],i.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const t1e={kernelName:eC,backendName:"webgl",kernelFunc:e1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n1e(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:r}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const o=Array.from(t.readSync(i.dataId)),a=t.readSync(s.dataId),l=Array.from(t.readSync(r.dataId)),[c,u,h]=Lye(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(u,s.dtype,c),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}const s1e={kernelName:tC,backendName:"webgl",kernelFunc:n1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i1e(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${r.shape}`);const o=t.readSync(s.dataId),a=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=AQ(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(u,s.dtype,c)}const r1e={kernelName:ZA,backendName:"webgl",kernelFunc:i1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o1e(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${r.shape}`);const o=t.readSync(s.dataId),a=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=AQ(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(u,s.dtype,c)}const a1e={kernelName:ey,backendName:"webgl",kernelFunc:o1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l1e(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=qo(r,i,a),p=!1;if(r.dtype==="string"){const A=t.bufferSync(i),y=t.bufferSync(r),b=lo(t.readSync(o.dataId)[0]),x=Dye(A,y,a,d,u,c,l,h,b,p);return t.makeTensorInfo(a,x.dtype,x.values)}const f=new YB(c,l,i.shape.length,r.shape.length,h,[d,1],p),g=t.runWebGLProgram(f,[r,i,o],r.dtype),m=Ke({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),m}const c1e={kernelName:ty,backendName:"webgl",kernelFunc:l1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:o}=s,a=Vt(o,i.shape)[0],l=cw(i,r,a),c=i.shape.length,u=new Array(c).fill(0),h=i.shape.slice();return l.map(d=>{const p=[...h];p[a]=d;const f=Jf({inputs:{x:i},backend:t,attrs:{begin:u,size:p}});return u[a]+=d,f})}const h1e={kernelName:Sf,backendName:"webgl",kernelFunc:u1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UR="return sqrt(x);",d1e=pn({opSnippet:UR,packedOpSnippet:UR,cpuKernelImpl:Oye}),p1e={kernelName:Fh,backendName:"webgl",kernelFunc:d1e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f1e="return x * x;",m1e=pn({opSnippet:f1e}),g1e={kernelName:ny,backendName:"webgl",kernelFunc:m1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QR="return (a - b) * (a - b);",A1e=oi({opSnippet:QR,packedOpSnippet:QR}),y1e={kernelName:$h,backendName:"webgl",kernelFunc:A1e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");const r=t.readSync(i.dataId),o=Po(r),a=zye(o,"string",s);return t.makeTensorInfo(i.shape,"string",a)}const b1e={kernelName:sy,backendName:"webgl",kernelFunc:x1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1e({inputs:n,attrs:e,backend:t}){const{x:s}=n,i=mo+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,r=new ua(s.shape,i);return t.runWebGLProgram(r,[s],s.dtype)}const C1e={kernelName:Uh,backendName:"webgl",kernelFunc:I1e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let w1e=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const i=s.length,r=Mn(s.length),o=Mn(s.length);let a="";if(i===1)a="coords * strides + begin";else{let l=0;a=s.map((c,u)=>(l++,s.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:A,begin:y,end:b,strides:x}=HC(i.shape,r,o,a,l,c,u,h,d);let C;if(g)C=Ke({inputs:{x:i},backend:t,attrs:{shape:f}});else if(m||A){R(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const E=WC(y,b,x),T=Jf({inputs:{x:i},backend:t,attrs:{begin:y,size:E}});C=Ke({inputs:{x:T},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(T)}else if(t.shouldExecuteOnCPU([i])){const T=t.readSync(i.dataId),v=zt(i.shape,i.dtype,T),S=Uye(p,v,x,y);C=t.makeTensorInfo(f,i.dtype,S.values)}else{const T=new w1e(y,x,p);C=t.runWebGLProgram(T,[i],i.dtype)}const w=Ke({inputs:{x:C},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(C),w}const S1e={kernelName:iy,backendName:"webgl",kernelFunc:v1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1e(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:h}=e,d=t.readSync(u.dataId),p=t.readSync(h.dataId),[f,g]=Qye(d,p,i,r,o,a,l,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",g)]}const _1e={kernelName:ry,backendName:"webgl",kernelFunc:E1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T1e(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:o}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(r.dataId),l=t.readSync(o.dataId)[0],[c,u,h]=Vye(a,l,i),d=u.length;return[t.makeTensorInfo([d,2],"int32",c),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const B1e={kernelName:nC,backendName:"webgl",kernelFunc:T1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k1e(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(r.dataId),a=Gye(o,i);return t.makeTensorInfo(r.shape,"int32",a)}const M1e={kernelName:sC,backendName:"webgl",kernelFunc:k1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N1e="return tan(x);",R1e=pn({opSnippet:N1e}),D1e={kernelName:Lh,backendName:"webgl",kernelFunc:R1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F1e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,$1e=pn({opSnippet:F1e}),P1e={kernelName:Oh,backendName:"webgl",kernelFunc:$1e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L1e(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:i,indices:r,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=qo(o,r,i.shape),d=[h/c,c];if(h===0)return t.makeTensorInfo(i.shape,r.dtype);const p=Ke({inputs:{x:r},backend:t,attrs:{shape:[l,a]}}),f=Ke({inputs:{x:o},backend:t,attrs:{shape:[l,c]}}),g=Ke({inputs:{x:i},backend:t,attrs:{shape:d}}),m=new YB(l,a,p.shape.length,f.shape.length,u,d,!1,!0),A=t.runWebGLProgram(m,[f,p,g],g.dtype),y=Ke({inputs:{x:A},backend:t,attrs:{shape:i.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(A),y}const O1e={kernelName:KA,backendName:"webgl",kernelFunc:L1e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let z1e=class{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const i=Mn(this.rank),r=U1e(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}};function U1e(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let i=0;i<n.length;i++)s.push(`imod(${t[i]}, ${n[i]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;if(i.dtype==="string"||i.shape.length>5){const l=t.readSync(i.dataId),c=i.dtype==="string"?l.map(d=>lo(d)):l,u=zt(i.shape,i.dtype,c),h=Hye(u,r);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new z1e(i.shape,r);return t.runWebGLProgram(o,[i],i.dtype)}const Q1e={kernelName:zh,backendName:"webgl",kernelFunc:jQ};let V1e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},G1e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fc(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function VR(n){let e=1;for(;e<n;)e*=2;return e}function W1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:o}=s,a=ae().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ae().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([i])||u<a||r>l){const S=t.readSync(i.dataId),[_,N]=qye(S,c,i.dtype,r,o);return[t.makeTensorInfo(_.shape,_.dtype,_.values),t.makeTensorInfo(N.shape,N.dtype,N.values)]}if(r===0)return c[c.length-1]=0,[t.makeTensorInfo(c,i.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[i,Ky({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(i.dataId),d=h!==null&&h.isPacked,p=d?t.unpackTensor(i):i,g=ce(c)/u,m=Ke({inputs:{x:p},attrs:{shape:[g,u]},backend:t});d&&Fc(t,p);const A=VR(r),y=VR(u);let b=null;const x=()=>b===null?[m,m]:[m,b],C=(S,_,N)=>{const D=x(),P=new V1e(N),z=[[u],[b===null?1:0],[Number.NEGATIVE_INFINITY],[S],[_]],q=b;b=t.runWebGLProgram(P,D,"int32",z),Fc(t,q)};for(let S=1;S<A;S*=2){const _=S*2;for(let N=S;N>=1;N/=2)C(_,N,[g,y])}for(let S=y;S>A;S/=2){const _=x(),N=new G1e([g,S/2]),P=[[u],[b===null?1:0],[A]],L=b;b=t.runWebGLProgram(N,_,"int32",P),Fc(t,L);const z=A/2,q=z*2;for(let V=z;V>=1;V/=2)C(q,V,b.shape)}let w=b;b=Jf({inputs:{x:b},backend:t,attrs:{begin:0,size:[g,r]}}),Fc(t,w);let E=QQ({inputs:{x:m,indices:b},backend:t,attrs:{axis:1,batchDims:1}});Fc(t,m);const T=c.slice(0,-1);T.push(r),w=b,b=Ke({inputs:{x:b},attrs:{shape:T},backend:t}),Fc(t,w);const v=E;return E=Ke({inputs:{x:E},attrs:{shape:T},backend:t}),Fc(t,v),[E,b]}const H1e={kernelName:oy,backendName:"webgl",kernelFunc:W1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let q1e=class{constructor(e,t,s,i,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1e(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,transforms:r}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=s,[u,h,d,p]=i.shape,[f,g]=c??[h,d],m=[u,f,g,p],A=new q1e(h,d,o,a,l,m);return t.runWebGLProgram(A,[i,r],"float32")}const X1e={kernelName:ay,backendName:"webgl",kernelFunc:Y1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j1e(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:r}=e;Wf(r,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(r.dataId),{outputValues:a,outputShape:l,indices:c}=Yye(o,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const K1e={kernelName:iC,backendName:"webgl",kernelFunc:j1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1e(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i,a=o.shape.length,l=i.shape[r],c=new Array(a-1);let u=0;for(let g=0;g<a;g++)g!==r&&(c[u++]=o.shape[g]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[r]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[r]=g;const m=Jf({inputs:{x:o},backend:t,attrs:{begin:d,size:p}}),A=Ke({inputs:{x:m},backend:t,attrs:{shape:c}});f[g]=A,h.push(m)}return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const Z1e={kernelName:_f,backendName:"webgl",kernelFunc:J1e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eEe{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,i=e.batchSize,r=e.inSize,o=e.numSegments,a=o*Math.ceil(r/s);this.outputShape=[i,a];const l="0.0",c="sumValue",u=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";r%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let f="";r%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tEe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:o}=s,a=i.shape.length,l=[];let c=0;const u=Nn([c],a);let h=i;u!=null&&(h=Pi({inputs:{x:i},backend:t,attrs:{perm:u}}),l.push(h),c=Vn(1,a)[0]);const d=Q_(h.shape,c,o),p=ce([h.shape[c]]),f=Ke({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(f);const g=hy(i.dtype),m=(x,C,w,E,T)=>{const v=x.shape[0],S=x.shape[1],_=TL(S,T),N={windowSize:_,inSize:S,batchSize:v,numSegments:T},D=new eEe(N,C),P=t.compileAndRun(D,[x,w],E);if(l.push(P),P.shape[1]===T)return P;const L=XQ({backend:t,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),z=jQ({inputs:{x:L},backend:t,attrs:{reps:[S/_]}});return l.push(L),l.push(z),m(P,C,z,E,T)},A=m(f,"unsortedSegmentSum",r,g,o),y=Ke({inputs:{x:A},backend:t,attrs:{shape:d}});let b=y;if(u!=null){l.push(y);const x=Sa(u);b=Pi({inputs:{x:b},backend:t,attrs:{perm:x}})}return l.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const nEe={kernelName:Tf,backendName:"webgl",kernelFunc:tEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sEe=[zxe,Qxe,Wxe,Yxe,jxe,Zxe,t0e,s0e,a0e,c0e,d0e,m0e,y0e,C0e,S0e,_0e,B0e,R0e,F0e,P0e,U0e,Y0e,j0e,ebe,nbe,lbe,ube,fbe,wxe,Abe,Cbe,Ebe,Nbe,Fbe,Pbe,Obe,Ube,Wbe,Ybe,Kbe,Zbe,tIe,sIe,oIe,lIe,dIe,fIe,AIe,bIe,CIe,EIe,kIe,DIe,PIe,zIe,UIe,VIe,WIe,qIe,XIe,KIe,tCe,iCe,aCe,cCe,dCe,mCe,xCe,wCe,Cxe,SCe,bbe,TCe,MCe,DCe,Sxe,LCe,QCe,GCe,YCe,KCe,twe,iwe,lwe,dwe,mwe,Awe,Iwe,wwe,Swe,Bwe,Mwe,Rwe,Fwe,Pwe,Uwe,Wwe,Xwe,sve,Txe,ave,uve,pve,gve,ibe,xve,Ive,wve,Eve,kve,_xe,Nve,Dve,$ve,Lve,Ove,rbe,Zwe,Qve,Hve,jve,kxe,eSe,sSe,aSe,uSe,fSe,gSe,xSe,CSe,SSe,TSe,MSe,DSe,LSe,USe,WSe,YSe,H0e,tve,KSe,ZSe,t1e,s1e,r1e,a1e,c1e,h1e,p1e,g1e,y1e,b1e,C1e,S1e,_1e,B1e,M1e,eve,Pxe,D1e,P1e,O1e,Q1e,H1e,X1e,Lxe,K1e,Z1e,nEe,bve];for(const n of sEe)cy(n);/** @license See the LICENSE file. */const iEe="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rEe={"tfjs-core":rL,"tfjs-backend-cpu":oU,"tfjs-backend-webgl":bQ,"tfjs-data":hz,"tfjs-layers":ww,"tfjs-converter":XO,tfjs:iEe},oEe=Object.freeze(Object.defineProperty({__proto__:null,Abs:Tp,Acos:qu,Acosh:Yu,AdadeltaOptimizer:T_,AdagradOptimizer:B_,AdamOptimizer:k_,AdamaxOptimizer:M_,Add:cc,AddN:Bp,All:hA,Any:dA,ArgMax:kp,ArgMin:Mp,Asin:Xu,Asinh:ju,Atan:Ku,Atan2:Zu,Atanh:Ju,AvgPool:Np,AvgPool3D:Rp,AvgPool3DGrad:fA,AvgPoolGrad:pA,BatchMatMul:Dp,BatchToSpaceND:Fp,Bincount:mA,BitwiseAnd:gA,BroadcastArgs:AA,BroadcastTo:r$,Callback:GO,CallbackList:qL,Cast:eh,Ceil:th,ClipByValue:nh,Complex:yA,ComplexAbs:$p,Concat:Pp,Conv2D:Lp,Conv2DBackpropFilter:xA,Conv2DBackpropInput:Op,Conv3D:zp,Conv3DBackpropFilterV2:bA,Conv3DBackpropInputV2:IA,Cos:sh,Cosh:ih,CropAndResize:wA,Cumprod:CA,Cumsum:Up,CustomCallback:XL,DataStorage:WI,DenseBincount:vA,DepthToSpace:SA,DepthwiseConv2dNative:Qp,DepthwiseConv2dNativeBackpropFilter:EA,DepthwiseConv2dNativeBackpropInput:_A,Diag:TA,Dilation2D:Vp,Dilation2DBackpropFilter:Eg,Dilation2DBackpropInput:Sg,Draw:BA,get ENV(){return f2},EarlyStopping:WO,Einsum:kA,Elu:oh,EluGrad:MA,Environment:s$,Equal:Gp,Erf:ah,Exp:lh,ExpandDims:Wp,Expm1:ch,FFT:NA,Fill:RA,FlipLeftRight:DA,Floor:uh,FloorDiv:hh,FromPixels:_g,FusedBatchNorm:Hp,FusedConv2D:rp,FusedDepthwiseConv2D:op,GPGPUContext:F0,GatherNd:FA,GatherV2:qp,GraphModel:xB,Greater:Yp,GreaterEqual:dh,History:YL,IFFT:$A,Identity:ph,Imag:PA,InputSpec:xs,IsFinite:fh,IsInf:mh,IsNan:gh,KernelBackend:uA,LRN:tf,LRNGrad:OA,LayerVariable:VL,LayersModel:ja,LeakyRelu:Xp,Less:jp,LessEqual:Kp,LinSpace:LA,Log:Ah,Log1p:yh,LogSoftmax:o$,LogicalAnd:Jp,LogicalNot:Zp,LogicalOr:ef,LogicalXor:HX,LowerBound:qX,MathBackendCPU:Wy,MathBackendWebGL:Xy,MatrixBandPart:YX,Max:nf,MaxPool:sf,MaxPool3D:rf,MaxPool3DGrad:UA,MaxPoolGrad:zA,MaxPoolWithArgmax:QA,Maximum:xh,Mean:of,Min:af,Minimum:bh,MirrorPad:lf,Mod:Ih,MomentumOptimizer:N_,Multinomial:VA,Multiply:Ch,Neg:cf,NonMaxSuppressionV3:GA,NonMaxSuppressionV4:jI,NonMaxSuppressionV5:WA,NotEqual:uf,OP_SCOPE_SUFFIX:x2,OneHot:df,OnesLike:hf,Optimizer:fl,OptimizerConstructors:oL,Pack:pf,PadV2:ff,Pool:XX,Pow:wh,Prelu:mf,Prod:gf,RMSPropOptimizer:R_,RNN:Xo,RaggedGather:KI,RaggedRange:JI,RaggedTensorToTensor:ZI,Range:HA,get Rank(){return s1},Real:qA,RealDiv:rh,Reciprocal:vh,get Reduction(){return Mi},Relu:Sh,Relu6:Eh,Reshape:Af,ResizeBilinear:xf,ResizeBilinearGrad:XA,ResizeNearestNeighbor:yf,ResizeNearestNeighborGrad:YA,Reverse:bf,RotateWithOffset:ly,Round:_h,Rsqrt:Th,SGDOptimizer:UC,ScatterNd:jA,SearchSorted:JA,Select:If,Selu:Bh,Sequential:Nu,Sigmoid:Rh,Sign:Nh,Sin:kh,Sinh:Mh,Slice:Cf,Softmax:Ef,Softplus:Dh,SpaceToBatchND:vf,SparseFillEmptyRows:eC,SparseReshape:tC,SparseSegmentMean:ZA,SparseSegmentSum:ey,SparseToDense:ty,SplitV:Sf,Sqrt:Fh,Square:ny,SquaredDifference:$h,StaticRegexReplace:sy,Step:Uh,StridedSlice:iy,StringNGrams:ry,StringSplit:nC,StringToHashBucketFast:sC,Sub:Ph,Sum:wf,SymbolicTensor:zo,Tan:Lh,Tanh:Oh,Tensor:nn,TensorBuffer:Is,TensorScatterUpdate:KA,Tile:zh,TopK:oy,Transform:ay,Transpose:Ol,Unique:iC,Unpack:_f,UnsortedSegmentSum:Tf,UpperBound:jX,Variable:kg,ZerosLike:Bf,_FusedMatMul:ip,abs:As,acos:S2,acosh:E2,add:Be,addN:P$,all:lC,any:Ng,argMax:jl,argMin:_2,asin:T2,asinh:B2,atan:k2,atan2:M2,atanh:N2,avgPool:py,avgPool3d:D2,backend:Yl,backend_util:kL,basicLSTMCell:L$,batchNorm:kf,batchNorm2d:F2,batchNorm3d:$2,batchNorm4d:P2,batchToSpaceND:fy,bincount:L2,bitwiseAnd:O$,booleanMaskAsync:wP,broadcastArgs:z$,broadcastTo:pu,broadcast_util:_J,browser:Gte,buffer:zt,callbacks:ale,cast:We,ceil:O2,clipByValue:Fi,clone:da,complex:sl,concat:Jn,concat1d:z2,concat2d:U2,concat3d:Q2,concat4d:V2,constraints:Hie,conv1d:cC,conv2d:il,conv2dTranspose:uC,conv3d:W2,conv3dTranspose:H2,copyRegisteredKernels:ej,cos:my,cosh:hC,cosineWindow:FC,cumprod:Fg,cumsum:dC,customGrad:ya,data:xue,denseBincount:Pb,deprecationWarn:Rj,depthToSpace:q2,depthwiseConv2d:Mf,deregisterOp:ule,device_util:_j,diag:Q$,dilation2d:Y2,disableDeprecationWarnings:Nj,dispose:Et,disposeVariables:Dj,div:et,divNoNan:X2,dot:j2,dropout:w_,einsum:Gc,elu:Nf,enableDebugMode:Mj,enableProdMode:kj,enclosingPowerOfTwo:v_,engine:hi,ensureShape:V$,env:ae,equal:br,erf:pC,euclideanNorm:J2,exp:fi,expandDims:rs,expm1:Z2,eye:fC,fft:Ty,fill:Qh,findBackend:Lj,findBackendFactory:Oj,floor:Df,floorDiv:aC,forceHalfFloat:IQ,fused:NP,gather:Ff,gatherND:_P,gather_util:Wte,getBackend:vu,getGradient:t1,getKernel:Bg,getKernelsForBackend:Fb,gpgpu_util:nye,grad:u9,grads:h9,greater:zi,greaterEqual:dl,ifft:fp,imag:gy,image:ii,inTopKAsync:TP,initializers:lre,input:cO,io:$_,irfft:BC,isFinite:e_,isInf:t_,isNaN:n_,keep:Ts,kernel_impls:ene,layers:Pae,leakyRelu:Ay,less:up,lessEqual:pc,linalg:__,linspace:H$,loadGraphModel:Du,loadGraphModelSync:Fce,loadLayersModel:Jre,localResponseNormalization:s_,log:Ir,log1p:yy,logSigmoid:i_,logSoftmax:gC,logSumExp:xy,logicalAnd:uo,logicalNot:by,logicalOr:AC,logicalXor:r_,losses:OP,lowerBound:Y$,matMul:tn,math:$te,max:Gr,maxPool:Iy,maxPool3d:o_,maxPoolWithArgmax:X$,maximum:Ea,mean:ts,memory:c1,meshgrid:j$,metrics:ele,min:cp,minimum:ol,mirrorPad:xC,mod:a_,model:toe,models:tle,moments:Cy,movingAverage:vP,mul:K,multiRNNCell:K$,multinomial:J$,neg:zn,nextFrame:O_,norm:Rf,notEqual:Tu,oneHot:hp,ones:Xi,onesLike:Cr,op:Z,outerProduct:Z$,pad:ho,pad1d:eP,pad2d:tP,pad3d:nP,pad4d:sP,pool:l_,pow:Aa,prelu:vy,print:v2,prod:c_,profile:Fj,raggedGather:iP,raggedRange:rP,raggedTensorToTensor:oP,rand:aP,randomGamma:uP,randomNormal:bC,randomStandardNormal:hP,randomUniform:fc,randomUniformInt:dP,range:Bu,ready:w$,real:dp,reciprocal:p_,registerBackend:oC,registerCallbackConstructor:soe,registerGradient:a$,registerKernel:cy,registerOp:cle,regularizers:rle,relu:Ho,relu6:IC,removeBackend:Pj,reshape:ee,reverse:qr,reverse1d:pP,reverse2d:fP,reverse3d:mP,reverse4d:gP,rfft:By,round:CC,rsqrt:wC,scalar:wt,scatterND:SP,scatter_util:mZ,searchSorted:yC,selu:vC,separableConv2d:SC,sequential:noe,serialization:gte,setBackend:C$,setPlatform:zj,setWebGLContext:wU,setdiff1dAsync:AP,shared:kB,sigmoid:yr,sign:f_,signal:LP,sin:EC,sinh:_C,slice:$t,slice1d:Sy,slice2d:TC,slice3d:Ey,slice4d:pp,slice_util:iL,softmax:_y,softplus:Vh,spaceToBatchND:wy,sparse:zP,sparseToDense:EP,spectral:PP,split:Ki,sqrt:Hs,square:vn,squaredDifference:kC,squeeze:mn,stack:$i,step:Gh,stridedSlice:m_,string:UP,sub:nt,sum:ft,sumOutType:hy,tan:g_,tanh:Jl,tensor:Ar,tensor1d:ls,tensor2d:Ji,tensor3d:A_,tensor4d:yP,tensor5d:xP,tensor6d:bP,tensorScatterUpdate:IP,tensor_util:Cj,test_util:T7,tidy:le,tile:Or,time:$j,topk:x_,train:Oc,transpose:on,truncatedNormal:NC,unique:b_,unregisterGradient:ZX,unregisterKernel:JX,unsortedSegmentSum:RC,unstack:Yr,upcastType:Ns,upperBound:CP,util:uj,valueAndGrad:d9,valueAndGrads:p9,variable:I_,variableGrads:q$,version:rEe,version_converter:XO,version_core:rL,version_cpu:oU,version_layers:ww,version_webgl:bQ,webgl:Ixe,webgl_util:lAe,where:Qs,whereAsync:C_,zeros:as,zerosLike:an},Symbol.toStringTag,{value:"Module"}));var uS={},GR;function aEe(){return GR||(GR=1,(function(){var n;function e(I){var B=0;return function(){return B<I.length?{done:!1,value:I[B++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(I,B,M){return I==Array.prototype||I==Object.prototype||(I[B]=M.value),I};function s(I){I=[typeof globalThis=="object"&&globalThis,I,typeof window=="object"&&window,typeof self=="object"&&self,typeof nN=="object"&&nN];for(var B=0;B<I.length;++B){var M=I[B];if(M&&M.Math==Math)return M}throw Error("Cannot find global object")}var i=s(this);function r(I,B){if(B)e:{var M=i;I=I.split(".");for(var F=0;F<I.length-1;F++){var H=I[F];if(!(H in M))break e;M=M[H]}I=I[I.length-1],F=M[I],B=B(F),B!=F&&B!=null&&t(M,I,{configurable:!0,writable:!0,value:B})}}r("Symbol",function(I){function B(j){if(this instanceof B)throw new TypeError("Symbol is not a constructor");return new M(F+(j||"")+"_"+H++,j)}function M(j,Y){this.h=j,t(this,"description",{configurable:!0,writable:!0,value:Y})}if(I)return I;M.prototype.toString=function(){return this.h};var F="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",H=0;return B}),r("Symbol.iterator",function(I){if(I)return I;I=Symbol("Symbol.iterator");for(var B="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),M=0;M<B.length;M++){var F=i[B[M]];typeof F=="function"&&typeof F.prototype[I]!="function"&&t(F.prototype,I,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return I});function o(I){return I={next:I},I[Symbol.iterator]=function(){return this},I}function a(I){var B=typeof Symbol<"u"&&Symbol.iterator&&I[Symbol.iterator];return B?B.call(I):{next:e(I)}}function l(I){if(!(I instanceof Array)){I=a(I);for(var B,M=[];!(B=I.next()).done;)M.push(B.value);I=M}return I}var c=typeof Object.assign=="function"?Object.assign:function(I,B){for(var M=1;M<arguments.length;M++){var F=arguments[M];if(F)for(var H in F)Object.prototype.hasOwnProperty.call(F,H)&&(I[H]=F[H])}return I};r("Object.assign",function(I){return I||c});var u=typeof Object.create=="function"?Object.create:function(I){function B(){}return B.prototype=I,new B},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var d;e:{var p={a:!0},f={};try{f.__proto__=p,d=f.a;break e}catch{}d=!1}h=d?function(I,B){if(I.__proto__=B,I.__proto__!==B)throw new TypeError(I+" is not extensible");return I}:null}var g=h;function m(I,B){if(I.prototype=u(B.prototype),I.prototype.constructor=I,g)g(I,B);else for(var M in B)if(M!="prototype")if(Object.defineProperties){var F=Object.getOwnPropertyDescriptor(B,M);F&&Object.defineProperty(I,M,F)}else I[M]=B[M];I.za=B.prototype}function A(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function y(I){if(I.m)throw new TypeError("Generator is already running");I.m=!0}A.prototype.u=function(I){this.i=I};function b(I,B){I.l={ma:B,na:!0},I.h=I.s||I.v}A.prototype.return=function(I){this.l={return:I},this.h=this.v};function x(I,B,M){return I.h=M,{value:B}}function C(I){this.h=new A,this.i=I}function w(I,B){y(I.h);var M=I.h.j;return M?E(I,"return"in M?M.return:function(F){return{value:F,done:!0}},B,I.h.return):(I.h.return(B),T(I))}function E(I,B,M,F){try{var H=B.call(I.h.j,M);if(!(H instanceof Object))throw new TypeError("Iterator result "+H+" is not an object");if(!H.done)return I.h.m=!1,H;var j=H.value}catch(Y){return I.h.j=null,b(I.h,Y),T(I)}return I.h.j=null,F.call(I.h,j),T(I)}function T(I){for(;I.h.h;)try{var B=I.i(I.h);if(B)return I.h.m=!1,{value:B.value,done:!1}}catch(M){I.h.i=void 0,b(I.h,M)}if(I.h.m=!1,I.h.l){if(B=I.h.l,I.h.l=null,B.na)throw B.ma;return{value:B.return,done:!0}}return{value:void 0,done:!0}}function v(I){this.next=function(B){return y(I.h),I.h.j?B=E(I,I.h.j.next,B,I.h.u):(I.h.u(B),B=T(I)),B},this.throw=function(B){return y(I.h),I.h.j?B=E(I,I.h.j.throw,B,I.h.u):(b(I.h,B),B=T(I)),B},this.return=function(B){return w(I,B)},this[Symbol.iterator]=function(){return this}}function S(I){function B(F){return I.next(F)}function M(F){return I.throw(F)}return new Promise(function(F,H){function j(Y){Y.done?F(Y.value):Promise.resolve(Y.value).then(B,M).then(j,H)}j(I.next())})}function _(I){return S(new v(new C(I)))}r("Promise",function(I){function B(Y){this.i=0,this.j=void 0,this.h=[],this.u=!1;var oe=this.l();try{Y(oe.resolve,oe.reject)}catch(Ie){oe.reject(Ie)}}function M(){this.h=null}function F(Y){return Y instanceof B?Y:new B(function(oe){oe(Y)})}if(I)return I;M.prototype.i=function(Y){if(this.h==null){this.h=[];var oe=this;this.j(function(){oe.m()})}this.h.push(Y)};var H=i.setTimeout;M.prototype.j=function(Y){H(Y,0)},M.prototype.m=function(){for(;this.h&&this.h.length;){var Y=this.h;this.h=[];for(var oe=0;oe<Y.length;++oe){var Ie=Y[oe];Y[oe]=null;try{Ie()}catch(ze){this.l(ze)}}}this.h=null},M.prototype.l=function(Y){this.j(function(){throw Y})},B.prototype.l=function(){function Y(ze){return function(Je){Ie||(Ie=!0,ze.call(oe,Je))}}var oe=this,Ie=!1;return{resolve:Y(this.I),reject:Y(this.m)}},B.prototype.I=function(Y){if(Y===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(Y instanceof B)this.L(Y);else{e:switch(typeof Y){case"object":var oe=Y!=null;break e;case"function":oe=!0;break e;default:oe=!1}oe?this.F(Y):this.s(Y)}},B.prototype.F=function(Y){var oe=void 0;try{oe=Y.then}catch(Ie){this.m(Ie);return}typeof oe=="function"?this.M(oe,Y):this.s(Y)},B.prototype.m=function(Y){this.v(2,Y)},B.prototype.s=function(Y){this.v(1,Y)},B.prototype.v=function(Y,oe){if(this.i!=0)throw Error("Cannot settle("+Y+", "+oe+"): Promise already settled in state"+this.i);this.i=Y,this.j=oe,this.i===2&&this.K(),this.H()},B.prototype.K=function(){var Y=this;H(function(){if(Y.D()){var oe=i.console;typeof oe<"u"&&oe.error(Y.j)}},1)},B.prototype.D=function(){if(this.u)return!1;var Y=i.CustomEvent,oe=i.Event,Ie=i.dispatchEvent;return typeof Ie>"u"?!0:(typeof Y=="function"?Y=new Y("unhandledrejection",{cancelable:!0}):typeof oe=="function"?Y=new oe("unhandledrejection",{cancelable:!0}):(Y=i.document.createEvent("CustomEvent"),Y.initCustomEvent("unhandledrejection",!1,!0,Y)),Y.promise=this,Y.reason=this.j,Ie(Y))},B.prototype.H=function(){if(this.h!=null){for(var Y=0;Y<this.h.length;++Y)j.i(this.h[Y]);this.h=null}};var j=new M;return B.prototype.L=function(Y){var oe=this.l();Y.T(oe.resolve,oe.reject)},B.prototype.M=function(Y,oe){var Ie=this.l();try{Y.call(oe,Ie.resolve,Ie.reject)}catch(ze){Ie.reject(ze)}},B.prototype.then=function(Y,oe){function Ie(Bt,ct){return typeof Bt=="function"?function(Qt){try{ze(Bt(Qt))}catch(rn){Je(rn)}}:ct}var ze,Je,Ut=new B(function(Bt,ct){ze=Bt,Je=ct});return this.T(Ie(Y,ze),Ie(oe,Je)),Ut},B.prototype.catch=function(Y){return this.then(void 0,Y)},B.prototype.T=function(Y,oe){function Ie(){switch(ze.i){case 1:Y(ze.j);break;case 2:oe(ze.j);break;default:throw Error("Unexpected state: "+ze.i)}}var ze=this;this.h==null?j.i(Ie):this.h.push(Ie),this.u=!0},B.resolve=F,B.reject=function(Y){return new B(function(oe,Ie){Ie(Y)})},B.race=function(Y){return new B(function(oe,Ie){for(var ze=a(Y),Je=ze.next();!Je.done;Je=ze.next())F(Je.value).T(oe,Ie)})},B.all=function(Y){var oe=a(Y),Ie=oe.next();return Ie.done?F([]):new B(function(ze,Je){function Ut(Qt){return function(rn){Bt[Qt]=rn,ct--,ct==0&&ze(Bt)}}var Bt=[],ct=0;do Bt.push(void 0),ct++,F(Ie.value).T(Ut(Bt.length-1),Je),Ie=oe.next();while(!Ie.done)})},B});function N(I,B){I instanceof String&&(I+="");var M=0,F=!1,H={next:function(){if(!F&&M<I.length){var j=M++;return{value:B(j,I[j]),done:!1}}return F=!0,{done:!0,value:void 0}}};return H[Symbol.iterator]=function(){return H},H}r("Array.prototype.keys",function(I){return I||function(){return N(this,function(B){return B})}}),r("Array.prototype.fill",function(I){return I||function(B,M,F){var H=this.length||0;for(0>M&&(M=Math.max(0,H+M)),(F==null||F>H)&&(F=H),F=Number(F),0>F&&(F=Math.max(0,H+F)),M=Number(M||0);M<F;M++)this[M]=B;return this}});function D(I){return I||Array.prototype.fill}r("Int8Array.prototype.fill",D),r("Uint8Array.prototype.fill",D),r("Uint8ClampedArray.prototype.fill",D),r("Int16Array.prototype.fill",D),r("Uint16Array.prototype.fill",D),r("Int32Array.prototype.fill",D),r("Uint32Array.prototype.fill",D),r("Float32Array.prototype.fill",D),r("Float64Array.prototype.fill",D),r("Object.is",function(I){return I||function(B,M){return B===M?B!==0||1/B===1/M:B!==B&&M!==M}}),r("Array.prototype.includes",function(I){return I||function(B,M){var F=this;F instanceof String&&(F=String(F));var H=F.length;for(M=M||0,0>M&&(M=Math.max(M+H,0));M<H;M++){var j=F[M];if(j===B||Object.is(j,B))return!0}return!1}}),r("String.prototype.includes",function(I){return I||function(B,M){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(B instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(B,M||0)!==-1}});var P=this||self;function L(I,B){I=I.split(".");var M=P;I[0]in M||typeof M.execScript>"u"||M.execScript("var "+I[0]);for(var F;I.length&&(F=I.shift());)I.length||B===void 0?M[F]&&M[F]!==Object.prototype[F]?M=M[F]:M=M[F]={}:M[F]=B}function z(I){var B;e:{if((B=P.navigator)&&(B=B.userAgent))break e;B=""}return B.indexOf(I)!=-1}var q=Array.prototype.map?function(I,B){return Array.prototype.map.call(I,B,void 0)}:function(I,B){for(var M=I.length,F=Array(M),H=typeof I=="string"?I.split(""):I,j=0;j<M;j++)j in H&&(F[j]=B.call(void 0,H[j],j,I));return F},V={},X=null;function te(I){var B=I.length,M=3*B/4;M%3?M=Math.floor(M):"=.".indexOf(I[B-1])!=-1&&(M="=.".indexOf(I[B-2])!=-1?M-2:M-1);var F=new Uint8Array(M),H=0;return se(I,function(j){F[H++]=j}),H!==M?F.subarray(0,H):F}function se(I,B){function M(Ie){for(;F<I.length;){var ze=I.charAt(F++),Je=X[ze];if(Je!=null)return Je;if(!/^[\s\xa0]*$/.test(ze))throw Error("Unknown base64 encoding at char: "+ze)}return Ie}fe();for(var F=0;;){var H=M(-1),j=M(0),Y=M(64),oe=M(64);if(oe===64&&H===-1)break;B(H<<2|j>>4),Y!=64&&(B(j<<4&240|Y>>2),oe!=64&&B(Y<<6&192|oe))}}function fe(){if(!X){X={};for(var I="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),B=["+/=","+/","-_=","-_.","-_"],M=0;5>M;M++){var F=I.concat(B[M].split(""));V[M]=F;for(var H=0;H<F.length;H++){var j=F[H];X[j]===void 0&&(X[j]=H)}}}}var me=typeof Uint8Array<"u",Te=!(z("Trident")||z("MSIE"))&&typeof P.btoa=="function";function Ee(I){if(!Te){var B;B===void 0&&(B=0),fe(),B=V[B];for(var M=Array(Math.floor(I.length/3)),F=B[64]||"",H=0,j=0;H<I.length-2;H+=3){var Y=I[H],oe=I[H+1],Ie=I[H+2],ze=B[Y>>2];Y=B[(Y&3)<<4|oe>>4],oe=B[(oe&15)<<2|Ie>>6],Ie=B[Ie&63],M[j++]=ze+Y+oe+Ie}switch(ze=0,Ie=F,I.length-H){case 2:ze=I[H+1],Ie=B[(ze&15)<<2]||F;case 1:I=I[H],M[j]=B[I>>2]+B[(I&3)<<4|ze>>4]+Ie+F}return M.join("")}for(B="";10240<I.length;)B+=String.fromCharCode.apply(null,I.subarray(0,10240)),I=I.subarray(10240);return B+=String.fromCharCode.apply(null,I),btoa(B)}var re=RegExp("[-_.]","g");function ue(I){switch(I){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function _e(I){if(!Te)return te(I);re.test(I)&&(I=I.replace(re,ue)),I=atob(I);for(var B=new Uint8Array(I.length),M=0;M<I.length;M++)B[M]=I.charCodeAt(M);return B}var ke;function Ne(){return ke||(ke=new Uint8Array(0))}var Ue={},ht=typeof Uint8Array.prototype.slice=="function",W=0,Ce=0;function be(I){var B=0>I;I=Math.abs(I);var M=I>>>0;I=Math.floor((I-M)/4294967296),B&&(M=a(ye(M,I)),B=M.next().value,I=M.next().value,M=B),W=M>>>0,Ce=I>>>0}var ge=typeof BigInt=="function";function ye(I,B){return B=~B,I?I=~I+1:B+=1,[I,B]}function Re(I,B){this.i=I>>>0,this.h=B>>>0}function De(I){if(!I)return Me||(Me=new Re(0,0));if(!/^-?\d+$/.test(I))return null;if(16>I.length)be(Number(I));else if(ge)I=BigInt(I),W=Number(I&BigInt(4294967295))>>>0,Ce=Number(I>>BigInt(32)&BigInt(4294967295));else{var B=+(I[0]==="-");Ce=W=0;for(var M=I.length,F=B,H=(M-B)%6+B;H<=M;F=H,H+=6)F=Number(I.slice(F,H)),Ce*=1e6,W=1e6*W+F,4294967296<=W&&(Ce+=W/4294967296|0,W%=4294967296);B&&(B=a(ye(W,Ce)),I=B.next().value,B=B.next().value,W=I,Ce=B)}return new Re(W,Ce)}var Me;function Tt(I,B){return Error("Invalid wire type: "+I+" (at position "+B+")")}function At(){return Error("Failed to read varint, encoding is invalid.")}function G(I,B){return Error("Tried to read past the end of the data "+B+" > "+I)}function $(){throw Error("Invalid UTF8")}function de(I,B){return B=String.fromCharCode.apply(null,B),I==null?B:I+B}var xe=void 0,Fe,ve=typeof TextDecoder<"u",ut,He=typeof TextEncoder<"u",pt;function yt(I){if(I!==Ue)throw Error("illegal external caller")}function Oe(I,B){if(yt(B),this.V=I,I!=null&&I.length===0)throw Error("ByteString should be constructed with non-empty values")}function tt(){return pt||(pt=new Oe(null,Ue))}function Nt(I){yt(Ue);var B=I.V;return B=B==null||me&&B!=null&&B instanceof Uint8Array?B:typeof B=="string"?_e(B):null,B==null?B:I.V=B}function _t(I){if(typeof I=="string")return{buffer:_e(I),C:!1};if(Array.isArray(I))return{buffer:new Uint8Array(I),C:!1};if(I.constructor===Uint8Array)return{buffer:I,C:!1};if(I.constructor===ArrayBuffer)return{buffer:new Uint8Array(I),C:!1};if(I.constructor===Oe)return{buffer:Nt(I)||Ne(),C:!0};if(I instanceof Uint8Array)return{buffer:new Uint8Array(I.buffer,I.byteOffset,I.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function st(I,B){this.i=null,this.m=!1,this.h=this.j=this.l=0,Wt(this,I,B)}function Wt(I,B,M){M=M===void 0?{}:M,I.S=M.S===void 0?!1:M.S,B&&(B=_t(B),I.i=B.buffer,I.m=B.C,I.l=0,I.j=I.i.length,I.h=I.l)}st.prototype.reset=function(){this.h=this.l};function ie(I,B){if(I.h=B,B>I.j)throw G(I.j,B)}function Ve(I){var B=I.i,M=I.h,F=B[M++],H=F&127;if(F&128&&(F=B[M++],H|=(F&127)<<7,F&128&&(F=B[M++],H|=(F&127)<<14,F&128&&(F=B[M++],H|=(F&127)<<21,F&128&&(F=B[M++],H|=F<<28,F&128&&B[M++]&128&&B[M++]&128&&B[M++]&128&&B[M++]&128&&B[M++]&128)))))throw At();return ie(I,M),H}function je(I,B){if(0>B)throw Error("Tried to read a negative byte length: "+B);var M=I.h,F=M+B;if(F>I.j)throw G(B,I.j-M);return I.h=F,M}var mt=[];function Qe(){this.h=[]}Qe.prototype.length=function(){return this.h.length},Qe.prototype.end=function(){var I=this.h;return this.h=[],I};function Pe(I,B,M){for(;0<M||127<B;)I.h.push(B&127|128),B=(B>>>7|M<<25)>>>0,M>>>=7;I.h.push(B)}function dt(I,B){for(;127<B;)I.h.push(B&127|128),B>>>=7;I.h.push(B)}function Gt(I,B){if(mt.length){var M=mt.pop();Wt(M,I,B),I=M}else I=new st(I,B);this.h=I,this.j=this.h.h,this.i=this.l=-1,this.setOptions(B)}Gt.prototype.setOptions=function(I){I=I===void 0?{}:I,this.ca=I.ca===void 0?!1:I.ca},Gt.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function _n(I){var B=I.h;if(B.h==B.j)return!1;I.j=I.h.h;var M=Ve(I.h)>>>0;if(B=M>>>3,M&=7,!(0<=M&&5>=M))throw Tt(M,I.j);if(1>B)throw Error("Invalid field number: "+B+" (at position "+I.j+")");return I.l=B,I.i=M,!0}function hn(I){switch(I.i){case 0:if(I.i!=0)hn(I);else e:{I=I.h;for(var B=I.h,M=B+10,F=I.i;B<M;)if((F[B++]&128)===0){ie(I,B);break e}throw At()}break;case 1:I=I.h,ie(I,I.h+8);break;case 2:I.i!=2?hn(I):(B=Ve(I.h)>>>0,I=I.h,ie(I,I.h+B));break;case 5:I=I.h,ie(I,I.h+4);break;case 3:B=I.l;do{if(!_n(I))throw Error("Unmatched start-group tag: stream EOF");if(I.i==4){if(I.l!=B)throw Error("Unmatched end-group tag");break}hn(I)}while(!0);break;default:throw Tt(I.i,I.j)}}var or=[];function Jr(){this.j=[],this.i=0,this.h=new Qe}function ka(I,B){B.length!==0&&(I.j.push(B),I.i+=B.length)}function Ma(I,B){if(B=B.R){ka(I,I.h.end());for(var M=0;M<B.length;M++)ka(I,Nt(B[M])||Ne())}}var Tr=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function jo(I,B){return Tr?I[Tr]|=B:I.A!==void 0?I.A|=B:(Object.defineProperties(I,{A:{value:B,configurable:!0,writable:!0,enumerable:!1}}),B)}function nm(I,B){Tr?I[Tr]&&(I[Tr]&=~B):I.A!==void 0&&(I.A&=~B)}function Gn(I){var B;return Tr?B=I[Tr]:B=I.A,B??0}function Br(I,B){Tr?I[Tr]=B:I.A!==void 0?I.A=B:Object.defineProperties(I,{A:{value:B,configurable:!0,writable:!0,enumerable:!1}})}function Al(I){return jo(I,1),I}function tx(I,B){Br(B,(I|0)&-51)}function yc(I,B){Br(B,(I|18)&-41)}var sm={};function rd(I){return I!==null&&typeof I=="object"&&!Array.isArray(I)&&I.constructor===Object}var xc,nx=[];Br(nx,23),xc=Object.freeze(nx);function im(I){if(Gn(I.o)&2)throw Error("Cannot mutate an immutable Message")}function rm(I){var B=I.length;(B=B?I[B-1]:void 0)&&rd(B)?B.g=1:(B={},I.push((B.g=1,B)))}function Q(I){var B=I.i+I.G;return I.B||(I.B=I.o[B]={})}function he(I,B){return B===-1?null:B>=I.i?I.B?I.B[B]:void 0:I.o[B+I.G]}function Ae(I,B,M,F){im(I),we(I,B,M,F)}function we(I,B,M,F){I.j&&(I.j=void 0),B>=I.i||F?Q(I)[B]=M:(I.o[B+I.G]=M,(I=I.B)&&B in I&&delete I[B])}function pe(I,B,M,F){var H=he(I,B);Array.isArray(H)||(H=xc);var j=Gn(H);if(j&1||Al(H),F)j&2||jo(H,2),M&1||Object.freeze(H);else{F=!(M&2);var Y=j&2;M&1||!Y?F&&j&16&&!Y&&nm(H,16):(H=Al(Array.prototype.slice.call(H)),we(I,B,H))}return H}function Ge(I,B){var M=he(I,B),F=M==null?M:typeof M=="number"||M==="NaN"||M==="Infinity"||M==="-Infinity"?Number(M):void 0;return F!=null&&F!==M&&we(I,B,F),F}function lt(I,B,M,F,H){I.h||(I.h={});var j=I.h[M],Y=pe(I,M,3,H);if(!j){var oe=Y;j=[];var Ie=!!(Gn(I.o)&16);Y=!!(Gn(oe)&2);var ze=oe;!H&&Y&&(oe=Array.prototype.slice.call(oe));for(var Je=Y,Ut=0;Ut<oe.length;Ut++){var Bt=oe[Ut],ct=B,Qt=!1;if(Qt=Qt===void 0?!1:Qt,Bt=Array.isArray(Bt)?new ct(Bt):Qt?new ct:void 0,Bt!==void 0){ct=Bt.o;var rn=Qt=Gn(ct);Y&&(rn|=2),Ie&&(rn|=16),rn!=Qt&&Br(ct,rn),ct=rn,Je=Je||!!(2&ct),j.push(Bt)}}return I.h[M]=j,Ie=Gn(oe),B=Ie|33,B=Je?B&-9:B|8,Ie!=B&&(Je=oe,Object.isFrozen(Je)&&(Je=Array.prototype.slice.call(Je)),Br(Je,B),oe=Je),ze!==oe&&we(I,M,oe),(H||F&&Y)&&jo(j,2),F&&Object.freeze(j),j}return H||(H=Object.isFrozen(j),F&&!H?Object.freeze(j):!F&&H&&(j=Array.prototype.slice.call(j),I.h[M]=j)),j}function xt(I,B,M){var F=!!(Gn(I.o)&2);if(B=lt(I,B,M,F,F),I=pe(I,M,3,F),!(F||Gn(I)&8)){for(F=0;F<B.length;F++){if(M=B[F],Gn(M.o)&2){var H=Na(M,!1);H.j=M}else H=M;M!==H&&(B[F]=H,I[F]=H.o)}jo(I,8)}return B}function it(I,B,M){if(M!=null&&typeof M!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof M+": "+M);Ae(I,B,M)}function Dt(I,B,M,F,H){im(I);var j=lt(I,M,B,!1,!1);return M=F??new M,I=pe(I,B,2,!1),H!=null?(j.splice(H,0,M),I.splice(H,0,M.o)):(j.push(M),I.push(M.o)),M.C()&&nm(I,8),M}function Ft(I,B){return I??B}function Ct(I,B,M){return M=M===void 0?0:M,Ft(Ge(I,B),M)}var en;function Cn(I){switch(typeof I){case"number":return isFinite(I)?I:String(I);case"object":if(I)if(Array.isArray(I)){if((Gn(I)&128)!==0)return I=Array.prototype.slice.call(I),rm(I),I}else{if(me&&I!=null&&I instanceof Uint8Array)return Ee(I);if(I instanceof Oe){var B=I.V;return B==null?"":typeof B=="string"?B:I.V=Ee(B)}}}return I}function Yn(I,B,M,F){if(I!=null){if(Array.isArray(I))I=Tn(I,B,M,F!==void 0);else if(rd(I)){var H={},j;for(j in I)H[j]=Yn(I[j],B,M,F);I=H}else I=B(I,F);return I}}function Tn(I,B,M,F){var H=Gn(I);F=F?!!(H&16):void 0,I=Array.prototype.slice.call(I);for(var j=0;j<I.length;j++)I[j]=Yn(I[j],B,M,F);return M(H,I),I}function Bn(I){return I.ja===sm?I.toJSON():Cn(I)}function Rt(I,B){I&128&&rm(B)}function Wn(I,B,M){if(M=M===void 0?yc:M,I!=null){if(me&&I instanceof Uint8Array)return I.length?new Oe(new Uint8Array(I),Ue):tt();if(Array.isArray(I)){var F=Gn(I);return F&2?I:B&&!(F&32)&&(F&16||F===0)?(Br(I,F|2),I):(I=Tn(I,Wn,F&4?yc:M,!0),B=Gn(I),B&4&&B&2&&Object.freeze(I),I)}return I.ja===sm?yi(I):I}}function dn(I,B,M,F,H,j,Y){if(I=I.h&&I.h[M]){if(F=Gn(I),F&2?F=I:(j=q(I,yi),yc(F,j),Object.freeze(j),F=j),im(B),Y=F==null?xc:Al([]),F!=null){for(j=!!F.length,I=0;I<F.length;I++){var oe=F[I];j=j&&!(Gn(oe.o)&2),Y[I]=oe.o}j=(j?8:0)|1,I=Gn(Y),(I&j)!==j&&(Object.isFrozen(Y)&&(Y=Array.prototype.slice.call(Y)),Br(Y,I|j)),B.h||(B.h={}),B.h[M]=F}else B.h&&(B.h[M]=void 0);we(B,M,Y,H)}else Ae(B,M,Wn(F,j,Y),H)}function yi(I){return Gn(I.o)&2||(I=Na(I,!0),jo(I.o,2)),I}function Na(I,B){var M=I.o,F=[];jo(F,16);var H=I.constructor.h;if(H&&F.push(H),H=I.B,H){F.length=M.length,F.fill(void 0,F.length,M.length);var j={};F[F.length-1]=j}(Gn(M)&128)!==0&&rm(F),B=B||I.C()?yc:tx,j=I.constructor,en=F,F=new j(F),en=void 0,I.R&&(F.R=I.R.slice()),j=!!(Gn(M)&16);for(var Y=H?M.length-1:M.length,oe=0;oe<Y;oe++)dn(I,F,oe-I.G,M[oe],!1,j,B);if(H)for(var Ie in H)dn(I,F,+Ie,H[Ie],!0,j,B);return F}function Rn(I,B,M){I==null&&(I=en),en=void 0;var F=this.constructor.i||0,H=0<F,j=this.constructor.h,Y=!1;if(I==null){I=j?[j]:[];var oe=48,Ie=!0;H&&(F=0,oe|=128),Br(I,oe)}else{if(!Array.isArray(I)||j&&j!==I[0])throw Error();var ze=oe=jo(I,0);if((Ie=(16&ze)!==0)&&((Y=(32&ze)!==0)||(ze|=32)),H){if(128&ze)F=0;else if(0<I.length){var Je=I[I.length-1];if(rd(Je)&&"g"in Je){F=0,ze|=128,delete Je.g;var Ut=!0,Bt;for(Bt in Je){Ut=!1;break}Ut&&I.pop()}}}else if(128&ze)throw Error();oe!==ze&&Br(I,ze)}this.G=(j?0:-1)-F,this.h=void 0,this.o=I;e:{if(j=this.o.length,F=j-1,j&&(j=this.o[F],rd(j))){this.B=j,this.i=F-this.G;break e}B!==void 0&&-1<B?(this.i=Math.max(B,F+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!H&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(M){B=Ie&&!Y&&!0,H=this.i;var ct;for(Ie=0;Ie<M.length;Ie++)Y=M[Ie],Y<H?(Y+=this.G,(F=I[Y])?yl(F,B):I[Y]=xc):(ct||(ct=Q(this)),(F=ct[Y])?yl(F,B):ct[Y]=xc)}}Rn.prototype.toJSON=function(){return Tn(this.o,Bn,Rt)},Rn.prototype.C=function(){return!!(Gn(this.o)&2)};function yl(I,B){if(Array.isArray(I)){var M=Gn(I),F=1;!B||M&2||(F|=16),(M&F)!==F&&Br(I,M|F)}}Rn.prototype.ja=sm,Rn.prototype.toString=function(){return this.o.toString()};function Hn(I,B,M){if(M){var F={},H;for(H in M){var j=M[H],Y=j.ra;Y||(F.J=j.xa||j.oa.W,j.ia?(F.aa=uk(j.ia),Y=(function(oe){return function(Ie,ze,Je){return oe.J(Ie,ze,Je,oe.aa)}})(F)):j.ka?(F.Z=hk(j.da.P,j.ka),Y=(function(oe){return function(Ie,ze,Je){return oe.J(Ie,ze,Je,oe.Z)}})(F)):Y=F.J,j.ra=Y),Y(B,I,j.da),F={J:F.J,aa:F.aa,Z:F.Z}}}Ma(B,I)}var li=Symbol();function Qi(I,B,M){return I[li]||(I[li]=function(F,H){return B(F,H,M)})}function Ks(I){var B=I[li];if(!B){var M=jw(I);B=function(F,H){return dk(F,H,M)},I[li]=B}return B}function xi(I){var B=I.ia;if(B)return Ks(B);if(B=I.wa)return Qi(I.da.P,B,I.ka)}function om(I){var B=xi(I),M=I.da,F=I.oa.U;return B?function(H,j){return F(H,j,M,B)}:function(H,j){return F(H,j,M)}}function Ko(I,B){var M=I[B];return typeof M=="function"&&M.length===0&&(M=M(),I[B]=M),Array.isArray(M)&&(lm in M||am in M||0<M.length&&typeof M[0]=="function")?M:void 0}function ck(I,B,M,F,H,j){B.P=I[0];var Y=1;if(I.length>Y&&typeof I[Y]!="number"){var oe=I[Y++];M(B,oe)}for(;Y<I.length;){M=I[Y++];for(var Ie=Y+1;Ie<I.length&&typeof I[Ie]!="number";)Ie++;switch(oe=I[Y++],Ie-=Y,Ie){case 0:F(B,M,oe);break;case 1:(Ie=Ko(I,Y))?(Y++,H(B,M,oe,Ie)):F(B,M,oe,I[Y++]);break;case 2:Ie=Y++,Ie=Ko(I,Ie),H(B,M,oe,Ie,I[Y++]);break;case 3:j(B,M,oe,I[Y++],I[Y++],I[Y++]);break;case 4:j(B,M,oe,I[Y++],I[Y++],I[Y++],I[Y++]);break;default:throw Error("unexpected number of binary field arguments: "+Ie)}}return B}var sx=Symbol();function uk(I){var B=I[sx];if(!B){var M=Xw(I);B=function(F,H){return pk(F,H,M)},I[sx]=B}return B}function hk(I,B){var M=I[sx];return M||(M=function(F,H){return Hn(F,H,B)},I[sx]=M),M}var am=Symbol();function DV(I,B){I.push(B)}function FV(I,B,M){I.push(B,M.W)}function $V(I,B,M,F){var H=uk(F),j=Xw(F).P,Y=M.W;I.push(B,function(oe,Ie,ze){return Y(oe,Ie,ze,j,H)})}function PV(I,B,M,F,H,j){var Y=hk(F,j),oe=M.W;I.push(B,function(Ie,ze,Je){return oe(Ie,ze,Je,F,Y)})}function Xw(I){var B=I[am];return B||(B=ck(I,I[am]=[],DV,FV,$V,PV),lm in I&&am in I&&(I.length=0),B)}var lm=Symbol();function LV(I,B){I[0]=B}function OV(I,B,M,F){var H=M.U;I[B]=F?function(j,Y,oe){return H(j,Y,oe,F)}:H}function zV(I,B,M,F,H){var j=M.U,Y=Ks(F),oe=jw(F).P;I[B]=function(Ie,ze,Je){return j(Ie,ze,Je,oe,Y,H)}}function UV(I,B,M,F,H,j,Y){var oe=M.U,Ie=Qi(F,H,j);I[B]=function(ze,Je,Ut){return oe(ze,Je,Ut,F,Ie,Y)}}function jw(I){var B=I[lm];return B||(B=ck(I,I[lm]={},LV,OV,zV,UV),lm in I&&am in I&&(I.length=0),B)}function dk(I,B,M){for(;_n(B)&&B.i!=4;){var F=B.l,H=M[F];if(!H){var j=M[0];j&&(j=j[F])&&(H=M[F]=om(j))}if(!H||!H(B,I,F)){H=B,F=I,j=H.j,hn(H);var Y=H;if(!Y.ca){if(H=Y.h.h-j,Y.h.h=j,Y=Y.h,H==0)H=tt();else{if(j=je(Y,H),Y.S&&Y.m)H=Y.i.subarray(j,j+H);else{Y=Y.i;var oe=j;H=j+H,H=oe===H?Ne():ht?Y.slice(oe,H):new Uint8Array(Y.subarray(oe,H))}H=H.length==0?tt():new Oe(H,Ue)}(j=F.R)?j.push(H):F.R=[H]}}}return I}function pk(I,B,M){for(var F=M.length,H=F%2==1,j=H?1:0;j<F;j+=2)(0,M[j+1])(B,I,M[j]);Hn(I,B,H?M[0]:void 0)}function cm(I,B){return{U:I,W:B}}var go=cm(function(I,B,M){if(I.i!==5)return!1;I=I.h;var F=I.i,H=I.h,j=F[H],Y=F[H+1],oe=F[H+2];return F=F[H+3],ie(I,I.h+4),Y=(j<<0|Y<<8|oe<<16|F<<24)>>>0,I=2*(Y>>31)+1,j=Y>>>23&255,Y&=8388607,Ae(B,M,j==255?Y?NaN:1/0*I:j==0?I*Math.pow(2,-149)*Y:I*Math.pow(2,j-150)*(Y+Math.pow(2,23))),!0},function(I,B,M){if(B=Ge(B,M),B!=null){dt(I.h,8*M+5),I=I.h;var F=+B;F===0?0<1/F?W=Ce=0:(Ce=0,W=2147483648):isNaN(F)?(Ce=0,W=2147483647):(F=(M=0>F?-2147483648:0)?-F:F,34028234663852886e22<F?(Ce=0,W=(M|2139095040)>>>0):11754943508222875e-54>F?(F=Math.round(F/Math.pow(2,-149)),Ce=0,W=(M|F)>>>0):(B=Math.floor(Math.log(F)/Math.LN2),F*=Math.pow(2,-B),F=Math.round(8388608*F),16777216<=F&&++B,Ce=0,W=(M|B+127<<23|F&8388607)>>>0)),M=W,I.h.push(M>>>0&255),I.h.push(M>>>8&255),I.h.push(M>>>16&255),I.h.push(M>>>24&255)}}),QV=cm(function(I,B,M){if(I.i!==0)return!1;var F=I.h,H=0,j=I=0,Y=F.i,oe=F.h;do{var Ie=Y[oe++];H|=(Ie&127)<<j,j+=7}while(32>j&&Ie&128);for(32<j&&(I|=(Ie&127)>>4),j=3;32>j&&Ie&128;j+=7)Ie=Y[oe++],I|=(Ie&127)<<j;if(ie(F,oe),128>Ie)F=H>>>0,Ie=I>>>0,(I=Ie&2147483648)&&(F=~F+1>>>0,Ie=~Ie>>>0,F==0&&(Ie=Ie+1>>>0)),F=4294967296*Ie+(F>>>0);else throw At();return Ae(B,M,I?-F:F),!0},function(I,B,M){B=he(B,M),B!=null&&(typeof B=="string"&&De(B),B!=null&&(dt(I.h,8*M),typeof B=="number"?(I=I.h,be(B),Pe(I,W,Ce)):(M=De(B),Pe(I.h,M.i,M.h))))}),VV=cm(function(I,B,M){return I.i!==0?!1:(Ae(B,M,Ve(I.h)),!0)},function(I,B,M){if(B=he(B,M),B!=null&&B!=null)if(dt(I.h,8*M),I=I.h,M=B,0<=M)dt(I,M);else{for(B=0;9>B;B++)I.h.push(M&127|128),M>>=7;I.h.push(1)}}),fk=cm(function(I,B,M){if(I.i!==2)return!1;var F=Ve(I.h)>>>0;I=I.h;var H=je(I,F);if(I=I.i,ve){var j=I,Y;(Y=Fe)||(Y=Fe=new TextDecoder("utf-8",{fatal:!0})),I=H+F,j=H===0&&I===j.length?j:j.subarray(H,I);try{var oe=Y.decode(j)}catch(Ut){if(xe===void 0){try{Y.decode(new Uint8Array([128]))}catch{}try{Y.decode(new Uint8Array([97])),xe=!0}catch{xe=!1}}throw!xe&&(Fe=void 0),Ut}}else{oe=H,F=oe+F,H=[];for(var Ie=null,ze,Je;oe<F;)ze=I[oe++],128>ze?H.push(ze):224>ze?oe>=F?$():(Je=I[oe++],194>ze||(Je&192)!==128?(oe--,$()):H.push((ze&31)<<6|Je&63)):240>ze?oe>=F-1?$():(Je=I[oe++],(Je&192)!==128||ze===224&&160>Je||ze===237&&160<=Je||((j=I[oe++])&192)!==128?(oe--,$()):H.push((ze&15)<<12|(Je&63)<<6|j&63)):244>=ze?oe>=F-2?$():(Je=I[oe++],(Je&192)!==128||(ze<<28)+(Je-144)>>30!==0||((j=I[oe++])&192)!==128||((Y=I[oe++])&192)!==128?(oe--,$()):(ze=(ze&7)<<18|(Je&63)<<12|(j&63)<<6|Y&63,ze-=65536,H.push((ze>>10&1023)+55296,(ze&1023)+56320))):$(),8192<=H.length&&(Ie=de(Ie,H),H.length=0);oe=de(Ie,H)}return Ae(B,M,oe),!0},function(I,B,M){if(B=he(B,M),B!=null){var F=!1;if(F=F===void 0?!1:F,He){if(F&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(B))throw Error("Found an unpaired surrogate");B=(ut||(ut=new TextEncoder)).encode(B)}else{for(var H=0,j=new Uint8Array(3*B.length),Y=0;Y<B.length;Y++){var oe=B.charCodeAt(Y);if(128>oe)j[H++]=oe;else{if(2048>oe)j[H++]=oe>>6|192;else{if(55296<=oe&&57343>=oe){if(56319>=oe&&Y<B.length){var Ie=B.charCodeAt(++Y);if(56320<=Ie&&57343>=Ie){oe=1024*(oe-55296)+Ie-56320+65536,j[H++]=oe>>18|240,j[H++]=oe>>12&63|128,j[H++]=oe>>6&63|128,j[H++]=oe&63|128;continue}else Y--}if(F)throw Error("Found an unpaired surrogate");oe=65533}j[H++]=oe>>12|224,j[H++]=oe>>6&63|128}j[H++]=oe&63|128}}B=H===j.length?j:j.subarray(0,H)}dt(I.h,8*M+2),dt(I.h,B.length),ka(I,I.h.end()),ka(I,B)}}),mk=cm(function(I,B,M,F,H){if(I.i!==2)return!1;B=Dt(B,M,F),M=I.h.j,F=Ve(I.h)>>>0;var j=I.h.h+F,Y=j-M;if(0>=Y&&(I.h.j=j,H(B,I,void 0,void 0,void 0),Y=j-I.h.h),Y)throw Error("Message parsing ended unexpectedly. Expected to read "+(F+" bytes, instead read "+(F-Y)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return I.h.h=j,I.h.j=M,!0},function(I,B,M,F,H){if(B=xt(B,F,M),B!=null)for(F=0;F<B.length;F++){var j=I;dt(j.h,8*M+2);var Y=j.h.end();ka(j,Y),Y.push(j.i),j=Y,H(B[F],I),Y=I;var oe=j.pop();for(oe=Y.i+Y.h.length()-oe;127<oe;)j.push(oe&127|128),oe>>>=7,Y.i++;j.push(oe),Y.i++}});function Kw(I){return function(B,M){e:{if(or.length){var F=or.pop();F.setOptions(M),Wt(F.h,B,M),B=F}else B=new Gt(B,M);try{var H=jw(I),j=dk(new H.P,B,H);break e}finally{H=B.h,H.i=null,H.m=!1,H.l=0,H.j=0,H.h=0,H.S=!1,B.l=-1,B.i=-1,100>or.length&&or.push(B)}j=void 0}return j}}function Jw(I){return function(){var B=new Jr;pk(this,B,Xw(I)),ka(B,B.h.end());for(var M=new Uint8Array(B.i),F=B.j,H=F.length,j=0,Y=0;Y<H;Y++){var oe=F[Y];M.set(oe,j),j+=oe.length}return B.j=[M],M}}function od(I){Rn.call(this,I)}m(od,Rn);var gk=[od,1,VV,2,go,3,fk,4,fk];od.prototype.l=Jw(gk);function Zw(I){Rn.call(this,I,-1,GV)}m(Zw,Rn),Zw.prototype.addClassification=function(I,B){return Dt(this,1,od,I,B),this};var GV=[1],WV=Kw([Zw,1,mk,gk]);function um(I){Rn.call(this,I)}m(um,Rn);var Ak=[um,1,go,2,go,3,go,4,go,5,go];um.prototype.l=Jw(Ak);function yk(I){Rn.call(this,I,-1,HV)}m(yk,Rn);var HV=[1],qV=Kw([yk,1,mk,Ak]);function ix(I){Rn.call(this,I)}m(ix,Rn);var xk=[ix,1,go,2,go,3,go,4,go,5,go,6,QV],YV=Kw(xk);ix.prototype.l=Jw(xk);function bk(I,B,M){if(M=I.createShader(M===0?I.VERTEX_SHADER:I.FRAGMENT_SHADER),I.shaderSource(M,B),I.compileShader(M),!I.getShaderParameter(M,I.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+I.getShaderInfoLog(M));return M}function XV(I){return xt(I,od,1).map(function(B){var M=he(B,1);return{index:M??0,qa:Ct(B,2),label:he(B,3)!=null?Ft(he(B,3),""):void 0,displayName:he(B,4)!=null?Ft(he(B,4),""):void 0}})}function jV(I){return{x:Ct(I,1),y:Ct(I,2),z:Ct(I,3),visibility:Ge(I,4)!=null?Ct(I,4):void 0}}function ev(I){return xt(qV(I),um,1).map(jV)}function tv(I,B){this.i=I,this.h=B,this.m=0}function Ik(I,B,M){return KV(I,B),typeof I.h.canvas.transferToImageBitmap=="function"?Promise.resolve(I.h.canvas.transferToImageBitmap()):M?Promise.resolve(I.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(I.h.canvas):(I.j===void 0&&(I.j=document.createElement("canvas")),new Promise(function(F){I.j.height=I.h.canvas.height,I.j.width=I.h.canvas.width,I.j.getContext("2d",{}).drawImage(I.h.canvas,0,0,I.h.canvas.width,I.h.canvas.height),F(I.j)}))}function KV(I,B){var M=I.h;if(I.s===void 0){var F=bk(M,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),H=bk(M,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),j=M.createProgram();if(M.attachShader(j,F),M.attachShader(j,H),M.linkProgram(j),!M.getProgramParameter(j,M.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+M.getProgramInfoLog(j));F=I.s=j,M.useProgram(F),H=M.getUniformLocation(F,"sampler0"),I.l={O:M.getAttribLocation(F,"aVertex"),N:M.getAttribLocation(F,"aTex"),ya:H},I.v=M.createBuffer(),M.bindBuffer(M.ARRAY_BUFFER,I.v),M.enableVertexAttribArray(I.l.O),M.vertexAttribPointer(I.l.O,2,M.FLOAT,!1,0,0),M.bufferData(M.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),M.STATIC_DRAW),M.bindBuffer(M.ARRAY_BUFFER,null),I.u=M.createBuffer(),M.bindBuffer(M.ARRAY_BUFFER,I.u),M.enableVertexAttribArray(I.l.N),M.vertexAttribPointer(I.l.N,2,M.FLOAT,!1,0,0),M.bufferData(M.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),M.STATIC_DRAW),M.bindBuffer(M.ARRAY_BUFFER,null),M.uniform1i(H,0)}F=I.l,M.useProgram(I.s),M.canvas.width=B.width,M.canvas.height=B.height,M.viewport(0,0,B.width,B.height),M.activeTexture(M.TEXTURE0),I.i.bindTexture2d(B.glName),M.enableVertexAttribArray(F.O),M.bindBuffer(M.ARRAY_BUFFER,I.v),M.vertexAttribPointer(F.O,2,M.FLOAT,!1,0,0),M.enableVertexAttribArray(F.N),M.bindBuffer(M.ARRAY_BUFFER,I.u),M.vertexAttribPointer(F.N,2,M.FLOAT,!1,0,0),M.bindFramebuffer(M.DRAW_FRAMEBUFFER?M.DRAW_FRAMEBUFFER:M.FRAMEBUFFER,null),M.clearColor(0,0,0,0),M.clear(M.COLOR_BUFFER_BIT),M.colorMask(!0,!0,!0,!0),M.drawArrays(M.TRIANGLE_FAN,0,4),M.disableVertexAttribArray(F.O),M.disableVertexAttribArray(F.N),M.bindBuffer(M.ARRAY_BUFFER,null),I.i.bindTexture2d(0)}function JV(I){this.h=I}var ZV=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function eG(I,B){return B+I}function Ck(I,B){window[I]=B}function tG(I){var B=document.createElement("script");return B.setAttribute("src",I),B.setAttribute("crossorigin","anonymous"),new Promise(function(M){B.addEventListener("load",function(){M()},!1),B.addEventListener("error",function(){M()},!1),document.body.appendChild(B)})}function nG(){return _(function(I){switch(I.h){case 1:return I.s=2,x(I,WebAssembly.instantiate(ZV),4);case 4:I.h=3,I.s=0;break;case 2:return I.s=0,I.l=null,I.return(!1);case 3:return I.return(!0)}})}function nv(I){if(this.h=I,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=I&&I.locateFile||eG,typeof window=="object")var B=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")B=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=B,I.options){B=a(Object.keys(I.options));for(var M=B.next();!M.done;M=B.next()){M=M.value;var F=I.options[M].default;F!==void 0&&(this.l[M]=typeof F=="function"?F():F)}}}n=nv.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function sG(I){var B,M,F,H,j,Y,oe,Ie,ze,Je,Ut;return _(function(Bt){switch(Bt.h){case 1:return I.ga?(B=I.h.files===void 0?[]:typeof I.h.files=="function"?I.h.files(I.l):I.h.files,x(Bt,nG(),2)):Bt.return();case 2:if(M=Bt.i,typeof window=="object")return Ck("createMediapipeSolutionsWasm",{locateFile:I.locateFile}),Ck("createMediapipeSolutionsPackedAssets",{locateFile:I.locateFile}),Y=B.filter(function(ct){return ct.data!==void 0}),oe=B.filter(function(ct){return ct.data===void 0}),Ie=Promise.all(Y.map(function(ct){var Qt=rx(I,ct.url);if(ct.path!==void 0){var rn=ct.path;Qt=Qt.then(function(Xn){return I.overrideFile(rn,Xn),Promise.resolve(Xn)})}return Qt})),ze=Promise.all(oe.map(function(ct){return ct.simd===void 0||ct.simd&&M||!ct.simd&&!M?tG(I.locateFile(ct.url,I.ha)):Promise.resolve()})).then(function(){var ct,Qt,rn;return _(function(Xn){if(Xn.h==1)return ct=window.createMediapipeSolutionsWasm,Qt=window.createMediapipeSolutionsPackedAssets,rn=I,x(Xn,ct(Qt),2);rn.i=Xn.i,Xn.h=0})}),Je=(function(){return _(function(ct){return I.h.graph&&I.h.graph.url?ct=x(ct,rx(I,I.h.graph.url),0):(ct.h=0,ct=void 0),ct})})(),x(Bt,Promise.all([ze,Ie,Je]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return F=B.filter(function(ct){return ct.simd===void 0||ct.simd&&M||!ct.simd&&!M}).map(function(ct){return I.locateFile(ct.url,I.ha)}),importScripts.apply(null,l(F)),H=I,x(Bt,createMediapipeSolutionsWasm(Module),6);case 6:H.i=Bt.i,I.m=new OffscreenCanvas(1,1),I.i.canvas=I.m,j=I.i.GL.createContext(I.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),I.i.GL.makeContextCurrent(j),Bt.h=4;break;case 7:if(I.m=document.createElement("canvas"),Ut=I.m.getContext("webgl2",{}),!Ut&&(Ut=I.m.getContext("webgl",{}),!Ut))return alert("Failed to create WebGL canvas context when passing video frame."),Bt.return();I.K=Ut,I.i.canvas=I.m,I.i.createContext(I.m,!0,!0,{});case 4:I.j=new I.i.SolutionWasm,I.ga=!1,Bt.h=0}})}function iG(I){var B,M,F,H,j,Y,oe,Ie;return _(function(ze){if(ze.h==1){if(I.h.graph&&I.h.graph.url&&I.fa===I.h.graph.url)return ze.return();if(I.u=!0,!I.h.graph||!I.h.graph.url){ze.h=2;return}return I.fa=I.h.graph.url,x(ze,rx(I,I.h.graph.url),3)}for(ze.h!=2&&(B=ze.i,I.j.loadGraph(B)),M=a(Object.keys(I.D)),F=M.next();!F.done;F=M.next())H=F.value,I.j.overrideFile(H,I.D[H]);if(I.D={},I.h.listeners)for(j=a(I.h.listeners),Y=j.next();!Y.done;Y=j.next())oe=Y.value,lG(I,oe);Ie=I.l,I.l={},I.setOptions(Ie),ze.h=0})}n.reset=function(){var I=this;return _(function(B){I.j&&(I.j.reset(),I.s={},I.v={}),B.h=0})},n.setOptions=function(I,B){var M=this;if(B=B||this.h.options){for(var F=[],H=[],j={},Y=a(Object.keys(I)),oe=Y.next();!oe.done;j={X:j.X,Y:j.Y},oe=Y.next())if(oe=oe.value,!(oe in this.l&&this.l[oe]===I[oe])){this.l[oe]=I[oe];var Ie=B[oe];Ie!==void 0&&(Ie.onChange&&(j.X=Ie.onChange,j.Y=I[oe],F.push((function(ze){return function(){var Je;return _(function(Ut){if(Ut.h==1)return x(Ut,ze.X(ze.Y),2);Je=Ut.i,Je===!0&&(M.u=!0),Ut.h=0})}})(j))),Ie.graphOptionXref&&(oe=Object.assign({},{calculatorName:"",calculatorIndex:0},Ie.graphOptionXref,{valueNumber:Ie.type===1?I[oe]:0,valueBoolean:Ie.type===0?I[oe]:!1,valueString:Ie.type===2?I[oe]:""}),H.push(oe)))}(F.length!==0||H.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(H),this.F=(this.F===void 0?[]:this.F).concat(F))}};function rG(I){var B,M,F,H,j,Y,oe;return _(function(Ie){switch(Ie.h){case 1:if(!I.u)return Ie.return();if(!I.F){Ie.h=2;break}B=a(I.F),M=B.next();case 3:if(M.done){Ie.h=5;break}return F=M.value,x(Ie,F(),4);case 4:M=B.next(),Ie.h=3;break;case 5:I.F=void 0;case 2:if(I.H){for(H=new I.i.GraphOptionChangeRequestList,j=a(I.H),Y=j.next();!Y.done;Y=j.next())oe=Y.value,H.push_back(oe);I.j.changeOptions(H),H.delete(),I.H=void 0}I.u=!1,Ie.h=0}})}n.initialize=function(){var I=this;return _(function(B){return B.h==1?x(B,sG(I),2):B.h!=3?x(B,iG(I),3):x(B,rG(I),0)})};function rx(I,B){var M,F;return _(function(H){return B in I.L?H.return(I.L[B]):(M=I.locateFile(B,""),F=fetch(M).then(function(j){return j.arrayBuffer()}),I.L[B]=F,H.return(F))})}n.overrideFile=function(I,B){this.j?this.j.overrideFile(I,B):this.D[I]=B},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(I,B){var M=this,F,H,j,Y,oe,Ie,ze,Je,Ut;return _(function(Bt){switch(Bt.h){case 1:return M.h.inputs?(F=1e3*(B??performance.now()),x(Bt,M.I,2)):Bt.return();case 2:return x(Bt,M.initialize(),3);case 3:for(H=new M.i.PacketDataList,j=a(Object.keys(I)),Y=j.next();!Y.done;Y=j.next())if(oe=Y.value,Ie=M.h.inputs[oe]){e:{var ct=I[oe];switch(Ie.type){case"video":var Qt=M.s[Ie.stream];if(Qt||(Qt=new tv(M.i,M.K),M.s[Ie.stream]=Qt),Qt.m===0&&(Qt.m=Qt.i.createTexture()),typeof HTMLVideoElement<"u"&&ct instanceof HTMLVideoElement)var rn=ct.videoWidth,Xn=ct.videoHeight;else typeof HTMLImageElement<"u"&&ct instanceof HTMLImageElement?(rn=ct.naturalWidth,Xn=ct.naturalHeight):(rn=ct.width,Xn=ct.height);Xn={glName:Qt.m,width:rn,height:Xn},rn=Qt.h,rn.canvas.width=Xn.width,rn.canvas.height=Xn.height,rn.activeTexture(rn.TEXTURE0),Qt.i.bindTexture2d(Qt.m),rn.texImage2D(rn.TEXTURE_2D,0,rn.RGBA,rn.RGBA,rn.UNSIGNED_BYTE,ct),Qt.i.bindTexture2d(0),Qt=Xn;break e;case"detections":for(Qt=M.s[Ie.stream],Qt||(Qt=new JV(M.i),M.s[Ie.stream]=Qt),Qt.data||(Qt.data=new Qt.h.DetectionListData),Qt.data.reset(ct.length),Xn=0;Xn<ct.length;++Xn){rn=ct[Xn];var qn=Qt.data,ci=qn.setBoundingBox,Zr=Xn,ar=rn.la,bn=new ix;if(it(bn,1,ar.sa),it(bn,2,ar.ta),it(bn,3,ar.height),it(bn,4,ar.width),it(bn,5,ar.rotation),Ae(bn,6,ar.pa),ar=bn.l(),ci.call(qn,Zr,ar),rn.ea)for(qn=0;qn<rn.ea.length;++qn){bn=rn.ea[qn],ci=Qt.data,Zr=ci.addNormalizedLandmark,ar=Xn,bn=Object.assign({},bn,{visibility:bn.visibility?bn.visibility:0});var ui=new um;it(ui,1,bn.x),it(ui,2,bn.y),it(ui,3,bn.z),bn.visibility&&it(ui,4,bn.visibility),bn=ui.l(),Zr.call(ci,ar,bn)}if(rn.ba)for(qn=0;qn<rn.ba.length;++qn)ci=Qt.data,Zr=ci.addClassification,ar=Xn,bn=rn.ba[qn],ui=new od,it(ui,2,bn.qa),bn.index&&Ae(ui,1,bn.index),bn.label&&Ae(ui,3,bn.label),bn.displayName&&Ae(ui,4,bn.displayName),bn=ui.l(),Zr.call(ci,ar,bn)}Qt=Qt.data;break e;default:Qt={}}}switch(ze=Qt,Je=Ie.stream,Ie.type){case"video":H.pushTexture2d(Object.assign({},ze,{stream:Je,timestamp:F}));break;case"detections":Ut=ze,Ut.stream=Je,Ut.timestamp=F,H.pushDetectionList(Ut);break;default:throw Error("Unknown input config type: '"+Ie.type+"'")}}return M.j.send(H),x(Bt,M.I,4);case 4:H.delete(),Bt.h=0}})};function oG(I,B,M){var F,H,j,Y,oe,Ie,ze,Je,Ut,Bt,ct,Qt,rn,Xn;return _(function(qn){switch(qn.h){case 1:if(!M)return qn.return(B);for(F={},H=0,j=a(Object.keys(M)),Y=j.next();!Y.done;Y=j.next())oe=Y.value,Ie=M[oe],typeof Ie!="string"&&Ie.type==="texture"&&B[Ie.stream]!==void 0&&++H;1<H&&(I.M=!1),ze=a(Object.keys(M)),Y=ze.next();case 2:if(Y.done){qn.h=4;break}if(Je=Y.value,Ut=M[Je],typeof Ut=="string")return rn=F,Xn=Je,x(qn,aG(I,Je,B[Ut]),14);if(Bt=B[Ut.stream],Ut.type==="detection_list"){if(Bt){for(var ci=Bt.getRectList(),Zr=Bt.getLandmarksList(),ar=Bt.getClassificationsList(),bn=[],ui=0;ui<ci.size();++ui){var xl=YV(ci.get(ui)),cG=Ct(xl,1),uG=Ct(xl,2),hG=Ct(xl,3),dG=Ct(xl,4),pG=Ct(xl,5,0),ox=void 0;ox=ox===void 0?0:ox,xl={la:{sa:cG,ta:uG,height:hG,width:dG,rotation:pG,pa:Ft(he(xl,6),ox)},ea:ev(Zr.get(ui)),ba:XV(WV(ar.get(ui)))},bn.push(xl)}ci=bn}else ci=[];F[Je]=ci,qn.h=7;break}if(Ut.type==="proto_list"){if(Bt){for(ci=Array(Bt.size()),Zr=0;Zr<Bt.size();Zr++)ci[Zr]=Bt.get(Zr);Bt.delete()}else ci=[];F[Je]=ci,qn.h=7;break}if(Bt===void 0){qn.h=3;break}if(Ut.type==="float_list"){F[Je]=Bt,qn.h=7;break}if(Ut.type==="proto"){F[Je]=Bt,qn.h=7;break}if(Ut.type!=="texture")throw Error("Unknown output config type: '"+Ut.type+"'");return ct=I.v[Je],ct||(ct=new tv(I.i,I.K),I.v[Je]=ct),x(qn,Ik(ct,Bt,I.M),13);case 13:Qt=qn.i,F[Je]=Qt;case 7:Ut.transform&&F[Je]&&(F[Je]=Ut.transform(F[Je])),qn.h=3;break;case 14:rn[Xn]=qn.i;case 3:Y=ze.next(),qn.h=2;break;case 4:return qn.return(F)}})}function aG(I,B,M){var F;return _(function(H){return typeof M=="number"||M instanceof Uint8Array||M instanceof I.i.Uint8BlobList?H.return(M):M instanceof I.i.Texture2dDataOut?(F=I.v[B],F||(F=new tv(I.i,I.K),I.v[B]=F),H.return(Ik(F,M,I.M))):H.return(void 0)})}function lG(I,B){for(var M=B.name||"$",F=[].concat(l(B.wants)),H=new I.i.StringList,j=a(B.wants),Y=j.next();!Y.done;Y=j.next())H.push_back(Y.value);j=I.i.PacketListener.implement({onResults:function(oe){for(var Ie={},ze=0;ze<B.wants.length;++ze)Ie[F[ze]]=oe.get(ze);var Je=I.listeners[M];Je&&(I.I=oG(I,Ie,B.outs).then(function(Ut){Ut=Je(Ut);for(var Bt=0;Bt<B.wants.length;++Bt){var ct=Ie[F[Bt]];typeof ct=="object"&&ct.hasOwnProperty&&ct.hasOwnProperty("delete")&&ct.delete()}Ut&&(I.I=Ut)}))}}),I.j.attachMultiListener(H,j),H.delete()}n.onResults=function(I,B){this.listeners[B||"$"]=I},L("Solution",nv),L("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function wk(I){switch(I===void 0&&(I=0),I){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function vk(I){var B=this;I=I||{},this.h=new nv({locateFile:I.locateFile,files:function(M){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:wk(M.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:ev},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:ev},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(M){var F,H,j;return _(function(Y){return Y.h==1?(F=wk(M),H="third_party/mediapipe/modules/pose_landmark/"+F,x(Y,rx(B.h,F),2)):(j=Y.i,B.h.overrideFile(H,j),Y.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=vk.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(I){this.h.onResults(I)},n.initialize=function(){var I=this;return _(function(B){return x(B,I.h.initialize(),0)})},n.send=function(I,B){var M=this;return _(function(F){return x(F,M.h.send(I,B),0)})},n.setOptions=function(I){this.h.setOptions(I)},L("Pose",vk),L("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),L("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),L("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),L("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),L("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),L("VERSION","0.5.1675469404")}).call(uS)),uS}var lEe=aEe();/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kr=ae();Kr.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Kr.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Kr.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Kr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Kr.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Kr.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Kr.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Kr.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Kr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Kr.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Kr.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Kr.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Kr.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cEe{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uEe{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,s=!1,i=!0){let r;const o=WR(e,t);return i?(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).length>0?(r=this.freeBuffers.get(o).pop(),this.numFreeBuffers--):(r=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e)):(r=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.usedBuffers.get(o).push(r),this.numUsedBuffers++,this.numBytesUsed+=e,r}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const s=e.size,i=e.usage,r=WR(s,i),o=this.usedBuffers.get(r),a=o.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");o[a]=o[o.length-1],o.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,t?(this.freeBuffers.get(r).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function WR(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hEe{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,s,i){const r=qR(s),o=e*t*r,a=HR(e,t,s,i);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=o,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const c=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(c),c}this.numBytesAllocated+=o;const l=this.device.createTexture({size:[e,t],format:s,usage:i});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,s=e.height,i=e.format,r=e.usage,o=HR(t,s,i,r);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(o),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const c=qR(i),u=t*s*c;this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function HR(n,e,t,s){return`${n}_${e}_${t}_${s}`}function qR(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dEe(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,s="xyzwuv",i=n.map(o=>`${e}.${s[o]}`),r=new Array(t-1);r[t-2]=i[t-1];for(let o=t-3;o>=0;--o)r[o]=`(${r[o+1]} * ${i[o+1]})`;return r}const Ac=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ip;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(Ip||(Ip={}));const pEe=(n,e,t,s,i)=>{const r={dtype:s.dtype,shape:s.shape},o=mEe(t,r,e),a=n.createShaderModule({code:o,label:e.constructor.name});let l=ae().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(u=>e.shaderKey.toLowerCase().includes(u)))&&(console.group(e.shaderKey),console.debug(o),console.groupEnd())}return i?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},Zt=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function ds(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Ka(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function Ye(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function YR(n,e){let t;return t=`
     ${fEe(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function fEe(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function mEe(n,e,t){const s=[],i=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${KQ(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const f=t.pixelsOpType===Ip.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Yc(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Yc(n[0].dtype,t.outputComponent)}>;`,g=e.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${g},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${f}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const m=jR(t);return[XR,s.join(`
`),P0(e.shape),t.getUserCode(),YR(m,t)].join(`
`)}let r,o,a="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((f,g)=>{const m=ds(n[g].shape.length);a+=`${f.charAt(0).toLowerCase()+f.slice(1)}Shape : ${m}, `,r=n[g].shape.length-1,o=ds(r),a+=`${f.charAt(0).toLowerCase()+f.slice(1)}ShapeStrides: ${o}, `});const l=ds(e.shape.length);a+=`outShape : ${l}, `,r=e.shape.length-1,o=ds(r),a+=`
         outShapeStrides: ${o}, `,t.size&&(a+="size : i32, "),t.uniforms&&(a+=t.uniforms),a+="};",a=vEe(a),s.push(a),t.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Yc(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((f,g)=>{s.push(`
      @group(0) @binding(${1+g}) var<storage, read> ${f}: array<${t.variableComponents?Yc(n[g].dtype,t.variableComponents[g]):Yc(n[g].dtype,t.outputComponent)}>;
        `)}),a!==""&&s.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=IEe(e.shape,t.dispatchLayout),u=[XR,s.join(`
`)+AEe,P0(e.shape),c,CEe(e.shape.length)];t.atomic||u.push(wEe(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((f,g)=>{u.push(`${P0(n[g].shape,f)}`)});const h=n.map((f,g)=>bEe(f,e.shape,t.variableComponents?t.variableComponents[g]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);u.push(h),u.push(t.getUserCode());const d=jR(t);return u.push(YR(d,t)),u.join(`
`)}function gEe(n,e,t){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const i=[],r=[];e.forEach(u=>{i.push(u.shape),r.push(u.dtype)}),i.push(t.shape),r.push(t.dtype);const o=e.map(u=>rl(u.shape,t.shape)),a=e.map(u=>qt(u.shape,t.shape)).join("_"),l=o.map(u=>u.join("_")).join(";"),c=KQ(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+i.map(u=>u.length).join(",")+r.join(",")+n.variableNames.join(",")+l+a+c,s}const XR=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,AEe=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function P0(n,e=""){const t=n.length,s=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",i=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const r=vt(n),o=ds(t),a=[];for(let c=0;c<t;c++)a.push(`d${c}`);if(r.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${i}; let d1 = index - d0 * uniforms.${i};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+r.map((c,u)=>{const h=`let ${a[u]} = index2 / uniforms.${i}.${Ka(u)}`,d=u===r.length-1?`let ${a[u+1]} = index2 - ${a[u]} * uniforms.${i}.${Ka(u)}`:`index2 = index2 - ${a[u]} * uniforms.${i}.${Ka(u)}`;return`${h}; ${d};`}).join(""),`
    fn ${s}(index : i32) -> ${o} {
      ${l}
      return ${o}(${a.join(",")});
    }
  `}function yEe(n,e){const t=n.name,s=n.shape.length,i=ds(s),r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=o.map(u=>`${u} : i32`).join(", ");if(s<1)return`
      fn ${r}() -> ${Zt(e)} {
        return ${Zt(e)}(${t}[0]);
      }
    `;const l=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let c=`${s}D`;return s===0&&(c="1D"),`
    fn ${r}(${a}) -> ${Zt(e)} {
      return ${Zt(e)}(${t}[getIndexFromCoords${c}(${i}(${o.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function xEe(n,e,t,s){const i=n.name,r=i.charAt(0).toUpperCase()+i.slice(1),o="get"+r+"ByOutput",a=n.shape.length,l=e.length,c=ds(l);if(qt(n.shape,e)&&s)return`
    fn ${o}Index(globalIndex : i32) -> ${Zt(t)} {
      return ${Zt(t)}(${i}[globalIndex]);
    }

    fn ${o}Coords(coords : ${c}) -> ${Zt(t)} {
      return ${Zt(t)}(${i}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const u=rl(n.shape,e),h=l-a;let d="";if(a===0)return`
    fn ${o}Index(globalIndex : i32) -> ${Zt(t)}{
      return get${r}();
    }

    fn ${o}Coords(coords : ${c}) -> ${Zt(t)}{
      return get${r}();
    }
  `;l<2&&u.length>=1?d="coords = 0;":d=u.map(m=>`coords.${Ka(m+h)} = 0;`).join(`
`);let p="";if(l<2&&a>0)p="coords";else if(l>1){const m=ds(a),A=n.shape.map((y,b)=>`coords.${Ka(b+h)}`).join(", ");p=`${m}(${A})`}else p="coords";const f=`uniforms.${i.charAt(0).toLowerCase()+i.slice(1)}Shape`,g=`${a}D`;return`
  fn ${o}Index(globalIndex : i32) -> ${Zt(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${d}
    return ${Zt(t)}(${i}[getIndexFromCoords${g}(${p}, ${f})${t===1?"":` / ${t}`}]);
  }

  fn ${o}Coords(coordsIn : ${c}) -> ${Zt(t)} {
    var coords = coordsIn;
    ${d}
    return ${Zt(t)}(${i}[getIndexFromCoords${g}(${p}, ${f})${t===1?"":` / ${t}`}]);
  }
`}function bEe(n,e,t,s){let i=yEe(n,t);return n.shape.length<=e.length&&(i+=xEe(n,e,t,s)),i}function IEe(n,e){const{x:t,y:s=[],z:i=[]}=e,r=n.length,o=t.length+s.length+i.length;if(o!==r)return"";if(t.length===r)return`fn getOutputCoords() -> ${ds(r)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[t,s,i];for(let d=0;d<l.length;d++){const p=l[d];if(p.length!==0)if(p.length===1)a+=`let d${p[0]} = i32(globalId[${d}]);`;else{const f=dEe(p,"uniforms.outShape");a+=`var index${d} = i32(globalId[${d}]);`;for(let g=0;g<f.length;g++)a+=`let d${p[g]} = index${d} / ${f[g]};`,g===f.length-1?a+=`let d${p[g+1]} = index${d} - d${p[g]} * ${f[g]};`:a+=`index${d} = index${d} - d${p[g]} * ${f[g]};`}}const c=[];for(let d=0;d<o;d++)c.push(`d${d}`);const u=ds(o);let h=`fn getOutputCoords() -> ${u} {
  ${a}
`;return c.length===0?h+=`return ${u}(0); }`:h+=`return ${u}(${c.join(",")}); }`,h}function CEe(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:R(!1,()=>`Unsupported ${n}D shape`);break}return e}function KQ(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function Yc(n,e=1){if(n==="float32")return Zt(e,"f32");if(n==="int32"||n==="bool")return Zt(e,"i32");throw new Error(`type ${n} is not supported.`)}function wEe(n,e,t){const s=n.length,i=Yc(e,t);let r=`fn setOutputAtIndex(flatIndex : i32, value : ${Zt(t)}) {
      result[flatIndex] = ${i}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Zt(t,"i32")}) {
      result[flatIndex] = ${i}(value);
    }
    `;if(s>=2){const o=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=ds(s);r+=`
      fn setOutputAtCoords(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Zt(t)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Zt(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return r}function vEe(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,s=>"@align(16) "+s);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(s,i,r)=>`vec${i}, @align(16) ${r}`),n}function jR(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gu=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function Xe(n,e,t=[1,1,1],s=[1,1,1]){const[i,r,o]=[Math.ceil(gu(n.x.map(a=>e[a]))/(t[0]*s[0])),n.y?Math.ceil(gu(n.y.map(a=>e[a]))/(t[1]*s[1])):1,n.z?Math.ceil(gu(n.z.map(a=>e[a]))/(t[2]*s[2])):1];return[i,r,o]}function SEe(n,e,t,s=!1){const i=[8,8,1],r=[4,4,1];return s||(n<=8&&(r[1]=1),e<=16&&t<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:r}}function JQ(n,e,t=!1){if(t)return[8,8,1];const s=gu(n.x.map(r=>e[r])),i=gu(n.y.map(r=>e[r]));return s<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function ZQ(n,e,t=!1){if(t)return[4,4,1];const s=gu(n.x.map(r=>e[r])),i=gu(n.y.map(r=>e[r]));return s<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function at(n){return{x:n.map((e,t)=>t)}}function KR(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function e4(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function t4(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&R(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var na;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(na||(na={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EEe=ae().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),_Ee=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,s=e.dispatchLayout,i=e.dispatch;if(i.every(o=>o<=t))return i;R(i[0]>t&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let r=Math.ceil(Math.sqrt(i[0]));return r>t?(r=Math.ceil(Math.cbrt(i[0])),R(r<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[r,r,r]):[r,r,1]};class Zf extends uA{nextDataId(){return Zf.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!e4())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new cEe(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new uEe(this.device),this.textureManager=new hEe(this.device),this.tensorMap=new WI(this,hi()),ae().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const s=this.tensorMap.get(e);return t?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,s){if(s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:s,shape:t,values:e,refCount:1}),i}move(e,t,s,i,r){if(i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:i,shape:s,values:t,refCount:r})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,s)=>{this.pipelineCache[t]=e[s]})}async getBufferData(e){if(ae().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,s=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const i=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),ae().getBool("WEBGPU_USE_PROFILE_TOOL")&&(R(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(e,t){const s=this.tensorMap.get(e);return s.values=t,s.values}readSync(e){const t=this.tensorMap.get(e),{values:s,complexTensorInfos:i}=t;if(s!=null||t.dtype==="string")return s;if(t.dtype==="complex64"){const g=this.readSync(i.real.dataId),m=this.readSync(i.imag.dataId),A=Zm($o(g,m).buffer,"float32");return this.convertAndCacheOnCPU(e,A),A}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const r=["opaque","premultiplied"],o=t.resource,a=o.size;R(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,c=new ArrayBuffer(a),u=256,h=256,d=r.map(g=>new OffscreenCanvas(u,h)),p=new OffscreenCanvas(u,h);this.endComputePassEncoder(),d.map((g,m)=>{const A=g.getContext("webgpu");return A.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:r[m]}),A.getCurrentTexture()}).map((g,m)=>{const A=u*4,y=(T,v,S)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:A,offset:S},{texture:g},{width:T,height:v}),this.submitQueue();const _=p.getContext("2d",{willReadFrequently:!0});_.clearRect(0,0,T,v),_.drawImage(d[m],0,0);const N=_.getImageData(0,0,T,v).data,D=r[m],P=new Uint8ClampedArray(c,S,T*v*4);for(let L=0;L<P.length;L+=4)if(D==="premultiplied")P[L+3]=N[L+3];else{const z=N[L];P[L]=N[L+2],P[L+1]=N[L+1],P[L+2]=z}},b=Math.floor(l/(u*h));let x=u,C=h,w=0;for(let T=0;T<b;T++)y(x,C,w),w+=u*h*4;const E=l%(u*h);C=Math.floor(E/u),C>0&&(y(x,C,w),w+=C*(u*4)),x=E%u,x>0&&y(x,1,w)});const f=Zm(c,t.dtype);return this.convertAndCacheOnCPU(e,f),f}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(s!=null)return s;let i;if(t.dtype==="complex64"){const r=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),o=r[0],a=r[1];i=$o(o,a)}else{const r=await this.getBufferData(t.resource);i=Zm(r,t.dtype)}return this.convertAndCacheOnCPU(e,i),i}copyBuffer(e){const t=e.size,s=e.usage,i=this.bufferManager.acquireBuffer(t,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,i,0,t),this.submitQueue(),i}createTensorFromGPUData(e,t,s){let i=e.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const r={id:this.nextDataId()};this.tensorMap.set(r,{dtype:s,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(r),a=KR(o.dtype)*ce(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(i=this.copyBuffer(i)),o.resource=i,hi().makeTensorFromDataId(r,t,s,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:s,dtype:i,shape:r,resource:o}=t;if(i==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(o==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=o,l=a.size,c=a.usage,u=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,u,0,l),this.submitQueue();const h=this.makeTensorInfo(r,i),d=hi().makeTensorFromTensorInfo(h),p=this.tensorMap.get(h.dataId);return p.resource=u,{tensorRef:d,buffer:u}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>lo(i));return zt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zt(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,e();const r=co(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=co(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(r);return a.kernelMs=d2(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,s){return t==="string"&&s!=null&&s.length>0&&To(s[0])&&(s=s.map(r=>Ro(r))),{dataId:this.write(s,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const s=this.tensorMap.get(e.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const s=KR(t.dtype)*ce(t.shape);let i;const r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(i=this.bufferManager.acquireBuffer(s,r,!0),i.mapState==="unmapped"){const o=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=o.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),o.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,i,0,s),this.stagingPendingDisposal.push(o)}else{const o=i.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),i.unmap()}t.values=null}else i=this.bufferManager.acquireBuffer(s,r);t.resource=i}makeUniforms(e){let t=0,s=0;const i=[];let r=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:R(!1,()=>`Unsupported ${l.data.length}D shape`)}(s===5||s===6)&&(c=16),c>r&&(r=c),t=Math.ceil(t/c)*c,s=l.data.length,i.push(t),t+=l.data.length*4}),t=Math.ceil(t/r)*r;const o=new ArrayBuffer(t);e.forEach((l,c)=>{const u=i[c];l.type==="int32"?new Int32Array(o,u,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(o,u,l.data.length).set(l.data):new Float32Array(o,u,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,o,0,t),this.uniformPendingDisposal.push(a),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,s,i,r){if(r||(r=this.makeTensorInfo(e.outputShape,s)),ce(r.shape)===0)return this.tensorMap.get(r.dataId).values=Cs(r.dtype,0),r;this.uploadToGPU(r.dataId),e.dispatch=_Ee(this.device,e);const o=t.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=gEe(e,o,r);const a=ae().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=pEe(this.device,e,o,r,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,r,t,i),r}recordAndSubmit(e,t,s,i){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let r=[],o=[];const a="int32";if(e.pixelsOpType==null){r.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=s.concat(t).map(p=>p.shape);const d="int32";o.map(p=>{r.push({type:d,data:p});const f=vt(p);r.push({type:d,data:f})})}else{const d=vt(t.shape);r.push({type:a,data:d})}if(e.size){const d=ce(e.outputShape);r.push({type:a,data:[e.outputComponent?d/e.outputComponent:d]})}i&&(r=[...r,...i]);const l=[this.tensorToBinding(t),...s.map(d=>this.tensorToBinding(d)),this.makeUniforms(r)];s.forEach(d=>{this.commandQueueOwnedIds.add(d.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((d,p)=>({binding:p,resource:d}))}),u=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};u&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(u||ae().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===Ip.DRAW)&&(this.endComputePassEncoder(),u?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),s=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),s}shouldExecuteOnCPU(e,t=EEe){return ae().getBool("WEBGPU_CPU_FORWARD")&&e.every(s=>this.tensorMap.get(s.dataId).resource==null&&ce(s.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Zf.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */e4()&&oC("webgpu",async()=>{const n={powerPreference:ae().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},s=[];e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),t.requiredFeatures=s;const i=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:i.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:i.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:i.maxStorageBufferBindingSize,maxBufferSize:i.maxBufferSize,maxComputeWorkgroupSizeX:i.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:i.maxComputeInvocationsPerWorkgroup};const r=await e.requestDevice(t),o="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new Zf(r,o)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Pt;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(Pt||(Pt={}));const TEe="let resultTemp = a + b;",BEe="let resultTemp = atan2(a, b);",kEe="let resultTemp = areal * breal - aimag * bimag;",MEe="let resultTemp = areal * bimag + aimag * breal;",NEe="let resultTemp = a / b;",REe="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",DEe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,FEe=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,$Ee=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,PEe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,LEe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,OEe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,zEe="return f32(a >= 1.0 && b >= 1.0);",UEe=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,QEe="return f32(a >= 1.0 || b >= 1.0);",VEe=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,GEe="let resultTemp = max(a, b);",WEe="let resultTemp = min(a, b);",HEe=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,qEe=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,YEe="let resultTemp = a * b;",XEe=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,jEe=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,KEe=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,JEe=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,ZEe="if (a < 0.0) { return b * a; }  return a;",e2e=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,t2e="let resultTemp = (a - b) * (a - b);",n2e="let resultTemp = a - b;";function XB(n,e){let t;do{switch(n){case Pt.ATAN2:t=BEe;break;case Pt.MAX:t=GEe;break;case Pt.MIN:t=WEe;break;case Pt.MOD:t=e?qEe:HEe;break;case Pt.NOT_EQUAL:t=e?jEe:XEe;break;case Pt.POW:t=e?JEe:KEe;break;default:continue}let s,i,r;return e?(s="isnanVec4",i="vec4<f32>",r="vec4<bool>"):(s="isnan",i="f32",r="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${i}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${i}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${i}(valueForNaN),
            ${r}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case Pt.ADD:t=TEe;break;case Pt.COMPLEX_MULTIPLY_IMAG:t=MEe;break;case Pt.COMPLEX_MULTIPLY_REAL:t=kEe;break;case Pt.DIV:t=NEe;break;case Pt.ELU_DER:t=REe;break;case Pt.EQUAL:t=DEe;break;case Pt.FLOOR_DIV:t=FEe;break;case Pt.GREATER:t=$Ee;break;case Pt.GREATER_EQUAL:t=PEe;break;case Pt.LESS:t=LEe;break;case Pt.LESS_EQUAL:t=OEe;break;case Pt.LOGICAL_AND:return e?UEe:zEe;case Pt.LOGICAL_OR:return e?VEe:QEe;case Pt.MUL:t=YEe;break;case Pt.PRELU:return e?e2e:ZEe;case Pt.SQUARED_DIFFERENCE:t=t2e;break;case Pt.SUB:t=n2e;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var qe;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(qe||(qe={}));const s2e="return abs(a);",i2e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,r2e=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,o2e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,a2e="return asinh(a);",l2e=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,c2e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,u2e="return ceil(a);",h2e="return cos(a);",d2e=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,p2e="return exp(a) - 1.0;",f2e="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",m2e=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,g2e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${JC};
  let a1 = ${ZC};
  let a2 = ${ew};
  let a3 = ${tw};
  let a4 = ${nw};
  let a5 = ${sw};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,A2e="return exp(a);",y2e="return floor(a);",x2e="return f32(!isnan(a) && !isinf(a));",b2e="return f32(isinf(a));",I2e="return f32(isnan(a));",C2e="return a;",w2e=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,v2e=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,S2e="return f32(!(a >= 1.0));",E2e="return -a;",_2e="if (a < 0.0) { return uniforms.alpha * a; } return a;",T2e=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,B2e="return 1.0 / a;",k2e="return select(a, 0.0, a < 0.0);",M2e="return clamp(a, 0.0, 6.0);",N2e="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",R2e=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,D2e="return round(a);",F2e="return inverseSqrt(a);",$2e=`
  if (a >= 0.0) {
    return ${Fy} * a;
  } else {
    return ${Dy} * (exp(a) - 1.0);
  }
`,P2e="return 1.0 / (1.0 + exp(-1.0 * a));",L2e="return sign(a);",O2e="return sin(a);",z2e=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,U2e=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,Q2e="return sqrt(a);",V2e="return a * a;",G2e=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,W2e="return tan(a);",H2e=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,q2e="return f32(i32((a)));";function zc(n,e){switch(n){case qe.ABS:return s2e;case qe.ACOS:return i2e;case qe.ACOSH:return r2e;case qe.ASIN:return o2e;case qe.ASINH:return a2e;case qe.ATAN:return l2e;case qe.ATANH:return c2e;case qe.COS:return h2e;case qe.COSH:return d2e;case qe.CEIL:return u2e;case qe.ELU:return e?m2e:f2e;case qe.ERF:return g2e;case qe.EXP:return A2e;case qe.EXPM1:return p2e;case qe.FLOOR:return y2e;case qe.IS_FINITE:return x2e;case qe.IS_INF:return b2e;case qe.IS_NAN:return I2e;case qe.LINEAR:return C2e;case qe.LOG:return w2e;case qe.LOG1P:return v2e;case qe.LOGICAL_NOT:return S2e;case qe.NEG:return E2e;case qe.LEAKYRELU:return e?T2e:_2e;case qe.RECIPROCAL:return B2e;case qe.RELU:return e?R2e:k2e;case qe.RELU6:return e?N2e:M2e;case qe.ROUND:return D2e;case qe.RSQRT:return F2e;case qe.SELU:return $2e;case qe.SIGMOID:return P2e;case qe.SIGN:return L2e;case qe.SIN:return O2e;case qe.SINH:return z2e;case qe.SOFTPLUS:return U2e;case qe.SQRT:return Q2e;case qe.SQUARE:return V2e;case qe.STEP:return G2e;case qe.TAN:return W2e;case qe.TANH:return H2e;case qe.TO_INT:return q2e;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gl(n,e=!1,t=!1,s=3){if(n===null)return"";let i="";if(n==="linear")i=zc(qe.LINEAR);else if(n==="relu")i=zc(qe.RELU,t);else if(n==="elu")i=zc(qe.ELU,t);else if(n==="relu6")i=zc(qe.RELU6,t);else if(n==="prelu")i=XB(Pt.PRELU,t);else if(n==="sigmoid")i=zc(qe.SIGMOID,t);else if(n==="leakyrelu")i=zc(qe.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const o=Zt(t?4:1);let a="";return e?a=`
      fn activation(a : ${o}, coords : vec${s}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${i}
      }`:a=`
      fn activation(a : ${o}, coords : vec${s}<i32>) -> ${o} {
        ${i}
      }`,a}function nd(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n4(n,e,t=!1,s=!1,i=!1,r=1){R(n&&r===1||!n,()=>`transposeA ${n} is not compatible with component size ${r}`);const o=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Zt(r)} {
    var value = ${Zt(r)}(0.0);
    ${t&&i?o:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Zt(r)} {
    var value = ${Zt(r)}(0.0);
    ${a}
    return value;
  }
  `}function jB(n,e,t,s,i=!1,r=!1,o=!1,a=1){return`
  ${n4(t,s,i,r,o,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Zt(a)}) {
    ${i&&r?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${nd(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const Y2e=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,X2e=(n,e,t,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let i="",r="";for(let o=0;o<e;o++)i+=`let BCached${o} = mm_Bsub[k * ${e} + ${o}][tileCol];`,r+=`acc[i] = fma(BCached${o}, vec4<f32>(ACached[${o}]), acc[i]);`;return`
      for (var k = 0; k < ${s/e}; k++) {
        ${i}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${r}
        }
      }`}};function Pw(n,e,t=!1,s=32,i=!1,r=32,o=!1){const a=e[1]*n[1],l=e[0]*n[0],c=t?a:s,u=t?s:a,h=c/e[0],d=s/e[1],p=n[1],f=n[0];return R((t&&h===4&&n[1]===4||!t&&(h===3||h===4))&&c%e[0]===0&&s%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${c/h}>, ${u}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/n[0]}>, ${s}>;

  ${Ye()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${p};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${p};
    let globalCol = i32(globalId.x) * ${f};
    let batch = ${i?"0":"i32(globalId.z)"};
    let batchA = ${i||!o?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${i||!o?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${i?`${Math.ceil(r/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${i?`i32(globalId.z) * ${r}`:"0"};

    var acc: array<vec4<f32>, ${p}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${Y2e(t,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${X2e(t,h,p,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const JR=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,j2e=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function Lw(n,e,t=!1,s=32,i=!1,r=32,o=!1,a=!1){const l=n[1]*e[1],c=n[0]*e[0],u=t?l:s,h=t?s:l;R(h%e[1]===0&&u%e[0]===0&&s%e[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}, tileInner ${s} must be divisible by workgroupSize[1]${e[1]}`);const d=h/e[1],p=u/e[0],f=s/e[1],g=n[1],m=n[0],A=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            ${JR(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${m}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${m}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${m}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${g};
  let tileCol = i32(localId.x) * ${m};

  let globalRow = i32(globalId.y) * ${g};
  let globalCol = i32(globalId.x) * ${m};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${d};
  let tileColA = i32(localId.x) * ${p};
  let tileRowB = i32(localId.y) * ${f};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
      for (var innerCol = 0; innerCol < ${p}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${JR(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${m}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${m}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${m}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        ${j2e(t)}
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${g}; innerRow++) {
    for (var innerCol = 0; innerCol < ${m}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${u}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${s}>;

    ${Ye()} {
      let batch = ${i?"0":"i32(globalId.z)"};
      let batchA = ${i||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${i||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${i?`${Math.ceil(r/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${i?`i32(globalId.z) * ${r}`:"0"};

      var acc : array<array<f32, ${m}>, ${g}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${A}
    }
  `}const K2e=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function J2e(n,e=!1){R(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${Ye()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${K2e(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class Z2e{constructor(e,t,s=!1,i=!1,r=null,o=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=s?e[1]:e[2];if(this.isVec4=(c%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!i,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const d=SEe(t[1],c,t[2],s);this.workgroupSize=d.workgroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const u=r!=null,h=a!=null;u&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=s,this.transposeB=i,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,s){const i=this.workgroupSize[1]*this.elementsPerThread[1],r=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=r;const o=e%i===0,a=t%r===0,l=s%this.tileInner===0;return[o,a,l]}getUserCode(){return`
      ${gl(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${jB(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Pw(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?J2e(this.workgroupSize,this.transposeA):Lw(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_e(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${Ye()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class t_e{constructor(e,t=!1,s=!1,i=null,r=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=i!=null,l=o!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=s,this.addBias=a,this.activation=r,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${t}_${s}`}getUserCode(){return`
      ${gl(this.activation,this.hasPreluActivationWeights)}
      ${jB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${e_e(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n_e(n){const e=n[1],t=n[0],s=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Ye()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class s_e{constructor(e,t,s,i=!1,r=!1,o=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const c=o!=null;c&&this.variableNames.push("bias");const u=l!=null;u&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=r,this.addBias=c,this.activation=a,this.hasPreluActivationWeights=u,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${r}`}getUserCode(){return`
      ${gl(this.activation,this.hasPreluActivationWeights)}
      ${jB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${n_e(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i_e{constructor(e,t,s=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,R(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const r=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=r?4:1,r||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Xe(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=i,this.shaderKey=`matMulSplitK_${s}_${i}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${n4(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Zt(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Ac("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?Pw(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Lw(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class r_e{constructor(e,t=null,s=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=i!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${gl(this.activation,this.hasPreluActivationWeights)}
    ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${nd(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o_e{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Ye("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function er(n){const{backend:e,attrs:t}=n,{shape:s,value:i}=t;let{dtype:r}=t;if(r=r||lc(i),r==="string"){const o=ns(r,ce(s));return o.fill(i),e.makeTensorInfo(s,r,o)}else{const o=new o_e(s),a=[{type:"float32",data:[i]}];return e.runWebGPUProgram(o,[],r,a)}}const a_e={kernelName:RA,backendName:"webgpu",kernelFunc:er};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bt(n){const{inputs:e,attrs:t}=n,{x:s}=e,{shape:i}=t,r=ce(s.shape),o=qI(i,r),a=ce(o);return R(r===a,()=>`The new shape (${o}) has ${a} elements and the old shape (${s.shape}) has ${r} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}}const l_e={kernelName:Af,backendName:"webgpu",kernelFunc:bt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ow({a:n,b:e,transposeA:t,transposeB:s,backend:i,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],d=s?e.shape[u-1]:e.shape[u-2],p=t?n.shape[c-1]:n.shape[c-2],f=s?e.shape[u-2]:e.shape[u-1],g=n.shape.slice(0,-2),m=e.shape.slice(0,-2),A=ce(g),y=ce(m),x=Mt(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);R(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const C=t?[A,h,p]:[A,p,h],w=s?[y,f,d]:[y,d,f],E=bt({inputs:{x:n},backend:i,attrs:{shape:C}}),T=bt({inputs:{x:e},backend:i,attrs:{shape:w}}),v=[E,T],S=Math.max(A,y),_=[E,T],N=[{type:"int32",data:[p]},{type:"int32",data:[f]},{type:"int32",data:[h]}];let D,P;const L=[S,p,f];let z=ae().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(z<0){const V=ae().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),X=V>0?V:i.thresholdToIncreaseWorkgroups,te=S*Math.ceil(p/32)*Math.ceil(f/32);te<=X||p<=8&&te<=X*2?S*p*f<=128?z=na.MatMulReduceProgram:S===1&&d>=2e3?z=na.MatMulSplitKProgram:z=na.MatMulSmallOutputSizeProgram:z=na.MatMulPackedProgram}switch(z){case na.MatMulReduceProgram:D=new t_e(L,t,s,r,l,o);break;case na.MatMulSplitKProgram:{if(P=er({backend:i,attrs:{shape:L,value:0,dtype:n.dtype}}),D=new i_e(L,d,t,s),r||l){P=i.runWebGPUProgram(D,_,n.dtype,N,P);const X=new r_e(P.shape,r,l,o);let te=null;const se=[P];r&&se.push(r),o&&se.push(o),l==="leakyrelu"&&(te=[{type:"float32",data:[a]}],X.uniforms+=" alpha : f32,");const fe=i.runWebGPUProgram(X,se,P.dtype,te);v.push(P);const me=bt({inputs:{x:fe},backend:i,attrs:{shape:x}});v.push(fe);for(const Te of v)i.disposeData(Te.dataId);return me}break}case na.MatMulSmallOutputSizeProgram:D=new s_e(C,w,L,t,s,r,l,o);break;case na.MatMulPackedProgram:const V=i.adapterInfo.isIntel();D=new Z2e(C,L,t,s,r,l,o,V);break;default:throw new Error(`Unsupported MatMulProgramType ${z}.`)}r&&_.push(r),o&&_.push(o),l==="leakyrelu"&&(N.push({type:"float32",data:[a]}),D.uniforms+=" alpha : f32,"),P=i.runWebGPUProgram(D,_,n.dtype,N,P);const q=bt({inputs:{x:P},backend:i,attrs:{shape:x}});v.push(P);for(const V of v)i.disposeData(V.dataId);return q}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c_e(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s;return Ow({a:i,b:r,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const u_e={kernelName:ip,backendName:"webgpu",kernelFunc:c_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZR{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Mt(t,s),this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${XB(this.op,!1)}
      }

      ${Ye("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rI{constructor(e,t,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Mt(t,s),this.dispatchLayout=at(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const i=t.length>0&&t[t.length-1]%4===0,r=s.length>0&&s[s.length-1]%4===0;i&&r?(this.outputComponent=4,this.variableComponents=[4,4]):i&&(ZS(s)||s[s.length-1]===1)||r&&(ZS(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=i?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${XB(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const i=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${i}];`:`let a = sharedBuf[${i}];
          let b = getBByOutputIndex(index);`;e=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ye("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${r}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${s}
       ${Ye("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vr(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const h_e={kernelName:ph,backendName:"webgpu",kernelFunc:vr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sd(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.makeTensorInfo(s.shape,"complex64"),o=t.tensorMap.get(r.dataId),a=vr({inputs:{x:s},backend:t}),l=vr({inputs:{x:i},backend:t});return o.complexTensorInfos={real:a,imag:l},r}const d_e={kernelName:yA,backendName:"webgpu",kernelFunc:sd};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class em{constructor(e,t,s=""){this.variableNames=["A"],this.size=!0;const i=128;this.workgroupSize=[i,1,1],this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${zc(this.op,!1)}
      }
      ${Ye("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fn({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:s,backend:i})=>{const{x:r}=s,o=i,a=t||r.dtype;if(o.shouldExecuteOnCPU([r])&&e!=null){const c=o.tensorMap.get(r.dataId),u=e(c.values,a);return o.makeTensorInfo(r.shape,a,u)}const l=new em(r.shape,n);return o.runWebGPUProgram(l,[r],a)}}function js({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:s}){return({inputs:i,backend:r})=>{const{a:o,b:a}=i,l=r;if(t&&o.dtype==="complex64"){const h=l.tensorMap.get(o.dataId),d=l.tensorMap.get(a.dataId);let p,f;if(n!==Pt.MUL)[p,f]=[[h.complexTensorInfos.real,d.complexTensorInfos.real],[h.complexTensorInfos.imag,d.complexTensorInfos.imag]].map(m=>{const[A,y]=m,b={dataId:A.dataId,dtype:A.dtype,shape:o.shape},x={dataId:y.dataId,dtype:y.dtype,shape:a.shape},C=new rI(n,o.shape,a.shape);return l.runWebGPUProgram(C,[b,x],Ns(A.dtype,y.dtype))});else{const m=new ZR(Pt.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),A=new ZR(Pt.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),y=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:o.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:a.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:a.shape}];p=l.runWebGPUProgram(m,y,"float32"),f=l.runWebGPUProgram(A,y,"float32")}const g=sd({inputs:{real:p,imag:f},backend:l});return l.disposeData(p.dataId),l.disposeData(f.dataId),g}const c=s||Ns(o.dtype,a.dtype);if((o.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([o,a]))&&e!=null){const h=l.tensorMap.get(o.dataId).values,d=l.tensorMap.get(a.dataId).values,p=o.dtype==="string"?Po(h):h,f=o.dtype==="string"?Po(d):d,[g,m]=e(o.shape,a.shape,p,f,c);return l.makeTensorInfo(m,c,g)}const u=new rI(n,o.shape,a.shape);return l.runWebGPUProgram(u,[o,a],c)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:p_e,castImpl:f_e,ceilImpl:m_e,concatImpl:g_e,equalImpl:A_e,expImpl:y_e,expm1Impl:x_e,floorImpl:b_e,floorDivImpl:I_e,gatherNdImpl:C_e,gatherV2Impl:w_e,greaterEqualImpl:v_e,greaterImpl:S_e,lessEqualImpl:E_e,lessImpl:__e,logImpl:T_e,maxImpl:B_e,maximumImpl:k_e,minimumImpl:M_e,multiplyImpl:N_e,negImpl:R_e,notEqualImpl:D_e,prodImpl:F_e,rangeImpl:$_e,rsqrtImpl:P_e,scatterImpl:L_e,simpleAbsImpl:O_e,sliceImpl:z_e,stridedSliceImpl:U_e,stringNGramsImpl:Q_e,subImpl:V_e,tileImpl:G_e,topKImpl:W_e,transposeImpl:H_e}=kB;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q_e=fn({opType:qe.ABS,cpuKernelImpl:O_e}),Y_e={kernelName:Tp,backendName:"webgpu",kernelFunc:q_e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X_e=fn({opType:qe.ACOS}),j_e={kernelName:qu,backendName:"webgpu",kernelFunc:X_e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K_e=fn({opType:qe.ACOSH}),J_e={kernelName:Yu,backendName:"webgpu",kernelFunc:K_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z_e=js({opType:Pt.ADD,cpuKernelImpl:p_e,supportsComplex:!0}),eTe={kernelName:cc,backendName:"webgpu",kernelFunc:Z_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tTe{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(i=>{e.push(`let v${i} = get${i}ByOutputCoords(coords);`)});const t=this.variableNames.map(i=>`v${i}`).join(" + ");return`
      ${Ye("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nTe(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return vr({inputs:{x:s[0]},backend:t});const i=s.map(a=>a.dtype).reduce((a,l)=>Ns(a,l)),r=s.map(a=>a.shape),o=new tTe(r);return t.runWebGPUProgram(o,s,i)}const sTe={kernelName:Bp,backendName:"webgpu",kernelFunc:nTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iTe{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[t[i]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){R(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Ye()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rTe{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[t[i]];this.outputShape=s,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=ds(this.outputShape.length),t=s4(this.newDim);return`
      ${Ye("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function s4(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let s=0;s<n.length;s++)t[n[s]]=`coords.${Ka(s)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ba(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{perm:r}=s,o=t,a=i.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=i.shape[r[u]];if(t.shouldExecuteOnCPU([i])){const h=o.tensorMap.get(i.dataId).values,d=H_e(h,i.shape,i.dtype,r,l);return t.makeTensorInfo(l,i.dtype,d)}if(i.shape.length===2&&qt(r,[1,0])){const u=new iTe(i.shape,r);return o.runWebGPUProgram(u,[i],i.dtype)}const c=new rTe(i.shape,r);return o.runWebGPUProgram(c,[i],i.dtype)}const oTe={kernelName:Ol,backendName:"webgpu",kernelFunc:ba};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aTe{constructor(e,t,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[i]=ps(this.inputShape,[1]);this.outputShape=i.length===0?[1]:i,e.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const i=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ye("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${i}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lTe={mean:"float32",all:"bool",any:"bool"};function id(n,e,t,s,i){const r=n.shape.length,o=[],a=Vt(e,n.shape);let l=a;const c=Nn(l,r);let u=n;c!=null&&(u=ba({inputs:{x:n},attrs:{perm:c},backend:i}),l=Vn(l.length,r),o.push(u)),vs(s,l,r);const[h,d]=ps(u.shape,l);let p=h;t&&(p=us(h,a));let f;if((s==="max"||s==="prod")&&i.shouldExecuteOnCPU([u])){const g=i.tensorMap.get(u.dataId).values;switch(s){case"max":const m=B_e(g,ce(d),p,n.dtype);f=i.makeTensorInfo(p,n.dtype,m);break;case"prod":const{outVals:A,outShape:y,outDtype:b}=F_e(u.shape,u.dtype,g,l);f=i.makeTensorInfo(y,b,A);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const g=ce(d),A=ce(u.shape)/g,y={windowSize:g,inSize:g,batchSize:A,outSize:1},b=lTe[s]||hy(n.dtype),x=[{type:"int32",data:[g]}],C=new aTe(y,s,i.device.limits.maxComputeWorkgroupSizeX),w=i.runWebGPUProgram(C,[u],b,x);o.push(w),f=bt({inputs:{x:w},attrs:{shape:p},backend:i})}return o.forEach(g=>i.disposeData(g.dataId)),f}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{keepDims:r,axis:o}=s;return id(i,o,r,"all",t)}const uTe={kernelName:hA,backendName:"webgpu",kernelFunc:cTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{keepDims:r,axis:o}=s;return id(i,o,r,"any",t)}const dTe={kernelName:dA,backendName:"webgpu",kernelFunc:hTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i4{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[t];this.op=s==="min"?"<":">";const[r,o]=ps(e,i);this.outputShape=r.length===0?[1]:r,this.dispatchLayout=at(this.outputShape),ce(o)<32?(this.type="plain",this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Xe(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Ka(this.inputShape.length-1)}`,s=()=>{let i="";if(this.outputShape.length===1)this.inputShape.length!==1&&(i+="outputCoords,");else for(let r=0;r<this.outputShape.length;r++)i+=`outputCoords.${Ka(r)},`;return i};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Ye("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Vt(r,i.shape);const a=Nn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=ba({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Vn(o.length,l.shape.length)),vs("argMax",[o[0]],l.shape.length);const u=new i4(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(p=>t.disposeData(p.dataId)),d}const fTe={kernelName:kp,backendName:"webgpu",kernelFunc:pTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Vt(r,i.shape);const a=Nn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=ba({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Vn(o.length,l.shape.length)),vs("argMin",[o[0]],l.shape.length);const u=new i4(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(p=>t.disposeData(p.dataId)),d}const gTe={kernelName:Mp,backendName:"webgpu",kernelFunc:mTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ATe=fn({opType:qe.ASIN}),yTe={kernelName:Xu,backendName:"webgpu",kernelFunc:ATe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xTe=fn({opType:qe.ASINH}),bTe={kernelName:ju,backendName:"webgpu",kernelFunc:xTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ITe=fn({opType:qe.ATAN}),CTe={kernelName:Ku,backendName:"webgpu",kernelFunc:ITe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wTe=js({opType:Pt.ATAN2}),vTe={kernelName:Zu,backendName:"webgpu",kernelFunc:wTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const STe=fn({opType:qe.ATANH}),ETe={kernelName:Ju,backendName:"webgpu",kernelFunc:STe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Te{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gg{constructor(e,t,s=!1,i=!1,r=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=r,this.shaderKey=`pool2D_${t}_${s}_${i}_${r}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class KB{constructor(e,t,s=!1,i=!1,r=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=r,this.shaderKey=`pool3D_${t}_${s}_${i}_${r}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r4(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:o}=s;return id(i,r,o,"max",t)}const TTe={kernelName:nf,backendName:"webgpu",kernelFunc:r4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o4(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{keepDims:r,axis:o}=s;return id(i,o,r,"mean",t)}const BTe={kernelName:of,backendName:"webgpu",kernelFunc:o4};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a4(n,e,t,s){if(e.filterWidth===1&&e.filterHeight===1&&qt(e.inShape,e.outShape))return vr({inputs:{x:n},backend:s});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const o=n.shape.length,a=bt({inputs:{x:n},backend:s,attrs:{shape:[n.shape[o-3]*n.shape[o-2],n.shape[o-1]]}});let l;t==="avg"?l=o4({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(R(t==="max",()=>`Invalid pool type ${t}`),l=r4({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const c=bt({inputs:{x:l},backend:s,attrs:{shape:e.outShape}});return s.disposeData(a.dataId),s.disposeData(l.dataId),c}let i;const r=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?i=new _Te(e):(t==="avg"?i=new Gg(e,"avg"):(R(t==="max",()=>`Invalid pool type ${t}`),i=new Gg(e,"max")),r.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),s.runWebGPUProgram(i,[n],n.dtype,r)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,u=mi(i.shape,r,o,1,a,l);return a4(i,u,"avg",t)}const MTe={kernelName:Np,backendName:"webgpu",kernelFunc:kTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],h=Xr(i.shape,r,o,u,a,c,l),d=new KB(h,"avg"),p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(d,[i],i.dtype,p)}const RTe={kernelName:Rp,backendName:"webgpu",kernelFunc:NTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DTe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class FTe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Te(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,h=Xr(o.shape,a,l,1,c,u),d=new FTe(h),p=1/(h.filterDepth*h.filterHeight*h.filterWidth),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[p]}];return t.runWebGPUProgram(d,[i],o.dtype,f)}const PTe={kernelName:fA,backendName:"webgpu",kernelFunc:$Te};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LTe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r;t4([i,r],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,u=mi(o.shape,a,l,1,c),h=new DTe(u),d=1/(u.filterHeight*u.filterWidth),p=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.effectiveFilterHeight-1-u.padInfo.top,u.effectiveFilterWidth-1-u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"float32",data:[d]}];return t.runWebGPUProgram(h,[i],o.dtype,p)}const OTe={kernelName:pA,backendName:"webgpu",kernelFunc:LTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zTe(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:o,transposeB:a}=s;return Ow({a:i,b:r,transposeA:o,transposeB:a,backend:t})}const UTe={kernelName:Dp,backendName:"webgpu",kernelFunc:zTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QTe{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${ds(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=ds(this.rank),t=VTe(this.rank);let s;return this.start.length===1?s=this.outputShape.map((r,o)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((r,o)=>`sourceLoc.${j1[o]} = uniforms.start.${Ka(o)} + coords.${j1[o]};`),`
      ${Ye("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const j1=["x","y","z","w","u","v"];function VTe(n){if(n===1)return"sourceLoc";if(n<=6)return j1.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tm(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:o}=s,[a,l]=Ry(i,r,o);if(GC(i,a,l),t.shouldExecuteOnCPU([i])||i.dtype==="string"){const h=t.tensorMap.get(i.dataId),d=z_e(h.values,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,d)}if(ce(l)===0)return t.makeTensorInfo(l,i.dtype,[]);const c=new QTe(a,l),u=[{type:"int32",data:a}];return t.runWebGPUProgram(c,[i],i.dtype,u)}const GTe={kernelName:Cf,backendName:"webgpu",kernelFunc:tm};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WTe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:o}=s;R(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=r.reduce((y,b)=>y*b),l=Hh(i.shape,r,a),c=qh(l.length,r.length),u=Yh(i.shape,r,a),h=jC(o,r.length),d=KC(u,o,r.length),p=[],f=bt({inputs:{x:i},backend:t,attrs:{shape:l}}),g=ba({inputs:{x:f},backend:t,attrs:{perm:c}}),m=bt({inputs:{x:g},backend:t,attrs:{shape:u}}),A=tm({inputs:{x:m},backend:t,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach(y=>t.disposeData(y.dataId)),A},HTe={kernelName:Fp,backendName:"webgpu",kernelFunc:WTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qTe=`
  fn bincount_write(index: i32, value: f32) {
    ${Ac("&result[index]","value","float32")}
  }
`,YTe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class l4{constructor(e,t,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?YTe:qTe}
  ${Ye("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o}=s,a=ce(i.shape),c=ce(r.shape)>0,u=[o],h=r.dtype,d=er({backend:t,attrs:{shape:u,value:0,dtype:h}}),p=new l4([a],c),f=[{type:"int32",data:[o]}],g=c?[i,r]:[i];return t.runWebGPUProgram(p,g,h,f,d)}const jTe={kernelName:mA,backendName:"webgpu",kernelFunc:XTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KTe{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Ye("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JTe(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e;if(t.shouldExecuteOnCPU([s,i])){const u=t.tensorMap.get(s.dataId),h=t.tensorMap.get(i.dataId),d=u.values,p=h.values,f=Mt(Array.from(d),Array.from(p));return t.makeTensorInfo([f.length],"int32",Int32Array.from(f))}const r=ce(s.shape),o=ce(i.shape),a=Math.max(r,o),l=new KTe(a),c=[{type:"int32",data:[r]},{type:"int32",data:[o]}];return t.runWebGPUProgram(l,[s,i],"int32",c)}const ZTe={kernelName:AA,backendName:"webgpu",kernelFunc:JTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c4=js({opType:Pt.NOT_EQUAL,dtype:"bool",cpuKernelImpl:D_e}),eBe={kernelName:uf,backendName:"webgpu",kernelFunc:c4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jy(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.tensorMap.get(s.dataId);return vr({inputs:{x:i.complexTensorInfos.real},backend:t})}const tBe={kernelName:qA,backendName:"webgpu",kernelFunc:Jy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nBe(n,e){const t=new em(n.shape,qe.TO_INT),s=e.runWebGPUProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return vr({inputs:{x:i},backend:t});const o=as(i.shape),a=K1({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=sd({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeData(a.dataId),l}if(i.dtype==="complex64"){const o=Jy({inputs:{input:i},backend:t}),a=K1({inputs:{x:o},backend:t,attrs:{dtype:r}});return t.disposeData(o.dataId),a}if(!YI(i.dtype,r)){const o=vr({inputs:{x:i},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:r}}if(t.shouldExecuteOnCPU([i])){const o=t.tensorMap.get(i.dataId).values,[a,l,c]=f_e(o,i.shape,i.dtype,r);return t.makeTensorInfo(a,l,c)}if(r==="int32")return nBe(i,t);if(r==="bool"){const o=t.makeTensorInfo([],"bool",Cs("bool",1)),l=c4({inputs:{a:i,b:o},backend:t});return t.disposeData(o.dataId),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}const sBe={kernelName:eh,backendName:"webgpu",kernelFunc:K1};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iBe=fn({opType:qe.CEIL,cpuKernelImpl:m_e}),rBe={kernelName:th,backendName:"webgpu",kernelFunc:iBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oBe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Ye("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aBe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Ye("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{clipValueMin:r,clipValueMax:o}=s;let a;const l=[{type:"float32",data:[r]},{type:"float32",data:[o]}];return ce(i.shape)%4===0?a=new oBe(i.shape):a=new aBe(i.shape),t.runWebGPUProgram(a,[i],i.dtype,l)}const cBe={kernelName:nh,backendName:"webgpu",kernelFunc:lBe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uBe{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Ye("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eD(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function hBe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=t.tensorMap.get(s.dataId),r=new uBe(s.shape),o=[eD(s,i.complexTensorInfos.real),eD(s,i.complexTensorInfos.imag)];return t.runWebGPUProgram(r,o,o[0].dtype)}const dBe={kernelName:$p,backendName:"webgpu",kernelFunc:hBe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pBe{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=Zi(e,1),this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let r=1;r<this.offsetLength;r++)e.push(`else if (yC < uniforms.offset${[r]}){ setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${r-1})); }`);const s=this.offsetLength,i=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${i})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Ye("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.tensorMap.get(s.dataId);return vr({inputs:{x:i.complexTensorInfos.imag},backend:t})}const fBe={kernelName:PA,backendName:"webgpu",kernelFunc:zw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Um(n,e,t){const s=n[0].dtype;if(s==="complex64"){const f=n.map(b=>Jy({inputs:{input:b},backend:t})),g=n.map(b=>zw({inputs:{input:b},backend:t})),m=Um(f,e,t),A=Um(g,e,t),y=sd({inputs:{real:m,imag:A},backend:t});return f.forEach(b=>t.disposeData(b.dataId)),g.forEach(b=>t.disposeData(b.dataId)),t.disposeData(m.dataId),t.disposeData(A.dataId),y}let i=t.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const f=n.map(C=>{const E=[-1,ce(C.shape.slice(e))];return bt({inputs:{x:C},backend:t,attrs:{shape:E}})}),g=f.map(C=>({vals:t.readSync(C.dataId),shape:C.shape})),m=Zi(f.map(C=>C.shape),1),A=f[0].shape[0]===1,y=g_e(g,m,s,A),b=Zi(n.map(C=>C.shape),e),x=t.makeTensorInfo(b,s,y);return f.forEach(C=>t.disposeData(C.dataId)),x}const r=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>r){const f=[];for(let m=0;m<n.length;m+=r){const A=n.slice(m,m+r);f.push(Um(A,e,t))}const g=Um(f,e,t);for(const m of f)t.disposeData(m.dataId);return g}const{tensors2D:o,outShape:a}=mBe(n,e,t),l=o.map(f=>f.shape),c=new pBe(l),u=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],u.push({type:"int32",data:[h[0]]});for(let f=1;f<h.length;f++)h[f]=h[f-1]+l[f][1],u.push({type:"int32",data:[h[f]]})}const d=t.runWebGPUProgram(c,o,o[0].dtype,u);o.forEach(f=>t.disposeData(f.dataId));const p=bt({inputs:{x:d},backend:t,attrs:{shape:a}});return t.disposeData(d.dataId),p}function mBe(n,e,t){const s=Zi(n.map(r=>r.shape),e);return{tensors2D:n.map(r=>bt({inputs:{x:r},backend:t,attrs:{shape:[ce(r.shape.slice(0,e)),ce(r.shape.slice(e))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=Vt(i,e[0].shape)[0],o=e.map(c=>c.shape);qC(o,r);const a=Zi(e.map(c=>c.shape),r);if(ce(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>ce(c.shape)>0);return l.length===1?vr({inputs:{x:l[0]},backend:t}):Um(l,r,t)}const gBe={kernelName:Pp,backendName:"webgpu",kernelFunc:u4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ABe(n,e,t,s,i=!1,r=null,o=!1,a=4,l=4,c=4){const u=v=>{switch(v){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${v} is not supported.`)}},h=v=>{switch(v){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${v} is not supported.`)}},d=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,p=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,f=n?"uniforms.xShape[1]":"uniforms.xShape[2]",g=n?"uniforms.xShape[2]":"uniforms.xShape[3]",m=n?"row":"col",A=n?"col":"row",y=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${m} / outWidth;
      let outCol = ${m} % outWidth;

      let WRow = ${A} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${A} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${A} % inChannels;
      var resData = ${Zt(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${g}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${u(a)}
      }
      return resData;`,b=n?e&&s?`
      ${y}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${y}
      }
      return ${Zt(a)}(0.0);`:s&&t?`
      ${y}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${y}
      }
      return ${Zt(a)}(0.0);`,x=`${h(l)}`,C=Zt(c),w=Zt(n?a:l),E=Zt(n?l:a);return`
      ${gl(r,o,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${w} {
        ${n?b:x}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${E} {
        ${n?x:b}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${C}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${p}
        ${nd(i,r)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class yBe{constructor(e,t,s,i,r=!1,o=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=JQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ZQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),r&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=r,this.activation=o,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=i%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?Pw(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Lw(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${ABe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xBe{constructor(e,t=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=s,this.hasPreluActivationWeights=i,t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${gl(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${nd(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Ye("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bBe{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",r=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Ye("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${i};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${r};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oI(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function IBe({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.dataFormat==="channelsLast",c=!l,u=!1,h=l&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",d=[];let p,f;if(h){const A=t.inHeight*t.inWidth*t.inChannels;p=bt({inputs:{x:n},backend:s,attrs:{shape:[1,t.batchSize,A]}}),f=bt({inputs:{x:e},backend:s,attrs:{shape:[1,A,t.outChannels]}})}else p=bt({inputs:{x:n},backend:s,attrs:{shape:l?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),f=bt({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(d.push(p),d.push(f),r!=null){const A=oI(r.shape,l);A!=null&&(r=bt({inputs:{x:r},backend:s,attrs:{shape:A}}),d.push(r))}if(i!=null){const A=oI(i.shape,l);A!=null&&(i=bt({inputs:{x:i},backend:s,attrs:{shape:A}}),d.push(i))}const g=Ow({a:l?p:f,b:l?f:p,transposeA:c,transposeB:u,backend:s,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o}),m=bt({inputs:{x:g},backend:s,attrs:{shape:t.outShape}});d.push(g);for(const A of d)s.disposeData(A.dataId);return m}function CBe({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,strideWidth:h,strideHeight:d,padInfo:p,outWidth:f,outHeight:g,dilationWidth:m,dilationHeight:A,dataFormat:y}=t,b=y==="channelsLast",x=l*c*u,C=g*f,w=b?[t.batchSize,C,x]:[t.batchSize,x,C],E=new bBe(w,b),T=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[d,h]},{type:"int32",data:[A,m]},{type:"int32",data:[f]},{type:"int32",data:[u*l]},{type:"int32",data:[u]}],v=s.runWebGPUProgram(E,[n],n.dtype,T),S=[];S.push(v);const _=bt({inputs:{x:e},backend:s,attrs:{shape:[1,x,-1]}});if(S.push(_),r!=null){const z=oI(r.shape,b);z!=null&&(r=bt({inputs:{x:r},backend:s,attrs:{shape:z}}),S.push(r))}if(i!=null){const z=oI(i.shape,b);z!=null&&(i=bt({inputs:{x:i},backend:s,attrs:{shape:z}}),S.push(i))}const P=Ow({a:b?v:_,b:b?_:v,transposeA:!b,transposeB:!1,backend:s,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o}),L=bt({inputs:{x:P},backend:s,attrs:{shape:t.outShape}});S.push(P);for(const z of S)s.disposeData(z.dataId);return L}function h4({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const l=i!=null,c=r!=null,u=t.dataFormat==="channelsLast",h=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",d=ae().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!d&&(h||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return IBe({x:n,filter:e,convInfo:t,backend:s,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o});const p=ae().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),f=p>-1?p:s.thresholdToIncreaseWorkgroups,g=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(ae().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=f)return CBe({x:n,filter:e,convInfo:t,backend:s,bias:i,preluActivationWeights:r,leakyreluAlpha:o,activation:a});let m;const A=[t.padInfo.top,t.padInfo.left],y=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...A]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(d)m=new xBe(t,l,a,c);else{const w=u?t.outHeight*t.outWidth:t.outChannels,E=u?t.outChannels:t.outHeight*t.outWidth,T=t.filterHeight*t.filterWidth*t.inChannels;y.push({type:"int32",data:[w]},{type:"int32",data:[E]},{type:"int32",data:[T]});const v=s.adapterInfo.isIntel();m=new yBe(t,w,E,T,l,a,c,v)}const b=[],x=[n,e];l&&(!u&&i.shape.length===1&&(i=bt({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),b.push(i)),x.push(i)),c&&(!u&&r.shape.length===1&&(r=bt({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),b.push(r)),x.push(r)),a==="leakyrelu"&&(y.push({type:"float32",data:[o]}),m.uniforms+=" alpha : f32,");const C=s.runWebGPUProgram(m,x,n.dtype,y);for(const w of b)s.disposeData(w.dataId);return C}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wBe(n){const{inputs:e,attrs:t,backend:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=t,h=Er(l),d=Qn(i.shape,r.shape,o,c,a,u,!1,h);return h4({x:i,filter:r,convInfo:d,backend:s})}const vBe={kernelName:Lp,backendName:"webgpu",kernelFunc:wBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SBe{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,i=`
    ${Ye()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${i}
    `:`
    ${Ye("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class EBe{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Ye("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class _Be{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Ye("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class TBe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Ye("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s,h=Er(l),d=Qn(i.shape,u,o,1,a,c,!1,h),p=new EBe(d),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return t.runWebGPUProgram(p,[i,r],i.dtype,f)}const kBe={kernelName:xA,backendName:"webgpu",kernelFunc:BBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MBe(n=4){const e=r=>{switch(r){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${r} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Zt(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Zt(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${Zt(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Zt(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Zt(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${Zt(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Zt(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class NBe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,R(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=JQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ZQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?Pw(this.elementsPerThread,this.workgroupSize):Lw(this.elementsPerThread,this.workgroupSize);return`
    ${MBe(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RBe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s,h=Er(c),d=Qn(o,r.shape,a,1,l,u,!1,h),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let f;if(ae().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||d.dataFormat!=="channelsLast")f=new SBe(d);else{f=new NBe(d);const g=d.inHeight*d.inWidth,m=d.inChannels,A=d.filterHeight*d.filterWidth*d.outChannels;p.push({type:"uint32",data:[g]},{type:"uint32",data:[m]},{type:"uint32",data:[A]})}return t.runWebGPUProgram(f,[i,r],"float32",p)}const DBe={kernelName:Op,backendName:"webgpu",kernelFunc:RBe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FBe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Be(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=Wo(i.shape,r.shape,o,l,a),u=[c.padInfo.front,c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],d=new FBe(c),p=Ns(i.dtype,r.dtype);return t.runWebGPUProgram(d,[i,r],p,h)}const PBe={kernelName:zp,backendName:"webgpu",kernelFunc:$Be};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,filterShape:l}=s,c=Wo(i.shape,l,o,1,a),u=new _Be(c),h=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return t.runWebGPUProgram(u,[i,r],r.dtype,h)}const OBe={kernelName:bA,backendName:"webgpu",kernelFunc:LBe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zBe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,pad:a,inputShape:l}=s,c=Wo(l,r.shape,o,1,a),u=new TBe(c),h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return t.runWebGPUProgram(u,[i,r],i.dtype,h)}const UBe={kernelName:IA,backendName:"webgpu",kernelFunc:zBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QBe=fn({opType:qe.COS}),VBe={kernelName:sh,backendName:"webgpu",kernelFunc:QBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GBe=fn({opType:qe.COSH}),WBe={kernelName:ih,backendName:"webgpu",kernelFunc:GBe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HBe{constructor(e,t,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[r]=t;this.outputShape=[r,s[0],s[1],e],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=i==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,i,r]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[o,a,l]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${i};
        let width_scale = ${a};
        let in_y = ${r};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qBe=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,u=new HBe(i.shape[3],r.shape,a,l),h=[{type:"float32",data:[c]}];return t.runWebGPUProgram(u,[i,r,o],"float32",h)},YBe={kernelName:wA,backendName:"webgpu",kernelFunc:qBe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Wg;(function(n){n.Prod="*",n.Sum="+"})(Wg||(Wg={}));class tD{constructor(e,t,s,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=i,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===Wg.Prod?"1.0":"0.0",s=this.exclusive?t:`getX(${nD(e,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let r="",o="";return this.exclusive?(r=this.reverse?`end != ${i-1}`:"end != 0",o=this.reverse?"end + 1":"end - 1"):(r=this.reverse?`end + pow2 < ${i}`:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),`
      ${Ye("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${sD(e,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${r}) {
           let idx = ${o};
           ${sD(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${nD(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function nD(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function sD(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d4(n,e,t,s,i,r){const o=e.shape.length,a=Nn([s],o);let l=e;a!=null&&(l=ba({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=Vn(1,o)[0];if(c!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const u=l.shape[c];let h=vr({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const p=new tD(n,l.shape,!1,r),f=h,g=[{type:"float32",data:[d]}];h=t.runWebGPUProgram(p,[h],h.dtype,g),t.disposeData(f.dataId)}if(i){const d=new tD(n,l.shape,i,r),p=h,f=[{type:"float32",data:[0]}];h=t.runWebGPUProgram(d,[h],h.dtype,f),t.disposeData(p.dataId)}if(a!=null){const d=Sa(a),p=ba({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeData(h.dataId),t.disposeData(l.dataId),p}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return d4(Wg.Prod,i,t,r,o,a)}const jBe={kernelName:CA,backendName:"webgpu",kernelFunc:XBe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return d4(Wg.Sum,i,t,r,o,a)}const JBe={kernelName:Up,backendName:"webgpu",kernelFunc:KBe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o,binaryOutput:a}=s,l=i.shape.length===1,u=ce(r.shape)>0,h=r.dtype,d=l?[i.shape[0]]:[i.shape[0],i.shape[1]],p=l?[o]:[i.shape[0],o],f=er({backend:t,attrs:{shape:p,value:0,dtype:h}}),g=new l4(d,u,a),m=[{type:"int32",data:[o]}],A=u?[i,r]:[i];return t.runWebGPUProgram(g,A,h,m,f)}const eke={kernelName:vA,backendName:"webgpu",kernelFunc:ZBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tke{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nke(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:o}=s,a=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],u=o==="NHWC"?i.shape[3]:i.shape[1],h=l*r,d=c*r,p=u/(r*r),f=o==="NHWC"?[a,h,d,p]:[a,p,h,d],g=[{type:"int32",data:[r]}],m=new tke(f,o);return t.runWebGPUProgram(m,[i],i.dtype,g)}const ske={kernelName:SA,backendName:"webgpu",kernelFunc:nke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ike{constructor(e,t,s,i=!1,r=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=r,this.hasPreluActivation=o,this.filterHeight=t,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`
      ${gl(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Ye()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${nd(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p4{constructor(e,t=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const r=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=at(r),this.dispatch=Xe(this.dispatchLayout,r,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),R(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${gl(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Ye("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${nd(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f4{constructor(e,t=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${gl(this.activation,this.hasPreluActivation,!1,4)}

      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${nd(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rke(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s,h=Er(l);let d=c;d==null&&(d=[1,1]);const p=Qn(i.shape,r.shape,o,d,a,u,!0,h),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],g=p.dataFormat==="channelsLast";let m;return!g&&p.inHeight>16&&p.inWidth>16&&p.strideHeight===1&&p.strideWidth===1&&p.dilationWidth===1&&p.dilationHeight===1&&p.inChannels===p.outChannels?m=new ike(p.outShape,p.filterHeight,p.filterWidth):g&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&p.dilationHeight===1&&p.dilationWidth===1&&p.inChannels%4===0?(m=new p4(p),f.push({type:"int32",data:[m.virtualWidth]})):(m=new f4(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),t.runWebGPUProgram(m,[i,r],i.dtype,f)}const oke={kernelName:Qp,backendName:"webgpu",kernelFunc:rke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ake{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class lke{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cke(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s,h=Qn(i.shape,u,o,a,l,c,!0),d=new ake(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(d,[i,r],"float32",p)}const uke={kernelName:EA,backendName:"webgpu",kernelFunc:cke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hke(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s,h=Qn(u,r.shape,o,a,l,c,!0),d=new lke(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(d,[i,r],i.dtype,p)}const dke={kernelName:_A,backendName:"webgpu",kernelFunc:hke};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pke{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fke(n){const{inputs:e,backend:t}=n,{x:s}=e,i=[...s.shape,...s.shape],r=ce(s.shape),o=bt({inputs:{x:s},backend:t,attrs:{shape:[r]}}),a=new pke(r),l=t.runWebGPUProgram(a,[o],o.dtype),c=bt({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const mke={kernelName:TA,backendName:"webgpu",kernelFunc:fke};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gke{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Ye("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ake(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=dc(i.shape,r.shape,o,a,"NHWC",l),u=[c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],d=new gke(c);return t.runWebGPUProgram(d,[i,r],i.dtype,h)}const yke={kernelName:Vp,backendName:"webgpu",kernelFunc:Ake};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xke{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=at(e.outShape),this.dispatch=Xe(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Ye("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Ac("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class bke{constructor(e,t,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=at(e.outShape),this.dispatch=Xe(this.dispatchLayout,e.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Ye("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Ac("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ike(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,dy:o}=e,{strides:a,pad:l,dilations:c}=s,u=dc(i.shape,r.shape,a,l,"NHWC",c),h=r.dtype,d=new bke(u,r.shape,h),p=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[ce(u.outShape)]}],f=er({backend:t,attrs:{shape:r.shape,value:0,dtype:h}});return t.runWebGPUProgram(d,[i,r,o],h,p,f)}const Cke={kernelName:Eg,backendName:"webgpu",kernelFunc:Ike};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wke(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,dy:o}=e,{strides:a,pad:l,dilations:c}=s,u=dc(i.shape,r.shape,a,l,"NHWC",c),h=i.dtype,d=new xke(u,h),p=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[ce(u.outShape)]}],f=er({backend:t,attrs:{shape:u.inShape,value:0,dtype:h}});return t.runWebGPUProgram(d,[i,r,o],h,p,f)}const vke={kernelName:Sg,backendName:"webgpu",kernelFunc:wke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ske{constructor(e,t,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=Ip.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=s,this.shaderKey=`draw_${t}_${s}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Ye("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eke(n){const{inputs:e,backend:t,attrs:s}=n,{image:i}=e,{canvas:r,options:o}=s,[a,l]=i.shape.slice(0,2),{imageOptions:c}=o||{},u=c?.alpha||1,h=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[a,l],p=new Ske(d,i.dtype,h);r.width=l,r.height=a;const f="webgpu";let g=r.getContext(f),m;g||(m=new OffscreenCanvas(l,a),g=m.getContext(f));const A=i.shape.length===3?i.shape[2]:1;g.configure({device:t.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const y="int32",b=t.makeTensorInfo(d,y),x=t.tensorMap.get(b.dataId);x.resource=g.getCurrentTexture(),x.external=!0;const C=[{type:"uint32",data:[A]},{type:"float32",data:[u]}];if(t.runWebGPUProgram(p,[i],y,C,b),m){const w=r.getContext("2d");if(!w)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");w.drawImage(m,0,0)}return t.disposeData(b.dataId),i}const _ke={kernelName:BA,backendName:"webgpu",kernelFunc:Eke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m4=js({opType:Pt.MUL,cpuKernelImpl:N_e,supportsComplex:!0}),Tke={kernelName:Ch,backendName:"webgpu",kernelFunc:m4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g4(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;return id(i,r,o,"sum",t)}const Bke={kernelName:wf,backendName:"webgpu",kernelFunc:g4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kke(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:o,summedDims:a,idDims:l}=iw(i,r.length);ow(o.length,l,r);const{path:c,steps:u}=aw(a,l),h=u.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const m of u[g]){const{permutationIndices:A,expandDims:y}=rw(p,l[m]);let b;lw(A)?b=r[m]:(b=ba({inputs:{x:r[m]},backend:t,attrs:{perm:A}}),f.push(b));const x=b.shape.slice();for(let C=0;C<y.length;++C)x.splice(y[C],0,1);qt(b.shape,x)||(b=bt({inputs:{x:b},backend:t,attrs:{shape:x}}),f.push(b)),d===null?d=b:(d=m4({inputs:{a:b,b:d},backend:t}),f.push(d))}g<h-1&&(c[g]>=0&&(d=g4({inputs:{x:d},backend:t,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeData(g.dataId);return d}const Mke={kernelName:kA,backendName:"webgpu",kernelFunc:kke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nke=fn({opType:qe.ELU}),Rke={kernelName:oh,backendName:"webgpu",kernelFunc:Nke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dke=n=>{const{inputs:e,backend:t}=n,{dy:s,y:i}=e,r=new rI(Pt.ELU_DER,s.shape,i.shape);return t.runWebGPUProgram(r,[s,i],s.dtype)},Fke={kernelName:MA,backendName:"webgpu",kernelFunc:Dke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ke=js({opType:Pt.EQUAL,dtype:"bool",cpuKernelImpl:A_e}),Pke={kernelName:Gp,backendName:"webgpu",kernelFunc:$ke};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lke=fn({opType:qe.ERF}),Oke={kernelName:ah,backendName:"webgpu",kernelFunc:Lke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zke=fn({opType:qe.EXP,cpuKernelImpl:y_e,dtype:"float32"}),Uke={kernelName:lh,backendName:"webgpu",kernelFunc:zke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1(n){const{inputs:e,attrs:t,backend:s}=n,{dim:i}=t,{input:r}=e,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(R(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),bt({inputs:{x:r},backend:s,attrs:{shape:a}})}const Qke={kernelName:Wp,backendName:"webgpu",kernelFunc:J1};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vke=fn({opType:qe.EXPM1,cpuKernelImpl:x_e}),Gke={kernelName:ch,backendName:"webgpu",kernelFunc:Vke};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iD{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A4(n,e,t){const s=t.tensorMap.get(n.dataId),i=ce(n.shape),r=n.shape[n.shape.length-1],o=i/r,a=[],l=bt({inputs:{x:n},backend:t,attrs:{shape:[o,r]}});a.push(l);const c=l.shape,u=new iD("real",c),h=new iD("imag",c),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],p=e?2*Math.PI:-2*Math.PI,f=e?c[1]:1,g=[{type:"float32",data:[p]},{type:"float32",data:[f]}],m=t.runWebGPUProgram(u,d,"float32",g);a.push(m);const A=t.runWebGPUProgram(h,d,"float32",g);a.push(A);const y=sd({inputs:{real:m,imag:A},backend:t});a.push(y);const b=bt({inputs:{x:y},backend:t,attrs:{shape:n.shape}});return a.forEach(x=>t.disposeData(x.dataId)),b}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wke(n){const{inputs:e,backend:t}=n,{input:s}=e;return A4(s,!1,t)}const Hke={kernelName:NA,backendName:"webgpu",kernelFunc:Wke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qke{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yke={kernelName:DA,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,i=new qke(t.shape);return s.runWebGPUProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xke=fn({opType:qe.FLOOR,cpuKernelImpl:b_e}),jke={kernelName:uh,backendName:"webgpu",kernelFunc:Xke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kke=js({opType:Pt.FLOOR_DIV,cpuKernelImpl:I_e,dtype:"int32"}),Jke={kernelName:hh,backendName:"webgpu",kernelFunc:Kke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zke{constructor(e,t,s=!1){this.pixelsOpType=Ip.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Ye("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eMe={kernelName:_g,backendName:"webgpu",kernelFunc:tMe};let kd,hS=ae().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function tMe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:i}=e;const{numChannels:r}=s;if(i==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&i instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,[u,h]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],d=[h,u,r],p=ae().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&o,f=o||a;if(c||l||f){let y;if(p)y=t.device.importExternalTexture({source:i});else{if(f){const D=ae().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(kd==null||D!==hS)&&(hS=D,kd=document.createElement("canvas").getContext("2d",{willReadFrequently:hS})),kd.canvas.width=u,kd.canvas.height=h,kd.drawImage(i,0,0,u,h),i=kd.canvas}const S=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,N=t.textureManager.acquireTexture(d[1],d[0],"rgba8unorm",S);t.queue.copyExternalImageToTexture({source:i},{texture:N},[d[1],d[0]]),y=N}const b=ce(d),x=vt(d),C=new Zke(d,r,p),w=[{type:"uint32",data:[b]},{type:"uint32",data:[r]},{type:"uint32",data:[...x]}],E=t.makeTensorInfo([h,u],"int32"),T=t.tensorMap.get(E.dataId);T.resource=y;const v=t.runWebGPUProgram(C,[E],"int32",w);return t.disposeData(E.dataId),v}const g=i.data;let m=g;if(r!=null&&r!==4){m=new Uint8Array(i.width*i.height*r);const y=g.length;let b=0;for(let x=0;x<y;x++)x%4<r&&(m[b++]=g[x])}const A=t.makeTensorInfo(d,"int32",new Int32Array(m));return t.uploadToGPU(A.dataId),A}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nMe{constructor(e,t,s,i,r){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Mt(e,t),Mt(e,s),this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),i!=null&&(Mt(e,i),this.variableNames.push("offset")),r!=null&&(Mt(e,r),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=r,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${Ye("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sMe={kernelName:Hp,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s,scale:i,offset:r,mean:o,variance:a}=n,{varianceEpsilon:l}=e,c=t,u=[s,o,a];let h=null;r!=null&&(h=r.shape,u.push(r));let d=null;i!=null&&(d=i.shape,u.push(i));const p=new nMe(s.shape,o.shape,a.shape,h,d),f=[{type:"float32",data:[l]}];return c.runWebGPUProgram(p,u,s.dtype,f)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iMe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,g=Er(u),m=Qn(i.shape,r.shape,l,h,c,d,!1,g);return h4({x:i,filter:r,convInfo:m,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:f,activation:p})}const rMe={kernelName:rp,backendName:"webgpu",kernelFunc:iMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oMe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s;let f=u;f==null&&(f=[1,1]),R(Rs(l,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${f}'`);const g=Qn(i.shape,r.shape,l,f,c,h,!0),m=[i,r],A=o!=null,y=a!=null;A&&m.push(o),y&&m.push(a);const b=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let x;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(x=new p4(g,A,d,y),b.push({type:"int32",data:[x.virtualWidth]})):(x=new f4(g,A,d,y),b.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),d==="leakyrelu"&&(b.push({type:"float32",data:[p]}),x.uniforms+=" alpha : f32,"),t.runWebGPUProgram(x,m,"float32",b)}const aMe={kernelName:op,backendName:"webgpu",kernelFunc:oMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lMe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${ds(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cMe(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=i.shape,o=r[r.length-1],a=ce(s.shape),[l,c,u,h]=Ny(s,i),d=bt({inputs:{x:i},backend:t,attrs:{shape:[c,o]}}),p=bt({inputs:{x:s},backend:t,attrs:{shape:[ce(s.shape)/u,u]}});if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const y=t.readSync(i.dataId),b=t.bufferSync(s),x=C_e(y,b,s.dtype,c,o,u,h,s.shape,a);return t.makeTensorInfo(l,s.dtype,x.values)}const f=new lMe(o,[c,u]),g=[{type:"int32",data:[o]},{type:"int32",data:h}],m=t.runWebGPUProgram(f,[p,d],p.dtype,g),A=bt({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeData(d.dataId),t.disposeData(p.dataId),t.disposeData(m.dataId),A}const uMe={kernelName:FA,backendName:"webgpu",kernelFunc:cMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hMe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=dMe(this.aShape);return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function dMe(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let s=0;s<n.length;s++)s===2?t.push("indexZ"):t.push(`${e[s]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y4(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:o,batchDims:a}=s,l=Vt(o,i.shape)[0],c=uw(i,r,l,a),u=ce(r.shape),h=[],d=bt({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=bt({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,r])){const b=t.tensorMap.get(p.dataId).values,x=zt(p.shape,p.dtype,b),w=t.tensorMap.get(d.dataId).values,E=zt(d.shape,d.dtype,w),T=w_e(E,x,f);return h.forEach(v=>t.disposeData(v.dataId)),t.makeTensorInfo(c.outputShape,T.dtype,T.values)}const g=new hMe(d.shape,f),m=t.runWebGPUProgram(g,[d,p],d.dtype);h.push(m);const A=bt({inputs:{x:m},backend:t,attrs:{shape:c.outputShape}});return h.forEach(y=>t.disposeData(y.dataId)),A}const pMe={kernelName:qp,backendName:"webgpu",kernelFunc:y4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fMe=js({opType:Pt.GREATER,cpuKernelImpl:S_e,dtype:"bool"}),mMe={kernelName:Yp,backendName:"webgpu",kernelFunc:fMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gMe=js({opType:Pt.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:v_e}),AMe={kernelName:dh,backendName:"webgpu",kernelFunc:gMe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yMe(n){const{inputs:e,backend:t}=n,{input:s}=e;return A4(s,!0,t)}const xMe={kernelName:$A,backendName:"webgpu",kernelFunc:yMe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bMe=fn({opType:qe.IS_FINITE,dtype:"bool"}),IMe={kernelName:fh,backendName:"webgpu",kernelFunc:bMe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CMe=fn({opType:qe.IS_INF,dtype:"bool"}),wMe={kernelName:mh,backendName:"webgpu",kernelFunc:CMe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vMe=fn({opType:qe.IS_NAN,dtype:"bool"}),SMe={kernelName:gh,backendName:"webgpu",kernelFunc:vMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EMe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s,o=[{type:"float32",data:[r]}],a=new em(i.shape,qe.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[i],"float32",o)}const _Me={kernelName:Xp,backendName:"webgpu",kernelFunc:EMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TMe=js({opType:Pt.LESS,dtype:"bool",cpuKernelImpl:__e}),BMe={kernelName:jp,backendName:"webgpu",kernelFunc:TMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kMe=js({opType:Pt.LESS_EQUAL,dtype:"bool",cpuKernelImpl:E_e}),MMe={kernelName:Kp,backendName:"webgpu",kernelFunc:kMe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NMe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RMe(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,o=(i-s)/(r-1),a=new NMe(r),l=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",l)}const DMe={kernelName:LA,backendName:"webgpu",kernelFunc:RMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FMe=fn({opType:qe.LOG,cpuKernelImpl:T_e}),$Me={kernelName:Ah,backendName:"webgpu",kernelFunc:FMe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PMe=fn({opType:qe.LOG1P}),LMe={kernelName:yh,backendName:"webgpu",kernelFunc:PMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OMe=js({opType:Pt.LOGICAL_AND,dtype:"bool"}),zMe={kernelName:Jp,backendName:"webgpu",kernelFunc:OMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UMe=fn({opType:qe.LOGICAL_NOT}),QMe={kernelName:Zp,backendName:"webgpu",kernelFunc:UMe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VMe=js({opType:Pt.LOGICAL_OR}),GMe={kernelName:ef,backendName:"webgpu",kernelFunc:VMe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x4=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class WMe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${x4}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class HMe{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,R(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Xe(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Ye()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${x4}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qMe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:o,alpha:a,beta:l}=s;let c;r>16?c=new WMe(i.shape):c=new HMe(i.shape,r);const u=[{type:"int32",data:[r]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return t.runWebGPUProgram(c,[i],i.dtype,u)}const YMe={kernelName:tf,backendName:"webgpu",kernelFunc:qMe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XMe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jMe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=s,h=new XMe(i.shape),d=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[u]}];return t.runWebGPUProgram(h,[i,r,o],i.dtype,d)}const KMe={kernelName:OA,backendName:"webgpu",kernelFunc:jMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JMe=js({opType:Pt.MAX,cpuKernelImpl:k_e}),ZMe={kernelName:xh,backendName:"webgpu",kernelFunc:JMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,u=mi(i.shape,r,o,1,a,l);return a4(i,u,"max",t)}const tNe={kernelName:sf,backendName:"webgpu",kernelFunc:eNe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],h=Xr(i.shape,r,o,u,a,c,l),d=new KB(h,"max"),p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(d,[i],i.dtype,p)}const sNe={kernelName:rf,backendName:"webgpu",kernelFunc:nNe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iNe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class rNe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oNe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=Xr(o.shape,a,l,h,c,u),p=new KB(d,"max",!0);let f=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];const g=t.runWebGPUProgram(p,[o],"int32",f),m=new rNe(d);f=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const A=t.runWebGPUProgram(m,[i,g],o.dtype,f);return t.disposeData(g.dataId),A}const aNe={kernelName:UA,backendName:"webgpu",kernelFunc:oNe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lNe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:o}=e,a=r;t4([r,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=mi(a.shape,l,c,1,u,h),p=new Gg(d,"max",!0);let f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const g=t.runWebGPUProgram(p,[a],"int32",f),m=new iNe(d);f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const A=t.runWebGPUProgram(m,[i,g],a.dtype,f);return t.disposeData(g.dataId),A}const cNe={kernelName:zA,backendName:"webgpu",kernelFunc:lNe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uNe(n){const{inputs:e,backend:t,attrs:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:a}=s,{x:l}=e;R(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];R(Rs(r,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const u=mi(l.shape,i,r,c,o),h=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]}];let d=new Gg(u,"max",!1);const p=t.runWebGPUProgram(d,[l],l.dtype,h);d=new Gg(u,"max",!0,!0,a);const f=t.runWebGPUProgram(d,[l],"int32",h);return[p,f]}const hNe={kernelName:QA,backendName:"webgpu",kernelFunc:uNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;return id(i,r,o,"min",t)}const pNe={kernelName:af,backendName:"webgpu",kernelFunc:dNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fNe=js({opType:Pt.MIN,cpuKernelImpl:M_e}),mNe={kernelName:bh,backendName:"webgpu",kernelFunc:fNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gNe{constructor(e,t,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((i,r)=>i[0]+e[r]+i[1]),this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((i,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((c,u)=>`uniforms.pad${u}[0]`).join(","),s=this.xShape.map((c,u)=>`uniforms.pad${u}[0] + uniforms.xShape${e>1?`[${u}]`:""}`).join(","),i=e===1?"start":"start[i]",r=e===1?"end":"end[i]",o=e===1?"outC":"outC[i]",a=ds(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${i}) {
              ${o} = ${i} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${r}) {
              ${o} = (${r} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ANe={kernelName:lf,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{paddings:i,mode:r}=e,o=t,a=i.map(u=>({type:"int32",data:[u[0],u[1]]})),l=new gNe(s.shape,i,r);return o.runWebGPUProgram(l,[s],s.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yNe=js({opType:Pt.MOD}),xNe={kernelName:Ih,backendName:"webgpu",kernelFunc:yNe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bNe{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ye("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class INe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Ye("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,o=bt({inputs:{x:i},backend:t,attrs:{shape:[ce(i.shape)/i.shape[r],i.shape[r]]}}),a=new INe(o.shape),l=t.runWebGPUProgram(a,[o],i.dtype),c=bt({inputs:{x:l},backend:t,attrs:{shape:i.shape}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const CNe={kernelName:Ef,backendName:"webgpu",kernelFunc:b4};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wNe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:o,normalized:a}=s,l=a?i:b4({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new bNe(c,r),d=[{type:"float32",data:[o]},{type:"int32",data:[u]}],p=t.runWebGPUProgram(h,[l],"int32",d);return a||t.disposeData(l.dataId),p}const vNe={kernelName:VA,backendName:"webgpu",kernelFunc:wNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SNe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const r=t.tensorMap.get(s.dataId),[o,a]=R_e(r.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}const i=new em(s.shape,qe.NEG);return t.runWebGPUProgram(i,[s],s.dtype)}const ENe={kernelName:cf,backendName:"webgpu",kernelFunc:SNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ne(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),{selectedIndices:h}=ky(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const TNe={kernelName:GA,backendName:"webgpu",kernelFunc:_Ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BNe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s,u=t.readSync(i.dataId),h=t.readSync(r.dataId),d=o,p=a,f=l,g=c,{selectedIndices:m,selectedScores:A}=My(u,h,d,p,f,g);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([A.length],"float32",new Float32Array(A))]}const kNe={kernelName:WA,backendName:"webgpu",kernelFunc:BNe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MNe{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Ye("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NNe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:o,onValue:a,offValue:l}=s,c=ce(i.shape),u=new MNe(c,o),h=bt({inputs:{x:i},backend:t,attrs:{shape:[c]}}),d=[{type:"float32",data:[a]},{type:"float32",data:[l]}],p=t.runWebGPUProgram(u,[h],r,d);t.disposeData(h.dataId);const f=[...i.shape,o],g=bt({inputs:{x:p},backend:t,attrs:{shape:f}});return t.disposeData(p.dataId),g}const RNe={kernelName:df,backendName:"webgpu",kernelFunc:NNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const i=Jy({inputs:{input:s},backend:t}),r=aI({inputs:{x:i},backend:t}),o=zw({inputs:{input:s},backend:t}),a=aI({inputs:{x:o},backend:t}),l=sd({inputs:{real:r,imag:a},backend:t});return t.disposeData(i.dataId),t.disposeData(r.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return er({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const DNe={kernelName:Bf,backendName:"webgpu",kernelFunc:aI};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I4(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=Jy({inputs:{input:s},backend:t}),r=I4({inputs:{x:i},backend:t}),o=zw({inputs:{input:s},backend:t}),a=aI({inputs:{x:o},backend:t}),l=sd({inputs:{real:r,imag:a},backend:t});return t.disposeData(i.dataId),t.disposeData(r.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return er({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const FNe={kernelName:hf,backendName:"webgpu",kernelFunc:I4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ne(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return J1({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,o=e[0].dtype;e.forEach(u=>{Xs(r,u.shape,"All tensors passed to stack must have matching shapes"),R(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=J1({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(h),h}),c=u4({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeData(u.dataId)),c}const PNe={kernelName:pf,backendName:"webgpu",kernelFunc:$Ne};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C4(n,e=!1){const t=n.length,s=ds(t),i=n.map((h,d)=>`uniforms.pad${d}[0]`).join(","),r=n.map((h,d)=>`uniforms.pad${d}[0] + uniforms.xShape${t>1?`[${d}]`:""}`).join(","),o=t>1?`${s}(${i})`:`${i}`,a=t>1?`${s}(${r})`:`${r}`,l=t>1?"any(paddedCoords < start)":"paddedCoords < start",c=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${o};
        let end = ${a};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${u}));
        }
  `}class LNe{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,i)=>s[0]+e[i]+s[1]),this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((s,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${C4(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ONe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:o}=s;if(r.every(c=>qt(c,[0,0])))return vr({inputs:{x:i},backend:t});if(ce(i.shape)===0){const c=r.map((u,h)=>u[0]+i.shape[h]+u[1]);return er({backend:t,attrs:{shape:c,value:o,dtype:i.dtype}})}const a=[{type:"float32",data:[o]}];r.map(c=>a.push({type:"int32",data:[c[0],c[1]]}));const l=new LNe(i.shape,r);return t.runWebGPUProgram(l,[i],i.dtype,a)},zNe={kernelName:ff,backendName:"webgpu",kernelFunc:ONe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UNe=js({opType:Pt.POW}),QNe={kernelName:wh,backendName:"webgpu",kernelFunc:UNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VNe(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e,r=new rI(Pt.PRELU,s.shape,i.shape);return t.runWebGPUProgram(r,[s,i],"float32")}const GNe={kernelName:mf,backendName:"webgpu",kernelFunc:VNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;return id(i,r,o,"prod",t)}const HNe={kernelName:gf,backendName:"webgpu",kernelFunc:WNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qNe=n=>{const{backend:e,attrs:t}=n,{start:s,stop:i,step:r,dtype:o}=t,a=$_e(s,i,r,o);return e.makeTensorInfo([a.length],o,a)},YNe={kernelName:HA,backendName:"webgpu",kernelFunc:qNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XNe=js({opType:Pt.DIV}),jNe={kernelName:rh,backendName:"webgpu",kernelFunc:XNe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KNe=fn({opType:qe.RECIPROCAL}),JNe={kernelName:vh,backendName:"webgpu",kernelFunc:KNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZNe=fn({opType:qe.RELU}),eRe={kernelName:Sh,backendName:"webgpu",kernelFunc:ZNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tRe=fn({opType:qe.RELU6}),nRe={kernelName:Eh,backendName:"webgpu",kernelFunc:tRe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sRe{constructor(e,t,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Ye("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iRe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,size:o,halfPixelCenters:a}=s,[l,c]=o,u=r&&l>1?1:0,h=r&&c>1?1:0,p=[{type:"float32",data:[u,h]},{type:"float32",data:[a?.5:0]}],f=new sRe(i.shape,l,c);return t.runWebGPUProgram(f,[i],"float32",p)}const rRe={kernelName:xf,backendName:"webgpu",kernelFunc:iRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oRe{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aRe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,[,a,l]=i.shape,[,c,u]=r.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],d=[o&&c>1?c-1:c,o&&u>1?u-1:u],p=h[0]/d[0],f=h[1]/d[1],g=1/p,m=1/f,A=Math.ceil(g)*2+2,y=Math.ceil(m)*2+2,b=new oRe(i.shape,o),x=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[g]},{type:"float32",data:[m]},{type:"int32",data:[A]},{type:"int32",data:[y]}];return t.runWebGPUProgram(b,[r],r.dtype,x)}const lRe={kernelName:XA,backendName:"webgpu",kernelFunc:aRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cRe{constructor(e,t,s,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey=`resizeNearest_${i}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uRe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s,[l,c]=a,u=r&&l>1?1:0,h=r&&c>1?1:0,p=[{type:"float32",data:[u,h]},{type:"float32",data:[r?.5:0]}],f=new cRe(i.shape,l,c,o);return t.runWebGPUProgram(f,[i],i.dtype,p)}const hRe={kernelName:yf,backendName:"webgpu",kernelFunc:uRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dRe{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pRe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,[,a,l]=i.shape,[,c,u]=r.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],d=[o&&c>1?c-1:c,o&&u>1?u-1:u],p=h[0]/d[0],f=h[1]/d[1],g=1/p,m=1/f,A=Math.ceil(g)*2+2,y=Math.ceil(m)*2+2,b=new dRe(i.shape,o),x=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[g]},{type:"float32",data:[m]},{type:"int32",data:[A]},{type:"int32",data:[y]}];return t.runWebGPUProgram(b,[r],r.dtype,x)}const fRe={kernelName:YA,backendName:"webgpu",kernelFunc:pRe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mRe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gRe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s,o=i.shape.length;if(o===0)return vr({inputs:{x:i},backend:t});const a=i.shape,l=[1,1,1,1];a.forEach((m,A)=>{const y=A+4-o;l[y]=m});const c=Vt(r,i.shape),u=[0,0,0,0];c.forEach(m=>{const A=m+4-o;u[A]=1});const h=[{type:"int32",data:u}],d=bt({inputs:{x:i},backend:t,attrs:{shape:l}}),p=new mRe(l),f=t.runWebGPUProgram(p,[d],d.dtype,h);t.disposeData(d.dataId);const g=bt({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),g}const ARe={kernelName:bf,backendName:"webgpu",kernelFunc:gRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yRe{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Ye("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xRe={kernelName:ly,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=e,a=t,l=new yRe(s.shape,r),[c,u]=XC(o,s.shape[1],s.shape[2]),h=[{type:"float32",data:[c]},{type:"float32",data:[u]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return typeof r=="number"?h.push({type:"float32",data:[Number.parseFloat(r.toFixed(2))]}):h.push({type:"float32",data:r}),a.runWebGPUProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bRe=fn({opType:qe.ROUND}),IRe={kernelName:_h,backendName:"webgpu",kernelFunc:bRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CRe=fn({opType:qe.RSQRT,cpuKernelImpl:P_e}),wRe={kernelName:Th,backendName:"webgpu",kernelFunc:CRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tg{constructor(e,t,s,i,r,o,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=at(e),this.dispatch=Xe(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${s}_${i}_${this.sliceDimGreaterThanOne}_${a}_${l}_${r.length}`;const c=ds(r.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=s}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",r="";this.dispatchLayout.x.length===1?(i="flattenedIndex",r=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(i="vec2<i32>(flattenedIndex, coords[1])",r=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(c,u)=>`coords[${u}]`).join(", ")})`;return`
    ${r}
      ${Ye("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${Yc(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${i});

          ${this.sumDupeIndices?Ac("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vRe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=qo(r,i,o),d=[h/c,c];if(h===0)return t.makeTensorInfo(o,i.dtype);const p=bt({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),f=bt({inputs:{x:r},backend:t,attrs:{shape:[l,c]}}),g=f.dtype,m=er({backend:t,attrs:{shape:d,value:0,dtype:g}}),A=ce(f.shape),y=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[A]}],b=new tg(f.shape,a,p.shape.length,f.shape.length,u,d,g),x=t.runWebGPUProgram(b,[f,p],g,y,m),C=bt({inputs:{x},backend:t,attrs:{shape:o}});return t.disposeData(p.dataId),t.disposeData(f.dataId),t.disposeData(x.dataId),C}const SRe={kernelName:jA,backendName:"webgpu",kernelFunc:vRe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ERe{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Ye("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Re(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:o}=s,a=new ERe([r.shape[0],r.shape[1]],o),l=[{type:"int32",data:[i.shape[1]]}];return t.runWebGPUProgram(a,[i,r],"int32",l)}const TRe={kernelName:JA,backendName:"webgpu",kernelFunc:_Re};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BRe{constructor(e,t,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=s,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],o=[];for(let a=0;a<this.outputShape.length;a++)o.push(`${i[a]}`),a<this.cRank&&r.push(`${i[a]}`);e=r.join(),t=o.join()}return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kRe(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e,o=new BRe(s.shape.length,i.shape,i.shape.length);return t.runWebGPUProgram(o,[s,i,r],Ns(i.dtype,r.dtype))}const MRe={kernelName:If,backendName:"webgpu",kernelFunc:kRe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NRe=fn({opType:qe.SELU}),RRe={kernelName:Bh,backendName:"webgpu",kernelFunc:NRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DRe=fn({opType:qe.SIGMOID}),FRe={kernelName:Rh,backendName:"webgpu",kernelFunc:DRe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Re=fn({opType:qe.SIGN}),PRe={kernelName:Nh,backendName:"webgpu",kernelFunc:$Re};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LRe=fn({opType:qe.SIN}),ORe={kernelName:kh,backendName:"webgpu",kernelFunc:LRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zRe=fn({opType:qe.SINH}),URe={kernelName:Mh,backendName:"webgpu",kernelFunc:zRe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QRe=fn({opType:qe.SOFTPLUS}),VRe={kernelName:Dh,backendName:"webgpu",kernelFunc:QRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GRe{constructor(e,t,s,i,r,o){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[r[l]];this.outputShape=a,this.newDim=r,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${ds(i.length)}, paddedXShapeStrides : ${ds(o)}, `,s.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${r}`}getUserCode(){const e=ds(this.outputShape.length),t=s4(this.newDim);return`
      ${P0(this.paddedXShape,"PaddedX")}
      ${Ye("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${C4(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WRe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:o}=s;R(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=r.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+r.length;y<i.shape.length;++y)l.push([0,0]);const c=l.map((y,b)=>y[0]+i.shape[b]+y[1]),u=Hh(c,r,a,!1),h=qh(u.length,r.length,!1),d=Yh(c,r,a,!1),p=vt(c),f=new GRe(i.shape,c,l,u,h,p.length),g=[{type:"int32",data:u},{type:"int32",data:p}];l.map(y=>g.push({type:"int32",data:[y[0],y[1]]}));const m=t.runWebGPUProgram(f,[i],i.dtype,g),A=bt({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeData(m.dataId),A},HRe={kernelName:vf,backendName:"webgpu",kernelFunc:WRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qRe{constructor(e,t,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=s,this.dispatchLayout=at([t]),this.dispatch=Xe(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Ye("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Ac("&result[outIndex]","value",this.type)}
      }
    }
  `}}class YRe{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=at(t),this.dispatch=Xe(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Ye("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Ac("&result[segmentId]","1","int32")}
      }
    }
  `}}class XRe{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=at(e),this.dispatch=Xe(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Ye("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w4(n,e,t,s=!1,i){const o=ce(n.shape)/n.shape[0],a=n.dtype,l=ce(e.shape),c=i.readSync(t.dataId),h=l>0?c[l-1]+1:0;let d;const p=n.shape.slice();p[0]=h;const f=l*o,g=er({backend:i,attrs:{shape:p,value:0,dtype:a}});d=new qRe(p,f,a);let m=[{type:"int32",data:[o]},{type:"int32",data:[f]}];const A=i.runWebGPUProgram(d,[n,e,t],a,m,g);if(s)return A;const y=er({backend:i,attrs:{shape:[h],value:0,dtype:"int32"}});d=new YRe(h,t.shape);const b=i.runWebGPUProgram(d,[t],"int32",null,y),x=er({backend:i,attrs:{shape:p,value:0,dtype:a}});d=new XRe(p,a),m=[{type:"int32",data:[o]}];const C=i.runWebGPUProgram(d,[A,b],a,m,x);return i.disposeData(A.dataId),i.disposeData(b.dataId),C}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jRe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;return w4(s,i,r,!1,t)}const KRe={kernelName:ZA,backendName:"webgpu",kernelFunc:jRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JRe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;return w4(s,i,r,!0,t)}const ZRe={kernelName:ey,backendName:"webgpu",kernelFunc:JRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eDe{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[i]*t[i];this.outputShape=s,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=tDe(this.rank,"uniforms.");return`
      ${Ye("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function tDe(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n;i++)s.push(`(${t[i]} % ${e}aShape[${i}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;if(t.shouldExecuteOnCPU([i])||i.dtype==="string"||i.shape.length>=5){const l=t.readSync(i.dataId),c=i.dtype==="string"?l.map(d=>lo(d)):l,u=zt(i.shape,i.dtype,c),h=G_e(u,r);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new eDe(i.shape,r);return t.runWebGPUProgram(o,[i],i.dtype)}const nDe={kernelName:zh,backendName:"webgpu",kernelFunc:JB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sDe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=qo(r,i,a),p=!1;if(r.dtype==="string"){const T=t.bufferSync(i),v=t.bufferSync(r),S=lo(t.readSync(o.dataId)[0]),_=L_e(T,v,a,d,u,c,l,h,S,p);return t.makeTensorInfo(a,_.dtype,_.values)}const f=[d/u,u],g=bt({inputs:{x:i},backend:t,attrs:{shape:[c,l]}}),m=r.shape.length?bt({inputs:{x:r},backend:t,attrs:{shape:[c,u]}}):vr({inputs:{x:r},backend:t}),A=m.dtype,y=t.makeTensorInfo([],A,Ws(1,A)),b=bt({inputs:{x:o},backend:t,attrs:{shape:Array(f.length).fill(1)}}),x=JB({inputs:{x:b},backend:t,attrs:{reps:f}}),C=ce([c,u]),w=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[C]}];switch(c){case 0:break;case 1:{const T=new tg([c,u],l,g.shape.length,m.shape.length,h,f,A,p);t.runWebGPUProgram(T,[m,g],A,w,x)}break;default:{const T=new tg([c,u],l,g.shape.length,y.shape.length,h,f,A,p);t.runWebGPUProgram(T,[y,g],A,w,x)}{const T=new tg([c,u],l,g.shape.length,m.shape.length,h,f,A);t.runWebGPUProgram(T,[m,g],A,w,x)}}const E=bt({inputs:{x},backend:t,attrs:{shape:a}});return t.disposeData(g.dataId),t.disposeData(m.dataId),t.disposeData(b.dataId),t.disposeData(y.dataId),t.disposeData(x.dataId),E}const iDe={kernelName:ty,backendName:"webgpu",kernelFunc:sDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:o}=s,a=Vt(o,i.shape)[0],l=cw(i,r,a),c=i.shape.length,u=new Array(c).fill(0),h=i.shape.slice();return l.map(d=>{const p=[...h];p[a]=d;const f=tm({inputs:{x:i},backend:t,attrs:{begin:u,size:p}});return u[a]+=d,f})}const oDe={kernelName:Sf,backendName:"webgpu",kernelFunc:rDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aDe=fn({opType:qe.SQRT}),lDe={kernelName:Fh,backendName:"webgpu",kernelFunc:aDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cDe={kernelName:ny,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e,i=new em(t.shape,qe.SQUARE);return s.runWebGPUProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uDe=js({opType:Pt.SQUARED_DIFFERENCE}),hDe={kernelName:$h,backendName:"webgpu",kernelFunc:uDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dDe({inputs:n,attrs:e,backend:t}){const{x:s}=n,i=new em(s.shape,qe.STEP,"stepAlpha : f32,"),r=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(i,[s],s.dtype,r)}const pDe={kernelName:Uh,backendName:"webgpu",kernelFunc:dDe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fDe{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=ds(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let i=0;t=this.outputShape.map((r,o)=>(i++,this.outputShape.length===1?`coords * uniforms.strides[${o}] + uniforms.begin[${o}]`:`coords[${i-1}] * uniforms.strides[${o}] + uniforms.begin[${o}]`)).join(",")}return`
       ${Ye("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:A,begin:y,end:b,strides:x}=HC(i.shape,r,o,a,l,c,u,h,d);let C;if(g)C=bt({inputs:{x:i},backend:t,attrs:{shape:f}});else if(m||A){R(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const w=WC(y,b,x),E=tm({inputs:{x:i},backend:t,attrs:{begin:y,size:w}});C=bt({inputs:{x:E},backend:t,attrs:{shape:f}}),t.disposeData(E.dataId)}else if(t.shouldExecuteOnCPU([i])){const E=t.readSync(i.dataId),T=zt(i.shape,i.dtype,E),v=U_e(p,T,x,y);C=t.makeTensorInfo(f,i.dtype,v.values)}else{const E=new fDe(p),T=[{type:"int32",data:y},{type:"int32",data:x}],v=t.runWebGPUProgram(E,[i],i.dtype,T);C=bt({inputs:{x:v},backend:t,attrs:{shape:f}}),t.disposeData(v.dataId)}return C}const gDe={kernelName:iy,backendName:"webgpu",kernelFunc:mDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ADe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:h}=e,d=t.readSync(u.dataId),p=t.readSync(h.dataId),[f,g]=Q_e(d,p,i,r,o,a,l,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",g)]}const yDe={kernelName:ry,backendName:"webgpu",kernelFunc:ADe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xDe=js({opType:Pt.SUB,cpuKernelImpl:V_e,supportsComplex:!0}),bDe={kernelName:Ph,backendName:"webgpu",kernelFunc:xDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IDe=fn({opType:qe.TAN}),CDe={kernelName:Lh,backendName:"webgpu",kernelFunc:IDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wDe=fn({opType:qe.TANH}),vDe={kernelName:Oh,backendName:"webgpu",kernelFunc:wDe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SDe(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:i,indices:r,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=qo(o,r,i.shape),d=[h/c,c];if(h===0)return t.makeTensorInfo(i.shape,r.dtype);const p=[],f=bt({inputs:{x:r},backend:t,attrs:{shape:[l,a]}});p.push(f);const g=bt({inputs:{x:o},backend:t,attrs:{shape:[l,c]}});p.push(g);const m=bt({inputs:{x:i},backend:t,attrs:{shape:d}});p.push(m);const A=JB({inputs:{x:m},backend:t,attrs:{reps:Array(d.length).fill(1)}}),y=new tg([l,c],a,f.shape.length,g.shape.length,u,d,i.dtype,!1),b=ce([l,c]),x=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[b]}],C=t.runWebGPUProgram(y,[g,f],m.dtype,x,A);p.push(C);const w=bt({inputs:{x:C},backend:t,attrs:{shape:i.shape}});return p.forEach(E=>t.disposeData(E.dataId)),w}const EDe={kernelName:KA,backendName:"webgpu",kernelFunc:SDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _De{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Ye("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class TDe{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Ye("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Md(n,e){e!==null&&n.disposeData(e.dataId)}function rD(n){let e=1;for(;e<n;)e*=2;return e}function BDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:o}=s,a=i.shape,l=a[a.length-1];if(t.shouldExecuteOnCPU([i])){const C=t.readSync(i.dataId),[w,E]=W_e(C,a,i.dtype,r,o);return[t.makeTensorInfo(w.shape,w.dtype,w.values),t.makeTensorInfo(E.shape,E.dtype,E.values)]}if(r===0)return a[a.length-1]=0,[t.makeTensorInfo(a,i.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(l===1)return[i,er({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const u=ce(a)/l,h=bt({inputs:{x:i},attrs:{shape:[u,l]},backend:t}),d=rD(r),p=rD(l);let f=null;const g=()=>f===null?[h,h]:[h,f],m=(C,w,E)=>{const T=g(),v=new _De(E),_=[{type:"int32",data:[l]},{type:"int32",data:[f===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[C]},{type:"int32",data:[w]}],N=f;f=t.runWebGPUProgram(v,T,"int32",_),Md(t,N)};for(let C=1;C<d;C*=2){const w=C*2;for(let E=C;E>=1;E/=2)m(w,E,[u,p])}for(let C=p;C>d;C/=2){const w=g(),E=new TDe([u,C/2]),v=[{type:"int32",data:[l]},{type:"int32",data:[f===null?1:0]},{type:"int32",data:[d]}],S=f;f=t.runWebGPUProgram(E,w,"int32",v),Md(t,S);const _=d/2,N=_*2;for(let D=_;D>=1;D/=2)m(N,D,f.shape)}let A=f;f=tm({inputs:{x:f},backend:t,attrs:{begin:0,size:[u,r]}}),Md(t,A);let y=y4({inputs:{x:h,indices:f},backend:t,attrs:{axis:1,batchDims:1}});Md(t,h);const b=a.slice(0,-1);b.push(r),A=f,f=bt({inputs:{x:f},attrs:{shape:b},backend:t}),Md(t,A);const x=y;return y=bt({inputs:{x:y},attrs:{shape:b},backend:t}),Md(t,x),[y,f]}const kDe={kernelName:oy,backendName:"webgpu",kernelFunc:BDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MDe{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ye("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NDe(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,transforms:r}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=s,[u,h,d,p]=i.shape,[f,g]=c??[h,d],m=[u,f,g,p],A=new MDe(m),y=o==="nearest"?1:2;let b;switch(a){case"constant":b=1;break;case"reflect":b=2;break;case"wrap":b=3;break;case"nearest":b=4;break;default:b=1;break}const x=[{type:"int32",data:[y]},{type:"int32",data:[b]},{type:"float32",data:[l]}];return t.runWebGPUProgram(A,[i,r],"float32",x)}const RDe={kernelName:ay,backendName:"webgpu",kernelFunc:NDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DDe(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i,a=o.shape.length,l=i.shape[r],c=new Array(a-1);let u=0;for(let g=0;g<a;g++)g!==r&&(c[u++]=o.shape[g]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[r]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[r]=g;const m=tm({inputs:{x:o},backend:t,attrs:{begin:d,size:p}}),A=bt({inputs:{x:m},backend:t,attrs:{shape:c}});f[g]=A,h.push(m)}return h.forEach(g=>t.disposeData(g.dataId)),f}const FDe={kernelName:_f,backendName:"webgpu",kernelFunc:DDe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $De{constructor(e,t,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=at(e),this.dispatch=Xe(this.dispatchLayout,e,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Ye("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Ac("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:o}=s,a=i.shape.length,l=[];let c=0;const u=Nn([c],a);let h=i;u!=null&&(h=ba({inputs:{x:i},backend:t,attrs:{perm:u}}),l.push(h),c=Vn(1,a)[0]);const d=Q_(h.shape,c,o),p=ce([h.shape[c]]),f=bt({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(f);const g=i.dtype,m=[f.shape[0],o],A=er({backend:t,attrs:{shape:m,value:0,dtype:g}}),y=new $De(f.shape,m,g),b=[{type:"int32",data:[o]},{type:"int32",data:[ce(f.shape)]}],x=t.runWebGPUProgram(y,[f,r],g,b,A),C=bt({inputs:{x},backend:t,attrs:{shape:d}});l.push(x);let w=C;if(u!=null){l.push(C);const E=Sa(u);w=ba({inputs:{x:w},backend:t,attrs:{perm:E}})}return l.forEach(E=>t.disposeData(E.dataId)),w}const LDe={kernelName:Tf,backendName:"webgpu",kernelFunc:PDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ODe=[u_e,Y_e,j_e,J_e,eTe,sTe,uTe,dTe,fTe,gTe,yTe,bTe,CTe,vTe,ETe,MTe,RTe,PTe,OTe,UTe,HTe,jTe,ZTe,sBe,rBe,cBe,d_e,dBe,gBe,vBe,kBe,DBe,PBe,OBe,UBe,VBe,WBe,YBe,jBe,JBe,eke,ske,uke,dke,oke,mke,yke,Cke,vke,_ke,Mke,Rke,Fke,Pke,Oke,Uke,Qke,Gke,Hke,a_e,Yke,eMe,jke,Jke,sMe,rMe,aMe,uMe,pMe,mMe,AMe,h_e,xMe,fBe,IMe,wMe,SMe,_Me,BMe,MMe,DMe,LMe,$Me,zMe,QMe,GMe,YMe,KMe,TTe,ZMe,tNe,cNe,sNe,aNe,hNe,BTe,pNe,mNe,ANe,xNe,vNe,Tke,ENe,TNe,kNe,eBe,RNe,FNe,PNe,zNe,QNe,GNe,HNe,YNe,tBe,jNe,JNe,eRe,nRe,l_e,rRe,lRe,hRe,fRe,ARe,xRe,IRe,wRe,SRe,TRe,MRe,RRe,FRe,PRe,ORe,URe,GTe,pDe,gDe,yDe,CNe,VRe,HRe,KRe,ZRe,iDe,oDe,lDe,cDe,hDe,bDe,Bke,CDe,vDe,EDe,nDe,kDe,RDe,oTe,FDe,LDe,DNe];for(const n of ODe)cy(n);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var v4=function(n,e){return(v4=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,s){t.__proto__=s}||function(t,s){for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(t[i]=s[i])})(n,e)};function S4(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}v4(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var Fn=function(){return(Fn=Object.assign||function(n){for(var e,t=1,s=arguments.length;t<s;t++)for(var i in e=arguments[t])Object.prototype.hasOwnProperty.call(e,i)&&(n[i]=e[i]);return n}).apply(this,arguments)};function ln(n,e,t,s){return new(t||(t=Promise))((function(i,r){function o(c){try{l(s.next(c))}catch(u){r(u)}}function a(c){try{l(s.throw(c))}catch(u){r(u)}}function l(c){var u;c.done?i(c.value):(u=c.value,u instanceof t?u:new t((function(h){h(u)}))).then(o,a)}l((s=s.apply(n,[])).next())}))}function cn(n,e){var t,s,i,r,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(r[Symbol.iterator]=function(){return this}),r;function a(l){return function(c){return(function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,s&&(i=2&u[0]?s.return:u[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,u[1])).done)return i;switch(s=0,i&&(u=[2&u[0],i.value]),u[0]){case 0:case 1:i=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,s=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(i=o.trys,!((i=i.length>0&&i[i.length-1])||u[0]!==6&&u[0]!==2)){o=0;continue}if(u[0]===3&&(!i||u[1]>i[0]&&u[1]<i[3])){o.label=u[1];break}if(u[0]===6&&o.label<i[1]){o.label=i[1],i=u;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(u);break}i[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],s=0}finally{t=i=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}})([l,c])}}}function nu(n,e,t){if(t||arguments.length===2)for(var s,i=0,r=e.length;i<r;i++)!s&&i in e||(s||(s=Array.prototype.slice.call(e,0,i)),s[i]=e[i]);return n.concat(s||Array.prototype.slice.call(e))}var Ia=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Hg=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],zDe={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},UDe={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},QDe=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],VDe=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function lI(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function E4(n){return ln(this,void 0,void 0,(function(){var e,t;return cn(this,(function(s){switch(s.label){case 0:return e=document.createElement("canvas"),n instanceof nn?[4,QC(n,e)]:[3,2];case 1:return s.sent(),[3,3];case 2:e.width=lI(n.width),e.height=lI(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),s.label=3;case 3:return[2,e]}}))}))}function _4(n){return ln(this,void 0,void 0,(function(){var e,t,s,i,r,o;return cn(this,(function(a){switch(a.label){case 0:return n instanceof nn?(e=n.shape.slice(0,2),t=e[0],s=e[1],i=ImageData.bind,[4,QC(n)]):[3,2];case 1:return[2,new(i.apply(ImageData,[void 0,a.sent(),s,t]))];case 2:return r=document.createElement("canvas"),o=r.getContext("2d"),r.width=lI(n.width),r.height=lI(n.height),o.drawImage(n,0,0),[2,o.getImageData(0,0,r.width,r.height)]}}))}))}function GDe(n){return ln(this,void 0,void 0,(function(){var e,t;return cn(this,(function(s){switch(s.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,E4(n)]:[3,2];case 1:return t=s.sent(),[3,3];case 2:t=n,s.label=3;case 3:return e=t,[2,VC(e,4)]}}))}))}function T4(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var Tm={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},WDe=(function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return ln(this,void 0,void 0,(function(){return cn(this,(function(e){return[2,this.mask]}))}))},n.prototype.toImageData=function(){return ln(this,void 0,void 0,(function(){return cn(this,(function(e){return[2,_4(this.mask)]}))}))},n.prototype.toTensor=function(){return ln(this,void 0,void 0,(function(){return cn(this,(function(e){return[2,GDe(this.mask)]}))}))},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n})();function HDe(n){return T4(n),"person"}var qDe=(function(){function n(e){var t,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new lEe.Pose({locateFile:function(i,r){if(e.solutionPath){var o=e.solutionPath.replace(/\/+$/,"");return"".concat(o,"/").concat(i)}return"".concat(r,"/").concat(i)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults((function(i){if(s.height=i.image.height,s.width=i.image.width,i.poseLandmarks==null)s.poses=[];else{var r=s.translateOutput(i.poseLandmarks,i.poseWorldLandmarks);i.segmentationMask&&(r.segmentation={maskValueToLabel:HDe,mask:new WDe(i.segmentationMask)}),s.poses=[r]}}))}return n.prototype.translateOutput=function(e,t){var s=this,i={keypoints:e.map((function(r,o){return{x:r.x*s.width,y:r.y*s.height,z:r.z,score:r.visibility,name:Hg[o]}}))};return t!=null&&(i.keypoints3D=t.map((function(r,o){return{x:r.x,y:r.y,z:r.z,score:r.visibility,name:Hg[o]}}))),i},n.prototype.estimatePoses=function(e,t,s){return ln(this,void 0,void 0,(function(){var i,r;return cn(this,(function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof nn?(r=ImageData.bind,[4,QC(e)]):[3,2];case 1:return i=new(r.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:i=e,o.label=3;case 3:return e=i,[4,this.poseSolution.send({image:e},s)];case 4:return o.sent(),[2,this.poses]}}))}))},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n})();function YDe(n){return ln(this,void 0,void 0,(function(){var e,t;return cn(this,(function(s){switch(s.label){case 0:return e=(function(i){if(i==null)return Fn({},Tm);var r=Fn({},i);return r.runtime="mediapipe",r.enableSegmentation==null&&(r.enableSegmentation=Tm.enableSegmentation),r.enableSmoothing==null&&(r.enableSmoothing=Tm.enableSmoothing),r.smoothSegmentation==null&&(r.smoothSegmentation=Tm.smoothSegmentation),r.modelType==null&&(r.modelType=Tm.modelType),r})(n),[4,(t=new qDe(e)).initialize()];case 1:return s.sent(),[2,t]}}))}))}function Cp(n){return n instanceof nn?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function B4(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function ZB(n){return n instanceof nn?n:VC(n)}function k4(n,e,t){return Z1(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function Z1(n,e){R(n.width!==0,(function(){return"".concat(e," width cannot be 0.")})),R(n.height!==0,(function(){return"".concat(e," height cannot be 0.")}))}function dS(n,e,t){var s=t.rotationVectorStartKeypointIndex,i=t.rotationVectorEndKeypointIndex,r=n.locationData,o=r.relativeKeypoints[s].x*e.width,a=r.relativeKeypoints[s].y*e.height,l=r.relativeKeypoints[i].x*e.width,c=r.relativeKeypoints[i].y*e.height,u=2*Math.sqrt((l-o)*(l-o)+(c-a)*(c-a)),h=(function(d,p,f){var g,m=d.locationData,A=f.rotationVectorStartKeypointIndex,y=f.rotationVectorEndKeypointIndex;g=f.rotationVectorTargetAngle?f.rotationVectorTargetAngle:Math.PI*f.rotationVectorTargetAngleDegree/180;var b=m.relativeKeypoints[A].x*p.width,x=m.relativeKeypoints[A].y*p.height,C=m.relativeKeypoints[y].x*p.width,w=m.relativeKeypoints[y].y*p.height;return B4(g-Math.atan2(-(w-x),C-b))})(n,e,t);return{xCenter:o/e.width,yCenter:a/e.height,width:u/e.width,height:u/e.height,rotation:h}}function M4(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function pS(n,e,t,s,i,r,o){return n[e][i]*(n[t][r]*n[s][o]-n[t][o]*n[s][r])}function wi(n,e,t){var s=(e+1)%4,i=(e+2)%4,r=(e+3)%4,o=(t+1)%4,a=(t+2)%4,l=(t+3)%4;return pS(n,s,i,r,o,a,l)+pS(n,i,r,s,o,a,l)+pS(n,r,s,i,o,a,l)}function oD(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var s=[],i=0,r=n;i<r.length;i++){var o=r[i],a=o.x-.5,l=o.y-.5,c=t.ignoreRotation?0:e.rotation,u=Math.cos(c)*a-Math.sin(c)*l,h=Math.sin(c)*a+Math.cos(c)*l;u=u*e.width+e.xCenter,h=h*e.height+e.yCenter;var d=o.z*e.width,p=Fn({},o);p.x=u,p.y=h,p.z=d,s.push(p)}return s}function N4(n,e){var t=(function(s,i,r,o){var a=i-s,l=o-r,c=l/a;return{scale:c,offset:r-s*c}})(0,255,e[0],e[1]);return le((function(){return Be(K(n,t.scale),t.offset)}))}function eE(n,e,t){var s,i,r,o,a,l,c,u,h,d,p,f,g,m,A=e.outputTensorSize,y=e.keepAspectRatio,b=e.borderMode,x=e.outputTensorFloatRange,C=Cp(n),w=(function(v,S){return S?{xCenter:S.xCenter*v.width,yCenter:S.yCenter*v.height,width:S.width*v.width,height:S.height*v.height,rotation:S.rotation}:{xCenter:.5*v.width,yCenter:.5*v.height,width:v.width,height:v.height,rotation:0}})(C,t),E=(function(v,S,_){if(_===void 0&&(_=!1),!_)return{top:0,left:0,right:0,bottom:0};var N=S.height,D=S.width;Z1(S,"targetSize"),Z1(v,"roi");var P,L,z=N/D,q=v.height/v.width,V=0,X=0;return z>q?(P=v.width,L=v.width*z,X=(1-q/z)/2):(P=v.height/z,L=v.height,V=(1-z/q)/2),v.width=P,v.height=L,{top:X,left:V,right:V,bottom:X}})(w,A,y),T=(s=w,i=C.width,r=C.height,o=!1,a=s.width,l=s.height,c=o?-1:1,u=Math.cos(s.rotation),h=Math.sin(s.rotation),d=s.xCenter,p=s.yCenter,f=1/i,g=1/r,(m=new Array(16))[0]=a*u*c*f,m[1]=-l*h*f,m[2]=0,m[3]=(-.5*a*u*c+.5*l*h+d)*f,m[4]=a*h*c*g,m[5]=l*u*g,m[6]=0,m[7]=(-.5*l*u-.5*a*h*c+p)*g,m[8]=0,m[9]=0,m[10]=a*f,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,M4(m));return{imageTensor:le((function(){var v=ZB(n),S=Ji(k4(T,C,A),[1,8]),_=b==="zero"?"constant":"nearest",N=ii.transform(rs(We(v,"float32")),S,"bilinear",_,0,[A.height,A.width]);return x!=null?N4(N,x):N})),padding:E,transformationMatrix:T}}function aD(n,e,t,s){return s===1?.5*(n+e):n+(e-n)*t/(s-1)}function XDe(n){return le((function(){var e=(function(i){return le((function(){return[$t(i,[0,0,0],[1,-1,1]),$t(i,[0,0,1],[1,-1,-1])]}))})(n),t=e[0],s=e[1];return{boxes:mn(s),logits:mn(t)}}))}function R4(n){return n!=null&&n.currentTime!=null}function lD(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,o=0;o<n.length;++o){var a=n[o];t=Math.min(t,a.x),s=Math.max(s,a.x),i=Math.min(i,a.y),r=Math.max(r,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:i,xMax:s,yMax:r,width:s-t,height:r-i},e}function jDe(n,e,t,s){return ln(this,void 0,void 0,(function(){var i,r,o,a,l;return cn(this,(function(c){switch(c.label){case 0:return n.sort((function(u,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,u.score)})),i=Ji(n.map((function(u){return[u.locationData.relativeBoundingBox.yMin,u.locationData.relativeBoundingBox.xMin,u.locationData.relativeBoundingBox.yMax,u.locationData.relativeBoundingBox.xMax]}))),r=ls(n.map((function(u){return u.score[0]}))),[4,ii.nonMaxSuppressionAsync(i,r,e,t)];case 1:return[4,(o=c.sent()).array()];case 2:return a=c.sent(),l=n.filter((function(u,h){return a.indexOf(h)>-1})),Et([i,r,o]),[2,l]}}))}))}function D4(n,e){return n.map((function(t){var s=Fn(Fn({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(s.z=t.z*e.width),s}))}function KDe(n,e,t){return ln(this,void 0,void 0,(function(){var s,i,r,o,a,l,c,u,h,d,p,f,g,m,A,y,b,x,C,w,E,T,v,S;return cn(this,(function(_){switch(_.label){case 0:if(s=mn(e,[0]),i=s.shape,r=i[0],o=i[1],a=i[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(a));return l=[],[4,s.buffer()];case 1:for(c=_.sent(),u=0;u<n.length;u++)if(h=n[u],d=Fn({},h),l.push(d),p=Math.trunc(d.x*o),f=Math.trunc(d.y*r),!(p<0||p>=o||f<0||p>=r)){for(g=Math.trunc((t.kernelSize-1)/2),m=Math.max(0,p-g),A=Math.min(o,p+g+1),y=Math.max(0,f-g),b=Math.min(r,f+g+1),x=0,C=0,w=0,E=0,T=y;T<b;++T)for(v=m;v<A;++v)S=c.get(T,v,u),x+=S,E=Math.max(E,S),C+=v*S,w+=T*S;E>=t.minConfidenceToRefine&&x>0&&(d.x=C/o/x,d.y=w/r/x)}return s.dispose(),[2,l]}}))}))}function cD(n,e){var t=e.left,s=e.top,i=e.left+e.right,r=e.top+e.bottom;return n.map((function(o){return Fn(Fn({},o),{x:(o.x-t)/(1-i),y:(o.y-s)/(1-r),z:o.z/(1-i)})}))}function JDe(n,e,t){return vu()==="webgl"?(function(s,i,r){var o=r.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(o,`);

      setOutput(outputValue);
    }
`)},l=Yl();return le((function(){var c=l.compileAndRun(a,[s,i]);return hi().makeTensorFromDataId(c.dataId,c.shape,c.dtype)}))})(n,e,t):le((function(){var s=nt(e,.5),i=vn(s),r=nt(1,ol(1,K(i,Be(5.68842,K(i,Be(-.748699,K(i,Be(-57.8051,K(i,Be(291.309,K(i,-624.717)))))))))));return Be(e,K(nt(n,e),K(r,t.combineWithPreviousRatio)))}))}function ZDe(n,e,t){return ln(this,void 0,void 0,(function(){var s,i,r,o,a;return cn(this,(function(l){switch(l.label){case 0:return s=n[0],i=n[1],r=(function(c,u,h){return le((function(){var d,p,f,g;h.reverseOutputOrder?(p=mn($t(c,[0,h.boxCoordOffset+0],[-1,1])),d=mn($t(c,[0,h.boxCoordOffset+1],[-1,1])),g=mn($t(c,[0,h.boxCoordOffset+2],[-1,1])),f=mn($t(c,[0,h.boxCoordOffset+3],[-1,1]))):(d=mn($t(c,[0,h.boxCoordOffset+0],[-1,1])),p=mn($t(c,[0,h.boxCoordOffset+1],[-1,1])),f=mn($t(c,[0,h.boxCoordOffset+2],[-1,1])),g=mn($t(c,[0,h.boxCoordOffset+3],[-1,1]))),p=Be(K(et(p,h.xScale),u.w),u.x),d=Be(K(et(d,h.yScale),u.h),u.y),h.applyExponentialOnBoxSize?(f=K(fi(et(f,h.hScale)),u.h),g=K(fi(et(g,h.wScale)),u.w)):(f=K(et(f,h.hScale),u.h),g=K(et(g,h.wScale),u.h));var m=nt(d,et(f,2)),A=nt(p,et(g,2)),y=Be(d,et(f,2)),b=Be(p,et(g,2)),x=Jn([ee(m,[h.numBoxes,1]),ee(A,[h.numBoxes,1]),ee(y,[h.numBoxes,1]),ee(b,[h.numBoxes,1])],1);if(h.numKeypoints)for(var C=0;C<h.numKeypoints;++C){var w=h.keypointCoordOffset+C*h.numValuesPerKeypoint,E=void 0,T=void 0;h.reverseOutputOrder?(E=mn($t(c,[0,w],[-1,1])),T=mn($t(c,[0,w+1],[-1,1]))):(T=mn($t(c,[0,w],[-1,1])),E=mn($t(c,[0,w+1],[-1,1])));var v=Be(K(et(E,h.xScale),u.w),u.x),S=Be(K(et(T,h.yScale),u.h),u.y);x=Jn([x,ee(v,[h.numBoxes,1]),ee(S,[h.numBoxes,1])],1)}return x}))})(i,e,t),o=le((function(){var c=s;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(c=Fi(s,-t.scoreClippingThresh,t.scoreClippingThresh)),c=yr(c)):c})),[4,e3e(r,o,t)];case 1:return a=l.sent(),Et([r,o]),[2,a]}}))}))}function e3e(n,e,t){return ln(this,void 0,void 0,(function(){var s,i,r,o,a,l,c,u,h,d,p,f;return cn(this,(function(g){switch(g.label){case 0:return s=[],[4,n.data()];case 1:return i=g.sent(),[4,e.data()];case 2:for(r=g.sent(),o=0;o<t.numBoxes;++o)if(!(t.minScoreThresh!=null&&r[o]<t.minScoreThresh||(a=o*t.numCoords,l=t3e(i[a+0],i[a+1],i[a+2],i[a+3],r[o],t.flipVertically,o),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(t.numKeypoints>0)for((u=l.locationData).relativeKeypoints=[],h=t.numKeypoints*t.numValuesPerKeypoint,d=0;d<h;d+=t.numValuesPerKeypoint)p=a+t.keypointCoordOffset+d,f={x:i[p+0],y:t.flipVertically?1-i[p+1]:i[p+1]},u.relativeKeypoints.push(f);s.push(l)}return[2,s]}}))}))}function t3e(n,e,t,s,i,r,o){return{score:[i],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:r?1-t:n,xMax:s,yMax:r?1-n:t,width:s-e,height:t-n}}}}function n3e(n,e){return n==="none"?e:(function(t){return 1/(1+Math.exp(-t))})(e)}function uD(n,e,t,s){return ln(this,void 0,void 0,(function(){var i,r,o,a,l,c,u,h;return cn(this,(function(d){switch(d.label){case 0:return t=t||e.flipHorizontally||!1,s=s||e.flipVertically||!1,i=n.size,r=i/e.numLandmarks,[4,n.data()];case 1:for(o=d.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*r,(h={x:0,y:0}).x=t?e.inputImageWidth-o[c]:o[c],r>1&&(h.y=s?e.inputImageHeight-o[c+1]:o[c+1]),r>2&&(h.z=o[c+2]),r>3&&(h.score=n3e(e.visibilityActivation,o[c+3])),a.push(h);for(u=0;u<a.length;++u)(h=a[u]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}}))}))}function hD(n,e,t){var s=n.width,i=n.height,r=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(r=(function(c,u){return u.rotation!=null?c+=u.rotation:u.rotationDegree!=null&&(c+=Math.PI*u.rotationDegree/180),B4(c)})(r,t)),r===0)n.xCenter=n.xCenter+s*t.shiftX,n.yCenter=n.yCenter+i*t.shiftY;else{var o=(e.width*s*t.shiftX*Math.cos(r)-e.height*i*t.shiftY*Math.sin(r))/e.width,a=(e.width*s*t.shiftX*Math.sin(r)+e.height*i*t.shiftY*Math.cos(r))/e.height;n.xCenter=n.xCenter+o,n.yCenter=n.yCenter+a}{var l=Math.max(s*e.width,i*e.height);s=l/e.width,i=l/e.height}return n.width=s*t.scaleX,n.height=i*t.scaleY,n}function F4(n,e){return n.map((function(t){var s=Fn(Fn({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),s}))}var Ll=(function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var s;return this.initialized?s=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(s=e,this.initialized=!0),this.rawValue=e,this.storedValue=s,s},n.prototype.applyWithAlpha=function(e,t,s){return this.alpha=t,this.apply(e,s)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n})(),fS=(function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Ll(this.getAlpha(this.minCutOff)),this.dx=new Ll(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,s){if(e==null)return e;var i=Math.trunc(t);if(this.lastTimestamp>=i)return e;this.lastTimestamp!==0&&i!==0&&(this.frequency=1/(1e-6*(i-this.lastTimestamp))),this.lastTimestamp=i;var r=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*s*this.frequency:0,o=this.dx.applyWithAlpha(r,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(o),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n})(),tE=(function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var i=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var r=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return nu([],e,!0);r=1/s}return e.map((function(o,a){var l=Fn(Fn({},o),{x:i.xFilters[a].apply(o.x,t,r),y:i.yFilters[a].apply(o.y,t,r)});return o.z!=null&&(l.z=i.zFilters[a].apply(o.z,t,r)),l}))},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map((function(s){return new fS(t.config)})),this.yFilters=e.map((function(s){return new fS(t.config)})),this.zFilters=e.map((function(s){return new fS(t.config)})))},n})(),mS=(function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new Ll(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,s){if(e==null)return e;var i,r=Math.trunc(t);if(this.lastTimestamp>=r)return e;if(this.lastTimestamp===-1)i=1;else{for(var o=e*s-this.lastValue*this.lastValueScale,a=r-this.lastTimestamp,l=o,c=a,u=(1+this.window.length)*(1e6/30),h=0,d=this.window;h<d.length;h++){var p=d[h];if(c+p.duration>u)break;l+=p.distance,c+=p.duration}var f=l/(1e-6*c);i=1-1/(1+this.config.velocityScale*Math.abs(f)),this.window.unshift({distance:o,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=s,this.lastTimestamp=r,this.lowPassFilter.applyWithAlpha(e,i)},n})(),s3e=(function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var i=this;if(e==null)return this.reset(),null;var r=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return nu([],e,!0);r=1/s}return this.initializeFiltersIfEmpty(e),e.map((function(o,a){var l=Fn(Fn({},o),{x:i.xFilters[a].apply(o.x,t,r),y:i.yFilters[a].apply(o.y,t,r)});return o.z!=null&&(l.z=i.zFilters[a].apply(o.z,t,r)),l}))},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map((function(s){return new mS(t.config)})),this.yFilters=e.map((function(s){return new mS(t.config)})),this.zFilters=e.map((function(s){return new mS(t.config)})))},n})(),gS=(function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new s3e(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new tE(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,s,i,r){if(i===void 0&&(i=!1),e==null)return this.keypointsFilter.reset(),null;var o=r!=null?(function(c,u){return(c.width*u.width+c.height*u.height)/2})(r,s):1,a=i?D4(e,s):e,l=this.keypointsFilter.apply(a,t,o);return i?F4(l,s):l},n})(),dD=(function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map((function(a){return new Ll(t.alpha)})));for(var s=[],i=0;i<e.length;++i){var r=e[i],o=Fn({},r);o.score=this.visibilityFilters[i].apply(r.score),s.push(o)}return s},n})(),i3e={interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Nd={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},r3e={maxPoses:1,flipHorizontal:!1},o3e={applyExponentialOnBoxSize:!1,flipVertically:!1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},a3e=.3,pD={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25},l3e={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},c3e={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},u3e={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},h3e={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},d3e={kernelSize:7,minConfidenceToRefine:.5},fD={alpha:.1},p3e={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},f3e={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},m3e={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},g3e={activation:"none"},A3e={combineWithPreviousRatio:.7},y3e=(function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return ln(this,void 0,void 0,(function(){return cn(this,(function(e){return[2,E4(this.mask)]}))}))},n.prototype.toImageData=function(){return ln(this,void 0,void 0,(function(){return cn(this,(function(e){return[2,_4(this.mask)]}))}))},n.prototype.toTensor=function(){return ln(this,void 0,void 0,(function(){return cn(this,(function(e){return[2,this.mask]}))}))},n.prototype.getUnderlyingType=function(){return"tensor"},n})();function x3e(n){return T4(n),"person"}var b3e=(function(){function n(e,t,s,i,r,o){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=s,this.enableSegmentation=i,this.smoothSegmentation=r,this.modelType=o,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=(function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var d=[],p=0;p<h.numLayers;){for(var f=[],g=[],m=[],A=[],y=p;y<h.strides.length&&h.strides[y]===h.strides[p];){var b=aD(h.minScale,h.maxScale,y,h.strides.length);if(y===0&&h.reduceBoxesInLowestLayer)m.push(1),m.push(2),m.push(.5),A.push(.1),A.push(b),A.push(b);else{for(var x=0;x<h.aspectRatios.length;++x)m.push(h.aspectRatios[x]),A.push(b);if(h.interpolatedScaleAspectRatio>0){var C=y===h.strides.length-1?1:aD(h.minScale,h.maxScale,y+1,h.strides.length);A.push(Math.sqrt(b*C)),m.push(h.interpolatedScaleAspectRatio)}}y++}for(var w=0;w<m.length;++w){var E=Math.sqrt(m[w]);f.push(A[w]/E),g.push(A[w]*E)}var T=0,v=0;if(h.featureMapHeight.length>0)T=h.featureMapHeight[p],v=h.featureMapWidth[p];else{var S=h.strides[p];T=Math.ceil(h.inputSizeHeight/S),v=Math.ceil(h.inputSizeWidth/S)}for(var _=0;_<T;++_)for(var N=0;N<v;++N)for(var D=0;D<f.length;++D){var P={xCenter:(N+h.anchorOffsetX)/v,yCenter:(_+h.anchorOffsetY)/T,width:0,height:0};h.fixedAnchorSize?(P.width=1,P.height=1):(P.width=g[D],P.height=f[D]),d.push(P)}p=y}return d})(i3e);var a=ls(this.anchors.map((function(h){return h.width}))),l=ls(this.anchors.map((function(h){return h.height}))),c=ls(this.anchors.map((function(h){return h.xCenter}))),u=ls(this.anchors.map((function(h){return h.yCenter})));this.anchorTensor={x:c,y:u,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?Ji([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,s){return ln(this,void 0,void 0,(function(){var i,r,o,a,l,c,u,h,d,p,f,g,m,A,y,b,x,C,w,E,T,v,S;return cn(this,(function(_){switch(_.label){case 0:return i=(function(N){var D;if((D=N==null?r3e:Fn({},N)).maxPoses==null&&(D.maxPoses=1),D.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(D.maxPoses,". Should be > 0."));if(D.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return D})(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=i.maxPoses,this.timestamp=s!=null?1e3*s:R4(e)?1e6*e.currentTime:null,r=Cp(e),o=le((function(){return We(ZB(e),"float32")})),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(o)]);case 1:if((l=_.sent()).length===0)return this.reset(),o.dispose(),[2,[]];c=l[0],a=this.poseDetectionToRoi(c,r),_.label=2;case 2:return[4,this.poseLandmarksByRoi(a,o)];case 3:return u=_.sent(),o.dispose(),u==null?(this.reset(),[2,[]]):(h=u.landmarks,d=u.auxiliaryLandmarks,p=u.poseScore,f=u.worldLandmarks,g=u.segmentationMask,m=this.poseLandmarkFiltering(h,d,f,r),A=m.actualLandmarksFiltered,y=m.auxiliaryLandmarksFiltered,b=m.actualWorldLandmarksFiltered,x=this.poseLandmarksToRoi(y,r),this.regionOfInterest=x,C=this.smoothSegmentation&&g!=null?this.poseSegmentationFiltering(g):g,(w=A!=null?D4(A,r):null)!=null&&w.forEach((function(N,D){N.name=Hg[D]})),(E=b)!=null&&E.forEach((function(N,D){N.name=Hg[D]})),T={score:p,keypoints:w,keypoints3D:E},C!==null&&(v=le((function(){var N=rs(C,2),D=ho(N,[[0,0],[0,0],[0,1]]);return xC(D,[[0,0],[0,0],[0,2]],"symmetric")})),this.smoothSegmentation||Et(C),S={maskValueToLabel:x3e,mask:new y3e(v)},T.segmentation=S),[2,[T]])}}))}))},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=JDe(t,e,A3e),Et(e)),Et(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Et([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Et(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Ji([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return ln(this,void 0,void 0,(function(){var t,s,i,r,o,a,l,c,u,h;return cn(this,(function(d){switch(d.label){case 0:return t=eE(e,l3e),s=t.imageTensor,i=t.padding,r=this.detectorModel.predict(s),o=XDe(r),a=o.boxes,[4,ZDe([l=o.logits,a],this.anchorTensor,o3e)];case 1:return(c=d.sent()).length===0?(Et([s,r,l,a]),[2,c]):[4,jDe(c,this.maxPoses,a3e)];case 2:return u=d.sent(),h=(function(p,f){p===void 0&&(p=[]);for(var g=f.left,m=f.top,A=f.left+f.right,y=f.top+f.bottom,b=0;b<p.length;b++){var x=p[b],C=x.locationData.relativeBoundingBox,w=(C.xMin-g)/(1-A),E=(C.yMin-m)/(1-y),T=C.width/(1-A),v=C.height/(1-y);C.xMin=w,C.yMin=E,C.width=T,C.height=v,C.xMax=w+T,C.yMax=E+v;var S=x.locationData.relativeKeypoints;S&&S.forEach((function(_){var N=(_.x-g)/(1-A),D=(_.y-m)/(1-y);_.x=N,_.y=D}))}return p})(u,i),Et([s,r,l,a]),[2,h]}}))}))},n.prototype.poseDetectionToRoi=function(e,t){return hD(dS(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,pD)},n.prototype.poseLandmarksByRoi=function(e,t){return ln(this,void 0,void 0,(function(){var s,i,r,o,a,l,c,u,h,d,p,f,g,m;return cn(this,(function(A){switch(A.label){case 0:if(s=Cp(t),i=eE(t,c3e,e),r=i.imageTensor,o=i.padding,a=i.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(r,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(u=A.sent())==null?(Et(c),Et(r),[2,null]):(h=u.landmarks,d=u.auxiliaryLandmarks,p=u.poseScore,f=u.worldLandmarks,g=u.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,e,o,a,h,d,f,g)]);case 2:return m=A.sent(),Et(c),Et(r),[2,Fn({poseScore:p},m)]}}))}))},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,s,i,r,o,a,l){return ln(this,void 0,void 0,(function(){var c,u,h,d,p,f;return cn(this,(function(g){return c=cD(r,s),u=cD(o,s),h=oD(c,t),d=oD(u,t),p=(function(m,A){for(var y=[],b=0,x=m;b<x.length;b++){var C=x[b],w=C.x,E=C.y,T=A.rotation,v=Math.cos(T)*w-Math.sin(T)*E,S=Math.sin(T)*w+Math.cos(T)*E,_=Fn({},C);_.x=v,_.y=S,y.push(_)}return y})(a,t),f=null,this.enableSegmentation&&(f=le((function(){var m=l.shape,A=m[0],y=m[1],b=(function(w){var E=M4(new Array(16).fill(0));E[0][0]=wi(w,0,0),E[1][0]=-wi(w,0,1),E[2][0]=wi(w,0,2),E[3][0]=-wi(w,0,3),E[0][2]=wi(w,2,0),E[1][2]=-wi(w,2,1),E[2][2]=wi(w,2,2),E[3][2]=-wi(w,2,3),E[0][1]=-wi(w,1,0),E[1][1]=wi(w,1,1),E[2][1]=-wi(w,1,2),E[3][1]=wi(w,1,3),E[0][3]=-wi(w,3,0),E[1][3]=wi(w,3,1),E[2][3]=-wi(w,3,2),E[3][3]=wi(w,3,3);for(var T=w[0][0]*E[0][0]+w[1][0]*E[0][1]+w[2][0]*E[0][2]+w[3][0]*E[0][3],v=0;v<E.length;v++)for(var S=0;S<E.length;S++)E[v][S]/=T;return E})(i),x=Ji(k4(b,{width:y,height:A},e),[1,8]),C=[1,A,y,1];return mn(ii.transform(ee(l,C),x,"bilinear","constant",0,[e.height,e.width]),[0,3])})),Et(l)),[2,{landmarks:h,auxiliaryLandmarks:d,worldLandmarks:p,segmentationMask:f}]}))}))},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return ln(this,void 0,void 0,(function(){var t,s,i,r,o,a,l,c,u,h,d,p,f;return cn(this,(function(g){switch(g.label){case 0:return t=e[0],s=e[1],i=e[2],r=e[3],o=this.enableSegmentation?e[4]:null,[4,s.data()];case 1:return(a=g.sent()[0])<.5?[2,null]:[4,uD(t,u3e)];case 2:return[4,KDe(g.sent(),i,d3e)];case 3:return l=g.sent(),c=l.slice(0,33),u=l.slice(33,35),[4,uD(r,h3e)];case 4:return h=g.sent(),d=h.slice(0,33),p=(function(m,A,y){for(var b=[],x=0;x<m.length;x++){var C=Fn({},A[x]);C.score=m[x].score,b.push(C)}return b})(c,d),f=this.enableSegmentation?(function(m,A,y){return le((function(){var b=mn(m,[0]),x=b.shape[2];if(x===1){var C=b;switch(A.activation){case"none":break;case"sigmoid":C=yr(C);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(A.activation,")"))}var w=C;return mn(w,[2])}throw new Error("Unsupported number of tensor channels ".concat(x))}))})(o,g3e):null,[2,{landmarks:c,auxiliaryLandmarks:u,poseScore:a,worldLandmarks:p,segmentationMask:f}]}}))}))},n.prototype.poseLandmarksToRoi=function(e,t){return hD(dS(lD(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,pD)},n.prototype.poseLandmarkFiltering=function(e,t,s,i){var r,o,a;if(this.timestamp!=null&&this.enableSmoothing){var l=dS(lD(t),i,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new dD(fD)),r=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new dD(fD)),o=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new gS(p3e)),r=this.landmarksSmoothingFilterActual.apply(r,this.timestamp,i,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new gS(f3e)),o=this.landmarksSmoothingFilterAuxiliary.apply(o,this.timestamp,i,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new gS(m3e)),a=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else r=e,o=t,a=s;return{actualLandmarksFiltered:r,auxiliaryLandmarksFiltered:o,actualWorldLandmarksFiltered:a}},n})();function I3e(n){return ln(this,void 0,void 0,(function(){var e,t,s,i,r,o;return cn(this,(function(a){switch(a.label){case 0:return e=(function(l){var c=Fn({},l??Nd);if(c.enableSmoothing==null&&(c.enableSmoothing=Nd.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=Nd.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=Nd.smoothSegmentation),c.modelType==null&&(c.modelType=Nd.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=Nd.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c})(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Du(e.detectorModelUrl,{fromTFHub:t}),Du(e.landmarkModelUrl,{fromTFHub:s})])];case 1:return i=a.sent(),r=i[0],o=i[1],[2,new b3e(r,o,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}}))}))}var Vl,di,$4=(function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,i=t.keypointTrackerParams.keypointFalloff;s<i.length;s++){var r=i[s];if(r<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(r))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var s=this.computeSimilarity(e);return this.assignTracks(e,s,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map((function(e){return e.id})))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter((function(s){return e-s.lastTimestamp<=t.maxAge}))},n.prototype.assignTracks=function(e,t,s){for(var i=Array.from(Array(t[0].length).keys()),r=[],o=0,a=Array.from(Array(e.length).keys());o<a.length;o++){var l=a[o];if(i.length!==0){for(var c=-1,u=-1,h=0,d=i;h<d.length;h++){var p=d[h],f=t[l][p];f>=this.minSimilarity&&f>u&&(c=p,u=f)}if(c>=0){var g=this.tracks[c];g=Object.assign(g,this.createTrack(e[l],s,g.id)),e[l].id=g.id;var m=i.indexOf(c);i.splice(m,1)}else r.push(l)}else r.push(l)}for(var A=0,y=r;A<y.length;A++){l=y[A];var b=this.createTrack(e[l],s);this.tracks.push(b),e[l].id=b.id}},n.prototype.updateTracks=function(e){this.tracks.sort((function(t,s){return s.lastTimestamp-t.lastTimestamp})),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,s){var i={id:s||this.nextTrackID(),lastTimestamp:t,keypoints:nu([],e.keypoints,!0).map((function(r){return Fn({},r)}))};return e.box!==void 0&&(i.box=Fn({},e.box)),i},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter((function(s){return!e.includes(s.id)}))},n.prototype.reset=function(){this.tracks=[]},n})(),C3e=(function(n){function e(t){return n.call(this,t)||this}return S4(e,n),e.prototype.computeSimilarity=function(t){var s=this;return t.length===0||this.tracks.length===0?[[]]:t.map((function(i){return s.tracks.map((function(r){return s.iou(i,r)}))}))},e.prototype.iou=function(t,s){var i=Math.max(t.box.xMin,s.box.xMin),r=Math.max(t.box.yMin,s.box.yMin),o=Math.min(t.box.xMax,s.box.xMax),a=Math.min(t.box.yMax,s.box.yMax);if(i>=o||r>=a)return 0;var l=(o-i)*(a-r);return l/(t.box.width*t.box.height+s.box.width*s.box.height-l)},e})($4),w3e=(function(n){function e(t){var s=n.call(this,t)||this;return s.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=t.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,s}return S4(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var s=[],i=0,r=t;i<r.length;i++){for(var o=r[i],a=[],l=0,c=this.tracks;l<c.length;l++){var u=c[l];a.push(this.oks(o,u))}s.push(a)}return s},e.prototype.oks=function(t,s){for(var i=this.area(s.keypoints)+1e-6,r=0,o=0,a=0;a<t.keypoints.length;++a){var l=t.keypoints[a],c=s.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){o+=1;var u=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),h=2*this.keypointFalloff[a];r+=Math.exp(-1*u/(2*i*Math.pow(h,2)))}}return o<this.minNumKeyoints?0:r/o},e.prototype.area=function(t){var s=this,i=t.filter((function(l){return l.score>s.keypointThreshold})),r=Math.min.apply(Math,nu([1],i.map((function(l){return l.x})),!1)),o=Math.max.apply(Math,nu([0],i.map((function(l){return l.x})),!1)),a=Math.min.apply(Math,nu([1],i.map((function(l){return l.y})),!1));return(o-r)*(Math.max.apply(Math,nu([0],i.map((function(l){return l.y})),!1))-a)},e})($4);function P4(n){switch(n){case di.BlazePose:return Hg.reduce((function(e,t,s){return e[t]=s,e}),{});case di.PoseNet:case di.MoveNet:return Ia.reduce((function(e,t,s){return e[t]=s,e}),{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Vl||(Vl={})),(function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"})(di||(di={}));var v3e=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case di.BlazePose:return zDe;case di.PoseNet:case di.MoveNet:return UDe;default:throw new Error("Model ".concat(n," is not supported."))}},getAdjacentPairs:function(n){switch(n){case di.BlazePose:return VDe;case di.PoseNet:case di.MoveNet:return QDe;default:throw new Error("Model ".concat(n," is not supported."))}},getKeypointIndexByName:P4}),mD=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],L4={modelType:"SinglePose.Lightning",enableSmoothing:!0},gD={},AD={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},AS={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},yD={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function S3e(n,e,t,s){for(var i={},r=0,o=Ia;r<o.length;r++){var a=o[r];i[a]=[e[t[a]].y*s.height,e[t[a]].x*s.width]}if((function(y,b){return(y[b.left_hip].score>.2||y[b.right_hip].score>.2)&&(y[b.left_shoulder].score>.2||y[b.right_shoulder].score>.2)})(e,t)){var l=(i.left_hip[0]+i.right_hip[0])/2,c=(i.left_hip[1]+i.right_hip[1])/2,u=(function(y,b,x,C,w){for(var E=["left_shoulder","right_shoulder","left_hip","right_hip"],T=0,v=0,S=0;S<E.length;S++)(L=Math.abs(C-x[E[S]][0]))>T&&(T=L),(z=Math.abs(w-x[E[S]][1]))>v&&(v=z);for(var _=0,N=0,D=0,P=Object.keys(x);D<P.length;D++){var L,z,q=P[D];y[b[q]].score<.2||((L=Math.abs(C-x[q][0]))>_&&(_=L),(z=Math.abs(w-x[q][1]))>N&&(N=z))}return[T,v,_,N]})(e,t,i,l,c),h=u[0],d=u[1],p=u[2],f=u[3],g=Math.max(1.9*d,1.9*h,1.2*p,1.2*f),m=[l-(g=Math.min(g,Math.max(c,s.width-c,l,s.height-l))),c-g];if(g>Math.max(s.width,s.height)/2)return nE(n==null,s);var A=2*g;return{yMin:m[0]/s.height,xMin:m[1]/s.width,yMax:(m[0]+A)/s.height,xMax:(m[1]+A)/s.width,height:(m[0]+A)/s.height-m[0]/s.height,width:(m[1]+A)/s.width-m[1]/s.width}}return nE(n==null,s)}function nE(n,e){var t,s,i,r;return n?e.width>e.height?(t=1,s=e.height/e.width,i=0,r=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,s=1,i=(e.height/2-e.width/2)/e.height,r=0):e.width>e.height?(t=e.width/e.height,s=1,i=(e.height/2-e.width/2)/e.height,r=0):(t=1,s=e.height/e.width,i=0,r=(e.width/2-e.height/2)/e.width),{yMin:i,xMin:r,yMax:i+t,xMax:r+s,height:t,width:s}}function E3e(n){var e,t=n==null?L4:Fn({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(mD.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(mD));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=Vl.BoundingBox),t.trackerType===Vl.Keypoint)t.trackerConfig!=null?t.trackerConfig=(function(s){var i=xD(AS,s);return i.keypointTrackerParams=Fn({},AS.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(i.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(i.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(i.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),i})(t.trackerConfig):t.trackerConfig=AS;else{if(t.trackerType!==Vl.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,xD(yD,e)):t.trackerConfig=yD}return t}function xD(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var _3e=(function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=P4(di.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new tE(AD),this.cropRegionFilterYMin=new Ll(.9),this.cropRegionFilterXMin=new Ll(.9),this.cropRegionFilterYMax=new Ll(.9),this.cropRegionFilterXMax=new Ll(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===Vl.Keypoint?this.tracker=new w3e(t.trackerConfig):t.trackerType===Vl.BoundingBox&&(this.tracker=new C3e(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return ln(this,void 0,void 0,(function(){var t,s,i,r,o;return cn(this,(function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return vu()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=a.sent(),a.label=3;case 3:for(t.dispose(),i={keypoints:[],score:0},r=0,o=0;o<17;++o)i.keypoints[o]={y:s[3*o],x:s[3*o+1],score:s[3*o+2]},i.keypoints[o].score>.2&&(++r,i.score+=i.keypoints[o].score);return r>0&&(i.score/=r),[2,i]}}))}))},n.prototype.runMultiPersonPoseModel=function(e){return ln(this,void 0,void 0,(function(){var t,s,i,r,o,a,l,c;return cn(this,(function(u){switch(u.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return vu()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=u.sent(),u.label=3;case 3:for(t.dispose(),i=[],r=s.length/56,o=0;o<r;++o)for(i[o]={keypoints:[]},a=56*o+51,i[o].box={yMin:s[a],xMin:s[a+1],yMax:s[a+2],xMax:s[a+3],width:s[a+3]-s[a+1],height:s[a+2]-s[a]},l=56*o+55,i[o].score=s[l],i[o].keypoints=[],c=0;c<17;++c)i[o].keypoints[c]={y:s[56*o+3*c],x:s[56*o+3*c+1],score:s[56*o+3*c+2]};return[2,i]}}))}))},n.prototype.estimatePoses=function(e,t,s){return t===void 0&&(t=gD),ln(this,void 0,void 0,(function(){var i,r,o,a,l,c;return cn(this,(function(u){switch(u.label){case 0:return t=(function(h){return h==null?gD:Fn({},h)})(t),e==null?(this.reset(),[2,[]]):(s==null?R4(e)&&(s=1e6*e.currentTime):s*=1e3,i=ZB(e),r=Cp(i),o=rs(i,0),e instanceof nn||i.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(o,r,s)]);case 1:return a=u.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(o,r,s)];case 3:a=u.sent(),u.label=4;case 4:for(l=0;l<a.length;++l)for(c=0;c<a[l].keypoints.length;++c)a[l].keypoints[c].name=Ia[c],a[l].keypoints[c].y*=r.height,a[l].keypoints[c].x*=r.width;return[2,a]}}))}))},n.prototype.estimateSinglePose=function(e,t,s){return ln(this,void 0,void 0,(function(){var i,r,o,a,l=this;return cn(this,(function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=nE(this.cropRegion==null,t)),i=le((function(){var u=Ji([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),h=as([1],"int32"),d=[l.modelInputResolution.height,l.modelInputResolution.width];return We(ii.cropAndResize(e,u,h,d,"bilinear",0),"int32")})),e.dispose(),[4,this.runSinglePersonPoseModel(i)];case 1:if(r=c.sent(),i.dispose(),r.score<this.minPoseScore)return this.reset(),[2,[]];for(o=0;o<r.keypoints.length;++o)r.keypoints[o].y=this.cropRegion.yMin+r.keypoints[o].y*this.cropRegion.height,r.keypoints[o].x=this.cropRegion.xMin+r.keypoints[o].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(r.keypoints=this.keypointFilter.apply(r.keypoints,s,1)),a=S3e(this.cropRegion,r.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[r]]}}))}))},n.prototype.estimateMultiplePoses=function(e,t,s){return ln(this,void 0,void 0,(function(){var i,r,o,a,l,c,u,h,d,p,f,g=this;return cn(this,(function(m){switch(m.label){case 0:return t.width>t.height?(r=this.multiPoseMaxDimension,o=Math.round(this.multiPoseMaxDimension*t.height/t.width),i=ii.resizeBilinear(e,[o,r]),l=r,c=32*Math.ceil(o/32),a=ho(i,[[0,0],[0,c-o],[0,0],[0,0]])):(r=Math.round(this.multiPoseMaxDimension*t.width/t.height),o=this.multiPoseMaxDimension,i=ii.resizeBilinear(e,[o,r]),l=32*Math.ceil(r/32),c=o,a=ho(i,[[0,0],[0,0],[0,l-r],[0,0]])),i.dispose(),e.dispose(),u=We(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(u)];case 1:for(h=m.sent(),u.dispose(),h=h.filter((function(A){return A.score>=g.minPoseScore})),p=0;p<h.length;++p)for(d=0;d<h[p].keypoints.length;++d)h[p].keypoints[d].y*=c/o,h[p].keypoints[d].x*=l/r;if(this.enableTracking&&(this.tracker.apply(h,s),this.enableSmoothing)){for(p=0;p<h.length;++p)this.keypointFilterMap.has(h[p].id)||this.keypointFilterMap.set(h[p].id,new tE(AD)),h[p].keypoints=this.keypointFilterMap.get(h[p].id).apply(h[p].keypoints,s,1);f=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach((function(A,y){f.has(y)||g.keypointFilterMap.delete(y)}))}return[2,h]}}))}))},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),s=this.cropRegionFilterXMin.apply(e.xMin),i=this.cropRegionFilterYMax.apply(e.yMax),r=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:s,yMax:i,xMax:r,height:i-t,width:r-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n})();function T3e(n){return n===void 0&&(n=L4),ln(this,void 0,void 0,(function(){var e,t,s,i;return cn(this,(function(r){switch(r.label){case 0:return e=E3e(n),s=!0,e.modelUrl?(s=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Du(e.modelUrl,{fromTFHub:s})]):[3,2];case 1:return t=r.sent(),[3,4];case 2:return i=void 0,e.modelType==="SinglePose.Lightning"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(i="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Du(i,{fromTFHub:s})];case 3:t=r.sent(),r.label=4;case 4:return vu()==="webgl"&&ae().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new _3e(t,e)]}}))}))}var bD={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},ID=["MobileNetV1","ResNet50"],CD={MobileNetV1:[8,16],ResNet50:[16]},B3e=[8,16,32],wD={MobileNetV1:[.5,.75,1],ResNet50:[1]},vD=[1,2,4],SD={maxPoses:1,flipHorizontal:!1},k3e={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},M3e=[-123.15,-115.9,-103.06];function yS(n){return Math.floor(n/2)}var N3e=(function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(yS(e),e);)this.exchange(e,yS(e)),e=yS(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var s=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=s},n})();function R3e(n,e,t,s,i,r){for(var o=r.shape,a=o[0],l=o[1],c=!0,u=Math.max(t-i,0),h=Math.min(t+i+1,a),d=u;d<h;++d){for(var p=Math.max(s-i,0),f=Math.min(s+i+1,l),g=p;g<f;++g)if(r.get(d,g,n)>e){c=!1;break}if(!c)break}return c}function D3e(n){return ln(this,void 0,void 0,(function(){return cn(this,(function(e){return[2,Promise.all(n.map((function(t){return t.buffer()})))]}))}))}function O4(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+17)}}function z4(n,e,t){var s=O4(n.heatmapY,n.heatmapX,n.id,t),i=s.y,r=s.x;return{x:n.heatmapX*e+r,y:n.heatmapY*e+i}}function U4(n,e,t,s){var i=t.x,r=t.y;return n.some((function(o){var a,l,c,u,h,d,p=o.keypoints;return a=r,l=i,c=p[s].y,u=p[s].x,(h=c-a)*h+(d=u-l)*d<=e}))}var ED=Ia.reduce((function(n,e,t){return n[e]=t,n}),{}),Q4=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map((function(n){var e=n[0],t=n[1];return[ED[e],ED[t]]})),xS=Q4.map((function(n){return n[1]})),_D=Q4.map((function(n){return n[0]}));function TD(n,e,t){return n<e?e:n>t?t:n}function bS(n,e,t,s){return{y:TD(Math.round(n.y/e),0,t-1),x:TD(Math.round(n.x/e),0,s-1)}}function BD(n,e){return{x:n.x+e.x,y:n.y+e.y}}function kD(n,e,t,s,i,r,o,a){a===void 0&&(a=2);for(var l=s.shape,c=l[0],u=l[1],h={y:e.y,x:e.x},d=BD(h,(function(y,b,x){var C=x.shape[2]/2;return{y:x.get(b.y,b.x,y),x:x.get(b.y,b.x,C+y)}})(n,bS(h,r,c,u),o)),p=0;p<a;p++){var f=bS(d,r,c,u),g=O4(f.y,f.x,t,i);d=BD({x:f.x*r,y:f.y*r},{x:g.x,y:g.y})}var m=bS(d,r,c,u),A=s.get(m.y,m.x,t);return{y:d.y,x:d.x,name:Ia[t],score:A}}function F3e(n,e,t,s,i,r){var o=e.shape[2],a=xS.length,l=new Array(o),c=n.part,u=n.score,h=z4(c,s,t);l[c.id]={score:u,name:Ia[c.id],y:h.y,x:h.x};for(var d=a-1;d>=0;--d){var p=xS[d],f=_D[d];l[p]&&!l[f]&&(l[f]=kD(d,l[p],f,e,t,s,r))}for(d=0;d<a;++d)p=_D[d],f=xS[d],l[p]&&!l[f]&&(l[f]=kD(d,l[p],f,e,t,s,i));return l}function $3e(n,e,t){return t.reduce((function(s,i,r){var o=i.y,a=i.x,l=i.score;return U4(n,e,{y:o,x:a},r)||(s+=l),s}),0)/t.length}function P3e(n,e,t,s,i,r,o,a){return o===void 0&&(o=.5),a===void 0&&(a=20),ln(this,void 0,void 0,(function(){var l,c,u,h,d,p,f,g,m,A,y,b;return cn(this,(function(x){switch(x.label){case 0:return[4,D3e([n,e,t,s])];case 1:for(l=x.sent(),c=l[0],u=l[1],h=l[2],d=l[3],p=[],f=(function(C,w,E){for(var T=E.shape,v=T[0],S=T[1],_=T[2],N=new N3e(v*S*_,(function(q){return q.score})),D=0;D<v;++D)for(var P=0;P<S;++P)for(var L=0;L<_;++L){var z=E.get(D,P,L);z<C||R3e(L,z,D,P,w,E)&&N.enqueue({score:z,part:{heatmapY:D,heatmapX:P,id:L}})}return N})(o,1,c),g=a*a;p.length<r&&!f.empty();)m=f.dequeue(),A=z4(m.part,i,u),U4(p,g,A,m.part.id)||(y=F3e(m,c,u,i,h,d),b=$3e(p,g,y),p.push({keypoints:y,score:b}));return[2,p]}}))}))}function V4(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return n}var L3e=(function(){function n(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=at(this.outputShape),this.dispatch=Xe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(V4("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n})();function O3e(n,e){if(Yl()instanceof Zf)return(function(t,s){var i=Yl(),r=new L3e(s.shape),o=i.runWebGPUProgram(r,[t,s],"float32");return hi().makeTensorFromTensorInfo(o)})(n,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var z3e=(function(){function n(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=at(t),this.dispatch=Xe(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(V4("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n})();function U3e(n,e){if(Yl()instanceof Zf)return(function(t,s){var i=Yl(),r=new z3e(t.shape),o=i.runWebGPUProgram(r,[t,s],"float32");return hi().makeTensorFromTensorInfo(o)})(n,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function G4(n){var e=n.shape,t=e[0],s=e[1],i=e[2];return le((function(){var r,o,a=ee(n,[t*s,i]),l=jl(a,0),c=rs(et(l,wt(s,"int32")),1),u=rs((r=l,o=s,le((function(){var h=et(r,wt(o,"int32"));return nt(r,K(h,wt(o,"int32")))}))),1);return Jn([c,u],1)}))}function Q3e(n,e,t){return le((function(){var s=(function(i,r){for(var o=[],a=0;a<Ia.length;a++){var l=i.get(a,0).valueOf(),c=i.get(a,1).valueOf(),u=V3e(l,c,a,r),h=u.x,d=u.y;o.push(d),o.push(h)}return Ji(o,[Ia.length,2])})(n,t);return Be(We(K(n.toTensor(),wt(e,"int32")),"float32"),s)}))}function V3e(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+Ia.length)}}function G3e(n,e,t){return ln(this,void 0,void 0,(function(){var s,i,r,o,a,l,c,u,h,d;return cn(this,(function(p){switch(p.label){case 0:return s=0,i=G4(n),[4,Promise.all([n.buffer(),e.buffer(),i.buffer()])];case 1:return r=p.sent(),o=r[0],a=r[1],l=r[2],[4,(c=Q3e(l,t,a)).buffer()];case 2:return u=p.sent(),h=Array.from((function(f,g){for(var m=g.shape[0],A=new Float32Array(m),y=0;y<m;y++){var b=g.get(y,0),x=g.get(y,1);A[y]=f.get(b,x,y)}return A})(o,l)),d=h.map((function(f,g){return s+=f,{y:u.get(g,0),x:u.get(g,1),score:f,name:Ia[g]}})),i.dispose(),c.dispose(),[2,{keypoints:d,score:s/d.length}]}}))}))}function W3e(n,e,t){return ln(this,void 0,void 0,(function(){var s,i,r;return cn(this,(function(o){return s=G4(n),i=(function(a,l,c){return le((function(){var u=U3e(a,c);return Be(We(K(a,wt(l,"int32")),"float32"),u)}))})(s,t,e),r=O3e(n,s),[2,[i,r]]}))}))}function MD(n,e){return(n-1)%e==0}var ND="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",RD="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function DD(n,e){return(function(t,s){return(t-1)%s==0})(n,e)?n:Math.floor(n/e)*e+1}var FD=(function(){function n(e,t){this.posenetModel=e;var s=this.posenetModel.inputs[0].shape;R(s[1]===-1&&s[2]===-1,(function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"}));var i,r,o=(i=t.inputResolution,r=t.outputStride,{height:DD(i.height,r),width:DD(i.width,r)});(function(a){R(B3e.indexOf(a)>=0,(function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."}))})(t.outputStride),(function(a,l){R(MD(a.height,l),(function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")})),R(MD(a.width,l),(function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")}))})(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=SD),ln(this,void 0,void 0,(function(){return cn(this,(function(s){return[2,this.estimatePosesGPU(e,t,!1)]}))}))},n.prototype.estimatePosesGPU=function(e,t,s){return t===void 0&&(t=SD),s===void 0&&(s=!1),ln(this,void 0,void 0,(function(){var i,r,o,a,l,c,u,h,d,p,f,g,m,A,y,b,x,C;return cn(this,(function(w){switch(w.label){case 0:return i=(function(E){var T=E;if(T.maxPoses==null&&(T.maxPoses=1),T.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(T.maxPoses,". Should be > 0."));if(T.maxPoses>1){if((T=Fn(Fn({},k3e),T)).scoreThreshold<0||T.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(T.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(T.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(T.nmsRadius,"."))}return T})(t),e==null?[2,s?[[],[]]:[]]:(this.maxPoses=i.maxPoses,r=eE(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=r.imageTensor,a=r.padding,l=this.architecture==="ResNet50"?Be(o,M3e):N4(o,[-1,1]),c=this.posenetModel.predict(l),this.architecture==="ResNet50"?(u=mn(c[2],[0]),h=mn(c[3],[0]),d=mn(c[0],[0]),p=mn(c[1],[0])):(u=mn(c[0],[0]),h=mn(c[1],[0]),d=mn(c[2],[0]),p=mn(c[3],[0])),f=yr(h),this.maxPoses!==1?[3,5]:s?[4,W3e(f,u,this.outputStride)]:[3,2]);case 1:return m=w.sent(),y=m[0],A=m[1],g=[y,A],[3,4];case 2:return[4,G3e(f,u,this.outputStride)];case 3:y=w.sent(),g=[y],w.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,P3e(f,u,d,p,this.outputStride,this.maxPoses,i.scoreThreshold,i.nmsRadius)];case 6:g=w.sent(),w.label=7;case 7:if(s){if(i.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");b=this.getCanvasInfo(Cp(e),this.inputResolution,a)}else C=Cp(e),x=(function(E,T,v,S){var _=T.height,N=T.width,D=_/(v.height*(1-S.top-S.bottom)),P=N/(v.width*(1-S.left-S.right)),L=-S.top*v.height,z=-S.left*v.width;if(P===1&&D===1&&L===0&&z===0)return E;for(var q=0,V=E;q<V.length;q++)for(var X=0,te=V[q].keypoints;X<te.length;X++){var se=te[X];se.x=(se.x+z)*P,se.y=(se.y+L)*D}return E})(g,C,this.inputResolution,a),i.flipHorizontal&&(x=(function(E,T){for(var v=0,S=E;v<S.length;v++)for(var _=0,N=S[v].keypoints;_<N.length;_++){var D=N[_];D.x=T.width-1-D.x}return E})(x,C));return o.dispose(),l.dispose(),Et(c),u.dispose(),h.dispose(),d.dispose(),p.dispose(),f.dispose(),[2,s?[g,b]:x]}}))}))},n.prototype.getCanvasInfo=function(e,t,s){var i=e.height,r=e.width,o=i/(t.height*(1-s.top-s.bottom)),a=r/(t.width*(1-s.left-s.right)),l=-s.top*t.height;return[-s.left*t.width,l,a,o,e.width,e.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n})();function H3e(n){return n===void 0&&(n=bD),ln(this,void 0,void 0,(function(){var e,t,s,i,r;return cn(this,(function(o){switch(o.label){case 0:return(e=(function(u){var h=u||bD;if(h.architecture==null&&(h.architecture="MobileNetV1"),ID.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(ID));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),CD[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(CD[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),wD[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(wD[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),vD.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(vD," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h})(n)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride".concat(a,".json"),t=l===4?RD+"float/"+c:RD+"quant".concat(l,"/")+c,[4,Du(e.modelUrl||t)]);case 1:return s=o.sent(),[2,new FD(s,e)];case 2:return i=(function(u,h,d){var p={1:"100",.75:"075",.5:"050"},f="model-stride".concat(u,".json");return d===4?ND+"float/".concat(p[h],"/")+f:ND+"quant".concat(d,"/").concat(p[h],"/")+f})(e.outputStride,e.multiplier,e.quantBytes),[4,Du(e.modelUrl||i)];case 3:return r=o.sent(),[2,new FD(r,e)]}var a,l,c}))}))}function W4(n,e){return ln(this,void 0,void 0,(function(){var t,s;return cn(this,(function(i){switch(n){case di.PoseNet:return[2,H3e(e)];case di.BlazePose:if(s=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,I3e(e)];if(t.runtime==="mediapipe")return[2,YDe(e)];s=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case di.MoveNet:return[2,T3e(e)];default:throw new Error("".concat(n," is not a supported model name."))}}))}))}var q3e={keypointsToNormalizedKeypoints:F4},H4={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}};const Y3e=Object.freeze(Object.defineProperty({__proto__:null,get SupportedModels(){return di},get TrackerType(){return Vl},calculators:q3e,createDetector:W4,movenet:H4,util:v3e},Symbol.toStringTag,{value:"Module"})),X3e=new lA(-1,1,1,-1,0,1);class j3e extends Xt{constructor(){super(),this.setAttribute("position",new gt([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new gt([0,2,0,0,2,0],2))}}const K3e=new j3e;class q4{constructor(e){this._mesh=new On(K3e,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,X3e)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}var si=Uint8Array,ng=Uint16Array,J3e=Int32Array,Y4=new si([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),X4=new si([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Z3e=new si([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),j4=function(n,e){for(var t=new ng(31),s=0;s<31;++s)t[s]=e+=1<<n[s-1];for(var i=new J3e(t[30]),s=1;s<30;++s)for(var r=t[s];r<t[s+1];++r)i[r]=r-t[s]<<5|s;return{b:t,r:i}},K4=j4(Y4,2),J4=K4.b,eFe=K4.r;J4[28]=258,eFe[258]=28;var tFe=j4(X4,0),nFe=tFe.b,Z4=new ng(32768);for(var jn=0;jn<32768;++jn){var _l=(jn&43690)>>1|(jn&21845)<<1;_l=(_l&52428)>>2|(_l&13107)<<2,_l=(_l&61680)>>4|(_l&3855)<<4,Z4[jn]=((_l&65280)>>8|(_l&255)<<8)>>1}var sg=function(n,e,t){for(var s=n.length,i=0,r=new ng(e);i<s;++i)n[i]&&++r[n[i]-1];var o=new ng(e);for(i=1;i<e;++i)o[i]=o[i-1]+r[i-1]<<1;var a;{a=new ng(1<<e);var l=15-e;for(i=0;i<s;++i)if(n[i])for(var c=i<<4|n[i],u=e-n[i],h=o[n[i]-1]++<<u,d=h|(1<<u)-1;h<=d;++h)a[Z4[h]>>l]=c}return a},Zy=new si(288);for(var jn=0;jn<144;++jn)Zy[jn]=8;for(var jn=144;jn<256;++jn)Zy[jn]=9;for(var jn=256;jn<280;++jn)Zy[jn]=7;for(var jn=280;jn<288;++jn)Zy[jn]=8;var eV=new si(32);for(var jn=0;jn<32;++jn)eV[jn]=5;var sFe=sg(Zy,9),iFe=sg(eV,5),IS=function(n){for(var e=n[0],t=1;t<n.length;++t)n[t]>e&&(e=n[t]);return e},Io=function(n,e,t){var s=e/8|0;return(n[s]|n[s+1]<<8)>>(e&7)&t},CS=function(n,e){var t=e/8|0;return(n[t]|n[t+1]<<8|n[t+2]<<16)>>(e&7)},tV=function(n){return(n+7)/8|0},Yd=function(n,e,t){return(e==null||e<0)&&(e=0),(t==null||t>n.length)&&(t=n.length),new si(n.subarray(e,t))},rFe=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Hi=function(n,e,t){var s=new Error(e||rFe[n]);if(s.code=n,Error.captureStackTrace&&Error.captureStackTrace(s,Hi),!t)throw s;return s},nV=function(n,e,t,s){var i=n.length,r=s?s.length:0;if(!i||e.f&&!e.l)return t||new si(0);var o=!t,a=o||e.i!=2,l=e.i;o&&(t=new si(i*3));var c=function(Ue){var ht=t.length;if(Ue>ht){var W=new si(Math.max(ht*2,Ue));W.set(t),t=W}},u=e.f||0,h=e.p||0,d=e.b||0,p=e.l,f=e.d,g=e.m,m=e.n,A=i*8;do{if(!p){u=Io(n,h,1);var y=Io(n,h+1,3);if(h+=3,y)if(y==1)p=sFe,f=iFe,g=9,m=5;else if(y==2){var w=Io(n,h,31)+257,E=Io(n,h+10,15)+4,T=w+Io(n,h+5,31)+1;h+=14;for(var v=new si(T),S=new si(19),_=0;_<E;++_)S[Z3e[_]]=Io(n,h+_*3,7);h+=E*3;for(var N=IS(S),D=(1<<N)-1,P=sg(S,N),_=0;_<T;){var L=P[Io(n,h,D)];h+=L&15;var b=L>>4;if(b<16)v[_++]=b;else{var z=0,q=0;for(b==16?(q=3+Io(n,h,3),h+=2,z=v[_-1]):b==17?(q=3+Io(n,h,7),h+=3):b==18&&(q=11+Io(n,h,127),h+=7);q--;)v[_++]=z}}var V=v.subarray(0,w),X=v.subarray(w);g=IS(V),m=IS(X),p=sg(V,g),f=sg(X,m)}else Hi(1);else{var b=tV(h)+4,x=n[b-4]|n[b-3]<<8,C=b+x;if(C>i){l&&Hi(0);break}a&&c(d+x),t.set(n.subarray(b,C),d),e.b=d+=x,e.p=h=C*8,e.f=u;continue}if(h>A){l&&Hi(0);break}}a&&c(d+131072);for(var te=(1<<g)-1,se=(1<<m)-1,fe=h;;fe=h){var z=p[CS(n,h)&te],me=z>>4;if(h+=z&15,h>A){l&&Hi(0);break}if(z||Hi(2),me<256)t[d++]=me;else if(me==256){fe=h,p=null;break}else{var Te=me-254;if(me>264){var _=me-257,Ee=Y4[_];Te=Io(n,h,(1<<Ee)-1)+J4[_],h+=Ee}var re=f[CS(n,h)&se],ue=re>>4;re||Hi(3),h+=re&15;var X=nFe[ue];if(ue>3){var Ee=X4[ue];X+=CS(n,h)&(1<<Ee)-1,h+=Ee}if(h>A){l&&Hi(0);break}a&&c(d+131072);var _e=d+Te;if(d<X){var ke=r-X,Ne=Math.min(X,_e);for(ke+d<0&&Hi(3);d<Ne;++d)t[d]=s[ke+d]}for(;d<_e;++d)t[d]=t[d-X]}}e.l=p,e.p=fe,e.b=d,e.f=u,p&&(u=1,e.m=g,e.d=f,e.n=m)}while(!u);return d!=t.length&&o?Yd(t,0,d):t.subarray(0,d)},oFe=new si(0),aa=function(n,e){return n[e]|n[e+1]<<8},Eo=function(n,e){return(n[e]|n[e+1]<<8|n[e+2]<<16|n[e+3]<<24)>>>0},wS=function(n,e){return Eo(n,e)+Eo(n,e+4)*4294967296},aFe=function(n){(n[0]!=31||n[1]!=139||n[2]!=8)&&Hi(6,"invalid gzip data");var e=n[3],t=10;e&4&&(t+=(n[10]|n[11]<<8)+2);for(var s=(e>>3&1)+(e>>4&1);s>0;s-=!n[t++]);return t+(e&2)},vS=(function(){function n(e,t){typeof e=="function"&&(t=e,e={}),this.ondata=t;var s=e&&e.dictionary&&e.dictionary.subarray(-32768);this.s={i:0,b:s?s.length:0},this.o=new si(32768),this.p=new si(0),s&&this.o.set(s)}return n.prototype.e=function(e){if(this.ondata||Hi(5),this.d&&Hi(4),!this.p.length)this.p=e;else if(e.length){var t=new si(this.p.length+e.length);t.set(this.p),t.set(e,this.p.length),this.p=t}},n.prototype.c=function(e){this.s.i=+(this.d=e||!1);var t=this.s.b,s=nV(this.p,this.s,this.o);this.ondata(Yd(s,t,this.s.b),this.d),this.o=Yd(s,this.s.b-32768),this.s.b=this.o.length,this.p=Yd(this.p,this.s.p/8|0),this.s.p&=7},n.prototype.push=function(e,t){this.e(e),this.c(t)},n})();function lFe(n,e){return nV(n,{i:2},e&&e.out,e&&e.dictionary)}var cFe=(function(){function n(e,t){this.v=1,this.r=0,vS.call(this,e,t)}return n.prototype.push=function(e,t){if(vS.prototype.e.call(this,e),this.r+=e.length,this.v){var s=this.p.subarray(this.v-1),i=s.length>3?aFe(s):4;if(i>s.length){if(!t)return}else this.v>1&&this.onmember&&this.onmember(this.r-s.length);this.p=s.subarray(i),this.v=0}vS.prototype.c.call(this,t),this.s.f&&!this.s.l&&!t&&(this.v=tV(this.s.p)+9,this.s={i:0},this.o=new si(0),this.push(new si(0),t))},n})(),sE=typeof TextDecoder<"u"&&new TextDecoder,uFe=0;try{sE.decode(oFe,{stream:!0}),uFe=1}catch{}var hFe=function(n){for(var e="",t=0;;){var s=n[t++],i=(s>127)+(s>223)+(s>239);if(t+i>n.length)return{s:e,r:Yd(n,t-1)};i?i==3?(s=((s&15)<<18|(n[t++]&63)<<12|(n[t++]&63)<<6|n[t++]&63)-65536,e+=String.fromCharCode(55296|s>>10,56320|s&1023)):i&1?e+=String.fromCharCode((s&31)<<6|n[t++]&63):e+=String.fromCharCode((s&15)<<12|(n[t++]&63)<<6|n[t++]&63):e+=String.fromCharCode(s)}};function dFe(n,e){if(e){for(var t="",s=0;s<n.length;s+=16384)t+=String.fromCharCode.apply(null,n.subarray(s,s+16384));return t}else{if(sE)return sE.decode(n);var i=hFe(n),r=i.s,t=i.r;return t.length&&Hi(8),r}}var pFe=function(n,e){return e+30+aa(n,e+26)+aa(n,e+28)},fFe=function(n,e,t){var s=aa(n,e+28),i=dFe(n.subarray(e+46,e+46+s),!(aa(n,e+8)&2048)),r=e+46+s,o=Eo(n,e+20),a=t&&o==4294967295?mFe(n,r):[o,Eo(n,e+24),Eo(n,e+42)],l=a[0],c=a[1],u=a[2];return[aa(n,e+10),l,c,i,r+aa(n,e+30)+aa(n,e+32),u]},mFe=function(n,e){for(;aa(n,e)!=1;e+=4+aa(n,e+2));return[wS(n,e+12),wS(n,e+4),wS(n,e+20)]};function gFe(n,e){for(var t={},s=n.length-22;Eo(n,s)!=101010256;--s)(!s||n.length-s>65558)&&Hi(13);var i=aa(n,s+8);if(!i)return{};var r=Eo(n,s+16),o=r==4294967295||i==65535;if(o){var a=Eo(n,s-12);o=Eo(n,a)==101075792,o&&(i=Eo(n,a+32),r=Eo(n,a+48))}for(var l=e&&e.filter,c=0;c<i;++c){var u=fFe(n,r,o),h=u[0],d=u[1],p=u[2],f=u[3],g=u[4],m=u[5],A=pFe(n,m);r=g,(!l||l({name:f,size:d,originalSize:p,compression:h}))&&(h?h==8?t[f]=lFe(n.subarray(A,A+d),{out:new si(p)}):Hi(14,"unknown compression type "+h):t[f]=Yd(n,A,A+d))}return t}let Ja;const sV=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&sV.decode();let Qm=null;function AFe(){return(Qm===null||Qm.byteLength===0)&&(Qm=new Uint8Array(Ja.memory.buffer)),Qm}function yFe(n,e){return n=n>>>0,sV.decode(AFe().subarray(n,n+e))}function xFe(n,e,t,s,i,r,o,a,l,c,u,h,d){return Ja.raycast_splats(n,e,t,s,i,r,o,a,l,c,u,h,d)}async function bFe(n,e){if(typeof Response=="function"&&n instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(n,e)}catch(s){if(n.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",s);else throw s}const t=await n.arrayBuffer();return await WebAssembly.instantiate(t,e)}else{const t=await WebAssembly.instantiate(n,e);return t instanceof WebAssembly.Instance?{instance:t,module:n}:t}}function IFe(){const n={};return n.wbg={},n.wbg.__wbg_buffer_609cc3eee51ed158=function(e){return e.buffer},n.wbg.__wbg_length_3b4f022188ae8db6=function(e){return e.length},n.wbg.__wbg_length_6ca527665d89694d=function(e){return e.length},n.wbg.__wbg_length_8cfd2c6409af88ad=function(e){return e.length},n.wbg.__wbg_new_9fee97a409b32b68=function(e){return new Uint16Array(e)},n.wbg.__wbg_new_e3b321dcfef89fc7=function(e){return new Uint32Array(e)},n.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(e,t,s){return new Float32Array(e,t>>>0,s>>>0)},n.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(e,t,s){return new Uint32Array(e,t>>>0,s>>>0)},n.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(e){return new Float32Array(e>>>0)},n.wbg.__wbg_set_10bad9bee0e9c58b=function(e,t,s){e.set(t,s>>>0)},n.wbg.__wbg_set_d23661d19148b229=function(e,t,s){e.set(t,s>>>0)},n.wbg.__wbg_set_f4f1f0daa30696fc=function(e,t,s){e.set(t,s>>>0)},n.wbg.__wbg_subarray_3aaeec89bb2544f0=function(e,t,s){return e.subarray(t>>>0,s>>>0)},n.wbg.__wbg_subarray_769e1e0f81bb259b=function(e,t,s){return e.subarray(t>>>0,s>>>0)},n.wbg.__wbindgen_init_externref_table=function(){const e=Ja.__wbindgen_export_0,t=e.grow(4);e.set(0,void 0),e.set(t+0,void 0),e.set(t+1,null),e.set(t+2,!0),e.set(t+3,!1)},n.wbg.__wbindgen_memory=function(){return Ja.memory},n.wbg.__wbindgen_throw=function(e,t){throw new Error(yFe(e,t))},n}function CFe(n,e){return Ja=n.exports,iV.__wbindgen_wasm_module=e,Qm=null,Ja.__wbindgen_start(),Ja}async function iV(n){if(Ja!==void 0)return Ja;typeof n<"u"&&(Object.getPrototypeOf(n)===Object.prototype?{module_or_path:n}=n:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof n>"u"&&(n=new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AX9gA39/fwBgAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgAW8Bf2AAAX9gBH9/f38AYAAAYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAcDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABwN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAHA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAcDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADgNhYAMAAQIIBQQCEwEMAAEBAgAAAQwBBAYFBQQAAQYFFAENBAAGBQQEAQQOAgECAQAIBAAVARYGCBcZGwUNAhAQBR0FAQMPAAIDAwMADAAAAQEBAAAABAECAAEAAQAAAQEDAwQJAnABLi5vAIABBQMBABEGCQF/AUGAgMAACwdiBgZtZW1vcnkCAAtzb3J0X3NwbGF0cwBNDXNvcnQzMl9zcGxhdHMATg5yYXljYXN0X3NwbGF0cwBCE19fd2JpbmRnZW5fZXhwb3J0XzABARBfX3diaW5kZ2VuX3N0YXJ0ABAJMwEAQQELLVhZV1xBZ0YuRUZETEtFRUhHST5RN086IWlfXmE7YGpKMiQrbk88IGtsVVpiYwrF3wFghCQCCX8BfiMAQRBrIggkAAJ/AkACQAJAAkACQAJAIABB9QFPBEBBACAAQc3/e08NBxogAEELaiIBQXhxIQVB7JbAACgCACIJRQ0EQR8hB0EAIAVrIQQgAEH0//8HTQRAIAVBBiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBwsgB0ECdEHQk8AAaigCACIBRQRAQQAhAAwCC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQMDQAJAIAEoAgRBeHEiBiAFSQ0AIAYgBWsiBiAETw0AIAEhAiAGIgQNAEEAIQQgASEADAQLIAEoAhQiBiAAIAYgASADQR12QQRxakEQaigCACIBRxsgACAGGyEAIANBAXQhAyABDQALDAELQeiWwAAoAgAiAkEQIABBC2pB+ANxIABBC0kbIgVBA3YiAHYiAUEDcQRAAkAgAUF/c0EBcSAAaiIGQQN0IgBB4JTAAGoiAyAAQeiUwABqKAIAIgEoAggiBEcEQCAEIAM2AgwgAyAENgIIDAELQeiWwAAgAkF+IAZ3cTYCAAsgASAAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEIAFBCGoMBwsgBUHwlsAAKAIATQ0DAkACQCABRQRAQeyWwAAoAgAiAEUNBiAAaEECdEHQk8AAaigCACICKAIEQXhxIAVrIQQgAiEBA0ACQCACKAIQIgANACACKAIUIgANACABKAIYIQcCQAJAIAEgASgCDCIARgRAIAFBFEEQIAEoAhQiABtqKAIAIgINAUEAIQAMAgsgASgCCCICIAA2AgwgACACNgIIDAELIAFBFGogAUEQaiAAGyEDA0AgAyEGIAIiAEEUaiAAQRBqIAAoAhQiAhshAyAAQRRBECACG2ooAgAiAg0ACyAGQQA2AgALIAdFDQQgASABKAIcQQJ0QdCTwABqIgIoAgBHBEAgB0EQQRQgBygCECABRhtqIAA2AgAgAEUNBQwECyACIAA2AgAgAA0DQeyWwABB7JbAACgCAEF+IAEoAhx3cTYCAAwECyAAKAIEQXhxIAVrIgIgBCACIARJIgIbIQQgACABIAIbIQEgACECDAALAAsCQEECIAB0IgNBACADa3IgASAAdHFoIgZBA3QiAUHglMAAaiIDIAFB6JTAAGooAgAiACgCCCIERwRAIAQgAzYCDCADIAQ2AggMAQtB6JbAACACQX4gBndxNgIACyAAIAVBA3I2AgQgACAFaiIGIAEgBWsiA0EBcjYCBCAAIAFqIAM2AgBB8JbAACgCACIEBEAgBEF4cUHglMAAaiEBQfiWwAAoAgAhAgJ/QeiWwAAoAgAiBUEBIARBA3Z0IgRxRQRAQeiWwAAgBCAFcjYCACABDAELIAEoAggLIQQgASACNgIIIAQgAjYCDCACIAE2AgwgAiAENgIIC0H4lsAAIAY2AgBB8JbAACADNgIAIABBCGoMCAsgACAHNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAEoAhQiAkUNACAAIAI2AhQgAiAANgIYCwJAAkAgBEEQTwRAIAEgBUEDcjYCBCABIAVqIgMgBEEBcjYCBCADIARqIAQ2AgBB8JbAACgCACIGRQ0BIAZBeHFB4JTAAGohAEH4lsAAKAIAIQICf0HolsAAKAIAIgVBASAGQQN2dCIGcUUEQEHolsAAIAUgBnI2AgAgAAwBCyAAKAIICyEGIAAgAjYCCCAGIAI2AgwgAiAANgIMIAIgBjYCCAwBCyABIAQgBWoiAEEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAwBC0H4lsAAIAM2AgBB8JbAACAENgIACyABQQhqDAYLIAAgAnJFBEBBACECQQIgB3QiAEEAIABrciAJcSIARQ0DIABoQQJ0QdCTwABqKAIAIQALIABFDQELA0AgACACIAAoAgRBeHEiAyAFayIGIARJIgcbIQkgACgCECIBRQRAIAAoAhQhAQsgAiAJIAMgBUkiABshAiAEIAYgBCAHGyAAGyEEIAEiAA0ACwsgAkUNACAFQfCWwAAoAgAiAE0gBCAAIAVrT3ENACACKAIYIQcCQAJAIAIgAigCDCIARgRAIAJBFEEQIAIoAhQiABtqKAIAIgENAUEAIQAMAgsgAigCCCIBIAA2AgwgACABNgIIDAELIAJBFGogAkEQaiAAGyEDA0AgAyEGIAEiAEEUaiAAQRBqIAAoAhQiARshAyAAQRRBECABG2ooAgAiAQ0ACyAGQQA2AgALIAdFDQIgAiACKAIcQQJ0QdCTwABqIgEoAgBHBEAgB0EQQRQgBygCECACRhtqIAA2AgAgAEUNAwwCCyABIAA2AgAgAA0BQeyWwABB7JbAACgCAEF+IAIoAhx3cTYCAAwCCwJAAkACQAJAAkAgBUHwlsAAKAIAIgFLBEAgBUH0lsAAKAIAIgBPBEAgBUGvgARqQYCAfHEiAkEQdkAAIQAgCEEEaiIBQQA2AgggAUEAIAJBgIB8cSAAQX9GIgIbNgIEIAFBACAAQRB0IAIbNgIAQQAgCCgCBCIBRQ0JGiAIKAIMIQZBgJfAACAIKAIIIgRBgJfAACgCAGoiADYCAEGEl8AAQYSXwAAoAgAiAiAAIAAgAkkbNgIAAkACQEH8lsAAKAIAIgIEQEHQlMAAIQADQCABIAAoAgAiAyAAKAIEIgdqRg0CIAAoAggiAA0ACwwCC0GMl8AAKAIAIgBBACAAIAFNG0UEQEGMl8AAIAE2AgALQZCXwABB/x82AgBB3JTAACAGNgIAQdSUwAAgBDYCAEHQlMAAIAE2AgBB7JTAAEHglMAANgIAQfSUwABB6JTAADYCAEHolMAAQeCUwAA2AgBB/JTAAEHwlMAANgIAQfCUwABB6JTAADYCAEGElcAAQfiUwAA2AgBB+JTAAEHwlMAANgIAQYyVwABBgJXAADYCAEGAlcAAQfiUwAA2AgBBlJXAAEGIlcAANgIAQYiVwABBgJXAADYCAEGclcAAQZCVwAA2AgBBkJXAAEGIlcAANgIAQaSVwABBmJXAADYCAEGYlcAAQZCVwAA2AgBBrJXAAEGglcAANgIAQaCVwABBmJXAADYCAEGolcAAQaCVwAA2AgBBtJXAAEGolcAANgIAQbCVwABBqJXAADYCAEG8lcAAQbCVwAA2AgBBuJXAAEGwlcAANgIAQcSVwABBuJXAADYCAEHAlcAAQbiVwAA2AgBBzJXAAEHAlcAANgIAQciVwABBwJXAADYCAEHUlcAAQciVwAA2AgBB0JXAAEHIlcAANgIAQdyVwABB0JXAADYCAEHYlcAAQdCVwAA2AgBB5JXAAEHYlcAANgIAQeCVwABB2JXAADYCAEHslcAAQeCVwAA2AgBB9JXAAEHolcAANgIAQeiVwABB4JXAADYCAEH8lcAAQfCVwAA2AgBB8JXAAEHolcAANgIAQYSWwABB+JXAADYCAEH4lcAAQfCVwAA2AgBBjJbAAEGAlsAANgIAQYCWwABB+JXAADYCAEGUlsAAQYiWwAA2AgBBiJbAAEGAlsAANgIAQZyWwABBkJbAADYCAEGQlsAAQYiWwAA2AgBBpJbAAEGYlsAANgIAQZiWwABBkJbAADYCAEGslsAAQaCWwAA2AgBBoJbAAEGYlsAANgIAQbSWwABBqJbAADYCAEGolsAAQaCWwAA2AgBBvJbAAEGwlsAANgIAQbCWwABBqJbAADYCAEHElsAAQbiWwAA2AgBBuJbAAEGwlsAANgIAQcyWwABBwJbAADYCAEHAlsAAQbiWwAA2AgBB1JbAAEHIlsAANgIAQciWwABBwJbAADYCAEHclsAAQdCWwAA2AgBB0JbAAEHIlsAANgIAQeSWwABB2JbAADYCAEHYlsAAQdCWwAA2AgBB/JbAACABQQ9qQXhxIgBBCGsiAjYCAEHglsAAQdiWwAA2AgBB9JbAACAEQShrIgMgASAAa2pBCGoiADYCACACIABBAXI2AgQgASADakEoNgIEQYiXwABBgICAATYCAAwICyACIANJIAEgAk1yDQAgACgCDCIDQQFxDQAgA0EBdiAGRg0DC0GMl8AAQYyXwAAoAgAiACABIAAgAUkbNgIAIAEgBGohA0HQlMAAIQACQAJAA0AgAyAAKAIAIgdHBEAgACgCCCIADQEMAgsLIAAoAgwiA0EBcQ0AIANBAXYgBkYNAQtB0JTAACEAA0ACQCACIAAoAgAiA08EQCACIAMgACgCBGoiB0kNAQsgACgCCCEADAELC0H8lsAAIAFBD2pBeHEiAEEIayIDNgIAQfSWwAAgBEEoayIJIAEgAGtqQQhqIgA2AgAgAyAAQQFyNgIEIAEgCWpBKDYCBEGIl8AAQYCAgAE2AgAgAiAHQSBrQXhxQQhrIgAgACACQRBqSRsiA0EbNgIEQdCUwAApAgAhCiADQRBqQdiUwAApAgA3AgAgAyAKNwIIQdyUwAAgBjYCAEHUlMAAIAQ2AgBB0JTAACABNgIAQdiUwAAgA0EIajYCACADQRxqIQADQCAAQQc2AgAgAEEEaiIAIAdJDQALIAIgA0YNByADIAMoAgRBfnE2AgQgAiADIAJrIgBBAXI2AgQgAyAANgIAIABBgAJPBEAgAiAAECIMCAsgAEH4AXFB4JTAAGohAQJ/QeiWwAAoAgAiA0EBIABBA3Z0IgBxRQRAQeiWwAAgACADcjYCACABDAELIAEoAggLIQAgASACNgIIIAAgAjYCDCACIAE2AgwgAiAANgIIDAcLIAAgATYCACAAIAAoAgQgBGo2AgQgAUEPakF4cUEIayICIAVBA3I2AgQgB0EPakF4cUEIayIEIAIgBWoiAGshBSAEQfyWwAAoAgBGDQMgBEH4lsAAKAIARg0EIAQoAgQiAUEDcUEBRgRAIAQgAUF4cSIBEB4gASAFaiEFIAEgBGoiBCgCBCEBCyAEIAFBfnE2AgQgACAFQQFyNgIEIAAgBWogBTYCACAFQYACTwRAIAAgBRAiDAYLIAVB+AFxQeCUwABqIQECf0HolsAAKAIAIgNBASAFQQN2dCIEcUUEQEHolsAAIAMgBHI2AgAgAQwBCyABKAIICyEDIAEgADYCCCADIAA2AgwgACABNgIMIAAgAzYCCAwFC0H0lsAAIAAgBWsiATYCAEH8lsAAQfyWwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIagwIC0H4lsAAKAIAIQACQCABIAVrIgJBD00EQEH4lsAAQQA2AgBB8JbAAEEANgIAIAAgAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBC0HwlsAAIAI2AgBB+JbAACAAIAVqIgM2AgAgAyACQQFyNgIEIAAgAWogAjYCACAAIAVBA3I2AgQLIABBCGoMBwsgACAEIAdqNgIEQfyWwABB/JbAACgCACIAQQ9qQXhxIgFBCGsiAjYCAEH0lsAAQfSWwAAoAgAgBGoiAyAAIAFrakEIaiIBNgIAIAIgAUEBcjYCBCAAIANqQSg2AgRBiJfAAEGAgIABNgIADAMLQfyWwAAgADYCAEH0lsAAQfSWwAAoAgAgBWoiATYCACAAIAFBAXI2AgQMAQtB+JbAACAANgIAQfCWwABB8JbAACgCACAFaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgALIAJBCGoMAwtBAEH0lsAAKAIAIgAgBU0NAhpB9JbAACAAIAVrIgE2AgBB/JbAAEH8lsAAKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGoMAgsgACAHNgIYIAIoAhAiAQRAIAAgATYCECABIAA2AhgLIAIoAhQiAUUNACAAIAE2AhQgASAANgIYCwJAIARBEE8EQCACIAVBA3I2AgQgAiAFaiIAIARBAXI2AgQgACAEaiAENgIAIARBgAJPBEAgACAEECIMAgsgBEH4AXFB4JTAAGohAQJ/QeiWwAAoAgAiA0EBIARBA3Z0IgRxRQRAQeiWwAAgAyAEcjYCACABDAELIAEoAggLIQMgASAANgIIIAMgADYCDCAAIAE2AgwgACADNgIIDAELIAIgBCAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhqCyAIQRBqJAALxgYBCH8CQAJAIAEgAEEDakF8cSICIABrIghJDQAgASAIayIGQQRJDQAgBkEDcSEHQQAhAQJAIAAgAkYiCQ0AAkAgACACayIEQXxLBEBBACECDAELQQAhAgNAIAEgACACaiIDLAAAQb9/SmogA0EBaiwAAEG/f0pqIANBAmosAABBv39KaiADQQNqLAAAQb9/SmohASACQQRqIgINAAsLIAkNACAAIAJqIQMDQCABIAMsAABBv39KaiEBIANBAWohAyAEQQFqIgQNAAsLIAAgCGohAgJAIAdFDQAgAiAGQXxxaiIALAAAQb9/SiEFIAdBAUYNACAFIAAsAAFBv39KaiEFIAdBAkYNACAFIAAsAAJBv39KaiEFCyAGQQJ2IQYgASAFaiEEA0AgAiEAIAZFDQJBwAEgBiAGQcABTxsiBUEDcSEHIAVBAnQhCEEAIQMgBkEETwRAIAAgCEHwB3FqIQkgACEBA0AgASgCACICQX9zQQd2IAJBBnZyQYGChAhxIANqIAEoAgQiAkF/c0EHdiACQQZ2ckGBgoQIcWogASgCCCICQX9zQQd2IAJBBnZyQYGChAhxaiABKAIMIgJBf3NBB3YgAkEGdnJBgYKECHFqIQMgAUEQaiIBIAlHDQALCyAGIAVrIQYgACAIaiECIANBCHZB/4H8B3EgA0H/gfwHcWpBgYAEbEEQdiAEaiEEIAdFDQALAn8gACAFQfwBcUECdGoiACgCACIBQX9zQQd2IAFBBnZyQYGChAhxIgEgB0EBRg0AGiABIAAoAgQiAUF/c0EHdiABQQZ2ckGBgoQIcWoiASAHQQJGDQAaIAAoAggiAEF/c0EHdiAAQQZ2ckGBgoQIcSABagsiAUEIdkH/gRxxIAFB/4H8B3FqQYGABGxBEHYgBGoPCyABRQRAQQAPCyABQQNxIQICQCABQQRJBEAMAQsgAUF8cSEFA0AgBCAAIANqIgEsAABBv39KaiABQQFqLAAAQb9/SmogAUECaiwAAEG/f0pqIAFBA2osAABBv39KaiEEIAUgA0EEaiIDRw0ACwsgAkUNACAAIANqIQEDQCAEIAEsAABBv39KaiEEIAFBAWohASACQQFrIgINAAsLIAQL3QUBBX8gACgCCCIDIAFJBEAgASADIgJrIgQgACgCACACa0sEQCAAIAIgBEEEQQQQJiAAKAIIIQILIAAoAgQiBiACQQJ0aiEFIARBAk8EQCAFIANBf3MgAWpBAnQQKhogASACakECdCADQQJ0ayAGakEEayEFIAIgBGpBAWshAgsgBUEANgIAIAAgAkEBajYCCAsgACgCFCIDIAFJBEAgASADIgJrIgQgACgCDCACa0sEQCAAQQxqIAIgBEEEQQQQJiAAKAIUIQILIAAoAhAiBiACQQJ0aiEFIARBAk8EQCAFIANBf3MgAWpBAnQQKhogASACakECdCADQQJ0ayAGakEEayEFIAIgBGpBAWshAgsgBUEANgIAIAAgAkEBajYCFAsgACgCOCIDIAFJBEAgASADIgJrIgQgACgCMCACa0sEQCAAQTBqIAIgBEEEQQQQJiAAKAI4IQILIAAoAjQiBiACQQJ0aiEFIARBAk8EQCAFIANBf3MgAWpBAnQQKhogASACakECdCADQQJ0ayAGakEEayEFIAIgBGpBAWshAgsgBUEANgIAIAAgAkEBajYCOAsgACgCICIDQf//A00EQCADIQFBgIAEIANrIgIgACgCGCADa0sEQCAAQRhqIAMgAkEEQQQQJiAAKAIgIQELIAAoAhwiBSABQQJ0IgRqIQIgA0H//wNHBEAgAkH8/w8gA0ECdCICaxAqGiAEIAJrIAVqQfz/D2ohAiABIANrQf//A2ohAQsgAkEANgIAIAAgAUEBajYCIAsgACgCLCIDQf//A00EQCADIQFBgIAEIANrIgIgACgCJCADa0sEQCAAQSRqIAMgAkEEQQQQJiAAKAIsIQELIAAoAigiBSABQQJ0IgRqIQIgA0H//wNHBEAgAkH8/w8gA0ECdCICaxAqGiAEIAJrIAVqQfz/D2ohAiABIANrQf//A2ohAQsgAkEANgIAIAAgAUEBajYCLAsLqQUBB38CQCAAKAIIQQFxRSIEIAAoAgAiCUVxRQRAAkAgBA0AIAEgAmohBwJAIAAoAgwiBkUEQCABIQQMAQsgASEEA0AgBCIDIAdGDQICfyADQQFqIAMsAAAiCEEATg0AGiADQQJqIAhBYEkNABogA0EDaiAIQXBJDQAaIANBBGoLIgQgA2sgBWohBSAGQQFrIgYNAAsLIAQgB0YNACAELAAAGiAFIAICfwJAIAVFDQAgAiAFSwRAIAEgBWosAABBv39KDQFBAAwCCyACIAVGDQBBAAwBCyABCyIDGyECIAMgASADGyEBCyAJRQ0BIAAoAgQhBwJAIAJBEE8EQCABIAIQEiEDDAELIAJFBEBBACEDDAELIAJBA3EhBgJAIAJBBEkEQEEAIQNBACEFDAELIAJBDHEhCEEAIQNBACEFA0AgAyABIAVqIgQsAABBv39KaiAEQQFqLAAAQb9/SmogBEECaiwAAEG/f0pqIARBA2osAABBv39KaiEDIAggBUEEaiIFRw0ACwsgBkUNACABIAVqIQQDQCADIAQsAABBv39KaiEDIARBAWohBCAGQQFrIgYNAAsLAkAgAyAHSQRAIAcgA2shBEEAIQMCQAJAAkAgAC0AIEEBaw4CAAECCyAEIQNBACEEDAELIARBAXYhAyAEQQFqQQF2IQQLIANBAWohAyAAKAIQIQYgACgCGCEFIAAoAhQhAANAIANBAWsiA0UNAiAAIAYgBSgCEBEAAEUNAAtBAQ8LDAILIAAgASACIAUoAgwRAgAEQEEBDwtBACEDA0AgAyAERgRAQQAPCyADQQFqIQMgACAGIAUoAhARAABFDQALIANBAWsgBEkPCyAAKAIUIAEgAiAAKAIYKAIMEQIADwsgACgCFCABIAIgACgCGCgCDBECAAu/BQEIf0ErQYCAxAAgACgCHCIIQQFxIgYbIQwgBCAGaiEGAkAgCEEEcUUEQEEAIQEMAQsCQCACQRBPBEAgASACEBIhBQwBCyACRQRADAELIAJBA3EhCQJAIAJBBEkEQAwBCyACQQxxIQoDQCAFIAEgB2oiCywAAEG/f0pqIAtBAWosAABBv39KaiALQQJqLAAAQb9/SmogC0EDaiwAAEG/f0pqIQUgCiAHQQRqIgdHDQALCyAJRQ0AIAEgB2ohBwNAIAUgBywAAEG/f0pqIQUgB0EBaiEHIAlBAWsiCQ0ACwsgBSAGaiEGCyAAKAIARQRAIAAoAhQiBiAAKAIYIgAgDCABIAIQPwRAQQEPCyAGIAMgBCAAKAIMEQIADwsCQAJAAkAgBiAAKAIEIgdPBEAgACgCFCIGIAAoAhgiACAMIAEgAhA/RQ0BQQEPCyAIQQhxRQ0BIAAoAhAhCCAAQTA2AhAgAC0AICEKQQEhBSAAQQE6ACAgACgCFCIJIAAoAhgiCyAMIAEgAhA/DQIgByAGa0EBaiEFAkADQCAFQQFrIgVFDQEgCUEwIAsoAhARAABFDQALQQEPCyAJIAMgBCALKAIMEQIABEBBAQ8LIAAgCjoAICAAIAg2AhBBAA8LIAYgAyAEIAAoAgwRAgAhBQwBCyAHIAZrIQYCQAJAAkAgAC0AICIFQQFrDgMAAQACCyAGIQVBACEGDAELIAZBAXYhBSAGQQFqQQF2IQYLIAVBAWohBSAAKAIQIQogACgCGCEIIAAoAhQhAAJAA0AgBUEBayIFRQ0BIAAgCiAIKAIQEQAARQ0AC0EBDwtBASEFIAAgCCAMIAEgAhA/DQAgACADIAQgCCgCDBECAA0AQQAhBQNAIAUgBkYEQEEADwsgBUEBaiEFIAAgCiAIKAIQEQAARQ0ACyAFQQFrIAZJDwsgBQv+BQEFfyAAQQhrIgEgAEEEaygCACIDQXhxIgBqIQICQAJAIANBAXENACADQQJxRQ0BIAEoAgAiAyAAaiEAIAEgA2siAUH4lsAAKAIARgRAIAIoAgRBA3FBA0cNAUHwlsAAIAA2AgAgAiACKAIEQX5xNgIEIAEgAEEBcjYCBCACIAA2AgAPCyABIAMQHgsCQAJAAkACQAJAIAIoAgQiA0ECcUUEQCACQfyWwAAoAgBGDQIgAkH4lsAAKAIARg0DIAIgA0F4cSICEB4gASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB+JbAACgCAEcNAUHwlsAAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQIkEAIQFBkJfAAEGQl8AAKAIAQQFrIgA2AgAgAA0EQdiUwAAoAgAiAARAA0AgAUEBaiEBIAAoAggiAA0ACwtBkJfAAEH/HyABIAFB/x9NGzYCAA8LQfyWwAAgATYCAEH0lsAAQfSWwAAoAgAgAGoiADYCACABIABBAXI2AgRB+JbAACgCACABRgRAQfCWwABBADYCAEH4lsAAQQA2AgALIABBiJfAACgCACIDTQ0DQfyWwAAoAgAiAkUNA0EAIQBB9JbAACgCACIEQSlJDQJB0JTAACEBA0AgAiABKAIAIgVPBEAgAiAFIAEoAgRqSQ0ECyABKAIIIQEMAAsAC0H4lsAAIAE2AgBB8JbAAEHwlsAAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAA8LIABB+AFxQeCUwABqIQICf0HolsAAKAIAIgNBASAAQQN2dCIAcUUEQEHolsAAIAAgA3I2AgAgAgwBCyACKAIICyEAIAIgATYCCCAAIAE2AgwgASACNgIMIAEgADYCCA8LQdiUwAAoAgAiAQRAA0AgAEEBaiEAIAEoAggiAQ0ACwtBkJfAAEH/HyAAIABB/x9NGzYCACADIARPDQBBiJfAAEF/NgIACwvpBAEFfwJ/AkAgAkECTwRAIAEoAgQiBEH//wFxRQRAIARBEHQMAwsgBEH/B3EhBSAEQYCAAnEhAyAEQYD4AXEiBkGA+AFGBEAgA0EQdCEDIANBgICA/AdyIAVFDQMaIAMgBUENdHJBgICA/gdyDAMLIANBEHQhAyAGRQ0BIAZBDXRBgICA/ABxIAVBDXRyQYCAgMADaiADcgwCC0EBQQFB9IHAABA1AAsgBSAFZ0EQayIFQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAVBF3RrcgshBQJ/IARBgIB8cSAEQRB2IgNB//8BcUUNABogA0H/B3EhBCADQYCAAnEhBiADQYD4AXEiB0GA+AFGBEAgBkEQdCEGIAZBgICA/AdyIARFDQEaIAYgA0ENdHJBgICA/gdyDAELIAZBEHQhAyAHQQ10QYCAgPwAcSAEQQ10ckGAgIDAA2ogA3IgBw0AGiAEIARnQRBrIgRB//8DcUEIanRB////A3EgA0GAgIDYA3IgBEEXdGtyCyEEIAACfwJAIAJBAkcEQCABKAIIIgJB//8BcUUEQCACQRB0DAMLIAJB/wdxIQEgAkGAgAJxIQMgAkGA+AFxIgJBgPgBRgRAIANBEHQhAiACQYCAgPwHciABRQ0DGiACIAFBDXRyQYCAgP4HcgwDCyADQRB0IQMgAkUNASACQQ10QYCAgPwAcSABQQ10ckGAgIDAA2ogA3IMAgtBAkECQYSCwAAQNQALIAEgAWdBEGsiAUH//wNxQQhqdEH///8DcSADQYCAgNgDciABQRd0a3ILNgIIIAAgBDYCBCAAIAU2AgAL6wQBCn8jAEEwayIDJAAgA0EDOgAsIANBIDYCHCADQQA2AiggAyABNgIkIAMgADYCICADQQA2AhQgA0EANgIMAn8CQAJAAkAgAigCECIKRQRAIAIoAgwiAEUNASACKAIIIgEgAEEDdGohBCAAQQFrQf////8BcUEBaiEHIAIoAgAhAANAIABBBGooAgAiBQRAIAMoAiAgACgCACAFIAMoAiQoAgwRAgANBAsgASgCACADQQxqIAEoAgQRAAANAyAAQQhqIQAgAUEIaiIBIARHDQALDAELIAIoAhQiAEUNACAAQQV0IQsgAEEBa0H///8/cUEBaiEHIAIoAgghBSACKAIAIQADQCAAQQRqKAIAIgEEQCADKAIgIAAoAgAgASADKAIkKAIMEQIADQMLIAMgCCAKaiIBQRBqKAIANgIcIAMgAUEcai0AADoALCADIAFBGGooAgA2AiggAUEMaigCACEEQQAhCUEAIQYCQAJAAkAgAUEIaigCAEEBaw4CAAIBCyAEQQN0IAVqIgwoAgANASAMKAIEIQQLQQEhBgsgAyAENgIQIAMgBjYCDCABQQRqKAIAIQQCQAJAAkAgASgCAEEBaw4CAAIBCyAEQQN0IAVqIgYoAgANASAGKAIEIQQLQQEhCQsgAyAENgIYIAMgCTYCFCAFIAFBFGooAgBBA3RqIgEoAgAgA0EMaiABKAIEEQAADQIgAEEIaiEAIAsgCEEgaiIIRw0ACwsgByACKAIETw0BIAMoAiAgAigCACAHQQN0aiIAKAIAIAAoAgQgAygCJCgCDBECAEUNAQtBAQwBC0EACyADQTBqJAALsgQCAn0EfyMAQRBrIQQgALwiBUEfdiEGAkACfSAAAn8CQAJAAkACQCAFQf////8HcSIDQdDYupUETwRAIANBgICA/AdLBEAgAA8LIAVBAEgiBUUgA0GX5MWVBEtxDQIgBUUNASAEQwAAgIAgAJU4AgggBCoCCBogA0G047+WBE0NAQwHCyADQZjkxfUDTQRAIANBgICAyANNDQNBACEDIAAMBgsgA0GSq5T8A00NAwsgAEM7qrg/lCAGQQJ0QYiSwABqKgIAkiIBQwAAAM9gIQRB/////wcCfyABi0MAAABPXQRAIAGoDAELQYCAgIB4C0GAgICAeCAEGyABQ////05eG0EAIAEgAVsbDAMLIABDAAAAf5QPCyAEIABDAAAAf5I4AgwgBCoCDBogAEMAAIA/kg8LIAZFIAZrCyIDsiIBQwByMb+UkiIAIAFDjr6/NZQiApMLIQEgACABIAEgASABlCIAIABDFVI1u5RDj6oqPpKUkyIAlEMAAABAIACTlSACk5JDAACAP5IhASADRQ0AAkACQAJAIANB/wBMBEAgA0GCf04NAyABQwAAgAyUIQEgA0Gbfk0NASADQeYAaiEDDAMLIAFDAAAAf5QhASADQf4BSw0BIANB/wBrIQMMAgsgAUMAAIAMlCEBQbZ9IAMgA0G2fU0bQcwBaiEDDAELIAFDAAAAf5QhAUH9AiADIANB/QJPG0H+AWshAwsgASADQRd0QYCAgPwDar6UIQELIAEL+QMBAn8gACABaiECAkACQCAAKAIEIgNBAXENACADQQJxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEH4lsAAKAIARgRAIAIoAgRBA3FBA0cNAUHwlsAAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAMAgsgACADEB4LAkACQAJAIAIoAgQiA0ECcUUEQCACQfyWwAAoAgBGDQIgAkH4lsAAKAIARg0DIAIgA0F4cSICEB4gACABIAJqIgFBAXI2AgQgACABaiABNgIAIABB+JbAACgCAEcNAUHwlsAAIAE2AgAPCyACIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUGAAk8EQCAAIAEQIg8LIAFB+AFxQeCUwABqIQICf0HolsAAKAIAIgNBASABQQN2dCIBcUUEQEHolsAAIAEgA3I2AgAgAgwBCyACKAIICyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCA8LQfyWwAAgADYCAEH0lsAAQfSWwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEH4lsAAKAIARw0BQfCWwABBADYCAEH4lsAAQQA2AgAPC0H4lsAAIAA2AgBB8JbAAEHwlsAAKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsLggMBCX8jAEEgayIEJAAQIyIAKAIQIQUgACgCDCEIIABCADcCDCAAKAIEIQYgACgCCCEDIABCBDcCBCAAKAIAIQIgAEEANgIAAkAgAyAIRgRAAkAgAiADRgRA0G9BgAEgAiACQYABTRsiB/wPASIBQX9GDQMCQCAFRQRAIAEhBQwBCyACIAVqIAFHDQQLIAIgB2oiByACSSAHQf////8DS3INAyAHQQJ0IgFB/P///wdLDQMgBCACBH8gBCAGNgIUIAQgAkECdDYCHEEEBUEACzYCGCAEQQhqQQQgASAEQRRqEDAgBCgCCEEBRg0DIAQoAgwhBiACIQEgByECDAELIAIgAyIBTQ0CCyAGIAFBAnRqIANBAWo2AgAgAUEBaiEDCyADIAhNDQAgBiAIQQJ0aigCACEBIAAgBTYCECAAIAE2AgwgACADNgIIIAAoAgQhAyAAIAY2AgQgACgCACEBIAAgAjYCACABBEAgAyABQQJ0EGULIARBIGokACAFIAhqDwsAC+cCAQV/AkBBzf97QRAgACAAQRBNGyIAayABTQ0AIABBECABQQtqQXhxIAFBC0kbIgRqQQxqEBEiAkUNACACQQhrIQECQCAAQQFrIgMgAnFFBEAgASEADAELIAJBBGsiBSgCACIGQXhxIAIgA2pBACAAa3FBCGsiAiAAQQAgAiABa0EQTRtqIgAgAWsiAmshAyAGQQNxBEAgACADIAAoAgRBAXFyQQJyNgIEIAAgA2oiAyADKAIEQQFyNgIEIAUgAiAFKAIAQQFxckECcjYCACABIAJqIgMgAygCBEEBcjYCBCABIAIQGgwBCyABKAIAIQEgACADNgIEIAAgASACajYCAAsCQCAAKAIEIgFBA3FFDQAgAUF4cSICIARBEGpNDQAgACAEIAFBAXFyQQJyNgIEIAAgBGoiASACIARrIgRBA3I2AgQgACACaiICIAIoAgRBAXI2AgQgASAEEBoLIABBCGohAwsgAwv7AgEHfyMAQRBrIgQkAAJAAkACQAJAAkAgASgCBCICRQ0AIAEoAgAhByACQQNxIQUCQCACQQRJBEBBACECDAELIAdBHGohAyACQXxxIQhBACECA0AgAygCACADQQhrKAIAIANBEGsoAgAgA0EYaygCACACampqaiECIANBIGohAyAIIAZBBGoiBkcNAAsLIAUEQCAGQQN0IAdqQQRqIQMDQCADKAIAIAJqIQIgA0EIaiEDIAVBAWsiBQ0ACwsgASgCDARAIAJBAEgNASAHKAIERSACQRBJcQ0BIAJBAXQhAgtBACEFIAJBAEgNAyACDQELQQEhA0EAIQIMAQtBsZPAAC0AABpBASEFIAJBARBdIgNFDQELIARBADYCCCAEIAM2AgQgBCACNgIAIARBwIvAACABEBhFDQFBqIzAAEHWACAEQQ9qQZiMwABBkI3AABAzAAsgBSACEFIACyAAIAQpAgA3AgAgAEEIaiAEQQhqKAIANgIAIARBEGokAAvxAgEEfyAAKAIMIQICQAJAIAFBgAJPBEAgACgCGCEDAkACQCAAIAJGBEAgAEEUQRAgACgCFCICG2ooAgAiAQ0BQQAhAgwCCyAAKAIIIgEgAjYCDCACIAE2AggMAQsgAEEUaiAAQRBqIAIbIQQDQCAEIQUgASICQRRqIAJBEGogAigCFCIBGyEEIAJBFEEQIAEbaigCACIBDQALIAVBADYCAAsgA0UNAiAAIAAoAhxBAnRB0JPAAGoiASgCAEcEQCADQRBBFCADKAIQIABGG2ogAjYCACACRQ0DDAILIAEgAjYCACACDQFB7JbAAEHslsAAKAIAQX4gACgCHHdxNgIADAILIAAoAggiACACRwRAIAAgAjYCDCACIAA2AggPC0HolsAAQeiWwAAoAgBBfiABQQN2d3E2AgAPCyACIAM2AhggACgCECIBBEAgAiABNgIQIAEgAjYCGAsgACgCFCIARQ0AIAIgADYCFCAAIAI2AhgLC7YCAQd/AkAgAkEQSQRAIAAhAwwBCyAAQQAgAGtBA3EiBGohBSAEBEAgACEDIAEhBgNAIAMgBi0AADoAACAGQQFqIQYgA0EBaiIDIAVJDQALCyAFIAIgBGsiCEF8cSIHaiEDAkAgASAEaiIEQQNxBEAgB0EATA0BIARBA3QiAkEYcSEJIARBfHEiBkEEaiEBQQAgAmtBGHEhAiAGKAIAIQYDQCAFIAYgCXYgASgCACIGIAJ0cjYCACABQQRqIQEgBUEEaiIFIANJDQALDAELIAdBAEwNACAEIQEDQCAFIAEoAgA2AgAgAUEEaiEBIAVBBGoiBSADSQ0ACwsgCEEDcSECIAQgB2ohAQsgAgRAIAIgA2ohAgNAIAMgAS0AADoAACABQQFqIQEgA0EBaiIDIAJJDQALCyAAC78CAQN/IwBBEGsiAiQAAkAgAUGAAU8EQCACQQA2AgwCfyABQYAQTwRAIAFBgIAETwRAIAJBDGpBA3IhBCACIAFBEnZB8AFyOgAMIAIgAUEGdkE/cUGAAXI6AA4gAiABQQx2QT9xQYABcjoADUEEDAILIAJBDGpBAnIhBCACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwwBCyACQQxqQQFyIQQgAiABQQZ2QcABcjoADEECCyEDIAQgAUE/cUGAAXI6AAAgAyAAKAIAIAAoAggiAWtLBEAgACABIAMQKSAAKAIIIQELIAAoAgQgAWogAkEMaiADEB8aIAAgASADajYCCAwBCyAAKAIIIgMgACgCAEYEQCAAECgLIAAgA0EBajYCCCAAKAIEIANqIAE6AAALIAJBEGokAEEAC70CAQJ/IwBBEGsiAiQAAkAgAUGAAU8EQCACQQA2AgwCfyABQYAQTwRAIAFBgIAETwRAIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAwCCyACIAFBP3FBgAFyOgAOIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAELIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECCyEBIAEgACgCACAAKAIIIgNrSwRAIAAgAyABECUgACgCCCEDCyAAKAIEIANqIAJBDGogARAfGiAAIAEgA2o2AggMAQsgACgCCCIDIAAoAgBGBEAgABAoCyAAIANBAWo2AgggACgCBCADaiABOgAACyACQRBqJABBAAvEAgEEfyAAQgA3AhAgAAJ/QQAgAUGAAkkNABpBHyABQf///wdLDQAaIAFBBiABQQh2ZyIDa3ZBAXEgA0EBdGtBPmoLIgI2AhwgAkECdEHQk8AAaiEEQQEgAnQiA0HslsAAKAIAcUUEQCAEIAA2AgAgACAENgIYIAAgADYCDCAAIAA2AghB7JbAAEHslsAAKAIAIANyNgIADwsCQAJAIAEgBCgCACIDKAIEQXhxRgRAIAMhAgwBCyABQRkgAkEBdmtBACACQR9HG3QhBQNAIAMgBUEddkEEcWpBEGoiBCgCACICRQ0CIAVBAXQhBSACIQMgAigCBEF4cSABRw0ACwsgAigCCCIBIAA2AgwgAiAANgIIIABBADYCGCAAIAI2AgwgACABNgIIDwsgBCAANgIAIAAgAzYCGCAAIAA2AgwgACAANgIIC/MCAQR/IwBBMGsiACQAAkACQEGQksAAKAIARQRAQaiSwAAoAgAhAUGoksAAQQA2AgAgAUUNASAAQRhqIAERBQAgAEEQaiICIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghAUGQksAAKAIAIgMNAgJAIANFDQBBlJLAACgCACICRQ0AQZiSwAAoAgAgAkECdBBlC0GUksAAIAE2AgBBkJLAAEEBNgIAQZiSwAAgACkDCDcCAEGgksAAIABBEGopAwA3AgALIABBMGokAEGUksAADwsgAEEANgIoIABBATYCHCAAQaCHwAA2AhggAEIENwIgIABBGGpBiIjAABBDAAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnQQZQsgAEEANgIoIABBATYCHCAAQaiIwAA2AhggAEIENwIgIAFBsIjAABBDAAuoAgIDfwF+IwBBQGoiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBJGoiBEEANgIAIAJCgICAgBA3AhwgAkEwaiADKAIAIgNBCGopAgA3AwAgAkE4aiADQRBqKQIANwMAIAIgAykCADcDKCACQRxqQcCIwAAgAkEoahAYGiACQRhqIAQoAgAiAzYCACACIAIpAhwiBTcDECABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQQhqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8AALQAAGiACIAU3AwBBDEEEEF0iAUUEQEEEQQwQbQALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEHgisAANgIEIAAgATYCACACQUBrJAAL0gECBH8BfiMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIEQQF0IgEgAiABIAJLGyICIAJBCEkbIgKtIgdCIIhQRQRAQQBBABBSAAsCQCAHpyIFQf////8HTQRAIAMgBAR/IAMgBDYCHCADIAAoAgQ2AhRBAQVBAAs2AhggA0EIakEBIAUgA0EUahAwIAMoAghBAUcNASADKAIMIQYgAygCECEBCyAGIAEQUgALIAMoAgwhASAAIAI2AgAgACABNgIEIANBIGokAAvrAQIEfwF+IwBBIGsiBSQAIAEgASACaiICSwRAQQBBABBSAAtBACEBIAMgBGpBAWtBACADa3GtQQQgACgCACIHQQF0IgYgAiACIAZJGyICIAJBBE0bIgKtfiIJQiCIUEUEQEEAQQAQUgALAkAgCaciBkGAgICAeCADa00EfyAFIAcEfyAFIAQgB2w2AhwgBSAAKAIENgIUIAMFQQALNgIYIAVBCGogAyAGIAVBFGoQMCAFKAIIQQFHDQEgBSgCECEIIAUoAgwFIAELIAgQUgALIAUoAgwhASAAIAI2AgAgACABNgIEIAVBIGokAAvTAQEFfyMAQSBrIgEkACAAKAIAIgJBf0YEQEEAQQAQUgALIAJBAXQiAyACQQFqIgUgAyAFSxsiA0H/////A0sEQEEAQQAQUgALAkBBBCADIANBBE0bIgNBAnQiBUH8////B00EfyABIAIEfyABIAJBAnQ2AhwgASAAKAIENgIUQQQFQQALNgIYIAFBCGpBBCAFIAFBFGoQMCABKAIIQQFHDQEgASgCECEEIAEoAgwFIAQLIAQQUgALIAEoAgwhAiAAIAM2AgAgACACNgIEIAFBIGokAAuyAQEEfyMAQSBrIgEkACAAKAIAIgJBf0YEQEEAQQAQUgALQQggAkEBdCIDIAJBAWoiBCADIARLGyIDIANBCE0bIgNBAEgEQEEAQQAQUgALIAEgAgR/IAEgAjYCHCABIAAoAgQ2AhRBAQVBAAs2AhggAUEIakEBIAMgAUEUahAwIAEoAghBAUYEQCABKAIMIAEoAhAQUgALIAEoAgwhAiAAIAM2AgAgACACNgIEIAFBIGokAAuyAQECfyMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIBQQF0IgQgAiACIARJGyICIAJBCE0bIgRBAEgEQEEAQQAQUgALIAMgAQR/IAMgATYCHCADIAAoAgQ2AhRBAQVBAAs2AhggA0EIakEBIAQgA0EUahAwIAMoAghBAUYEQCADKAIMIAMoAhAQUgALIAMoAgwhASAAIAQ2AgAgACABNgIEIANBIGokAAudAQEDfwJAIAFBEEkEQCAAIQIMAQsgAEEAIABrQQNxIgRqIQMgBARAIAAhAgNAIAJBADoAACACQQFqIgIgA0kNAAsLIAMgASAEayIBQXxxIgRqIQIgBEEASgRAA0AgA0EANgIAIANBBGoiAyACSQ0ACwsgAUEDcSEBCyABBEAgASACaiEBA0AgAkEAOgAAIAJBAWoiAiABSQ0ACwsgAAvBAQIDfwF+IwBBMGsiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBFGoiBEEANgIAIAJCgICAgBA3AgwgAkEgaiADKAIAIgNBCGopAgA3AwAgAkEoaiADQRBqKQIANwMAIAIgAykCADcDGCACQQxqQcCIwAAgAkEYahAYGiACQQhqIAQoAgAiAzYCACACIAIpAgwiBTcDACABQQhqIAM2AgAgASAFNwIACyAAQeCKwAA2AgQgACABNgIAIAJBMGokAAuWAgECfyMAQSBrIgUkAEHMk8AAQcyTwAAoAgAiBkEBajYCAAJAAn9BACAGQQBIDQAaQQFBmJfAAC0AAA0AGkGYl8AAQQE6AABBlJfAAEGUl8AAKAIAQQFqNgIAQQILQf8BcSIGQQJHBEAgBkEBcUUNASAFQQhqIAAgASgCGBEBAAALQcCTwAAoAgAiBkEASA0AQcCTwAAgBkEBajYCAEHAk8AAQcSTwAAoAgAEfyAFIAAgASgCFBEBACAFIAQ6AB0gBSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBxJPAACgCACAFQRBqQciTwAAoAgAoAhQRAQBBwJPAACgCAEEBawUgBgs2AgBBmJfAAEEAOgAAIANFDQAACwALrwEBBn8CQAJAIABBhAFJDQAgANBvJgEQIyIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnQQZQsPCwALowEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAhBlDAELIAMgAkEEIAFBAnQiAhBUIgVFDQILIAAgATYCBCAAIAU2AgAgBkEQaiQADwtBxIbAAEEyEGgAC0EEIAIQUgALrAEBA38gASgCDCECAkACQAJAAkACQAJAIAEoAgQOAgABAgsgAg0BQQEhA0EAIQFBASECDAMLIAJFDQELIAAgARAdDwsgASgCACICKAIEIgFBAEgNASACKAIAIQMgAUUEQEEBIQJBACEBDAELQbGTwAAtAAAaQQEhBCABQQEQXSICRQ0BCyACIAMgARAfIQIgACABNgIIIAAgAjYCBCAAIAE2AgAPCyAEIAEQUgALiQEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhBUDAILCyABIAJFDQAaQbGTwAAtAAAaIAIgARBdCyIDBEAgACACNgIIIAAgAzYCBCAAQQA2AgAPCyAAIAI2AgggACABNgIEDAELIABBADYCBAsgAEEBNgIAC5cBAgR/AW8jAEEgayIDJAAgACgCACIGEHAhACADIAI2AgQgAyAANgIAIAAgAkYEQBBbIgQQUyIFJQEgASACEAQhBxAbIgAgByYBIARBhAFPBEAgBBAtCyAFQYQBTwRAIAUQLQsgBiAAQQAQZCAAQYQBTwRAIAAQLQsgA0EgaiQADwsgA0EANgIIIAMgA0EEaiADQQhqEEAAC3kBAX8jAEEgayICJAACfyAAKAIAQYCAgIB4RwRAIAEgACgCBCAAKAIIEFYMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahAYCyACQSBqJAALewEBfyMAQUBqIgUkACAFIAE2AgwgBSAANgIIIAUgAzYCFCAFIAI2AhAgBUECNgIcIAVBoI/AADYCGCAFQgI3AiQgBSAFQRBqrUKAgICAsAWENwM4IAUgBUEIaq1CgICAgMAFhDcDMCAFIAVBMGo2AiAgBUEYaiAEEEMAC24BAX8jAEEwayIBJAAgASAANgIAIAFBgAE2AgQgAUECNgIMIAFB2JHAADYCCCABQgI3AhQgASABQQRqrUKAgICA4ACENwMoIAEgAa1CgICAgOAAhDcDICABIAFBIGo2AhAgAUEIakHIj8AAEEMAC2kCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQfyNwAA2AgggA0ICNwIUIANCgICAgOAAIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhBDAAtpAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0H4kcAANgIIIANCAjcCFCADQoCAgIDgACIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQQwALZgAjAEEwayIAJABBsJPAAC0AAARAIABBAjYCDCAAQbCKwAA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIDgAIQ3AyAgACAAQSBqNgIQIABBCGpB0IrAABBDAAsgAEEwaiQAC5QBAgN/AW8jAEEgayIDJAAgAyAAKAIAEHAiBDYCACADIAI2AgQgAiAERwRAIANBADYCCCADIANBBGogA0EIahBAAAsQWyIEEFMiBSUBEAUhBhAbIgIgBiYBIAVBhAFPBEAgBRAtCyACIAAoAgAgAUECdhBkIAJBhAFPBEAgAhAtCyAEQYQBTwRAIAQQLQsgA0EgaiQAC08BAX8jAEEwayIAJAAgAEEBNgIMIABBwI3AADYCCCAAQgE3AhQgACAAQS9qrUKAgICAoAWENwMgIAAgAEEgajYCECAAQQhqQcSBwAAQQwALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhAlIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALTQECf0Gxk8AALQAAGiABKAIEIQIgASgCACEDQQhBBBBdIgFFBEBBBEEIEG0ACyABIAI2AgQgASADNgIAIABB8IrAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhApIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALQQEBfyMAQSBrIgIkACACQQA2AhAgAkEBNgIEIAJCBDcCCCACQS42AhwgAiAANgIYIAIgAkEYajYCACACIAEQQwALswIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARBnDwtBACEAIwBBgAFrIgQkACACKAIAIQIDQCAAIARqQf8AaiACQQ9xIgNBMHIgA0E3aiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAhA0AAsgAUHYj8AAQQIgACAEakGAAWpBACAAaxAVIARBgAFqJAAPC0EAIQAjAEGAAWsiBCQAIAIoAgAhAgNAIAAgBGpB/wBqIAJBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAhA0AAsgAUHYj8AAQQIgACAEakGAAWpBACAAaxAVIARBgAFqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAgAL0AIBAX8jAEEQayIDJAAgAyABNgIMIAMgADYCCCMAQfAAayIAJAAgAEG0hsAANgIMIAAgA0EIajYCCCAAQbSGwAA2AhQgACADQQxqNgIQIABBjI7AADYCGCAAQQI2AhwCQCACKAIARQRAIABBAzYCXCAAQciOwAA2AlggAEIDNwJkIAAgAEEQaq1CgICAgLAFhDcDSCAAIABBCGqtQoCAgICwBYQ3A0AMAQsgAEEwaiACQRBqKQIANwMAIABBKGogAkEIaikCADcDACAAIAIpAgA3AyAgAEEENgJcIABB/I7AADYCWCAAQgQ3AmQgACAAQRBqrUKAgICAsAWENwNQIAAgAEEIaq1CgICAgLAFhDcDSCAAIABBIGqtQoCAgIDQBYQ3A0ALIAAgAEEYaq1CgICAgMAFhDcDOCAAIABBOGo2AmAgAEHYAGpBpIbAABBDAAuyAQECfyMAQRBrIgAkACABKAIUQYCKwABBCyABKAIYKAIMEQIAIQMgAEEIaiICQQA6AAUgAiADOgAEIAIgATYCACACIgEtAAQhAiABLQAFBEAgAQJ/QQEgAkEBcQ0AGiABKAIAIgEtABxBBHFFBEAgASgCFEGxj8AAQQIgASgCGCgCDBECAAwBCyABKAIUQbCPwABBASABKAIYKAIMEQIACyICOgAECyACQQFxIABBEGokAAvrEgIYfxB9EBsiDiAJJgEjAEGAAWsiDSQAIA0gDjYCLCANIAg2AiggDSAHOAIkIA0gBjgCICANIAU4AhwgDSAEOAIYIA0gAzgCFCANIAI4AhAgDSABOAIMIA0gADgCCCANIApBAEc6ADMgDSALOAI0IA0gDDgCOCANQQA2AkQgDUKAgICAwAA3AjwgDSANQThqNgJ8IA0gDUE0ajYCeCANIA1BJGo2AnQgDSANQSBqNgJwIA0gDUEcajYCbCANIA1BGGo2AmggDSANQRRqNgJkIA0gDUEQajYCYCANIA1BDGo2AlwgDSANQQhqNgJYIA0gDUE8ajYCVCANIA1BM2o2AlAgDSANQSxqNgJMIA0gDUEoajYCSCANQcgAaiIYIQgjAEEgayIQJAACQEEAQYiAwAAoAgARAwAiEwRAIBMoAgBFBEAgCCgCNCEZIAgoAjAhGiAIKAIsIRsgCCgCKCEcIAgoAiQhHSAIKAIgIR4gCCgCHCEfIAgoAhghICAIKAIUISEgCCgCECEiIAgoAgwhESAIKAIIISMgCCgCBCEkIAgoAgAhFiATQX82AgAgEyAWKAIAIggEfyATQQxqKAIAIRcgE0EIaigCACEKQQAhDgNAIBAgJCAOQQJ0IA5BgIAEIAggDmsiCCAIQYCABE8bIghqIhRBAnQQZjYCDAJAAkAgFyAIQQJ0Ig5PBEAgEEEMaiAKIA4QOCAZKgIAIQAgGioCACEDIBsqAgAhLyAcKgIAITAgHSoCACEEIB4qAgAhBSAfKgIAIQYgICoCACExICEqAgAhMiAiKgIAITMgIy0AAA0BIAAgA5NDAAB+Q5UhACAGIAaUIAUgBZSSIAQgBJSSIQsgCiEIA0AgDkEEIA5BBEkiDxshEgJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgEEEQaiAIIBIQFwJ9AkAgD0UEQCAQKgIYIQEgECoCFCECIBAqAhAhB0MAAAAAIQxDAAAAACElIAgoAgwiD0H/AXEEQCADIAAgD0EBa0H/AXGzlJIQGSElCyAPQQh2IhVB/wFxBEAgAyAAIBVBAWtB/wFxs5SSEBkhDAsgMSABkyEBIDIgApMhAiAzIAeTIQcgD0EQdiIPQf8BcQ0BQwAAAAAMAgtBAyASQZSCwAAQNQALIAMgACAPQQFrQf8BcbOUkhAZCyEpIAYgB5QgBSAClJIgBCABlJIiJiAmlCALIAcgB5QgAiAClJIgASABlJIgJSAMkiApkkMAAEBAlSIBIAGUk5STIgFDAAAAAF0NACAmjCABkZMgC5UiASAwYEUgASAvX0VyDQAgESgCCCIPIBEoAgBGBEAgERAnCyARKAIEIA9BAnRqIAE4AgAgESAPQQFqNgIICyAIIBJBAnRqIQggDiASayIODQALDAILIA4gF0GIg8AAEDYACyAAIAOTQwAAfkOVISwgCiEIA0AgDkEEIA5BBEkiDxshEgJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgEEEQaiAIIBIQFwJ9AkAgD0UEQCAQKgIYIQAgECoCFCEBIBAqAhAhAkMAAAAAIQdDAAAAACELIAgoAgwiD0H/AXEEQCADICwgD0EBa0H/AXGzlJIQGSELCyAPQQh2IhVB/wFxBEAgAyAsIBVBAWtB/wFxs5SSEBkhBwsgMSAAkyEnIDIgAZMhLSAzIAKTIS4gD0EQdiIVQf8BcQ0BQwAAAAAMAgtBAyASQZSCwAAQNQALIAMgLCAVQQFrQf8BcbOUkhAZCyEMIAQgCCgCCCIVQRh1skMAAP5ClSIAIAUgD0EYdbJDAAD+QpUiAZQgBCAAlJMiKJQgFUEQdsCyQwAA/kKVIgIgBCAClCAGIAGUkyIqlJMgBiAAlCAFIAKUkyIrQwAAgD8gAiAClJMgACAAlJMgASABlJNDAAAAABBQkSIllJIiJiAmkpIhJiAFIAIgK5QgASAolJMgKiAllJIiKSApkpIhKSAGIAEgKpQgACArlJMgKCAllJIiKCAokpIhKCAnIAAgLSABlCAnIACUkyIqlCACICcgApQgLiABlJMiK5STIC4gAJQgLSAClJMiNCAllJIiJyAnkpIhJyAtIAIgNJQgASAqlJMgKyAllJIiAiACkpIhAiAuIAEgK5QgACA0lJMgKiAllJIiACAAkpIhAAJAIAwgCyAHEFAgDBBQQwrXIzyUIgFdRQRAIAEgB15FBEAgASALXkUEQEMAAIA/IAyVIgwgJ5QiASAMICaUIgyUQwAAgD8gC5UiCyAAlCIAIAsgKJQiC5RDAACAPyAHlSIHIAKUIgIgByAplCIHlJKSIiUgJZQgDCAMlCALIAuUIAcgB5SSkiIHIAEgAZQgACAAlCACIAKUkpJDAACAv5KUkyIAQwAAAABdDQQgJYwgAJGTIAeVIQAMAwsgKItDvTeGNV0NAyACICkgAIwgKJUiAJSSIAeVIgEgAZQgJyAmIACUkiAMlSIBIAGUkkMAAIA/XkUNAgwDCyApi0O9N4Y1XQ0CIAAgKCACjCAplSIAlJIgC5UiASABlCAnICYgAJSSIAyVIgEgAZSSQwAAgD9eDQIMAQsgJotDvTeGNV0NASAAICggJ4wgJpUiAJSSIAuVIgEgAZQgAiApIACUkiAHlSIBIAGUkkMAAIA/Xg0BCyAAIDBgRSAAIC9fRXINACARKAIIIg8gESgCAEYEQCARECcLIBEoAgQgD0ECdGogADgCACARIA9BAWo2AggLIAggEkECdGohCCAOIBJrIg4NAAsLIBAoAgwiCEGEAU8EQCAIEC0LIBYoAgAiCCAUIg5LDQALIBMoAgBBAWoFQQALNgIAIBBBIGokAAwCCxA5AAtBnIDAAEHGACAQQR9qQYyAwABBtIHAABAzAAsgDSgCRBANIQkQGyIIIAkmASANIAg2AkggDSgCQCERIA0oAkQhDiMAQSBrIgokACAYKAIAIhMlARAKIRQgCiAONgIEIAogFDYCAAJAIA4gFEYEQBBbIhQQUyIQJQEgESAOEAghCRAbIg4gCSYBIBRBhAFPBEAgFBAtCyAQQYQBTwRAIBAQLQsgEyUBIA4lAUEAEAkgDkGEAU8EQCAOEC0LIApBIGokAAwBCyAKQQA2AgggCiAKQQRqIApBCGoQQAALIA0oAjwiCgRAIA0oAkAgCkECdBBlCyANKAIsIgpBhAFPBEAgChAtCyANQYABaiQAIAglASAIEC0L+gECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEGci8AAIAEoAgQgASgCCCIALQAIIAAtAAkQLAALIAAgAzYCBCAAIAI2AgAgAEGAi8AAIAEoAgQgASgCCCIALQAIIAAtAAkQLAALJAAgAEUEQEHEhsAAQTIQaAALIAAgAiADIAQgBSABKAIQEQgACyIAIABFBEBBxIbAAEEyEGgACyAAIAIgAyAEIAEoAhARDQALIgAgAEUEQEHEhsAAQTIQaAALIAAgAiADIAQgASgCEBEPAAsiACAARQRAQcSGwABBMhBoAAsgACACIAMgBCABKAIQERgACyIAIABFBEBBxIbAAEEyEGgACyAAIAIgAyAEIAEoAhARGgALIgAgAEUEQEHEhsAAQTIQaAALIAAgAiADIAQgASgCEBEcAAslAQF/IAAoAgAiAUGAgICAeHJBgICAgHhHBEAgACgCBCABEGULCyAAIABFBEBBxIbAAEEyEGgACyAAIAIgAyABKAIQEQQACx4AIABFBEBBxIbAAEEyEGgACyAAIAIgASgCEBEAAAuvDwEPfxAbIgMgASYBEBsiBCACJgEjAEEgayIKJAAgCiAENgIIIAogAzYCBCAKIAA2AgAgCiAKQQRqIgAoAgAQbzYCDCAKIApBCGo2AhwgCiAKNgIYIAogADYCFCAKIApBDGo2AhAgCkEQaiEAIwBB0ABrIgckAAJAAkACQAJAQQBBgIDAACgCABEDACINBEAgDSgCAEUEQCAAKAIMIREgDUF/NgIAIAAoAgQgACgCCCEOIAAoAgAoAgAiBiANQQRqIgQoAggiA0sEQCAGIAMiAGsiCSAEKAIAIABrSwRAIAQgACAJQQJBAhAmIAQoAgghAAsgBCgCBCIMIABBAXRqIQUgCUECTwRAIAUgA0F/cyAGakEBdBAqGiAAIAZqQQF0IANBAXRrIAxqQQJrIQUgACAJakEBayEACyAFQQA7AQAgBCAAQQFqNgIICyAEKAIUIgMgBkkEQCAGIAMiAGsiCSAEKAIMIABrSwRAIARBDGogACAJQQRBBBAmIAQoAhQhAAsgBCgCECIMIABBAnRqIQUgCUECTwRAIAUgA0F/cyAGakECdBAqGiAAIAZqQQJ0IANBAnRrIAxqQQRrIQUgACAJakEBayEACyAFQQA2AgAgBCAAQQFqNgIUCyAEKAIgIgNBgPgBTQRAQYH4ASADIgBrIgUgBCgCGCAAa0sEQCAEQRhqIAAgBUEEQQQQJiAEKAIgIQALIAQoAhwiBiAAQQJ0IglqIQUgA0GA+AFHBH8gBUGA4AcgA0ECdCIFaxAqGiAAIANrQYD4AWohACAJIAVrIAZqQYDgB2oFIAULQQA2AgAgBCAAQQFqNgIgCygCACUBQQAgDigCACIJEAshARAbIgAgASYBIAcgADYCACAJIA0oAgwiAEsNAiANKAIIIQgjAEEgayIAJAAgACAHKAIAEG8iAzYCACAAIAk2AgQgAyAJRwRAIABBADYCCCAAIABBBGogAEEIahBAAAsQWyIFEFMiBiUBEAEhARAbIgMgASYBIAZBhAFPBEAgBhAtCyADJQEgBygCACUBIAhBAXYQAiADQYQBTwRAIAMQLQsgBUGEAU8EQCAFEC0LIABBIGokACAHQQRqIRBBACEAQQAhBSMAQTBrIgYkAAJAAkACQAJAIAkgBCgCCCIDTQRAIAQoAgQhAyAEQQA2AiAgBCgCGEGA+AFNBEAgBEEYakEAQYH4AUEEQQQQJiAEKAIgIQALIAQoAhwiDiAAQQJ0Ig9qQYDgBxAqIAQgAEGB+AFqIgw2AiBBgOAHakEANgIAAkAgCQRAIAlBAXQhCCADIQADQCAALwEAIgtBgPgBSQRAIAsgDE8NAyAOIAtBAnRqIgsgCygCAEEBajYCAAsgAEECaiEAIAhBAmsiCA0ACwsgBkEANgIEAkAgDEECSQ0AIA4gDEECdGpBCGsiACgCACEFIABBADYCACAGIAU2AgQgACAORg0AIA9B+N8HaiILQQJ2QQFqQQNxIggEQCAIQQJ0IQgDQCAAQQRrIgAoAgAhDyAAIAU2AgAgBiAFIA9qIgU2AgQgCEEEayIIDQALCyALQQxJDQAgAEEQayEAA0AgAEEMaiIIKAIAIQsgCCAFNgIAIAYgBSALaiIFNgIEIABBCGoiCCgCACELIAggBTYCACAGIAUgC2oiBTYCBCAAQQRqIggoAgAhCyAIIAU2AgAgBiAFIAtqIgU2AgQgACgCACEIIAAgBTYCACAGIAUgCGoiBTYCBCAAIA5GIABBEGshAEUNAAsLAkAgCQRAIAlBAXQhCCAEKAIQIQ8gBCgCFCEJQQAhAANAIAMvAQAiBEGA+AFJBEAgBCAMTw0DIAkgDiAEQQJ0aiIEKAIAIgtNBEAgCyAJQZiEwAAQNQALIA8gC0ECdGogADYCACAEIAQoAgBBAWo2AgALIANBAmohAyAAQQFqIQAgCEECayIIDQALCyAMRQ0FIA4oAgAgBUcNAyAQQYCAgIB4NgIAIBAgBTYCBAwECyAEIAxBiITAABA1AAsgCyAMQaiEwAAQNQALIAkgA0G4g8AAEDYACyAGQQI2AgwgBkH4g8AANgIIIAZCAjcCFCAGIA6tQoCAgIDgAIQ3AyggBiAGQQRqrUKAgICA4ACENwMgIAYgBkEgajYCECAQIAZBCGoQHQsgBkEwaiQADAELQQBBAEHIg8AAEDUACyAHKAIEQYCAgIB4Rw0DIAcoAggiAEUNBSAAIA0oAhgiA0sNBCANKAIUIQQgByARQQAgABBmIgM2AiggB0EoaiAEIAAQMSADQYQBSQ0FIAMQLQwFCxA5AAtBnIDAAEHGACAHQc8AakGMgMAAQbSBwAAQMwALIAkgAEHAgsAAEDYACyAHQRhqIAdBDGooAgA2AgAgByAHKQIENwMQIAdBATYCLCAHQeCCwAA2AiggB0IBNwI0IAcgB0EQaq1CgICAgMAAhDcDQCAHIAdBQGs2AjAgB0EcaiAHQShqEC8gBygCICAHKAIkEGgACyAAIANB0ILAABA2AAsgBygCACIDQYQBTwRAIAMQLQsgDSANKAIAQQFqNgIAIAdB0ABqJAAgCigCCCIDQYQBTwRAIAMQLQsgCigCBCIDQYQBTwRAIAMQLQsgCkEgaiQAIAALmA8BE38QGyIEIAEmARAbIg8gAiYBIwBBIGsiCiQAIAogDzYCCCAKIAQ2AgQgCiAANgIAIAogCkEEaiIAKAIAEHA2AgwgCiAKQQhqNgIcIAogCjYCGCAKIAA2AhQgCiAKQQxqNgIQIApBEGohACMAQdAAayIIJAACQAJAAkACQEEAQYSAwAAoAgARAwAiEARAIBAoAgBFBEAgACgCDCEUIBBBfzYCACAAKAIEIQQgACgCCCEPIBBBBGoiCSAAKAIAKAIAIgAQEyAIIARBACAPKAIAIgwQZjYCACAMIBAoAgwiBEsNAiAIIBAoAgggDBA4IwBBMGsiDSQAIAkgABATAkACQCAMIAkoAggiAE0EQCAJKAIEIQ8gCSgCHCEEIAkoAiAiDgRAIAQgDkECdBAqGgsgCSgCKCESIAkoAiwiEQRAIBIgEUECdBAqGgsgDARAIAxBAnQhBSAPIQADQAJAIAAoAgAiA0GAgID8B08NACAOIANBf3MiC0H//wNxIgNLBEAgBCADQQJ0aiIDIAMoAgBBAWo2AgAgESALQRB2IgNLBEAgEiADQQJ0aiIDIAMoAgBBAWo2AgAMAgsgAyARQbiFwAAQNQALIAMgDkGohcAAEDUACyAAQQRqIQAgBUEEayIFDQALCyAORQRAQQAhBQwDCyAOQQFrQf////8DcSIAQQFqIgVBB3EhAyAAQQdJBEBBACEFIAQhAAwCCyAFQfj///8HcSELQQAhBSAEIQADQCAAKAIAIQYgACAFNgIAIAAoAgQhByAAIAUgBmoiBTYCBCAAKAIIIQYgACAFIAdqIgU2AgggACgCDCEHIAAgBSAGaiIFNgIMIAAoAhAhBiAAIAUgB2oiBTYCECAAKAIUIQcgACAFIAZqIgU2AhQgACgCGCEGIAAgBSAHaiIFNgIYIAAoAhwhByAAIAUgBmoiBTYCHCAAQSBqIQAgBSAHaiEFIAtBCGsiCw0ACwwBCyAMIABBuITAABA2AAsgA0UNAANAIAAoAgAhCyAAIAU2AgAgAEEEaiEAIAUgC2ohBSADQQFrIgMNAAsLIA0gBTYCBCAMBEAgDEECdCELIAkoAjQhFSAJKAI4IQZBACEDIA8hAANAAkAgACgCACIHQYCAgPwHTw0AAkAgDiAHQX9zQf//A3EiB0sEQCAEIAdBAnRqIgcoAgAiEyAGTw0BIBUgE0ECdGogAzYCACAHIAcoAgBBAWo2AgAMAgsgByAOQYiFwAAQNQALIBMgBkGYhcAAEDUACyAAQQRqIQAgA0EBaiEDIAtBBGsiCw0ACwsgCEEEaiEOAkAgEUUNACARQQFrQf////8DcSIEQQFqIgZBB3EhC0EAIQMgEiEAIARBB08EQCAGQfj///8HcSEEA0AgACgCACEGIAAgAzYCACAAKAIEIQcgACADIAZqIgM2AgQgACgCCCEGIAAgAyAHaiIDNgIIIAAoAgwhByAAIAMgBmoiAzYCDCAAKAIQIQYgACADIAdqIgM2AhAgACgCFCEHIAAgAyAGaiIDNgIUIAAoAhghBiAAIAMgB2oiAzYCGCAAKAIcIQcgACADIAZqIgM2AhwgAEEgaiEAIAMgB2ohAyAEQQhrIgQNAAsLIAtFDQADQCAAKAIAIQQgACADNgIAIABBBGohACADIARqIQMgC0EBayILDQALCwJAIAVFDQAgCSgCNCEDIAkoAjhBAnQhACAJKAIQIRMgCSgCFCELIAUhBAJAAkADQCAARQ0DIAMoAgAiCSAMTw0CIBEgDyAJQQJ0aigCAEF/c0EQdiIGSwRAIBIgBkECdGoiBigCACIHIAtPDQIgA0EEaiEDIBMgB0ECdGogCTYCACAGIAYoAgBBAWo2AgAgAEEEayEAIARBAWsiBA0BDAQLCyAGIBFB6ITAABA1AAsgByALQfiEwAAQNQALIAkgDEHYhMAAEDUACwJAIBFB//8DSwRAAkAgBSASKAL8/w9GBEAgDkGAgICAeDYCACAOIAU2AgQMAQsgDUECNgIMIA1B+IPAADYCCCANQgI3AhQgDSASQfz/D2qtQoCAgIDgAIQ3AyggDSANQQRqrUKAgICA4ACENwMgIA0gDUEgajYCECAOIA1BCGoQHQsgDUEwaiQADAELQf//AyARQciEwAAQNQALIAgoAgRBgICAgHhHDQMgCCgCCCIARQ0FIAAgECgCGCIESw0EIBAoAhQhDyAIIBRBACAAEGYiBDYCKCAIQShqIA8gABAxIARBhAFJDQUgBBAtDAULEDkAC0GcgMAAQcYAIAhBzwBqQYyAwABBtIHAABAzAAsgDCAEQeiCwAAQNgALIAhBGGogCEEMaigCADYCACAIIAgpAgQ3AxAgCEEBNgIsIAhB4ILAADYCKCAIQgE3AjQgCCAIQRBqrUKAgICAwACENwNAIAggCEFAazYCMCAIQRxqIAhBKGoQLyAIKAIgIAgoAiQQaAALIAAgBEH4gsAAEDYACyAIKAIAIgRBhAFPBEAgBBAtCyAQIBAoAgBBAWo2AgAgCEHQAGokACAKKAIIIgRBhAFPBEAgBBAtCyAKKAIEIgRBhAFPBEAgBBAtCyAKQSBqJAAgAAsXAQF/IAAoAgAiAQRAIAAoAgQgARBlCwsUACABIAEgACAAIAFdGyAAIABcGwscACAAQQA2AhAgAEIANwIIIABCgICAgMAANwIAC0QAIABFBEAjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQeyLwAA2AgggAEIENwIQIABBCGpBiIzAABBDAAsgACABEG0ACxYBAW8gACUBEAAhARAbIgAgASYBIAALzgYBBn8CfwJAAkACQAJAAkAgAEEEayIFKAIAIgZBeHEiBEEEQQggBkEDcSIHGyABak8EQCAHQQAgAUEnaiIJIARJGw0BAkACQCACQQlPBEAgAiADEBwiCA0BQQAMCQsgA0HM/3tLDQFBECADQQtqQXhxIANBC0kbIQECQCAHRQRAIAFBgAJJIAQgAUEEcklyIAQgAWtBgYAIT3INAQwJCyAAQQhrIgIgBGohBwJAAkACQAJAIAEgBEsEQCAHQfyWwAAoAgBGDQQgB0H4lsAAKAIARg0CIAcoAgQiBkECcQ0FIAZBeHEiBiAEaiIEIAFJDQUgByAGEB4gBCABayIDQRBJDQEgBSABIAUoAgBBAXFyQQJyNgIAIAEgAmoiASADQQNyNgIEIAIgBGoiAiACKAIEQQFyNgIEIAEgAxAaDA0LIAQgAWsiA0EPSw0CDAwLIAUgBCAFKAIAQQFxckECcjYCACACIARqIgEgASgCBEEBcjYCBAwLC0HwlsAAKAIAIARqIgQgAUkNAgJAIAQgAWsiA0EPTQRAIAUgBkEBcSAEckECcjYCACACIARqIgEgASgCBEEBcjYCBEEAIQNBACEBDAELIAUgASAGQQFxckECcjYCACABIAJqIgEgA0EBcjYCBCACIARqIgIgAzYCACACIAIoAgRBfnE2AgQLQfiWwAAgATYCAEHwlsAAIAM2AgAMCgsgBSABIAZBAXFyQQJyNgIAIAEgAmoiASADQQNyNgIEIAcgBygCBEEBcjYCBCABIAMQGgwJC0H0lsAAKAIAIARqIgQgAUsNBwsgAxARIgFFDQEgASAAQXxBeCAFKAIAIgFBA3EbIAFBeHFqIgEgAyABIANJGxAfIAAQFgwICyAIIAAgASADIAEgA0kbEB8aIAUoAgAiAkF4cSIDIAFBBEEIIAJBA3EiAhtqSQ0DIAJBACADIAlLGw0EIAAQFgsgCAwGC0GBicAAQbCJwAAQPQALQcCJwABB8InAABA9AAtBgYnAAEGwicAAED0AC0HAicAAQfCJwAAQPQALIAUgASAGQQFxckECcjYCACABIAJqIgIgBCABayIBQQFyNgIEQfSWwAAgATYCAEH8lsAAIAI2AgAgAAwBCyAACwsZACABKAIUQaCNwABBDiABKAIYKAIMEQIACxYAIAAoAhQgASACIAAoAhgoAgwRAgALhwIBA39BnJPAACgCAEUEQAJAAkACQAJAIABFDQAgACgCACAAQQA2AgBBAXFFDQAgACgCECECIAAoAgwhASAAKAIIIQMgACgCBCEADAELQQAhAEGxk8AALQAAGkGAgBAhAkGAgBAhAwJAQYCAwAAQESIBRQ0AIAFBBGstAABBA3FFDQAgAUGAgMAAECoaCyABRQ0BC0Gsk8AAIAI2AgBBoJPAACAANgIAQaiTwAAoAgAhAkGok8AAIAE2AgBBpJPAACgCACEAQaSTwAAgAzYCAEGck8AAKAIAQZyTwABBATYCAEUgAEVyRQRAIAIgAEECdBBlCwwBC0EEQYCAwAAQUgALC0Ggk8AAC/ICAQl/QaySwAAoAgBFBEACfwJAIABFDQAgACgCACAAQQA2AgBBAXFFDQAgACgCKCEBIAAoAiQhByAAKAIgIQIgACgCHCEDIAAoAhghCCAAKAIUIQQgACgCECEFIAAoAgwhCSAAKAIIIQYgACgCBAwBC0ECIQlBBCEHQQAhAUEEIQhBAAshAEHUksAAIAE2AgBByJLAACADNgIAQbySwAAgBTYCAEGwksAAIAA2AgBB0JLAACgCACEFQdCSwAAgBzYCAEHMksAAKAIAIQBBzJLAACACNgIAQcSSwAAoAgAhAUHEksAAIAg2AgBBwJLAACgCACECQcCSwAAgBDYCAEG4ksAAKAIAIQRBuJLAACAJNgIAQbSSwAAoAgAhA0G0ksAAIAY2AgBBrJLAACgCACEGQaySwABBATYCAAJAIAZFDQAgAwRAIAQgA0EBdBBlCyACBEAgASACQQJ0EGULIABFDQAgBSAAQQJ0EGULC0GwksAAC8QEARF/QdiSwAAoAgBFBEACQCAABEAgACgCQCEBIAAoAjwhAiAAKAI4IQMgACgCNCEEIAAoAjAhBSAAKAIsIQYgACgCKCEHIAAoAiQhCCAAKAIgIQkgACgCHCEKIAAoAhghCyAAKAIUIQwgACgCECENIAAoAgwhDiAAKAIIIQ8gACgCBCEQIAAoAgAgAEEANgIAQQFxDQELQQQhAkEAIQFBACEDQQAhBEEEIQVBACEGQQAhB0EEIQhBACEJQQAhCkEEIQtBACEMQQAhDUEEIQ5BACEPQQAhEAtBmJPAACABNgIAQYyTwAAgBDYCAEGAk8AAIAc2AgBB9JLAACAKNgIAQeiSwAAgDTYCAEHcksAAIBA2AgBBlJPAACgCACEHQZSTwAAgAjYCAEGQk8AAKAIAIQBBkJPAACADNgIAQYiTwAAoAgAhCkGIk8AAIAU2AgBBhJPAACgCACEBQYSTwAAgBjYCAEH8ksAAKAIAIQVB/JLAACAINgIAQfiSwAAoAgAhAkH4ksAAIAk2AgBB8JLAACgCACEGQfCSwAAgCzYCAEHsksAAKAIAIQNB7JLAACAMNgIAQeSSwAAoAgAhCEHkksAAIA42AgBB4JLAACgCACEEQeCSwAAgDzYCAEHYksAAKAIAIQlB2JLAAEEBNgIAAkAgCUUNACAEBEAgCCAEQQJ0EGULIAMEQCAGIANBAnQQZQsgAgRAIAUgAkECdBBlCyABBEAgCiABQQJ0EGULIABFDQAgByAAQQJ0EGULC0HcksAACxQAIAAoAgAgASAAKAIEKAIMEQAACxQCAW8BfxAPIQAQGyIBIAAmASABCxAAIAEgACgCBCAAKAIIEBQLGQACfyABQQlPBEAgASAAEBwMAQsgABARCwsiACAAQu26rbbNhdT14wA3AwggAEL4gpm9le7Gxbl/NwMACyAAIABC2KGkg7Hi0d18NwMIIABCldfdmMOXiowLNwMACxMAIABB8IrAADYCBCAAIAE2AgALEAAgASAAKAIAIAAoAgQQVgsQACABIAAoAgAgACgCBBAUCxAAIAEoAhQgASgCGCAAEBgLDgAgACUBIAElASACEAYLWwECfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABAWDAILQYGJwABBsInAABA9AAtBwInAAEHwicAAED0ACwsdAQFvIAAoAgAlASABIAIQDCEDEBsiACADJgEgAAvCAgEGfyAAKAIAIQIjAEEQayIEJABBCiEDAkAgAkGQzgBJBEAgAiEADAELA0AgBEEGaiADaiIGQQRrIAIgAkGQzgBuIgBBkM4AbGsiB0H//wNxQeQAbiIFQQF0QdqPwABqLwAAOwAAIAZBAmsgByAFQeQAbGtB//8DcUEBdEHaj8AAai8AADsAACADQQRrIQMgAkH/wdcvSyAAIQINAAsLAkAgAEHjAE0EQCAAIQIMAQsgA0ECayIDIARBBmpqIAAgAEH//wNxQeQAbiICQeQAbGtB//8DcUEBdEHaj8AAai8AADsAAAsCQCACQQpPBEAgA0ECayIDIARBBmpqIAJBAXRB2o/AAGovAAA7AAAMAQsgA0EBayIDIARBBmpqIAJBMHI6AAALIAFBAUEAIARBBmogA2pBCiADaxAVIARBEGokAAsJACAAIAEQDgALDQAgAEHAiMAAIAEQGAsMACAAIAEpAgA3AwALDQAgAEHAi8AAIAEQGAsNACABQbiLwABBBRBWCxkAIAAgAUG8k8AAKAIAIgBBFSAAGxEBAAALCQAgAEEANgIACwgAIAAlARADCwgAIAAlARAHCwueEgQAQYCAwAALCQEAAAACAAAAAwBBlIDAAAuBDAEAAAAFAAAAY2Fubm90IGFjY2VzcyBhIFRocmVhZCBMb2NhbCBTdG9yYWdlIHZhbHVlIGR1cmluZyBvciBhZnRlciBkZXN0cnVjdGlvbi9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAAABiABAATwAAAAQBAAAaAAAAYgAQAE8AAAD4AQAAJgAAAHNwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJz1AAQACAAAAB+AAAAHAAAANQAEAAgAAAAgAAAABwAAADUABAAIAAAAIUAAAAgAAAAc3BhcmstaW50ZXJuYWwtcnMvc3JjL2xpYi5ycyQBEAAcAAAAHQAAADMAAAAkARAAHAAAACgAAAAtAAAAAQAAAAAAAAAkARAAHAAAADoAAAAzAAAAJAEQABwAAABFAAAALQAAACQBEAAcAAAAXgAAACgAAABzcGFyay1pbnRlcm5hbC1ycy9zcmMvc29ydC5ycwAAAJgBEAAdAAAAGwAAAB0AAACYARAAHQAAADkAAAAPAAAARXhwZWN0ZWQgIGFjdGl2ZSBzcGxhdHMgYnV0IGdvdCDYARAACQAAAOEBEAAXAAAAmAEQAB0AAAAzAAAAHQAAAJgBEAAdAAAAMwAAABUAAACYARAAHQAAACQAAAAUAAAAmAEQAB0AAAB0AAAAGQAAAJgBEAAdAAAApwAAABMAAACYARAAHQAAAJ8AAAATAAAAmAEQAB0AAACiAAAAHQAAAJgBEAAdAAAAogAAABEAAACYARAAHQAAAJAAAAAgAAAAmAEQAB0AAACQAAAAFAAAAJgBEAAdAAAAfAAAABgAAACYARAAHQAAAH0AAAAYAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnPIAhAAXAAAAPsYAAABAAAAAAAAAAQAAAAEAAAAEwAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkTGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkdgMQACoAAAAvVXNlcnMvZG1hcmNvcy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwCoAxAAXwAAAAgDAAAZAAAAcmVlbnRyYW50IGluaXQAABgEEAAOAAAAqAMQAF8AAAB6AgAADQAAABYAAAAMAAAABAAAABcAAAAYAAAAGQAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZABYBBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAWAQQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAAAsFEAAVAAAAIAUQAA0AAABzdGQvc3JjL2FsbG9jLnJzQAUQABAAAABjAQAACQAAABYAAAAMAAAABAAAABoAAAAAAAAACAAAAAQAAAAbAAAAAAAAAAgAAAAEAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAQAAAABAAAACEAAAAiAAAAIwAAACQAAABFcnJvcgAAACUAAAAMAAAABAAAACYAAAAnAAAAKAAAAGNhcGFjaXR5IG92ZXJmbG93AAAA2AUQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5yc/QFEAAUAAAAGAAAAAUAQaCMwAAL8AUBAAAAKQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAfgYQABAAAAB+AgAADgAAAEJvcnJvd011dEVycm9yYWxyZWFkeSBib3Jyb3dlZDogrgYQABIAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAyAYQACAAAADoBhAAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogABcHEAAQAAAAJwcQABcAAAA+BxAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAAAXBxAAEAAAAGAHEAAQAAAAcAcQAAkAAAA+BxAACQAAADogAAABAAAAAAAAAJwHEAACAAAAfSB9Y29yZS9zcmMvZm10L251bS5ycwAAswcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlyYW5nZSBzdGFydCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAACiCBAAEgAAALQIEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgIEAAQAAAAtAgQACIAAAAAAAA/AAAAvwBBqJLAAAsBFABwCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44My4wICg5MGIzNWE2MjMgMjAyNC0xMS0yNikGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4HMC4yLjEwMABJD3RhcmdldF9mZWF0dXJlcwQrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQrD3JlZmVyZW5jZS10eXBlcysKbXVsdGl2YWx1ZQ==",import.meta.url));const e=IFe();(typeof n=="string"||typeof Request=="function"&&n instanceof Request||typeof URL=="function"&&n instanceof URL)&&(n=fetch(n));const{instance:t,module:s}=await bFe(await n,e);return CFe(t,s)}const al=-12,ll=9,wFe=-30,SS=Math.exp(wFe),vFe=11,SFe=11,Pn=1<<vFe,su=1<<SFe,EFe=1;function _Fe(n){return n==="bool"||n==="bvec2"||n==="bvec3"||n==="bvec4"}function iu(n){return n==="int"||n==="ivec2"||n==="ivec3"||n==="ivec4"}function ru(n){return n==="uint"||n==="uvec2"||n==="uvec3"||n==="uvec4"}function TFe(n){return n==="float"||n==="vec2"||n==="vec3"||n==="vec4"}function BFe(n){return n==="mat2"||n==="mat2x2"||n==="mat2x3"||n==="mat2x4"||n==="mat3"||n==="mat3x2"||n==="mat3x3"||n==="mat3x4"||n==="mat4"||n==="mat4x2"||n==="mat4x3"||n==="mat4x4"}function qg(n){return TFe(n)||BFe(n)}function Rd(n){return n==="mat2"||n==="mat2x2"}function Dd(n){return n==="mat3"||n==="mat3x3"}function Fd(n){return n==="mat4"||n==="mat4x4"}function kFe(n){switch(n){case"vec2":return"float";case"vec3":return"float";case"vec4":return"float";case"ivec2":return"int";case"ivec3":return"int";case"ivec4":return"int";case"uvec2":return"uint";case"uvec3":return"uint";case"uvec4":return"uint";default:throw new Error(`Invalid vector type: ${n}`)}}function MFe(n){switch(n){case"vec2":case"ivec2":case"uvec2":return 2;case"vec3":case"ivec3":case"uvec3":return 3;case"vec4":case"ivec4":case"uvec4":return 4;default:throw new Error(`Invalid vector type: ${n}`)}}function Fs(n){return Math.trunc(n).toString()}function $s(n){return`${Math.max(0,Math.trunc(n)).toString()}u`}function In(n){return n===Number.POSITIVE_INFINITY?"INFINITY":n===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(n)?n.toFixed(1):n.toString()}function Ha(n){return n instanceof ou?n.type:n.dynoOut().type}class ou{constructor(e){this.__isDynoValue=!0,this.type=e}}class xr extends ou{constructor(e,t){super(e.outTypes[t]),this.dyno=e,this.key=t}}class L0 extends ou{constructor(e,t){super(e),this.literal=t}getLiteral(){return this.literal}}class NFe extends L0{constructor(e,t){super(e,""),this.value=t}getLiteral(){const{type:e,value:t}=this;switch(e){case"bool":return t?"true":"false";case"uint":return $s(t);case"int":return Fs(t);case"float":return In(t);case"bvec2":{const s=t;return`bvec2(${s[0]}, ${s[1]})`}case"uvec2":{if(t instanceof $e)return`uvec2(${$s(t.x)}, ${$s(t.y)})`;const s=t;return`uvec2(${$s(s[0])}, ${$s(s[1])})`}case"ivec2":{if(t instanceof $e)return`ivec2(${Fs(t.x)}, ${Fs(t.y)})`;const s=t;return`ivec2(${Fs(s[0])}, ${Fs(s[1])})`}case"vec2":{if(t instanceof $e)return`vec2(${In(t.x)}, ${In(t.y)})`;const s=t;return`vec2(${In(s[0])}, ${In(s[1])})`}case"bvec3":{const s=t;return`bvec3(${s[0]}, ${s[1]}, ${s[2]})`}case"uvec3":{if(t instanceof U)return`uvec3(${$s(t.x)}, ${$s(t.y)}, ${$s(t.z)})`;const s=t;return`uvec3(${$s(s[0])}, ${$s(s[1])}, ${$s(s[2])})`}case"ivec3":{if(t instanceof U)return`ivec3(${Fs(t.x)}, ${Fs(t.y)}, ${Fs(t.z)})`;const s=t;return`ivec3(${Fs(s[0])}, ${Fs(s[1])}, ${Fs(s[2])})`}case"vec3":{if(t instanceof U)return`vec3(${In(t.x)}, ${In(t.y)}, ${In(t.z)})`;const s=t;return`vec3(${In(s[0])}, ${In(s[1])}, ${In(s[2])})`}case"bvec4":{const s=t;return`bvec4(${s[0]}, ${s[1]}, ${s[2]}, ${s[3]})`}case"uvec4":{if(t instanceof Yt)return`uvec4(${$s(t.x)}, ${$s(t.y)}, ${$s(t.z)}, ${$s(t.w)})`;const s=t;return`uvec4(${$s(s[0])}, ${$s(s[1])}, ${$s(s[2])}, ${$s(s[3])})`}case"ivec4":{if(t instanceof Yt)return`ivec4(${Fs(t.x)}, ${Fs(t.y)}, ${Fs(t.z)}, ${Fs(t.w)})`;const s=t;return`ivec4(${Fs(s[0])}, ${Fs(s[1])}, ${Fs(s[2])}, ${Fs(s[3])})`}case"vec4":{if(t instanceof Yt)return`vec4(${In(t.x)}, ${In(t.y)}, ${In(t.z)}, ${In(t.w)})`;if(t instanceof $n)return`vec4(${In(t.x)}, ${In(t.y)}, ${In(t.z)}, ${In(t.w)})`;const s=t;return`vec4(${In(s[0])}, ${In(s[1])}, ${In(s[2])}, ${In(s[3])})`}case"mat2":case"mat2x2":{const s=t,i=s instanceof cA?s.elements:t,r=new Array(4).fill(0).map((o,a)=>In(i[a]));return`${e}(${r.join(", ")})`}case"mat2x3":{const s=t,i=new Array(6).fill(0).map((r,o)=>In(s[o]));return`${e}(${i.join(", ")})`}case"mat2x4":{const s=t,i=new Array(8).fill(0).map((r,o)=>In(s[o]));return`${e}(${i.join(", ")})`}case"mat3":case"mat3x3":{const s=t,i=s instanceof Ht?s.elements:t,r=new Array(9).fill(0).map((o,a)=>In(i[a]));return`${e}(${r.join(", ")})`}case"mat3x2":{const s=t,i=new Array(6).fill(0).map((r,o)=>In(s[o]));return`${e}(${i.join(", ")})`}case"mat3x4":{const s=t,i=new Array(12).fill(0).map((r,o)=>In(s[o]));return`${e}(${i.join(", ")})`}case"mat4":case"mat4x4":{const s=t,i=s instanceof kt?s.elements:t,r=new Array(16).fill(0).map((o,a)=>In(i[a]));return`${e}(${r.join(", ")})`}case"mat4x2":{const s=t,i=new Array(8).fill(0).map((r,o)=>In(s[o]));return`${e}(${i.join(", ")})`}case"mat4x3":{const s=t,i=new Array(12).fill(0).map((r,o)=>In(s[o]));return`${e}(${i.join(", ")})`}default:throw new Error(`Type not implemented: ${String(e)}`)}}}function ig(n,e){return new NFe(n,e)}function p0(n){const e=String(n);if(_Fe(n))return`${e}(false)`;if(qg(n))return`${e}(0.0)`;if(iu(n))return`${e}(0)`;if(ru(n))return`${e}(0u)`;throw new Error(`Type not implemented: ${e}`)}const $D="    ";class RFe{constructor({indent:e}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=$D,this.indent=e??$D}nextSequence(){return this.sequence++}}class ai{constructor({inTypes:e,outTypes:t,inputs:s,update:i,globals:r,statements:o,generate:a}){this.inTypes=e??{},this.outTypes=t??{},this.inputs=s??{},this.update=i,this.globals=r,this.statements=o,this.generate=a??(({inputs:l,outputs:c,compile:u})=>{var h,d;return{globals:(h=this.globals)==null?void 0:h.call(this,{inputs:l,outputs:c,compile:u}),statements:(d=this.statements)==null?void 0:d.call(this,{inputs:l,outputs:c,compile:u})}})}get outputs(){const e={};for(const t in this.outTypes)e[t]=new xr(this,t);return e}apply(e){return Object.assign(this.inputs,e),this.outputs}compile({inputs:e,outputs:t,compile:s}){const i=[`// ${this.constructor.name}(${Object.values(e).join(", ")}) => (${Object.values(t).join(", ")})`],r=[];for(const c in t){const u=t[c];u&&!s.declares.has(u)&&(s.declares.add(u),r.push(c))}const{globals:o,statements:a,uniforms:l}=this.generate({inputs:e,outputs:t,compile:s});for(const c of o??[])s.globals.add(c);for(const c in l)s.uniforms[c]=l[c];this.update&&s.updaters.push(this.update);for(const c of r){const u=t[c];u&&(s.uniforms[u]||i.push(`${rV(u,this.outTypes[c])};`))}return a?.length&&(i.push("{"),i.push(...a.map(c=>s.indent+c)),i.push("}")),i}}class DFe extends ai{constructor({inTypes:e,outTypes:t,inputs:s,update:i,globals:r,construct:o}){super({inTypes:e,outTypes:t,inputs:s,update:i,globals:r,generate:a=>this.generateBlock(a)}),this.construct=o}generateBlock({inputs:e,outputs:t,compile:s}){var i,r;const o={},a={};for(const m in e)e[m]!=null&&(o[m]=new L0(this.inTypes[m],e[m]));for(const m in t)t[m]!=null&&(a[m]=new ou(this.outTypes[m]));const l={roots:[]},c=this.construct(o,a,l);for(const m of((i=this.globals)==null?void 0:i.call(this,{inputs:e,outputs:t,compile:s}))??[])s.globals.add(m);const u=[],h=new Map;function d(m,A,y){let b=h.get(m);if(!b){b={sequence:s.nextSequence(),outNames:new Map,newOuts:new Set},h.set(m,b);for(const x in m.inputs){let C=m.inputs[x];for(;C;){if(C instanceof ou){C instanceof xr&&d(C.dyno,C.key);break}C=C.dynoOut()}}u.push(m)}A&&(y||b.newOuts.add(A),b.outNames.set(A,y??`${A}_${b.sequence}`))}for(const m of l.roots)d(m);for(const m in a){let A=c?.[m]??a[m];for(;A;){if(A instanceof ou){A instanceof xr&&d(A.dyno,A.key,t[m]);break}A=A.dynoOut()}a[m]=A}const p=[];for(const m of u){const A={},y={};for(const C in m.inputs){let w=m.inputs[C];for(;w;){if(w instanceof ou){if(w instanceof L0)A[C]=w.getLiteral();else if(w instanceof xr){const E=(r=h.get(w.dyno))==null?void 0:r.outNames.get(w.key);if(!E)throw new Error(`Source not found for ${w.dyno.constructor.name}.${w.key}`);A[C]=E}break}w=w.dynoOut()}}const b=h.get(m)??{outNames:new Map};for(const[C,w]of b.outNames.entries())y[C]=w;const x=m.compile({inputs:A,outputs:y,compile:s});p.push(x)}const f=[];for(const m in t)a[m]instanceof L0&&f.push(`${t[m]} = ${a[m].getLiteral()};`);return f.length>0&&p.push(f),{statements:p.flatMap((m,A)=>A===0?m:["",...m])}}}function cl(n,e,t,{update:s,globals:i}={}){return new DFe({inTypes:n,outTypes:e,construct:t,update:s,globals:i})}function Uw({inTypes:n,outTypes:e,inputs:t,update:s,globals:i,statements:r,generate:o}){return new ai({inTypes:n,outTypes:e,inputs:t,update:s,globals:i,statements:r,generate:o})}function rV(n,e,t){const s=typeof e=="string"?e:e.type;if(!s)throw new Error(`Invalid DynoType: ${String(e)}`);return`${s} ${n}${t!=null?`[${t}]`:""}`}function Ta(n){var e;let t=!1;const s=n.split(`
`).map(o=>{const a=o.trimEnd();return t?a:a.length>0?(t=!0,a):null}).filter(o=>o!=null);for(;s.length>0&&s[s.length-1].length===0;)s.pop();if(s.length===0)return[];const i=(e=s[0].match(/^\s*/))==null?void 0:e[0];if(!i)return s;const r=new RegExp(`^${i}`);return s.map(o=>o.replace(r,""))}function _r(n){return Ta(n).join(`
`)}class Qw extends ai{constructor({a:e,outKey:t,outTypeFunc:s}){const i={a:Ha(e)},r=s(Ha(e)),o={[t]:r};super({inTypes:i,outTypes:o,inputs:{a:e}}),this.outKey=t}dynoOut(){return new xr(this,this.outKey)}}class Vw extends ai{constructor({a:e,b:t,outKey:s,outTypeFunc:i}){const r={a:Ha(e),b:Ha(t)},o=i(Ha(e),Ha(t)),a={[s]:o};super({inTypes:r,outTypes:a,inputs:{a:e,b:t}}),this.outKey=s}dynoOut(){return new xr(this,this.outKey)}}const Ys={type:"Gsplat"},Gw={type:"PackedSplats"},rg=(n,e)=>new $Fe({packedSplats:n,index:e}),FFe=(n,e,t,s)=>new PFe({packedSplats:n,index:e,base:t,count:s}),O0=n=>new LFe({gsplat:n}),ES=({gsplat:n,flags:e,index:t,center:s,scales:i,quaternion:r,rgba:o,rgb:a,opacity:l,x:c,y:u,z:h,r:d,g:p,b:f})=>new OFe({gsplat:n,flags:e,index:t,center:s,scales:i,quaternion:r,rgba:o,rgb:a,opacity:l,x:c,y:u,z:h,r:d,g:p,b:f}),oV=(n,{scale:e,rotate:t,translate:s,recolor:i})=>new zFe({gsplat:n,scale:e,rotate:t,translate:s,recolor:i}),Ba=_r(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`),ek=_r(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
    vec4 rgbMinMaxLnScaleMinMax;
  };
`),aV=_r(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);
      return true;
    } else {
      return false;
    }
  }
`);class $Fe extends ai{constructor({packedSplats:e,index:t}){super({inTypes:{packedSplats:Gw,index:"int"},outTypes:{gsplat:Ys},inputs:{packedSplats:e,index:t},globals:()=>[Ba,ek,aV],statements:({inputs:s,outputs:i})=>{const{gsplat:r}=i;if(!r)return[];const{packedSplats:o,index:a}=s;let l;return o&&a?l=Ta(`
            if (readPackedSplat(${o}.texture, ${o}.numSplats, ${o}.rgbMinMaxLnScaleMinMax, ${a}, ${r})) {
              bool zeroSize = all(equal(${r}.scales, vec3(0.0, 0.0, 0.0)));
              ${r}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${r}.flags = 0u;
            }
          `):l=[`${r}.flags = 0u;`],l.push(`${r}.index = ${a??"0"};`),l}})}dynoOut(){return new xr(this,"gsplat")}}class PFe extends ai{constructor({packedSplats:e,index:t,base:s,count:i}){super({inTypes:{packedSplats:Gw,index:"int",base:"int",count:"int"},outTypes:{gsplat:Ys},inputs:{packedSplats:e,index:t,base:s,count:i},globals:()=>[Ba,ek,aV],statements:({inputs:r,outputs:o})=>{const{gsplat:a}=o;if(!a)return[];const{packedSplats:l,index:c,base:u,count:h}=r;let d;return l&&c&&u&&h?d=Ta(`
            ${a}.flags = 0u;
            if ((${c} >= ${u}) && (${c} < (${u} + ${h}))) {
              if (readPackedSplat(${l}.texture, ${l}.numSplats, ${l}.rgbMinMaxLnScaleMinMax, ${c}, ${a})) {
                bool zeroSize = all(equal(${a}.scales, vec3(0.0, 0.0, 0.0)));
                ${a}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `):d=[`${a}.flags = 0u;`],d.push(`${a}.index = ${c??"0"};`),d}})}dynoOut(){return new xr(this,"gsplat")}}class LFe extends ai{constructor({gsplat:e}){super({inTypes:{gsplat:Ys},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:e},globals:()=>[Ba],statements:({inputs:t,outputs:s})=>{const{gsplat:i}=t,{flags:r,active:o,index:a,center:l,scales:c,quaternion:u,rgba:h,rgb:d,opacity:p,x:f,y:g,z:m,r:A,g:y,b}=s;return[r?`${r} = ${i?`${i}.flags`:"0u"};`:null,o?`${o} = isGsplatActive(${i?`${i}.flags`:"0u"});`:null,a?`${a} = ${i?`${i}.index`:"0"};`:null,l?`${l} = ${i?`${i}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,c?`${c} = ${i?`${i}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,u?`${u} = ${i?`${i}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,h?`${h} = ${i?`${i}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,d?`${d} = ${i?`${i}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,p?`${p} = ${i?`${i}.rgba.a`:"0.0"};`:null,f?`${f} = ${i?`${i}.center.x`:"0.0"};`:null,g?`${g} = ${i?`${i}.center.y`:"0.0"};`:null,m?`${m} = ${i?`${i}.center.z`:"0.0"};`:null,A?`${A} = ${i?`${i}.rgba.r`:"0.0"};`:null,y?`${y} = ${i?`${i}.rgba.g`:"0.0"};`:null,b?`${b} = ${i?`${i}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class OFe extends ai{constructor({gsplat:e,flags:t,index:s,center:i,scales:r,quaternion:o,rgba:a,rgb:l,opacity:c,x:u,y:h,z:d,r:p,g:f,b:g}){super({inTypes:{gsplat:Ys,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:Ys},inputs:{gsplat:e,flags:t,index:s,center:i,scales:r,quaternion:o,rgba:a,rgb:l,opacity:c,x:u,y:h,z:d,r:p,g:f,b:g},globals:()=>[Ba],statements:({inputs:m,outputs:A})=>{const{gsplat:y}=A;if(!y)return[];const{gsplat:b,flags:x,index:C,center:w,scales:E,quaternion:T,rgba:v,rgb:S,opacity:_,x:N,y:D,z:P,r:L,g:z,b:q}=m;return[`${y}.flags = ${x??(b?`${b}.flags`:"0u")};`,`${y}.index = ${C??(b?`${b}.index`:"0")};`,`${y}.center = ${w??(b?`${b}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${y}.scales = ${E??(b?`${b}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${y}.quaternion = ${T??(b?`${b}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${y}.rgba = ${v??(b?`${b}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,S?`${y}.rgba.rgb = ${S};`:null,_?`${y}.rgba.a = ${_};`:null,N?`${y}.center.x = ${N};`:null,D?`${y}.center.y = ${D};`:null,P?`${y}.center.z = ${P};`:null,L?`${y}.rgba.r = ${L};`:null,z?`${y}.rgba.g = ${z};`:null,q?`${y}.rgba.b = ${q};`:null].filter(Boolean)}})}dynoOut(){return new xr(this,"gsplat")}}_r(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);class zFe extends ai{constructor({gsplat:e,scale:t,rotate:s,translate:i,recolor:r}){super({inTypes:{gsplat:Ys,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:Ys},inputs:{gsplat:e,scale:t,rotate:s,translate:i,recolor:r},globals:()=>[Ba],statements:({inputs:o,outputs:a,compile:l})=>{const{gsplat:c}=a;if(!c||!o.gsplat)return[];const{scale:u,rotate:h,translate:d,recolor:p}=o,f=l.indent;return[`${c} = ${o.gsplat};`,`if (isGsplatActive(${c}.flags)) {`,u?`${f}${c}.center *= ${u};`:null,h?`${f}${c}.center = quatVec(${h}, ${c}.center);`:null,d?`${f}${c}.center += ${d};`:null,u?`${f}${c}.scales *= ${u};`:null,h?`${f}${c}.quaternion = quatQuat(${h}, ${c}.quaternion);`:null,p?`${f}${c}.rgba *= ${p};`:null,"}"].filter(Boolean)}})}dynoOut(){return new xr(this,"gsplat")}}const UFe=(n,e)=>new QFe({gsplat:n,rgbMinMaxLnScaleMinMax:e});class QFe extends ai{constructor({gsplat:e,rgbMinMaxLnScaleMinMax:t}){super({inTypes:{gsplat:Ys,rgbMinMaxLnScaleMinMax:"vec4"},inputs:{gsplat:e,rgbMinMaxLnScaleMinMax:t},globals:()=>[Ba],statements:({inputs:s,outputs:i})=>{const{output:r}=i;if(!r)return[];const{gsplat:o,rgbMinMaxLnScaleMinMax:a}=s;return o?Ta(`
            if (isGsplatActive(${o}.flags)) {
              ${r} = packSplatEncoding(${o}.center, ${o}.scales, ${o}.quaternion, ${o}.rgba, ${a});
            } else {
              ${r} = uvec4(0u, 0u, 0u, 0u);
            }
          `):[`${r} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new xr(this,"output")}}class VFe extends ai{constructor({rgba8:e}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:e},statements:({inputs:t,outputs:s})=>[`target = ${t.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new xr(this,"rgba8")}}class Qo extends ai{constructor({key:e,type:t,count:s,value:i,update:r,globals:o}){e=e??"value",super({outTypes:{[e]:t},update:()=>{if(r){const a=r(this.value);a!==void 0&&(this.value=a)}this.uniform.value=this.value},generate:({inputs:a,outputs:l})=>{const c=o?.({inputs:a,outputs:l})??[],u={},h=l[e];return h&&(c.push(`uniform ${rV(h,t,s)};`),u[h]=this.uniform),{globals:c,uniforms:u}}}),this.type=t,this.count=s,this.value=i,this.uniform={value:i},this.outKey=e}dynoOut(){return new xr(this,this.outKey)}}class PD extends Qo{constructor({key:e,value:t,update:s}){super({key:e,type:"bool",value:t,update:s})}}class iE extends Qo{constructor({key:e,value:t,update:s}){super({key:e,type:"int",value:t,update:s})}}class Yg extends Qo{constructor({key:e,value:t,update:s}){super({key:e,type:"float",value:t,update:s})}}class _S extends Qo{constructor({key:e,value:t,update:s}){super({key:e,type:"vec2",value:t,update:s})}}class cI extends Qo{constructor({key:e,value:t,update:s}){super({key:e,type:"vec3",value:t,update:s})}}class Ww extends Qo{constructor({key:e,value:t,update:s}){super({key:e,type:"vec4",value:t,update:s})}}class TS extends Qo{constructor({key:e,value:t,update:s}){super({key:e,type:"usampler2DArray",value:t,update:s})}}const tk=new Float32Array(1),lV=new Uint32Array(tk.buffer),nk="Float16Array"in globalThis,uI=nk?new globalThis.Float16Array(1):null,cV=new Uint16Array(uI?.buffer),BS=nk?GFe:WFe,kS=nk?HFe:qFe;function GFe(n){return uI[0]=n,cV[0]}function WFe(n){tk[0]=n;const e=lV[0],t=e>>31&1,s=e>>23&255,i=e&8388607,r=t<<15;if(s===255)return i!==0?r|32767:r|31744;const o=s-127+15;if(o>=31)return r|31744;if(o<=0){if(o<-10)return r;const l=(i|8388608)>>1-o+13;return r|l}const a=i>>13;return r|o<<10|a}function HFe(n){return cV[0]=n,uI[0]}function qFe(n){const e=n>>15&1,t=n>>10&31,s=n&1023;let i;if(t===0)if(s===0)i=e<<31;else{let r=s,o=-14;for(;(r&1024)===0;)r<<=1,o--;r&=1023;const a=o+127,l=r<<13;i=e<<31|a<<23|l}else if(t===31)s===0?i=e<<31|2139095040:i=e<<31|2143289344;else{const r=t-15+127,o=s<<13;i=e<<31|r<<23|o}return lV[0]=i,tk[0]}function f0(n){return Math.max(0,Math.min(255,Math.round(n*255)))}function YFe(n){const e=[],t=new Set;function s(i){i&&typeof i=="object"&&!t.has(i)&&(t.add(i),i instanceof ArrayBuffer?e.push(i):ArrayBuffer.isView(i)?e.push(i.buffer):Array.isArray(i)?i.forEach(s):Object.values(i).forEach(s))}return s(n),e}class XFe{constructor({allocate:e,dispose:t,valid:s}){this.items=[],this.allocate=e,this.dispose=t,this.valid=s}alloc(e){for(;;){const t=this.items.pop();if(!t)break;if(this.valid(t,e))return t;this.dispose&&this.dispose(t)}return this.allocate(e)}free(e){this.items.push(e)}disposeAll(){let e;for(e=this.items.pop();e;)this.dispose&&this.dispose(e),e=this.items.pop()}}function LD(n,e,t,s,i,r,o,a,l,c,u,h,d,p,f,g,m){const A=m?.rgbMin??0,b=(m?.rgbMax??1)-A,x=f0((p-A)/b),C=f0((f-A)/b),w=f0((g-A)/b),E=f0(d),T=l$e(jFe.set(l,c,u,h)),v=T&255,S=T>>>8&255,_=T>>>16&255,N=m?.lnScaleMin??al,P=254/((m?.lnScaleMax??ll)-N),L=r<SS?0:Math.min(255,Math.max(1,Math.round((Math.log(r)-N)*P)+1)),z=o<SS?0:Math.min(255,Math.max(1,Math.round((Math.log(o)-N)*P)+1)),q=a<SS?0:Math.min(255,Math.max(1,Math.round((Math.log(a)-N)*P)+1)),V=BS(t),X=BS(s),te=BS(i),se=e*4;n[se]=x|C<<8|w<<16|E<<24,n[se+1]=V|X<<16,n[se+2]=te|v<<16|S<<24,n[se+3]=L|z<<8|q<<16|_<<24}const jFe=new $n,KFe=new U,JFe=new U,ZFe=new $n,e$e=new ot,t$e={center:KFe,scales:JFe,quaternion:ZFe,color:e$e,opacity:0};function OD(n,e,t){const s=t$e,i=e*4,r=n[i],o=n[i+1],a=n[i+2],l=n[i+3],c=t?.rgbMin??0,h=(t?.rgbMax??1)-c;s.color.set(c+(r&255)/255*h,c+(r>>>8&255)/255*h,c+(r>>>16&255)/255*h),s.opacity=(r>>>24&255)/255,s.center.set(kS(o&65535),kS(o>>>16&65535),kS(a&65535));const d=t?.lnScaleMin??al,f=((t?.lnScaleMax??ll)-d)/254,g=l&255;s.scales.x=g===0?0:Math.exp(d+(g-1)*f);const m=l>>>8&255;s.scales.y=m===0?0:Math.exp(d+(m-1)*f);const A=l>>>16&255;s.scales.z=A===0?0:Math.exp(d+(A-1)*f);const y=a>>>16&65535|l>>>8&16711680;return c$e(y,s.quaternion),s}function ro(n){const e=Pn,t=Math.max(EFe,Math.min(su,Math.ceil(n/e))),s=Math.ceil(n/(e*t)),i=e*t*s;return{width:e,height:t,depth:s,maxSplats:i}}function n$e(n){const e=new VI(n.autoStart);return e.startTime=n.startTime,e.oldTime=n.oldTime,e.elapsedTime=n.elapsedTime,e.running=n.running,e}const s$e=_r(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);function i$e(n){const e=new U;for(const t of n)e.add(t);return e.divideScalar(n.length)}function r$e(n){if(n.length===0)return new $n;const e=n[0].clone();for(let t=1;t<n.length;t++)n[t].dot(n[0])<0?(e.x-=n[t].x,e.y-=n[t].y,e.z-=n[t].z,e.w-=n[t].w):(e.x+=n[t].x,e.y+=n[t].y,e.z+=n[t].z,e.w+=n[t].w);return e.normalize()}function o$e(n,e){const[t,s]=[new U,new $n],[i,r]=[new U,new $n];n.decompose(t,s,new U),e.decompose(i,r,new U);const o=t.distanceTo(i),a=Math.abs(s.dot(r));return{distance:o,coorient:a}}function rE({matrix1:n,matrix2:e,maxDistance:t,minCoorient:s}){const{distance:i,coorient:r}=o$e(n,e);return i<=t&&(s==null||r>=s)}const a$e=new $n,oE=new U;function l$e(n){const e=a$e.copy(n).normalize();e.w<0&&e.set(-e.x,-e.y,-e.z,-e.w);const t=2*Math.acos(e.w),s=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z),i=s<1e-6?oE.set(1,0,0):oE.set(e.x,e.y,e.z).divideScalar(s),r=Math.abs(i.x)+Math.abs(i.y)+Math.abs(i.z);let o=i.x/r,a=i.y/r;if(i.z<0){const p=o;o=(1-Math.abs(a))*(o>=0?1:-1),a=(1-Math.abs(p))*(a>=0?1:-1)}const l=o*.5+.5,c=a*.5+.5,u=Math.round(l*255),h=Math.round(c*255);return Math.round(t*(255/Math.PI))<<16|h<<8|u}function c$e(n,e){const t=n&255,s=n>>>8&255,i=n>>>16&255,r=t/255,o=s/255;let a=(r-.5)*2,l=(o-.5)*2;const c=1-(Math.abs(a)+Math.abs(l)),u=Math.max(-c,0);a+=a>=0?-u:u,l+=l>=0?-u:u;const h=oE.set(a,l,c).normalize(),p=i/255*Math.PI*.5,f=Math.sin(p),g=Math.cos(p);return e.set(h.x*f,h.y*f,h.z*f,g),e}function u$e(n,e){const t=[];let s=0,i=null;const r=new cFe((l,c)=>{if(t.push(l),s+=l.length,c||s>=e){const u=new Uint8Array(s);let h=0;for(const d of t)u.set(d,h),h+=d.length;i=u.slice(0,e)}}),o=1024;let a=0;for(;i==null&&a<n.length;){const l=n.slice(a,a+o);r.push(l,!1),a+=o}if(i==null&&(r.push(new Uint8Array,!0),i==null))throw new Error("Failed to decompress partial gzip");return i}class uV{constructor({graph:e,inputs:t,outputs:s,template:i}){this.graph=e,this.template=i,this.inputs=t??{},this.outputs=s??{};const r=new RFe({indent:this.template.indent});for(const a in this.outputs)this.outputs[a]&&r.declares.add(this.outputs[a]);const o=e.compile({inputs:this.inputs,outputs:this.outputs,compile:r});this.shader=i.generate({globals:r.globals,statements:o}),this.uniforms=r.uniforms,this.updaters=r.updaters}prepareMaterial(){return h$e(this)}update(){for(const e of this.updaters)e()}}class hV{constructor(e){const t=e.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m),s=e.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);if(!t||!s)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=e.substring(0,t.index),this.between=e.substring(t.index+t[0].length,s.index),this.after=e.substring(s.index+s[0].length),this.indent=s[1]}generate({globals:e,statements:t}){return this.before+Array.from(e).join(`

`)+this.between+t.map(s=>this.indent+s).join(`
`)+this.after}}const zD=new Map;function h$e(n){let e=zD.get(n);return e||(e=new rA({glslVersion:pg,vertexShader:s$e,fragmentShader:n.shader,uniforms:n.uniforms}),zD.set(n,e),e)}function dV(n,e,t="add"){const s=()=>{throw new Error(`Invalid ${t} types: ${n}, ${e}`)};if(n===e)return n;if(n==="int"){if(iu(e))return e;s()}if(e==="int"){if(iu(n))return n;s()}if(n==="uint"){if(ru(e))return e;s()}if(e==="uint"){if(ru(n))return n;s()}if(n==="float"){if(qg(e))return e;s()}if(e==="float"){if(qg(n))return n;s()}throw new Error(`Invalid ${t} types: ${n}, ${e}`)}function d$e(n,e){return dV(n,e,"sub")}function p$e(n,e){const t=()=>{throw new Error(`Invalid mul types: ${n}, ${e}`)},s=i=>i;if(n==="int"){if(iu(e))return s(e);t()}if(e==="int"){if(iu(n))return s(n);t()}if(n==="uint"){if(ru(e))return s(e);t()}if(e==="uint"){if(ru(n))return s(n);t()}if(n==="float"){if(qg(e))return s(e);t()}if(e==="float"){if(qg(n))return s(n);t()}if(iu(n)||ru(n)||iu(e)||ru(e)){if(n===e)return s(n);t()}if(n==="vec2"){if(e==="vec2"||Rd(e))return s("vec2");if(e==="mat3x2")return s("vec3");if(e==="mat4x2")return s("vec4");t()}if(n==="vec3"){if(e==="mat2x3")return s("vec2");if(e==="vec3"||Dd(e))return s("vec3");if(e==="mat4x3")return s("vec4");t()}if(n==="vec4"){if(e==="mat2x4")return s("vec2");if(e==="mat3x4")return s("vec3");if(e==="vec4"||Fd(e))return s("vec4");t()}if(e==="vec2"){if(Rd(n))return s("vec2");if(n==="mat2x3")return s("vec3");if(n==="mat2x4")return s("vec4");t()}if(e==="vec3"){if(n==="mat3x2")return s("vec2");if(Dd(n))return s("vec3");if(n==="mat3x4")return s("vec4");t()}if(e==="vec4"){if(n==="mat4x2")return s("vec2");if(n==="mat4x3")return s("vec3");if(Fd(n))return s("vec4");t()}if(Rd(n)){if(Rd(e))return s("mat2");if(e==="mat3x2")return s("mat3x2");if(e==="mat4x2")return s("mat4x2");t()}if(n==="mat2x3"){if(Rd(e))return s("mat2x3");if(e==="mat3x2")return s("mat3");if(e==="mat4x2")return s("mat4x3");t()}if(n==="mat2x4"){if(Rd(e))return s("mat2x4");if(e==="mat3x2")return s("mat3x4");if(e==="mat4x2")return s("mat4");t()}if(n==="mat3x2"){if(e==="mat2x3")return s("mat2");if(Dd(e))return s("mat3x2");if(e==="mat4x3")return s("mat4x2");t()}if(Dd(n)){if(e==="mat2x3")return s("mat2x3");if(Dd(e))return s("mat3");if(e==="mat4x3")return s("mat4x3");t()}if(n==="mat3x4"){if(e==="mat2x3")return s("mat2x4");if(Dd(e))return s("mat3x4");if(e==="mat4x3")return s("mat4");t()}if(n==="mat4x2"){if(e==="mat2x4")return s("mat2");if(e==="mat3x4")return s("mat3x2");if(Fd(e))return s("mat4x2");t()}if(n==="mat4x3"){if(e==="mat2x4")return s("mat2x3");if(e==="mat3x4")return s("mat3");if(Fd(e))return s("mat4x3");t()}if(Fd(n)){if(e==="mat2x4")return s("mat2x4");if(e==="mat3x4")return s("mat3x4");if(Fd(e))return s("mat4");t()}throw new Error(`Invalid mul types: ${n}, ${e}`)}const Xc=(n,e)=>new f$e({a:n,b:e}),UD=(n,e)=>new m$e({a:n,b:e}),Vm=(n,e)=>new g$e({a:n,b:e});class f$e extends Vw{constructor({a:e,b:t}){super({a:e,b:t,outKey:"sum",outTypeFunc:dV}),this.statements=({inputs:s,outputs:i})=>[`${i.sum} = ${s.a} + ${s.b};`]}}class m$e extends Vw{constructor({a:e,b:t}){super({a:e,b:t,outKey:"difference",outTypeFunc:d$e}),this.statements=({inputs:s,outputs:i})=>[`${i.difference} = ${s.a} - ${s.b};`]}}class g$e extends Vw{constructor({a:e,b:t}){super({a:e,b:t,outKey:"product",outTypeFunc:p$e}),this.statements=({inputs:s,outputs:i})=>[`${i.product} = ${s.a} * ${s.b};`]}}const A$e=n=>new x$e({value:n}),y$e=n=>new b$e({value:n}),QD=n=>new I$e({value:n});class x$e extends Qw{constructor({value:e}){super({a:e,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:t,outputs:s})=>[`${s.uint} = floatBitsToUint(${t.a});`]}}class b$e extends Qw{constructor({value:e}){super({a:e,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:t,outputs:s})=>[`${s.uint} = packHalf2x16(${t.a});`]}}class I$e extends Qw{constructor({value:e}){super({a:e,outKey:"rgba8",outTypeFunc:()=>"vec4"}),this.statements=({inputs:t,outputs:s})=>[`uvec4 uRgba = uvec4(${t.a} & 0xffu, (${t.a} >> 8u) & 0xffu, (${t.a} >> 16u) & 0xffu, (${t.a} >> 24u) & 0xffu);`,`${s.rgba8} = vec4(uRgba) / 255.0;`]}}const C$e=n=>new E$e({a:n}),w$e=n=>new k$e({vector:n}),v$e=({vector:n,vectorType:e,x:t,y:s,z:i,w:r,r:o,g:a,b:l,a:c})=>new M$e({vector:n,vectorType:e,x:t,y:s,z:i,w:r,r:o,g:a,b:l,a:c}),S$e=(n,e)=>new T$e({a:n,b:e});class E$e extends Qw{constructor({a:e}){super({a:e,outTypeFunc:t=>t,outKey:"normalize"}),this.statements=({inputs:t,outputs:s})=>[`${s.normalize} = normalize(${t.a});`]}}function _$e(n){if(n==="float")return"vec2";if(n==="vec2")return"vec3";if(n==="vec3")return"vec4";throw new Error("Invalid type")}class T$e extends Vw{constructor({a:e,b:t}){const s=Ha(e),i=_$e(s);super({a:e,b:t,outKey:"extend",outTypeFunc:()=>i}),this.statements=({inputs:r,outputs:o})=>[`${o.extend} = ${i}(${r.a}, ${r.b});`]}}function B$e(n){const e=t=>t;switch(n){case"vec2":return e({x:"float",y:"float",r:"float",g:"float"});case"vec3":return e({x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"});case"vec4":return e({x:"float",y:"float",z:"float",w:"float",r:"float",g:"float",b:"float",a:"float"});case"ivec2":return e({x:"int",y:"int",r:"int",g:"int"});case"ivec3":return e({x:"int",y:"int",z:"int",r:"int",g:"int",b:"int"});case"ivec4":return e({x:"int",y:"int",z:"int",w:"int",r:"int",g:"int",b:"int",a:"int"});case"uvec2":return e({x:"uint",y:"uint",r:"uint",g:"uint"});case"uvec3":return e({x:"uint",y:"uint",z:"uint",r:"uint",g:"uint",b:"uint"});case"uvec4":return e({x:"uint",y:"uint",z:"uint",w:"uint",r:"uint",g:"uint",b:"uint",a:"uint"});default:throw new Error(`Invalid vector type: ${n}`)}}class k$e extends ai{constructor({vector:e}){const s={vector:Ha(e)},i=B$e(s.vector);super({inTypes:s,outTypes:i,inputs:{vector:e}}),this.statements=({inputs:r,outputs:o})=>{const{x:a,y:l,z:c,w:u,r:h,g:d,b:p,a:f}=o,{vector:g}=r;return[a?`${a} = ${g}.x;`:null,l?`${l} = ${g}.y;`:null,c?`${c} = ${g}.z;`:null,u?`${u} = ${g}.w;`:null,h?`${h} = ${g}.r;`:null,d?`${d} = ${g}.g;`:null,p?`${p} = ${g}.b;`:null,f?`${f} = ${g}.a;`:null].filter(Boolean)}}}class M$e extends ai{constructor({vector:e,vectorType:t,x:s,y:i,z:r,w:o,r:a,g:l,b:c,a:u}){if(!e&&!t)throw new Error("Either vector or vectorType must be provided");const h=t??Ha(e),d=kFe(h),p=MFe(h),f={vector:h,x:d,y:d,r:d,g:d},g={vector:e,x:s,y:i,r:a,g:l};p>=3&&(Object.assign(f,{z:d,b:d}),Object.assign(g,{z:r,b:c})),p>=4&&(Object.assign(f,{w:d,a:d}),Object.assign(g,{w:o,a:u})),super({inTypes:f,outTypes:{vector:h},inputs:g}),this.statements=({inputs:m,outputs:A})=>{const{vector:y}=A,{vector:b,x,y:C,z:w,w:E,r:T,g:v,b:S,a:_}=m,N=[`${y}.x = ${x??T??(b?`${b}.x`:p0(d))};`,`${y}.y = ${C??v??(b?`${b}.y`:p0(d))};`];return p>=3&&N.push(`${y}.z = ${w??S??(b?`${b}.z`:p0(d))};`),p>=4&&N.push(`${y}.w = ${E??_??(b?`${b}.w`:p0(d))};`),N}}dynoOut(){return new xr(this,"vector")}}const N$e=(n,{scale:e,scales:t,rotate:s,translate:i})=>new D$e({position:n,scale:e,scales:t,rotate:s,translate:i}).outputs.position,R$e=(n,{scale:e,scales:t,rotate:s})=>new F$e({dir:n,scale:e,scales:t,rotate:s}).outputs.dir;class D$e extends ai{constructor({position:e,scale:t,scales:s,rotate:i,translate:r}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:e,scale:t,scales:s,rotate:i,translate:r},statements:({inputs:o,outputs:a})=>{const{position:l}=a;if(!l)return[];const{scale:c,scales:u,rotate:h,translate:d}=o;return[`${l} = ${o.position??"vec3(0.0, 0.0, 0.0)"};`,c?`${l} *= ${c};`:null,u?`${l} *= ${u};`:null,h?`${l} = quatVec(${h}, ${l});`:null,d?`${l} += ${d};`:null].filter(Boolean)}})}}class F$e extends ai{constructor({dir:e,scale:t,scales:s,rotate:i}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:e,scale:t,scales:s,rotate:i},statements:({inputs:r,outputs:o})=>{const{dir:a}=o;if(!a)return[];const{scale:l,scales:c,rotate:u}=r;return[`${a} = ${r.dir??"vec3(0.0, 0.0, 0.0)"};`,l?`${a} *= ${l};`:null,c?`${a} *= ${c};`:null,u?`${a} = quatVec(${u}, ${a});`:null].filter(Boolean)}})}}var $$e=`precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out vec4 target;

{{ GLOBALS }}

void computeReadback(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        computeReadback(index);
    } else {
        target = vec4(0.0, 0.0, 0.0, 0.0);
    }
}`;const Hw=class Bl{constructor({renderer:e}={}){this.renderer=e,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(e,t){const i=Math.ceil(Math.max(1,e)/Pn)*Pn*4;if(t.byteLength>=i)return t;const r=new ArrayBuffer(i);if(t instanceof ArrayBuffer)return r;const o=t.constructor;return new o(r)}ensureCapacity(e){const{width:t,height:s,depth:i,maxSplats:r}=ro(e);(!this.target||r>this.capacity)&&(this.dispose(),this.capacity=r,this.target=new RE(t,s,i,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:bs,minFilter:bs}),this.target.texture.format=ys,this.target.texture.type=Di,this.target.texture.internalFormat="RGBA8",this.target.scissorTest=!0)}prepareProgramMaterial(e){let t=Bl.readbackProgram.get(e);if(!t){const i=cl({index:"int"},{rgba8:"vec4"},({index:r})=>(e.inputs.index=r,{rgba8:new VFe({rgba8:e.outputs.rgba8})}));Bl.programTemplate||(Bl.programTemplate=new hV($$e)),t=new uV({graph:i,inputs:{index:"index"},outputs:{rgba8:"target"},template:Bl.programTemplate}),Object.assign(t.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),Bl.readbackProgram.set(e,t)}const s=t.prepareMaterial();return Bl.fullScreenQuad.material=s,{program:t,material:s}}saveRenderState(e){return{xrEnabled:e.xr.enabled,autoClear:e.autoClear}}resetRenderState(e,t){e.setRenderTarget(null),e.xr.enabled=t.xrEnabled,e.autoClear=t.autoClear}process({count:e,material:t}){const s=this.renderer;if(!s)throw new Error("No renderer");if(!this.target)throw new Error("No target");const i=Pn*su;t.uniforms.targetBase.value=0,t.uniforms.targetCount.value=e;let r=0;for(;r<e;){const o=Math.floor(r/i),a=o*i,l=Math.min(su,Math.ceil((e-a)/Pn));t.uniforms.targetLayer.value=o,this.target.scissor.set(0,0,Pn,l),s.setRenderTarget(this.target,o),s.xr.enabled=!1,s.autoClear=!1,Bl.fullScreenQuad.render(s),r+=Pn*l}this.count=e}async read({readback:e}){const t=this.renderer;if(!t)throw new Error("No renderer");if(!this.target)throw new Error("No target");const s=Math.ceil(this.count/Pn)*Pn;if(e.byteLength<s*4)throw new Error(`Readback buffer too small: ${e.byteLength} < ${s*4}`);const i=new Uint8Array(e instanceof ArrayBuffer?e:e.buffer),r=Pn*su;let o=0;const a=[];for(;o<this.count;){const l=Math.floor(o/r),c=l*r,u=Math.min(su,Math.ceil((this.count-c)/Pn));t.setRenderTarget(this.target,l);const h=Pn*u*4,d=i.subarray(c*4,c*4+h),p=t?.readRenderTargetPixelsAsync(this.target,0,0,Pn,u,d);a.push(p),o+=Pn*u}return Promise.all(a).then(()=>e)}render({reader:e,count:t,renderer:s}){if(this.renderer=s||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(t);const{program:i,material:r}=this.prepareProgramMaterial(e);i.update();const o=this.saveRenderState(this.renderer);this.process({count:t,material:r}),this.resetRenderState(this.renderer,o)}async readback({readback:e}){if(!this.renderer)throw new Error("No renderer");const t=this.saveRenderState(this.renderer),s=this.read({readback:e});return this.resetRenderState(this.renderer,t),s}async renderReadback({reader:e,count:t,renderer:s,readback:i}){if(this.renderer=s||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(t);const{program:r,material:o}=this.prepareProgramMaterial(e);r.update();const a=this.saveRenderState(this.renderer);this.process({count:t,material:o});const l=this.read({readback:i});return this.resetRenderState(this.renderer,a),l}getTexture(){var e;return(e=this.target)==null?void 0:e.texture}};Hw.programTemplate=null;Hw.readbackProgram=new Map;Hw.fullScreenQuad=new q4(new rA({visible:!1}));let pV=Hw;const sk=class Gi{constructor(e={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new Qo({key:"rgbaArray",type:fV,globals:()=>[mV],value:{texture:Gi.getEmpty(),count:0},update:t=>{var s;return t.texture=((s=this.readback)==null?void 0:s.getTexture())??this.source??Gi.getEmpty(),t.count=this.count,t}}),e.array?(this.array=e.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/Pn)*Pn,this.count=Math.min(this.capacity,e.count??Number.POSITIVE_INFINITY)):(this.capacity=e.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(e){var t;if(!this.array||e>(((t=this.array)==null?void 0:t.length)??0)/4){this.capacity=ro(e).maxSplats;const s=new Uint8Array(this.capacity*4);this.array&&s.set(this.array),this.array=s}return this.array}getTexture(){var e;let t=(e=this.readback)==null?void 0:e.getTexture();return(this.source||this.array)&&(t=this.maybeUpdateSource()),t??Gi.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:e,height:t,depth:s}=this.source.image;this.capacity!==e*t*s&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:e,height:t,depth:s}=ro(this.capacity);this.source=new ko(this.array,e,t,s),this.source.format=ys,this.source.type=Di,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:e,count:t,renderer:s}){this.readback||(this.readback=new pV({renderer:s})),this.readback.render({reader:e,count:t,renderer:s}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:e,base:t,count:s,renderer:i}){const{dynoSplats:r,dynoBase:o,dynoCount:a,reader:l}=Gi.makeDynos();return r.packedSplats=e,o.value=t,a.value=s,this.render({reader:l,count:s,renderer:i}),this}async read(){if(!this.readback)throw new Error("No readback");return(!this.array||this.array.length<this.count*4)&&(this.array=new Uint8Array(this.capacity*4)),(await this.readback.readback({readback:this.array})).subarray(0,this.count*4)}static getEmpty(){if(!Gi.emptySource){const e=new Uint8Array(4);Gi.emptySource=new ko(e,1,1,1),Gi.emptySource.format=ys,Gi.emptySource.type=Di,Gi.emptySource.internalFormat="RGBA8",Gi.emptySource.needsUpdate=!0}return Gi.emptySource}static makeDynos(){if(!Gi.dynos){const e=new rk,t=new iE({value:0}),s=new iE({value:0}),i=cl({index:"int"},{rgba8:"vec4"},({index:r})=>{if(!r)throw new Error("index is undefined");r=Xc(r,t);const o=FFe(e,r,t,s);return{rgba8:O0(o).outputs.rgba}});Gi.dynos={dynoSplats:e,dynoBase:t,dynoCount:s,reader:i}}return Gi.dynos}};sk.emptySource=null;sk.dynos=null;let P$e=sk;const fV={type:"RgbaArray"},mV=_r(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);function L$e(n,e){return new ai({inTypes:{rgba:fV,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:n,index:e},globals:()=>[mV],statements:({inputs:s,outputs:i})=>Ta(`
        if ((index >= 0) && (index < ${s.rgba}.count)) {
          ${i.rgba} = texelFetch(${s.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${i.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)}).outputs.rgba}function O$e(n){switch(n){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${n}`)}}function z$e(n){switch(n){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${n}`)}}class U$e extends un{constructor(e={}){super();const{type:t,invert:s,opacity:i,color:r,displace:o,radius:a}=e;this.type=t??"sphere",this.invert=s??!1,this.opacity=i??1,this.color=r??new ot(1,1,1),this.displace=o??new U(0,0,0),this.radius=a??0}}const gV=class AV extends un{constructor(e={}){const{name:t,rgbaBlendMode:s="multiply",sdfSmooth:i=0,softEdge:r=0,invert:o=!1,sdfs:a=null}=e;super(),this.rgbaBlendMode=s,this.sdfSmooth=i,this.softEdge=r,this.invert=o,this.sdfs=a,this.ordering=AV.nextOrdering++,this.name=t??`Edit ${this.ordering}`}addSdf(e){this.sdfs==null&&(this.sdfs=[]),this.sdfs.includes(e)||this.sdfs.push(e)}removeSdf(e){this.sdfs!=null&&(this.sdfs=this.sdfs.filter(t=>t!==e))}};gV.nextOrdering=1;let yV=gV;class Q$e{constructor({maxSdfs:e,maxEdits:t}){this.maxSdfs=Math.max(16,e??0),this.numSdfs=0,this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new Qo({key:"sdfArray",type:xV,globals:()=>[bV],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:s=>(s.numSdfs=this.numSdfs,s.sdfTexture=this.sdfTexture,s)}),this.maxEdits=Math.max(16,t??0),this.numEdits=0,this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new iE({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(e,t){const s=new Mo(e,8,t,ha,Ri);return s.internalFormat="RGBA32UI",s.needsUpdate=!0,s}newEdits(e,t){return new Qo({key:"edits",type:"uvec4",count:t,globals:()=>[IV],value:e})}ensureCapacity({maxSdfs:e,maxEdits:t}){let s=!1;return e>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(this.maxSdfs*2,e),this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),t>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(this.maxEdits*2,t),this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),s=!0),s}updateEditData(e,t){const s=this.editData[e]!==t;return this.editData[e]=t,s}updateEditFloatData(e,t){$d[0]=t;const s=this.editFloatData[e]!==$d[0];return s&&(this.editFloatData[e]=$d[0]),s}encodeEdit(e,{sdfFirst:t,sdfCount:s,invert:i,rgbaBlendMode:r,softEdge:o,sdfSmooth:a}){const l=e*4;let c=!1;return c=this.updateEditData(l+0,r|(i?256:0))||c,c=this.updateEditData(l+1,t|s<<16)||c,c=this.updateEditFloatData(l+2,o)||c,c=this.updateEditFloatData(l+3,a)||c,c}updateSdfData(e,t){const s=this.sdfData[e]!==t;return this.sdfData[e]=t,s}updateSdfFloatData(e,t){$d[0]=t;const s=this.sdfFloatData[e]!==$d[0];return s&&(this.sdfFloatData[e]=$d[0]),s}encodeSdf(e,{sdfType:t,invert:s,center:i,quaternion:r,scale:o,sizes:a},l){const c=e*32,u=t|(s?256:0);let h=!1;h=this.updateSdfFloatData(c+0,i?.x??0)||h,h=this.updateSdfFloatData(c+1,i?.y??0)||h,h=this.updateSdfFloatData(c+2,i?.z??0)||h,h=this.updateSdfData(c+3,u)||h,h=this.updateSdfFloatData(c+4,r?.x??0)||h,h=this.updateSdfFloatData(c+5,r?.y??0)||h,h=this.updateSdfFloatData(c+6,r?.z??0)||h,h=this.updateSdfFloatData(c+7,r?.w??0)||h,h=this.updateSdfFloatData(c+8,o?.x??0)||h,h=this.updateSdfFloatData(c+9,o?.y??0)||h,h=this.updateSdfFloatData(c+10,o?.z??0)||h,h=this.updateSdfData(c+11,0)||h,h=this.updateSdfFloatData(c+12,a?.x??0)||h,h=this.updateSdfFloatData(c+13,a?.y??0)||h,h=this.updateSdfFloatData(c+14,a?.z??0)||h,h=this.updateSdfFloatData(c+15,a?.w??0)||h;const d=Math.min(4,l.length);for(let p=0;p<d;++p){const f=c+16+p*4;h=this.updateSdfFloatData(f+0,l[p].x)||h,h=this.updateSdfFloatData(f+1,l[p].y)||h,h=this.updateSdfFloatData(f+2,l[p].z)||h,h=this.updateSdfFloatData(f+3,l[p].w)||h}return h}update(e){const t=e.reduce((h,{sdfs:d})=>h+d.length,0),s=this.ensureCapacity({maxEdits:e.length,maxSdfs:t}),i=[new Yt,new Yt],r=new U,o=new $n,a=new U,l=new Yt;let c=0,u=s;e.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=e.length,this.numEdits=e.length,u=!0);for(const[h,{edit:d,sdfs:p}]of e.entries()){u=this.encodeEdit(h,{sdfFirst:c,sdfCount:p.length,invert:d.invert,rgbaBlendMode:z$e(d.rgbaBlendMode),softEdge:d.softEdge,sdfSmooth:d.sdfSmooth})||u;let f=!1;for(const g of p)l.set(g.scale.x,g.scale.y,g.scale.z,g.radius),g.scale.setScalar(1),g.updateMatrixWorld(),g.matrixWorld.clone().invert().decompose(r,o,a),g.scale.set(l.x,l.y,l.z),g.updateMatrixWorld(),i[0].set(g.color.r,g.color.g,g.color.b,g.opacity),i[1].set(g.displace.x,g.displace.y,g.displace.z,1),f=this.encodeSdf(c,{sdfType:O$e(g.type),invert:g.invert,center:r,quaternion:o,scale:a,sizes:l},i)||f,c+=1;this.numSdfs=c,f&&(this.sdfTexture.needsUpdate=!0),u||(u=f)}return{updated:u,dynoUpdated:s}}modify(e){return V$e(e,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const xV={type:"SdfArray"},bV=_r(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`),IV=_r(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);function V$e(n,e,t,s){return new ai({inTypes:{gsplat:Ys,sdfArray:xV,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:Ys},globals:()=>[bV,IV],inputs:{gsplat:n,sdfArray:e,numEdits:t,rgbaDisplaceEdits:s},statements:({inputs:r,outputs:o})=>{const{sdfArray:a,numEdits:l,rgbaDisplaceEdits:c}=r,{gsplat:u}=o;return Ta(`
        ${u} = ${r.gsplat};
        if (isGsplatActive(${u}.flags)) {
          for (int editIndex = 0; editIndex < ${l}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${c}[editIndex], ${a}.sdfTexture, ${a}.numSdfs,
              ${u}.center, ${u}.rgba
            );
          }
        }
      `)}}).outputs.gsplat}const $d=new Float32Array(1);class G$e{constructor(e){this.modifier=e,this.cache=new Map}apply(e){let t=this.cache.get(e);return t||(t=cl({index:"int"},{gsplat:Ys},({index:s})=>{const{gsplat:i}=e.apply({index:s});return this.modifier.apply({gsplat:i})}),this.cache.set(e,t)),t}}class m0{constructor(){this.scale=new Yg({value:Number.NEGATIVE_INFINITY}),this.rotate=new Ww({value:new $n(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new cI({value:new U(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(e){return N$e(e,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(e){return R$e(e,{rotate:this.rotate})}applyGsplat(e){return oV(e,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(e){const t=new U,s=new $n,i=new U;e.decompose(i,s,t);const r=(t.x+t.y+t.z)/3;let o=!1;return r!==this.scale.value&&(this.scale.value=r,o=!0),i.equals(this.translate.value)||(this.translate.value.copy(i),o=!0),s.equals(this.rotate.value)||(this.rotate.value.copy(s),o=!0),o}update(e){return e.updateMatrixWorld(),this.updateFromMatrix(e.matrixWorld)}}class aE extends un{constructor({numSplats:e,generator:t,construct:s,update:i}){if(super(),this.numSplats=e??0,this.generator=t,this.frameUpdate=i,this.version=0,s){const r=s(this);Object.assign(this,r)}}updateVersion(){this.version+=1}set needsUpdate(e){e&&this.updateVersion()}}const Xg=class lE extends aE{constructor(e={}){const t=new m0,s=new m0,i=new m0,r=new m0,o=new Ww({value:new Yt(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),a=new Yg({value:0}),l=new Yg({value:0}),c={transform:t,viewToWorld:s,worldToView:i,viewToObject:r,recolor:o,time:a,deltaTime:l};if(super({update:({time:u,deltaTime:h,viewToWorld:d,globalEdits:p})=>this.update({time:u,deltaTime:h,viewToWorld:d,globalEdits:p})}),this.isInitialized=!1,this.recolor=new ot(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=e.packedSplats??new Uu,this.packedSplats.splatEncoding=e.splatEncoding??{...qw},this.numSplats=this.packedSplats.numSplats,this.editable=e.editable??!0,this.onFrame=e.onFrame,this.context=c,this.objectModifier=e.objectModifier,this.worldModifier=e.worldModifier,this.updateGenerator(),e.url||e.fileBytes||e.constructSplats||e.packedSplats&&!e.packedSplats.isInitialized)this.initialized=this.asyncInitialize(e).then(async()=>{if(this.updateGenerator(),this.isInitialized=!0,e.onLoad){const u=e.onLoad(this);u instanceof Promise&&await u}return this});else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),e.onLoad){const u=e.onLoad(this);u instanceof Promise&&(this.initialized=u.then(()=>this))}this.add(Z$e())}async asyncInitialize(e){const{url:t,fileBytes:s,fileType:i,fileName:r,maxSplats:o,constructSplats:a,splatEncoding:l}=e;if(t||s||a){const c={url:t,fileBytes:s,fileType:i,fileName:r,maxSplats:o,construct:a,splatEncoding:l};this.packedSplats.reinitialize(c)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await iV(),lE.isStaticInitialized=!0}pushSplat(e,t,s,i,r){this.packedSplats.pushSplat(e,t,s,i,r)}forEachSplat(e){this.packedSplats.forEachSplat(e)}dispose(){this.packedSplats.dispose()}getBoundingBox(e=!0){if(!this.initialized)throw new Error("Cannot get bounding box before SplatMesh is initialized");const t=new U(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),s=new U(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY),i=new U,r=[-1,1];return this.packedSplats.forEachSplat((a,l,c,u,h,d)=>{if(e)t.min(l),s.max(l);else for(const p of r)for(const f of r)for(const g of r)i.set(p*c.x,f*c.y,g*c.z),i.applyQuaternion(u),i.add(l),t.min(i),s.max(i)}),new Us(t,s)}constructGenerator(e){const{transform:t,viewToObject:s,recolor:i}=e,r=cl({index:"int"},{gsplat:Ys},({index:o})=>{if(!o)throw new Error("index is undefined");let a=rg(this.packedSplats.dyno,o);if(this.maxSh>=1){const{sh1Texture:c,sh2Texture:u,sh3Texture:h}=this.ensureShTextures();if(c){let d=function(b,x){const{x:C,y:w}=w$e(x).outputs,E=Vm(Xc(C,w),ig("float",.5)),T=Vm(UD(w,C),ig("float",.5));return Xc(E,Vm(b,T))};const p=s.translate,{center:f}=O0(a).outputs,g=C$e(UD(f,p)),m=Y$e(a,c,g);let A=d(m,this.packedSplats.dynoSh1MinMax);if(this.maxSh>=2&&u){const b=X$e(a,u,g);A=Xc(A,d(b,this.packedSplats.dynoSh2MinMax))}if(this.maxSh>=3&&h){const b=j$e(a,h,g);A=Xc(A,d(b,this.packedSplats.dynoSh3MinMax))}let{rgba:y}=O0(a).outputs;y=Xc(y,S$e(A,ig("float",0))),a=ES({gsplat:a,rgba:y})}}if(this.splatRgba){const c=L$e(this.splatRgba.dyno,o);a=ES({gsplat:a,rgba:c})}this.skinning&&(a=this.skinning.modify(a)),this.objectModifier&&(a=this.objectModifier.apply({gsplat:a}).gsplat),a=t.applyGsplat(a);const l=Vm(i,O0(a).outputs.rgba);return a=ES({gsplat:a,rgba:l}),this.rgbaDisplaceEdits&&(a=this.rgbaDisplaceEdits.modify(a)),this.worldModifier&&(a=this.worldModifier.apply({gsplat:a}).gsplat),{gsplat:a}});this.generator=r}updateGenerator(){this.constructGenerator(this.context)}update({time:e,viewToWorld:t,deltaTime:s,globalEdits:i}){var r;this.numSplats=this.packedSplats.numSplats,this.context.time.value=e,this.context.deltaTime.value=s,lE.dynoTime.value=e;const{transform:o,viewToObject:a,recolor:l}=this.context;let c=o.update(this);this.context.viewToWorld.updateFromMatrix(t)&&this.enableViewToWorld&&(c=!0);const u=t.clone().invert();this.context.worldToView.updateFromMatrix(u)&&this.enableWorldToView&&(c=!0);const p=new kt().compose(o.translate.value,o.rotate.value,new U().setScalar(o.scale.value)).invert().multiply(t);a.updateFromMatrix(p)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(c=!0);const f=new Yt(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);f.equals(l.value)||(l.value.copy(f),c=!0);const g=this.editable?(this.edits??[]).concat(i):[];this.editable&&!this.edits&&this.traverseVisible(A=>{A instanceof yV&&g.push(A)}),g.sort((A,y)=>A.ordering-y.ordering);const m=g.map(A=>{if(A.sdfs!=null)return{edit:A,sdfs:A.sdfs};const y=[];return A.traverseVisible(b=>{b instanceof U$e&&y.push(b)}),{edit:A,sdfs:y}});if(m.length>0&&!this.rgbaDisplaceEdits){const A=m.length,y=m.reduce((b,x)=>b+x.sdfs.length,0);this.rgbaDisplaceEdits=new Q$e({maxEdits:A,maxSdfs:y}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const A=this.rgbaDisplaceEdits.update(m);c||(c=A.updated),A.dynoUpdated&&this.updateGenerator()}c&&this.updateVersion(),(r=this.onFrame)==null||r.call(this,{mesh:this,time:e,deltaTime:s})}raycast(e,t){var s,i;if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:r,far:o,ray:a}=e,l=this.matrixWorld.clone().invert(),c=new Ht().setFromMatrix4(l),u=a.origin.clone().applyMatrix4(l),h=a.direction.clone().applyMatrix3(c),d=new U;l.decompose(new U,new $n,d),(d.x*d.y*d.z)**(1/3);const f=xFe(u.x,u.y,u.z,h.x,h.y,h.z,r,o,this.packedSplats.numSplats,this.packedSplats.packedArray,!0,((s=this.packedSplats.splatEncoding)==null?void 0:s.lnScaleMin)??al,((i=this.packedSplats.splatEncoding)==null?void 0:i.lnScaleMax)??ll);for(const g of f){const m=a.direction.clone().multiplyScalar(g).add(a.origin);t.push({distance:g,point:m,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let e=this.packedSplats.extra.sh1Texture;if(!e){let i=this.packedSplats.extra.sh1;const{width:r,height:o,depth:a,maxSplats:l}=ro(i.length/2);if(i.length<l*2){const u=new Uint32Array(l*2);u.set(i),this.packedSplats.extra.sh1=u,i=u}const c=new ko(i,r,o,a);c.format=Jg,c.type=Ri,c.internalFormat="RG32UI",c.needsUpdate=!0,e=new TS({value:c,key:"sh1"}),this.packedSplats.extra.sh1Texture=e}if(!this.packedSplats.extra.sh2)return{sh1Texture:e};let t=this.packedSplats.extra.sh2Texture;if(!t){let i=this.packedSplats.extra.sh2;const{width:r,height:o,depth:a,maxSplats:l}=ro(i.length/4);if(i.length<l*4){const u=new Uint32Array(l*4);u.set(i),this.packedSplats.extra.sh2=u,i=u}const c=new ko(i,r,o,a);c.format=ha,c.type=Ri,c.internalFormat="RGBA32UI",c.needsUpdate=!0,t=new TS({value:c,key:"sh2"}),this.packedSplats.extra.sh2Texture=t}if(!this.packedSplats.extra.sh3)return{sh1Texture:e,sh2Texture:t};let s=this.packedSplats.extra.sh3Texture;if(!s){let i=this.packedSplats.extra.sh3;const{width:r,height:o,depth:a,maxSplats:l}=ro(i.length/4);if(i.length<l*4){const u=new Uint32Array(l*4);u.set(i),this.packedSplats.extra.sh3=u,i=u}const c=new ko(i,r,o,a);c.format=ha,c.type=Ri,c.internalFormat="RGBA32UI",c.needsUpdate=!0,s=new TS({value:c,key:"sh3"}),this.packedSplats.extra.sh3Texture=s}return{sh1Texture:e,sh2Texture:t,sh3Texture:s}}};Xg.staticInitialized=Xg.staticInitialize();Xg.isStaticInitialized=!1;Xg.dynoTime=new Yg({value:0});let zu=Xg;const W$e=_r(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`),H$e=_r(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`),q$e=_r(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);function Y$e(n,e,t){return Uw({inTypes:{gsplat:Ys,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:n,sh1:e,viewDir:t},globals:()=>[Ba,W$e],statements:({inputs:s,outputs:i})=>Ta(`
        if (isGsplatActive(${s.gsplat}.flags)) {
          ${i.rgb} = evaluateSH1(${s.gsplat}, ${s.sh1}, ${s.viewDir});
        } else {
          ${i.rgb} = vec3(0.0);
        }
      `)}).outputs.rgb}function X$e(n,e,t){return Uw({inTypes:{gsplat:Ys,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:n,sh2:e,viewDir:t},globals:()=>[Ba,H$e],statements:({inputs:s,outputs:i})=>Ta(`
        if (isGsplatActive(${s.gsplat}.flags)) {
          ${i.rgb} = evaluateSH2(${s.gsplat}, ${s.sh2}, ${s.viewDir});
        } else {
          ${i.rgb} = vec3(0.0);
        }
      `)}).outputs.rgb}function j$e(n,e,t){return Uw({inTypes:{gsplat:Ys,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:n,sh3:e,viewDir:t},globals:()=>[Ba,q$e],statements:({inputs:s,outputs:i})=>Ta(`
        if (isGsplatActive(${s.gsplat}.flags)) {
          ${i.rgb} = evaluateSH3(${s.gsplat}, ${s.sh3}, ${s.viewDir});
        } else {
          ${i.rgb} = vec3(0.0);
        }
      `)}).outputs.rgb}const K$e=new Xt,J$e=new Hr;function Z$e(){const n=new On(K$e,J$e);return n.frustumCulled=!1,n.onBeforeRender=function(e,t){if(!t.isScene){this.removeFromParent();return}let s=!1;t.traverse(i=>{i instanceof hE&&(s=!0)}),s||t.add(new hE({renderer:e})),this.removeFromParent()},n}const VD=["char","uchar","short","ushort","int","uint","float","double"],CV=class z0{constructor({fileBytes:e}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=e instanceof ArrayBuffer?new Uint8Array(e):e}async parseHeader(){const t=new ReadableStream({start:o=>{o.enqueue(this.fileBytes.slice(0,65536)),o.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const s=`end_header
`;for(;;){const{value:o,done:a}=await t.read();if(a)throw new Error("Failed to read header");this.header+=o;const l=this.header.indexOf(s);if(l>=0){this.header=this.header.slice(0,l+s.length);break}}const i=new TextEncoder().encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,i),this.elements={};let r=null;this.comments=[],this.header.trim().split(`
`).forEach((o,a)=>{const l=o.trim();if(a===0){if(l!=="ply")throw new Error("Invalid PLY header");return}if(l.length===0)return;const c=l.split(" ");switch(c[0]){case"format":if(c[1]==="binary_little_endian")this.littleEndian=!0;else if(c[1]==="binary_big_endian")this.littleEndian=!1;else throw new Error(`Unsupported PLY format: ${c[1]}`);if(c[2]!=="1.0")throw new Error(`Unsupported PLY version: ${c[2]}`);break;case"end_header":break;case"comment":this.comments.push(l.slice(8));break;case"element":{const u=c[1];r={name:u,count:Number.parseInt(c[2]),properties:{}},this.elements[u]=r;break}case"property":if(r==null)throw new Error("Property must be inside an element");c[1]==="list"?r.properties[c[4]]={isList:!0,type:c[3],countType:c[2]}:r.properties[c[2]]={isList:!1,type:c[1]};break}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(e){let t=0;const s=this.data;if(s==null)throw new Error("No data to parse");for(const i in this.elements){const r=this.elements[i],{count:o,properties:a}=r,l=sPe(a),c=iPe(a,this.littleEndian),u=e(r)??(()=>{});for(let h=0;h<o;h++)t=c(s,t,l),u(h,l)}}parseSplats(e,t){if(this.elements.vertex==null)throw new Error("No vertex element found");let s=!1;const i=[];let r=0,o=[],a=[],l=[],c,u,h;function d(){const A=nPe[r];o=new Array(3).fill(null).flatMap((y,b)=>[0,1,2].map((x,C)=>b+C*A/3)),a=new Array(5).fill(null).flatMap((y,b)=>[0,1,2].map((x,C)=>3+b+C*A/3)),l=new Array(7).fill(null).flatMap((y,b)=>[0,1,2].map((x,C)=>8+b+C*A/3)),c=r>=1?new Float32Array(9):void 0,u=r>=2?new Float32Array(15):void 0,h=r>=3?new Float32Array(21):void 0}function p(A,y){if(!c)throw new Error("Missing sh1");const b=y.f_rest;for(let x=0;x<o.length;x++)c[x]=b[o[x]]*8/255-4;if(u)for(let x=0;x<a.length;x++)u[x]=b[a[x]]*8/255-4;if(h)for(let x=0;x<l.length;x++)h[x]=b[l[x]]*8/255-4;t?.(A,c,u,h)}function f(A){const{min_x:y,min_y:b,min_z:x,max_x:C,max_y:w,max_z:E,min_scale_x:T,min_scale_y:v,min_scale_z:S,max_scale_x:_,max_scale_y:N,max_scale_z:D}=A.properties;if(!y||!b||!x||!C||!w||!E||!T||!v||!S||!_||!N||!D)throw new Error("Missing PLY chunk properties");return s=!0,(P,L)=>{const{min_x:z,min_y:q,min_z:V,max_x:X,max_y:te,max_z:se,min_scale_x:fe,min_scale_y:me,min_scale_z:Te,max_scale_x:Ee,max_scale_y:re,max_scale_z:ue,min_r:_e,min_g:ke,min_b:Ne,max_r:Ue,max_g:ht,max_b:W}=L;i.push({min_x:z,min_y:q,min_z:V,max_x:X,max_y:te,max_z:se,min_scale_x:fe,min_scale_y:me,min_scale_z:Te,max_scale_x:Ee,max_scale_y:re,max_scale_z:ue,min_r:_e,min_g:ke,min_b:Ne,max_r:Ue,max_g:ht,max_b:W})}}function g(A){if(t&&A.name==="sh")return r=cE(A.properties),d(),p;if(A.name!=="vertex")return null;const{packed_position:y,packed_rotation:b,packed_scale:x,packed_color:C}=A.properties;if(!y||!b||!x||!C)throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const w=Math.sqrt(2);return(E,T)=>{const v=i[E>>>8];if(v==null)throw new Error("Missing PLY chunk");const{min_x:S,min_y:_,min_z:N,max_x:D,max_y:P,max_z:L,min_scale_x:z,min_scale_y:q,min_scale_z:V,max_scale_x:X,max_scale_y:te,max_scale_z:se,min_r:fe,min_g:me,min_b:Te,max_r:Ee,max_g:re,max_b:ue}=v,{packed_position:_e,packed_rotation:ke,packed_scale:Ne,packed_color:Ue}=T,ht=(_e>>>21&2047)/2047*(D-S)+S,W=(_e>>>11&1023)/1023*(P-_)+_,Ce=(_e&2047)/2047*(L-N)+N,be=((ke>>>20&1023)/1023-.5)*w,ge=((ke>>>10&1023)/1023-.5)*w,ye=((ke&1023)/1023-.5)*w,Re=Math.sqrt(Math.max(0,1-be*be-ge*ge-ye*ye)),De=ke>>>30,Me=De===0?be:De===1?Re:ge,Tt=De<=1?ge:De===2?Re:ye,At=De<=2?ye:Re,G=De===0?Re:be,$=Math.exp((Ne>>>21&2047)/2047*(X-z)+z),de=Math.exp((Ne>>>11&1023)/1023*(te-q)+q),xe=Math.exp((Ne&2047)/2047*(se-V)+V),Fe=(Ue>>>24&255)/255*((Ee??1)-(fe??0))+(fe??0),ve=(Ue>>>16&255)/255*((re??1)-(me??0))+(me??0),ut=(Ue>>>8&255)/255*((ue??1)-(Te??0))+(Te??0),He=(Ue&255)/255;e(E,ht,W,Ce,$,de,xe,Me,Tt,At,G,He,Fe,ve,ut)}}const m=A=>{if(A.name==="chunk")return f(A);if(s)return g(A);if(A.name!=="vertex")return null;const{x:y,y:b,z:x,scale_0:C,scale_1:w,scale_2:E,rot_0:T,rot_1:v,rot_2:S,rot_3:_,opacity:N,f_dc_0:D,f_dc_1:P,f_dc_2:L,red:z,green:q,blue:V,alpha:X}=A.properties;if(!y||!b||!x)throw new Error("Missing PLY properties: x, y, z");const te=C&&w&&E,se=T&&v&&S&&_,fe=X!=null?A0[X.type]:1,me=z!=null?A0[z.type]:1,Te=q!=null?A0[q.type]:1,Ee=V!=null?A0[V.type]:1;return r=cE(A.properties),d(),(re,ue)=>{const _e=te?Math.exp(ue.scale_0):z0.defaultPointScale,ke=te?Math.exp(ue.scale_1):z0.defaultPointScale,Ne=te?Math.exp(ue.scale_2):z0.defaultPointScale,Ue=se?ue.rot_1:0,ht=se?ue.rot_2:0,W=se?ue.rot_3:0,Ce=se?ue.rot_0:1,be=N!=null?1/(1+Math.exp(-ue.opacity)):X!=null?ue.alpha/fe:1,ge=D!=null?ue.f_dc_0*g0+.5:z!=null?ue.red/me:1,ye=P!=null?ue.f_dc_1*g0+.5:q!=null?ue.green/Te:1,Re=L!=null?ue.f_dc_2*g0+.5:V!=null?ue.blue/Ee:1;if(e(re,ue.x,ue.y,ue.z,_e,ke,Ne,Ue,ht,W,Ce,be,ge,ye,Re),t&&c){const De=ue.f_rest;if(c)for(let Me=0;Me<o.length;Me++)c[Me]=De[o[Me]];if(u)for(let Me=0;Me<a.length;Me++)u[Me]=De[a[Me]];if(h)for(let Me=0;Me<l.length;Me++)h[Me]=De[l[Me]];t(re,c,u,h)}}};this.parseData(m)}injectRgba(e){let t=0;const s=this.data;if(s==null)throw new Error("No parsed data");if(e.length!==this.numSplats*4)throw new Error("Invalid RGBA array length");for(const i in this.elements){const r=this.elements[i],{count:o,properties:a}=r,l=[];let c=0;const u=i==="vertex";if(u){for(const h of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!a[h]||a[h].type!=="float")throw new Error(`Can't injectRgba due to property: ${h}`)}for(const[h,d]of Object.entries(a))if(d.isList)l.push(()=>{const p=Vd[d.countType](s,t,this.littleEndian);t+=Bo[d.countType],t+=p*Bo[d.type]});else{if(u)if(h==="f_dc_0"||h==="f_dc_1"||h==="f_dc_2"){const p=Number.parseInt(h.slice(5));l.push(()=>{const f=(e[c+p]/255-.5)/g0;GD[d.type](s,t,this.littleEndian,f)})}else h==="opacity"&&l.push(()=>{const p=Math.max(-100,Math.min(100,-Math.log(1/(e[c+3]/255)-1)));GD[d.type](s,t,this.littleEndian,p)});l.push(()=>{t+=Bo[d.type]})}for(let h=0;h<o;h++){for(const d of l)d();u&&(c+=4)}}}};CV.defaultPointScale=.001;let ePe=CV;const g0=.28209479177387814,Vd={char:(n,e,t)=>n.getInt8(e),uchar:(n,e,t)=>n.getUint8(e),short:(n,e,t)=>n.getInt16(e,t),ushort:(n,e,t)=>n.getUint16(e,t),int:(n,e,t)=>n.getInt32(e,t),uint:(n,e,t)=>n.getUint32(e,t),float:(n,e,t)=>n.getFloat32(e,t),double:(n,e,t)=>n.getFloat64(e,t)},GD={char:(n,e,t,s)=>{n.setInt8(e,s)},uchar:(n,e,t,s)=>{n.setUint8(e,s)},short:(n,e,t,s)=>{n.setInt16(e,s,t)},ushort:(n,e,t,s)=>{n.setUint16(e,s,t)},int:(n,e,t,s)=>{n.setInt32(e,s,t)},uint:(n,e,t,s)=>{n.setUint32(e,s,t)},float:(n,e,t,s)=>{n.setFloat32(e,s,t)},double:(n,e,t,s)=>{n.setFloat64(e,s,t)}},Bo={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},A0={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},tPe={0:0,9:1,24:2,45:3},nPe={0:0,1:9,2:24,3:45},ik=/^f_rest_([0-9]{1,2})$/;function sPe(n){const e={};for(const[t,s]of Object.entries(n))ik.test(t)?e.f_rest=new Array(cE(n)):e[t]=s.isList?[]:0;return e}function iPe(n,e){return aPe(n)?lPe(n,e):cPe(n,e)}const rPe=(()=>{try{new Function("return 42;")}catch{return!1}return!0})(),oPe=/^[a-zA-Z0-9_]+$/;function aPe(n){if(!rPe)return!1;for(const[e,t]of Object.entries(n))if(!oPe.test(e)||t.isList&&!VD.includes(t.countType)||!VD.includes(t.type))return!1;return!0}function lPe(n,e){const t=["let list;"];for(const[i,r]of Object.entries(n)){const o=i.match(ik);if(o){const a=+o[1];t.push(`
        item.f_rest[${a}] = PARSE_FIELD['${r.type}'](data, offset, ${e});
        offset += ${Bo[r.type]};
      `)}else r.isList?t.push(`
        list = item['${i}'];
        list.length = PARSE_FIELD['${r.countType}'](data, offset, ${e});
        offset += ${Bo[r.countType]};
        for (let i = 0; i < list.length; i++) {
          list[i] = PARSE_FIELD['${r.type}'](data, offset, ${e});
          offset += ${Bo[r.type]};
        }
      `):t.push(`
        item['${i}'] = PARSE_FIELD['${r.type}'](data, offset, ${e});
        offset += ${Bo[r.type]};
      `)}t.push("return offset;");const s=new Function("data","offset","item","PARSE_FIELD",t.join(`
`));return(i,r,o)=>s(i,r,o,Vd)}function cPe(n,e){const t=[];for(const[s,i]of Object.entries(n)){const r=s.match(ik);if(r){const o=+r[1];t.push((a,l,c)=>(c.f_rest[o]=Vd[i.type](a,l,e),l+Bo[i.type]))}else i.isList?t.push((o,a,l)=>{const c=l[s];c.length=Vd[i.countType](o,a,e);let u=a+Bo[i.countType];for(let h=0;h<c.length;h++)c[h]=Vd[i.type](o,u,e),u+=Bo[i.type];return u}):t.push((o,a,l)=>(l[s]=Vd[i.type](o,a,e),a+Bo[i.type]))}return(s,i,r)=>{let o=i;for(let a=0;a<t.length;a++)o=t[a](s,o,r);return o}}function cE(n){let e=0;for(;n[`f_rest_${e}`];)e+=1;const t=tPe[e];if(t==null)throw new Error(`Unsupported number of SH coefficients: ${e}`);return t}const wV=`(function() {
  "use strict";
  let wasm;
  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
    throw Error("TextDecoder not available");
  } };
  if (typeof TextDecoder !== "undefined") {
    cachedTextDecoder.decode();
  }
  let cachedUint8ArrayMemory0 = null;
  function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
  }
  function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
  }
  function sort_splats(num_splats, readback, ordering) {
    const ret = wasm.sort_splats(num_splats, readback, ordering);
    return ret >>> 0;
  }
  function sort32_splats(num_splats, readback, ordering) {
    const ret = wasm.sort32_splats(num_splats, readback, ordering);
    return ret >>> 0;
  }
  async function __wbg_load(module, imports) {
    if (typeof Response === "function" && module instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return await WebAssembly.instantiateStreaming(module, imports);
        } catch (e) {
          if (module.headers.get("Content-Type") != "application/wasm") {
            console.warn("\`WebAssembly.instantiateStreaming\` failed because your server does not serve Wasm with \`application/wasm\` MIME type. Falling back to \`WebAssembly.instantiate\` which is slower. Original error:\\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = await module.arrayBuffer();
      return await WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = await WebAssembly.instantiate(module, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module };
      } else {
        return instance;
      }
    }
  }
  function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
      const ret = arg0.buffer;
      return ret;
    };
    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {
      const ret = arg0.length;
      return ret;
    };
    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {
      const ret = arg0.length;
      return ret;
    };
    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {
      const ret = arg0.length;
      return ret;
    };
    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {
      const ret = new Uint16Array(arg0);
      return ret;
    };
    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {
      const ret = new Uint32Array(arg0);
      return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {
      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {
      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {
      const ret = new Float32Array(arg0 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {
      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {
      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
      const table = wasm.__wbindgen_export_0;
      const offset = table.grow(4);
      table.set(0, void 0);
      table.set(offset + 0, void 0);
      table.set(offset + 1, null);
      table.set(offset + 2, true);
      table.set(offset + 3, false);
    };
    imports.wbg.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return ret;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    return imports;
  }
  function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedUint8ArrayMemory0 = null;
    wasm.__wbindgen_start();
    return wasm;
  }
  async function __wbg_init(module_or_path) {
    if (wasm !== void 0) return wasm;
    if (typeof module_or_path !== "undefined") {
      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
        ({ module_or_path } = module_or_path);
      } else {
        console.warn("using deprecated parameters for the initialization function; pass a single object instead");
      }
    }
    if (typeof module_or_path === "undefined") {
      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AX9gA39/fwBgAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgAW8Bf2AAAX9gBH9/f38AYAAAYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAcDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABwN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAHA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAcDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADgNhYAMAAQIIBQQCEwEMAAEBAgAAAQwBBAYFBQQAAQYFFAENBAAGBQQEAQQOAgECAQAIBAAVARYGCBcZGwUNAhAQBR0FAQMPAAIDAwMADAAAAQEBAAAABAECAAEAAQAAAQEDAwQJAnABLi5vAIABBQMBABEGCQF/AUGAgMAACwdiBgZtZW1vcnkCAAtzb3J0X3NwbGF0cwBNDXNvcnQzMl9zcGxhdHMATg5yYXljYXN0X3NwbGF0cwBCE19fd2JpbmRnZW5fZXhwb3J0XzABARBfX3diaW5kZ2VuX3N0YXJ0ABAJMwEAQQELLVhZV1xBZ0YuRUZETEtFRUhHST5RN086IWlfXmE7YGpKMiQrbk88IGtsVVpiYwrF3wFghCQCCX8BfiMAQRBrIggkAAJ/AkACQAJAAkACQAJAIABB9QFPBEBBACAAQc3/e08NBxogAEELaiIBQXhxIQVB7JbAACgCACIJRQ0EQR8hB0EAIAVrIQQgAEH0//8HTQRAIAVBBiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBwsgB0ECdEHQk8AAaigCACIBRQRAQQAhAAwCC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQMDQAJAIAEoAgRBeHEiBiAFSQ0AIAYgBWsiBiAETw0AIAEhAiAGIgQNAEEAIQQgASEADAQLIAEoAhQiBiAAIAYgASADQR12QQRxakEQaigCACIBRxsgACAGGyEAIANBAXQhAyABDQALDAELQeiWwAAoAgAiAkEQIABBC2pB+ANxIABBC0kbIgVBA3YiAHYiAUEDcQRAAkAgAUF/c0EBcSAAaiIGQQN0IgBB4JTAAGoiAyAAQeiUwABqKAIAIgEoAggiBEcEQCAEIAM2AgwgAyAENgIIDAELQeiWwAAgAkF+IAZ3cTYCAAsgASAAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEIAFBCGoMBwsgBUHwlsAAKAIATQ0DAkACQCABRQRAQeyWwAAoAgAiAEUNBiAAaEECdEHQk8AAaigCACICKAIEQXhxIAVrIQQgAiEBA0ACQCACKAIQIgANACACKAIUIgANACABKAIYIQcCQAJAIAEgASgCDCIARgRAIAFBFEEQIAEoAhQiABtqKAIAIgINAUEAIQAMAgsgASgCCCICIAA2AgwgACACNgIIDAELIAFBFGogAUEQaiAAGyEDA0AgAyEGIAIiAEEUaiAAQRBqIAAoAhQiAhshAyAAQRRBECACG2ooAgAiAg0ACyAGQQA2AgALIAdFDQQgASABKAIcQQJ0QdCTwABqIgIoAgBHBEAgB0EQQRQgBygCECABRhtqIAA2AgAgAEUNBQwECyACIAA2AgAgAA0DQeyWwABB7JbAACgCAEF+IAEoAhx3cTYCAAwECyAAKAIEQXhxIAVrIgIgBCACIARJIgIbIQQgACABIAIbIQEgACECDAALAAsCQEECIAB0IgNBACADa3IgASAAdHFoIgZBA3QiAUHglMAAaiIDIAFB6JTAAGooAgAiACgCCCIERwRAIAQgAzYCDCADIAQ2AggMAQtB6JbAACACQX4gBndxNgIACyAAIAVBA3I2AgQgACAFaiIGIAEgBWsiA0EBcjYCBCAAIAFqIAM2AgBB8JbAACgCACIEBEAgBEF4cUHglMAAaiEBQfiWwAAoAgAhAgJ/QeiWwAAoAgAiBUEBIARBA3Z0IgRxRQRAQeiWwAAgBCAFcjYCACABDAELIAEoAggLIQQgASACNgIIIAQgAjYCDCACIAE2AgwgAiAENgIIC0H4lsAAIAY2AgBB8JbAACADNgIAIABBCGoMCAsgACAHNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAEoAhQiAkUNACAAIAI2AhQgAiAANgIYCwJAAkAgBEEQTwRAIAEgBUEDcjYCBCABIAVqIgMgBEEBcjYCBCADIARqIAQ2AgBB8JbAACgCACIGRQ0BIAZBeHFB4JTAAGohAEH4lsAAKAIAIQICf0HolsAAKAIAIgVBASAGQQN2dCIGcUUEQEHolsAAIAUgBnI2AgAgAAwBCyAAKAIICyEGIAAgAjYCCCAGIAI2AgwgAiAANgIMIAIgBjYCCAwBCyABIAQgBWoiAEEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAwBC0H4lsAAIAM2AgBB8JbAACAENgIACyABQQhqDAYLIAAgAnJFBEBBACECQQIgB3QiAEEAIABrciAJcSIARQ0DIABoQQJ0QdCTwABqKAIAIQALIABFDQELA0AgACACIAAoAgRBeHEiAyAFayIGIARJIgcbIQkgACgCECIBRQRAIAAoAhQhAQsgAiAJIAMgBUkiABshAiAEIAYgBCAHGyAAGyEEIAEiAA0ACwsgAkUNACAFQfCWwAAoAgAiAE0gBCAAIAVrT3ENACACKAIYIQcCQAJAIAIgAigCDCIARgRAIAJBFEEQIAIoAhQiABtqKAIAIgENAUEAIQAMAgsgAigCCCIBIAA2AgwgACABNgIIDAELIAJBFGogAkEQaiAAGyEDA0AgAyEGIAEiAEEUaiAAQRBqIAAoAhQiARshAyAAQRRBECABG2ooAgAiAQ0ACyAGQQA2AgALIAdFDQIgAiACKAIcQQJ0QdCTwABqIgEoAgBHBEAgB0EQQRQgBygCECACRhtqIAA2AgAgAEUNAwwCCyABIAA2AgAgAA0BQeyWwABB7JbAACgCAEF+IAIoAhx3cTYCAAwCCwJAAkACQAJAAkAgBUHwlsAAKAIAIgFLBEAgBUH0lsAAKAIAIgBPBEAgBUGvgARqQYCAfHEiAkEQdkAAIQAgCEEEaiIBQQA2AgggAUEAIAJBgIB8cSAAQX9GIgIbNgIEIAFBACAAQRB0IAIbNgIAQQAgCCgCBCIBRQ0JGiAIKAIMIQZBgJfAACAIKAIIIgRBgJfAACgCAGoiADYCAEGEl8AAQYSXwAAoAgAiAiAAIAAgAkkbNgIAAkACQEH8lsAAKAIAIgIEQEHQlMAAIQADQCABIAAoAgAiAyAAKAIEIgdqRg0CIAAoAggiAA0ACwwCC0GMl8AAKAIAIgBBACAAIAFNG0UEQEGMl8AAIAE2AgALQZCXwABB/x82AgBB3JTAACAGNgIAQdSUwAAgBDYCAEHQlMAAIAE2AgBB7JTAAEHglMAANgIAQfSUwABB6JTAADYCAEHolMAAQeCUwAA2AgBB/JTAAEHwlMAANgIAQfCUwABB6JTAADYCAEGElcAAQfiUwAA2AgBB+JTAAEHwlMAANgIAQYyVwABBgJXAADYCAEGAlcAAQfiUwAA2AgBBlJXAAEGIlcAANgIAQYiVwABBgJXAADYCAEGclcAAQZCVwAA2AgBBkJXAAEGIlcAANgIAQaSVwABBmJXAADYCAEGYlcAAQZCVwAA2AgBBrJXAAEGglcAANgIAQaCVwABBmJXAADYCAEGolcAAQaCVwAA2AgBBtJXAAEGolcAANgIAQbCVwABBqJXAADYCAEG8lcAAQbCVwAA2AgBBuJXAAEGwlcAANgIAQcSVwABBuJXAADYCAEHAlcAAQbiVwAA2AgBBzJXAAEHAlcAANgIAQciVwABBwJXAADYCAEHUlcAAQciVwAA2AgBB0JXAAEHIlcAANgIAQdyVwABB0JXAADYCAEHYlcAAQdCVwAA2AgBB5JXAAEHYlcAANgIAQeCVwABB2JXAADYCAEHslcAAQeCVwAA2AgBB9JXAAEHolcAANgIAQeiVwABB4JXAADYCAEH8lcAAQfCVwAA2AgBB8JXAAEHolcAANgIAQYSWwABB+JXAADYCAEH4lcAAQfCVwAA2AgBBjJbAAEGAlsAANgIAQYCWwABB+JXAADYCAEGUlsAAQYiWwAA2AgBBiJbAAEGAlsAANgIAQZyWwABBkJbAADYCAEGQlsAAQYiWwAA2AgBBpJbAAEGYlsAANgIAQZiWwABBkJbAADYCAEGslsAAQaCWwAA2AgBBoJbAAEGYlsAANgIAQbSWwABBqJbAADYCAEGolsAAQaCWwAA2AgBBvJbAAEGwlsAANgIAQbCWwABBqJbAADYCAEHElsAAQbiWwAA2AgBBuJbAAEGwlsAANgIAQcyWwABBwJbAADYCAEHAlsAAQbiWwAA2AgBB1JbAAEHIlsAANgIAQciWwABBwJbAADYCAEHclsAAQdCWwAA2AgBB0JbAAEHIlsAANgIAQeSWwABB2JbAADYCAEHYlsAAQdCWwAA2AgBB/JbAACABQQ9qQXhxIgBBCGsiAjYCAEHglsAAQdiWwAA2AgBB9JbAACAEQShrIgMgASAAa2pBCGoiADYCACACIABBAXI2AgQgASADakEoNgIEQYiXwABBgICAATYCAAwICyACIANJIAEgAk1yDQAgACgCDCIDQQFxDQAgA0EBdiAGRg0DC0GMl8AAQYyXwAAoAgAiACABIAAgAUkbNgIAIAEgBGohA0HQlMAAIQACQAJAA0AgAyAAKAIAIgdHBEAgACgCCCIADQEMAgsLIAAoAgwiA0EBcQ0AIANBAXYgBkYNAQtB0JTAACEAA0ACQCACIAAoAgAiA08EQCACIAMgACgCBGoiB0kNAQsgACgCCCEADAELC0H8lsAAIAFBD2pBeHEiAEEIayIDNgIAQfSWwAAgBEEoayIJIAEgAGtqQQhqIgA2AgAgAyAAQQFyNgIEIAEgCWpBKDYCBEGIl8AAQYCAgAE2AgAgAiAHQSBrQXhxQQhrIgAgACACQRBqSRsiA0EbNgIEQdCUwAApAgAhCiADQRBqQdiUwAApAgA3AgAgAyAKNwIIQdyUwAAgBjYCAEHUlMAAIAQ2AgBB0JTAACABNgIAQdiUwAAgA0EIajYCACADQRxqIQADQCAAQQc2AgAgAEEEaiIAIAdJDQALIAIgA0YNByADIAMoAgRBfnE2AgQgAiADIAJrIgBBAXI2AgQgAyAANgIAIABBgAJPBEAgAiAAECIMCAsgAEH4AXFB4JTAAGohAQJ/QeiWwAAoAgAiA0EBIABBA3Z0IgBxRQRAQeiWwAAgACADcjYCACABDAELIAEoAggLIQAgASACNgIIIAAgAjYCDCACIAE2AgwgAiAANgIIDAcLIAAgATYCACAAIAAoAgQgBGo2AgQgAUEPakF4cUEIayICIAVBA3I2AgQgB0EPakF4cUEIayIEIAIgBWoiAGshBSAEQfyWwAAoAgBGDQMgBEH4lsAAKAIARg0EIAQoAgQiAUEDcUEBRgRAIAQgAUF4cSIBEB4gASAFaiEFIAEgBGoiBCgCBCEBCyAEIAFBfnE2AgQgACAFQQFyNgIEIAAgBWogBTYCACAFQYACTwRAIAAgBRAiDAYLIAVB+AFxQeCUwABqIQECf0HolsAAKAIAIgNBASAFQQN2dCIEcUUEQEHolsAAIAMgBHI2AgAgAQwBCyABKAIICyEDIAEgADYCCCADIAA2AgwgACABNgIMIAAgAzYCCAwFC0H0lsAAIAAgBWsiATYCAEH8lsAAQfyWwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIagwIC0H4lsAAKAIAIQACQCABIAVrIgJBD00EQEH4lsAAQQA2AgBB8JbAAEEANgIAIAAgAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBC0HwlsAAIAI2AgBB+JbAACAAIAVqIgM2AgAgAyACQQFyNgIEIAAgAWogAjYCACAAIAVBA3I2AgQLIABBCGoMBwsgACAEIAdqNgIEQfyWwABB/JbAACgCACIAQQ9qQXhxIgFBCGsiAjYCAEH0lsAAQfSWwAAoAgAgBGoiAyAAIAFrakEIaiIBNgIAIAIgAUEBcjYCBCAAIANqQSg2AgRBiJfAAEGAgIABNgIADAMLQfyWwAAgADYCAEH0lsAAQfSWwAAoAgAgBWoiATYCACAAIAFBAXI2AgQMAQtB+JbAACAANgIAQfCWwABB8JbAACgCACAFaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgALIAJBCGoMAwtBAEH0lsAAKAIAIgAgBU0NAhpB9JbAACAAIAVrIgE2AgBB/JbAAEH8lsAAKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGoMAgsgACAHNgIYIAIoAhAiAQRAIAAgATYCECABIAA2AhgLIAIoAhQiAUUNACAAIAE2AhQgASAANgIYCwJAIARBEE8EQCACIAVBA3I2AgQgAiAFaiIAIARBAXI2AgQgACAEaiAENgIAIARBgAJPBEAgACAEECIMAgsgBEH4AXFB4JTAAGohAQJ/QeiWwAAoAgAiA0EBIARBA3Z0IgRxRQRAQeiWwAAgAyAEcjYCACABDAELIAEoAggLIQMgASAANgIIIAMgADYCDCAAIAE2AgwgACADNgIIDAELIAIgBCAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhqCyAIQRBqJAALxgYBCH8CQAJAIAEgAEEDakF8cSICIABrIghJDQAgASAIayIGQQRJDQAgBkEDcSEHQQAhAQJAIAAgAkYiCQ0AAkAgACACayIEQXxLBEBBACECDAELQQAhAgNAIAEgACACaiIDLAAAQb9/SmogA0EBaiwAAEG/f0pqIANBAmosAABBv39KaiADQQNqLAAAQb9/SmohASACQQRqIgINAAsLIAkNACAAIAJqIQMDQCABIAMsAABBv39KaiEBIANBAWohAyAEQQFqIgQNAAsLIAAgCGohAgJAIAdFDQAgAiAGQXxxaiIALAAAQb9/SiEFIAdBAUYNACAFIAAsAAFBv39KaiEFIAdBAkYNACAFIAAsAAJBv39KaiEFCyAGQQJ2IQYgASAFaiEEA0AgAiEAIAZFDQJBwAEgBiAGQcABTxsiBUEDcSEHIAVBAnQhCEEAIQMgBkEETwRAIAAgCEHwB3FqIQkgACEBA0AgASgCACICQX9zQQd2IAJBBnZyQYGChAhxIANqIAEoAgQiAkF/c0EHdiACQQZ2ckGBgoQIcWogASgCCCICQX9zQQd2IAJBBnZyQYGChAhxaiABKAIMIgJBf3NBB3YgAkEGdnJBgYKECHFqIQMgAUEQaiIBIAlHDQALCyAGIAVrIQYgACAIaiECIANBCHZB/4H8B3EgA0H/gfwHcWpBgYAEbEEQdiAEaiEEIAdFDQALAn8gACAFQfwBcUECdGoiACgCACIBQX9zQQd2IAFBBnZyQYGChAhxIgEgB0EBRg0AGiABIAAoAgQiAUF/c0EHdiABQQZ2ckGBgoQIcWoiASAHQQJGDQAaIAAoAggiAEF/c0EHdiAAQQZ2ckGBgoQIcSABagsiAUEIdkH/gRxxIAFB/4H8B3FqQYGABGxBEHYgBGoPCyABRQRAQQAPCyABQQNxIQICQCABQQRJBEAMAQsgAUF8cSEFA0AgBCAAIANqIgEsAABBv39KaiABQQFqLAAAQb9/SmogAUECaiwAAEG/f0pqIAFBA2osAABBv39KaiEEIAUgA0EEaiIDRw0ACwsgAkUNACAAIANqIQEDQCAEIAEsAABBv39KaiEEIAFBAWohASACQQFrIgINAAsLIAQL3QUBBX8gACgCCCIDIAFJBEAgASADIgJrIgQgACgCACACa0sEQCAAIAIgBEEEQQQQJiAAKAIIIQILIAAoAgQiBiACQQJ0aiEFIARBAk8EQCAFIANBf3MgAWpBAnQQKhogASACakECdCADQQJ0ayAGakEEayEFIAIgBGpBAWshAgsgBUEANgIAIAAgAkEBajYCCAsgACgCFCIDIAFJBEAgASADIgJrIgQgACgCDCACa0sEQCAAQQxqIAIgBEEEQQQQJiAAKAIUIQILIAAoAhAiBiACQQJ0aiEFIARBAk8EQCAFIANBf3MgAWpBAnQQKhogASACakECdCADQQJ0ayAGakEEayEFIAIgBGpBAWshAgsgBUEANgIAIAAgAkEBajYCFAsgACgCOCIDIAFJBEAgASADIgJrIgQgACgCMCACa0sEQCAAQTBqIAIgBEEEQQQQJiAAKAI4IQILIAAoAjQiBiACQQJ0aiEFIARBAk8EQCAFIANBf3MgAWpBAnQQKhogASACakECdCADQQJ0ayAGakEEayEFIAIgBGpBAWshAgsgBUEANgIAIAAgAkEBajYCOAsgACgCICIDQf//A00EQCADIQFBgIAEIANrIgIgACgCGCADa0sEQCAAQRhqIAMgAkEEQQQQJiAAKAIgIQELIAAoAhwiBSABQQJ0IgRqIQIgA0H//wNHBEAgAkH8/w8gA0ECdCICaxAqGiAEIAJrIAVqQfz/D2ohAiABIANrQf//A2ohAQsgAkEANgIAIAAgAUEBajYCIAsgACgCLCIDQf//A00EQCADIQFBgIAEIANrIgIgACgCJCADa0sEQCAAQSRqIAMgAkEEQQQQJiAAKAIsIQELIAAoAigiBSABQQJ0IgRqIQIgA0H//wNHBEAgAkH8/w8gA0ECdCICaxAqGiAEIAJrIAVqQfz/D2ohAiABIANrQf//A2ohAQsgAkEANgIAIAAgAUEBajYCLAsLqQUBB38CQCAAKAIIQQFxRSIEIAAoAgAiCUVxRQRAAkAgBA0AIAEgAmohBwJAIAAoAgwiBkUEQCABIQQMAQsgASEEA0AgBCIDIAdGDQICfyADQQFqIAMsAAAiCEEATg0AGiADQQJqIAhBYEkNABogA0EDaiAIQXBJDQAaIANBBGoLIgQgA2sgBWohBSAGQQFrIgYNAAsLIAQgB0YNACAELAAAGiAFIAICfwJAIAVFDQAgAiAFSwRAIAEgBWosAABBv39KDQFBAAwCCyACIAVGDQBBAAwBCyABCyIDGyECIAMgASADGyEBCyAJRQ0BIAAoAgQhBwJAIAJBEE8EQCABIAIQEiEDDAELIAJFBEBBACEDDAELIAJBA3EhBgJAIAJBBEkEQEEAIQNBACEFDAELIAJBDHEhCEEAIQNBACEFA0AgAyABIAVqIgQsAABBv39KaiAEQQFqLAAAQb9/SmogBEECaiwAAEG/f0pqIARBA2osAABBv39KaiEDIAggBUEEaiIFRw0ACwsgBkUNACABIAVqIQQDQCADIAQsAABBv39KaiEDIARBAWohBCAGQQFrIgYNAAsLAkAgAyAHSQRAIAcgA2shBEEAIQMCQAJAAkAgAC0AIEEBaw4CAAECCyAEIQNBACEEDAELIARBAXYhAyAEQQFqQQF2IQQLIANBAWohAyAAKAIQIQYgACgCGCEFIAAoAhQhAANAIANBAWsiA0UNAiAAIAYgBSgCEBEAAEUNAAtBAQ8LDAILIAAgASACIAUoAgwRAgAEQEEBDwtBACEDA0AgAyAERgRAQQAPCyADQQFqIQMgACAGIAUoAhARAABFDQALIANBAWsgBEkPCyAAKAIUIAEgAiAAKAIYKAIMEQIADwsgACgCFCABIAIgACgCGCgCDBECAAu/BQEIf0ErQYCAxAAgACgCHCIIQQFxIgYbIQwgBCAGaiEGAkAgCEEEcUUEQEEAIQEMAQsCQCACQRBPBEAgASACEBIhBQwBCyACRQRADAELIAJBA3EhCQJAIAJBBEkEQAwBCyACQQxxIQoDQCAFIAEgB2oiCywAAEG/f0pqIAtBAWosAABBv39KaiALQQJqLAAAQb9/SmogC0EDaiwAAEG/f0pqIQUgCiAHQQRqIgdHDQALCyAJRQ0AIAEgB2ohBwNAIAUgBywAAEG/f0pqIQUgB0EBaiEHIAlBAWsiCQ0ACwsgBSAGaiEGCyAAKAIARQRAIAAoAhQiBiAAKAIYIgAgDCABIAIQPwRAQQEPCyAGIAMgBCAAKAIMEQIADwsCQAJAAkAgBiAAKAIEIgdPBEAgACgCFCIGIAAoAhgiACAMIAEgAhA/RQ0BQQEPCyAIQQhxRQ0BIAAoAhAhCCAAQTA2AhAgAC0AICEKQQEhBSAAQQE6ACAgACgCFCIJIAAoAhgiCyAMIAEgAhA/DQIgByAGa0EBaiEFAkADQCAFQQFrIgVFDQEgCUEwIAsoAhARAABFDQALQQEPCyAJIAMgBCALKAIMEQIABEBBAQ8LIAAgCjoAICAAIAg2AhBBAA8LIAYgAyAEIAAoAgwRAgAhBQwBCyAHIAZrIQYCQAJAAkAgAC0AICIFQQFrDgMAAQACCyAGIQVBACEGDAELIAZBAXYhBSAGQQFqQQF2IQYLIAVBAWohBSAAKAIQIQogACgCGCEIIAAoAhQhAAJAA0AgBUEBayIFRQ0BIAAgCiAIKAIQEQAARQ0AC0EBDwtBASEFIAAgCCAMIAEgAhA/DQAgACADIAQgCCgCDBECAA0AQQAhBQNAIAUgBkYEQEEADwsgBUEBaiEFIAAgCiAIKAIQEQAARQ0ACyAFQQFrIAZJDwsgBQv+BQEFfyAAQQhrIgEgAEEEaygCACIDQXhxIgBqIQICQAJAIANBAXENACADQQJxRQ0BIAEoAgAiAyAAaiEAIAEgA2siAUH4lsAAKAIARgRAIAIoAgRBA3FBA0cNAUHwlsAAIAA2AgAgAiACKAIEQX5xNgIEIAEgAEEBcjYCBCACIAA2AgAPCyABIAMQHgsCQAJAAkACQAJAIAIoAgQiA0ECcUUEQCACQfyWwAAoAgBGDQIgAkH4lsAAKAIARg0DIAIgA0F4cSICEB4gASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB+JbAACgCAEcNAUHwlsAAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQIkEAIQFBkJfAAEGQl8AAKAIAQQFrIgA2AgAgAA0EQdiUwAAoAgAiAARAA0AgAUEBaiEBIAAoAggiAA0ACwtBkJfAAEH/HyABIAFB/x9NGzYCAA8LQfyWwAAgATYCAEH0lsAAQfSWwAAoAgAgAGoiADYCACABIABBAXI2AgRB+JbAACgCACABRgRAQfCWwABBADYCAEH4lsAAQQA2AgALIABBiJfAACgCACIDTQ0DQfyWwAAoAgAiAkUNA0EAIQBB9JbAACgCACIEQSlJDQJB0JTAACEBA0AgAiABKAIAIgVPBEAgAiAFIAEoAgRqSQ0ECyABKAIIIQEMAAsAC0H4lsAAIAE2AgBB8JbAAEHwlsAAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAA8LIABB+AFxQeCUwABqIQICf0HolsAAKAIAIgNBASAAQQN2dCIAcUUEQEHolsAAIAAgA3I2AgAgAgwBCyACKAIICyEAIAIgATYCCCAAIAE2AgwgASACNgIMIAEgADYCCA8LQdiUwAAoAgAiAQRAA0AgAEEBaiEAIAEoAggiAQ0ACwtBkJfAAEH/HyAAIABB/x9NGzYCACADIARPDQBBiJfAAEF/NgIACwvpBAEFfwJ/AkAgAkECTwRAIAEoAgQiBEH//wFxRQRAIARBEHQMAwsgBEH/B3EhBSAEQYCAAnEhAyAEQYD4AXEiBkGA+AFGBEAgA0EQdCEDIANBgICA/AdyIAVFDQMaIAMgBUENdHJBgICA/gdyDAMLIANBEHQhAyAGRQ0BIAZBDXRBgICA/ABxIAVBDXRyQYCAgMADaiADcgwCC0EBQQFB9IHAABA1AAsgBSAFZ0EQayIFQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAVBF3RrcgshBQJ/IARBgIB8cSAEQRB2IgNB//8BcUUNABogA0H/B3EhBCADQYCAAnEhBiADQYD4AXEiB0GA+AFGBEAgBkEQdCEGIAZBgICA/AdyIARFDQEaIAYgA0ENdHJBgICA/gdyDAELIAZBEHQhAyAHQQ10QYCAgPwAcSAEQQ10ckGAgIDAA2ogA3IgBw0AGiAEIARnQRBrIgRB//8DcUEIanRB////A3EgA0GAgIDYA3IgBEEXdGtyCyEEIAACfwJAIAJBAkcEQCABKAIIIgJB//8BcUUEQCACQRB0DAMLIAJB/wdxIQEgAkGAgAJxIQMgAkGA+AFxIgJBgPgBRgRAIANBEHQhAiACQYCAgPwHciABRQ0DGiACIAFBDXRyQYCAgP4HcgwDCyADQRB0IQMgAkUNASACQQ10QYCAgPwAcSABQQ10ckGAgIDAA2ogA3IMAgtBAkECQYSCwAAQNQALIAEgAWdBEGsiAUH//wNxQQhqdEH///8DcSADQYCAgNgDciABQRd0a3ILNgIIIAAgBDYCBCAAIAU2AgAL6wQBCn8jAEEwayIDJAAgA0EDOgAsIANBIDYCHCADQQA2AiggAyABNgIkIAMgADYCICADQQA2AhQgA0EANgIMAn8CQAJAAkAgAigCECIKRQRAIAIoAgwiAEUNASACKAIIIgEgAEEDdGohBCAAQQFrQf////8BcUEBaiEHIAIoAgAhAANAIABBBGooAgAiBQRAIAMoAiAgACgCACAFIAMoAiQoAgwRAgANBAsgASgCACADQQxqIAEoAgQRAAANAyAAQQhqIQAgAUEIaiIBIARHDQALDAELIAIoAhQiAEUNACAAQQV0IQsgAEEBa0H///8/cUEBaiEHIAIoAgghBSACKAIAIQADQCAAQQRqKAIAIgEEQCADKAIgIAAoAgAgASADKAIkKAIMEQIADQMLIAMgCCAKaiIBQRBqKAIANgIcIAMgAUEcai0AADoALCADIAFBGGooAgA2AiggAUEMaigCACEEQQAhCUEAIQYCQAJAAkAgAUEIaigCAEEBaw4CAAIBCyAEQQN0IAVqIgwoAgANASAMKAIEIQQLQQEhBgsgAyAENgIQIAMgBjYCDCABQQRqKAIAIQQCQAJAAkAgASgCAEEBaw4CAAIBCyAEQQN0IAVqIgYoAgANASAGKAIEIQQLQQEhCQsgAyAENgIYIAMgCTYCFCAFIAFBFGooAgBBA3RqIgEoAgAgA0EMaiABKAIEEQAADQIgAEEIaiEAIAsgCEEgaiIIRw0ACwsgByACKAIETw0BIAMoAiAgAigCACAHQQN0aiIAKAIAIAAoAgQgAygCJCgCDBECAEUNAQtBAQwBC0EACyADQTBqJAALsgQCAn0EfyMAQRBrIQQgALwiBUEfdiEGAkACfSAAAn8CQAJAAkACQCAFQf////8HcSIDQdDYupUETwRAIANBgICA/AdLBEAgAA8LIAVBAEgiBUUgA0GX5MWVBEtxDQIgBUUNASAEQwAAgIAgAJU4AgggBCoCCBogA0G047+WBE0NAQwHCyADQZjkxfUDTQRAIANBgICAyANNDQNBACEDIAAMBgsgA0GSq5T8A00NAwsgAEM7qrg/lCAGQQJ0QYiSwABqKgIAkiIBQwAAAM9gIQRB/////wcCfyABi0MAAABPXQRAIAGoDAELQYCAgIB4C0GAgICAeCAEGyABQ////05eG0EAIAEgAVsbDAMLIABDAAAAf5QPCyAEIABDAAAAf5I4AgwgBCoCDBogAEMAAIA/kg8LIAZFIAZrCyIDsiIBQwByMb+UkiIAIAFDjr6/NZQiApMLIQEgACABIAEgASABlCIAIABDFVI1u5RDj6oqPpKUkyIAlEMAAABAIACTlSACk5JDAACAP5IhASADRQ0AAkACQAJAIANB/wBMBEAgA0GCf04NAyABQwAAgAyUIQEgA0Gbfk0NASADQeYAaiEDDAMLIAFDAAAAf5QhASADQf4BSw0BIANB/wBrIQMMAgsgAUMAAIAMlCEBQbZ9IAMgA0G2fU0bQcwBaiEDDAELIAFDAAAAf5QhAUH9AiADIANB/QJPG0H+AWshAwsgASADQRd0QYCAgPwDar6UIQELIAEL+QMBAn8gACABaiECAkACQCAAKAIEIgNBAXENACADQQJxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEH4lsAAKAIARgRAIAIoAgRBA3FBA0cNAUHwlsAAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAMAgsgACADEB4LAkACQAJAIAIoAgQiA0ECcUUEQCACQfyWwAAoAgBGDQIgAkH4lsAAKAIARg0DIAIgA0F4cSICEB4gACABIAJqIgFBAXI2AgQgACABaiABNgIAIABB+JbAACgCAEcNAUHwlsAAIAE2AgAPCyACIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUGAAk8EQCAAIAEQIg8LIAFB+AFxQeCUwABqIQICf0HolsAAKAIAIgNBASABQQN2dCIBcUUEQEHolsAAIAEgA3I2AgAgAgwBCyACKAIICyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCA8LQfyWwAAgADYCAEH0lsAAQfSWwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEH4lsAAKAIARw0BQfCWwABBADYCAEH4lsAAQQA2AgAPC0H4lsAAIAA2AgBB8JbAAEHwlsAAKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsLggMBCX8jAEEgayIEJAAQIyIAKAIQIQUgACgCDCEIIABCADcCDCAAKAIEIQYgACgCCCEDIABCBDcCBCAAKAIAIQIgAEEANgIAAkAgAyAIRgRAAkAgAiADRgRA0G9BgAEgAiACQYABTRsiB/wPASIBQX9GDQMCQCAFRQRAIAEhBQwBCyACIAVqIAFHDQQLIAIgB2oiByACSSAHQf////8DS3INAyAHQQJ0IgFB/P///wdLDQMgBCACBH8gBCAGNgIUIAQgAkECdDYCHEEEBUEACzYCGCAEQQhqQQQgASAEQRRqEDAgBCgCCEEBRg0DIAQoAgwhBiACIQEgByECDAELIAIgAyIBTQ0CCyAGIAFBAnRqIANBAWo2AgAgAUEBaiEDCyADIAhNDQAgBiAIQQJ0aigCACEBIAAgBTYCECAAIAE2AgwgACADNgIIIAAoAgQhAyAAIAY2AgQgACgCACEBIAAgAjYCACABBEAgAyABQQJ0EGULIARBIGokACAFIAhqDwsAC+cCAQV/AkBBzf97QRAgACAAQRBNGyIAayABTQ0AIABBECABQQtqQXhxIAFBC0kbIgRqQQxqEBEiAkUNACACQQhrIQECQCAAQQFrIgMgAnFFBEAgASEADAELIAJBBGsiBSgCACIGQXhxIAIgA2pBACAAa3FBCGsiAiAAQQAgAiABa0EQTRtqIgAgAWsiAmshAyAGQQNxBEAgACADIAAoAgRBAXFyQQJyNgIEIAAgA2oiAyADKAIEQQFyNgIEIAUgAiAFKAIAQQFxckECcjYCACABIAJqIgMgAygCBEEBcjYCBCABIAIQGgwBCyABKAIAIQEgACADNgIEIAAgASACajYCAAsCQCAAKAIEIgFBA3FFDQAgAUF4cSICIARBEGpNDQAgACAEIAFBAXFyQQJyNgIEIAAgBGoiASACIARrIgRBA3I2AgQgACACaiICIAIoAgRBAXI2AgQgASAEEBoLIABBCGohAwsgAwv7AgEHfyMAQRBrIgQkAAJAAkACQAJAAkAgASgCBCICRQ0AIAEoAgAhByACQQNxIQUCQCACQQRJBEBBACECDAELIAdBHGohAyACQXxxIQhBACECA0AgAygCACADQQhrKAIAIANBEGsoAgAgA0EYaygCACACampqaiECIANBIGohAyAIIAZBBGoiBkcNAAsLIAUEQCAGQQN0IAdqQQRqIQMDQCADKAIAIAJqIQIgA0EIaiEDIAVBAWsiBQ0ACwsgASgCDARAIAJBAEgNASAHKAIERSACQRBJcQ0BIAJBAXQhAgtBACEFIAJBAEgNAyACDQELQQEhA0EAIQIMAQtBsZPAAC0AABpBASEFIAJBARBdIgNFDQELIARBADYCCCAEIAM2AgQgBCACNgIAIARBwIvAACABEBhFDQFBqIzAAEHWACAEQQ9qQZiMwABBkI3AABAzAAsgBSACEFIACyAAIAQpAgA3AgAgAEEIaiAEQQhqKAIANgIAIARBEGokAAvxAgEEfyAAKAIMIQICQAJAIAFBgAJPBEAgACgCGCEDAkACQCAAIAJGBEAgAEEUQRAgACgCFCICG2ooAgAiAQ0BQQAhAgwCCyAAKAIIIgEgAjYCDCACIAE2AggMAQsgAEEUaiAAQRBqIAIbIQQDQCAEIQUgASICQRRqIAJBEGogAigCFCIBGyEEIAJBFEEQIAEbaigCACIBDQALIAVBADYCAAsgA0UNAiAAIAAoAhxBAnRB0JPAAGoiASgCAEcEQCADQRBBFCADKAIQIABGG2ogAjYCACACRQ0DDAILIAEgAjYCACACDQFB7JbAAEHslsAAKAIAQX4gACgCHHdxNgIADAILIAAoAggiACACRwRAIAAgAjYCDCACIAA2AggPC0HolsAAQeiWwAAoAgBBfiABQQN2d3E2AgAPCyACIAM2AhggACgCECIBBEAgAiABNgIQIAEgAjYCGAsgACgCFCIARQ0AIAIgADYCFCAAIAI2AhgLC7YCAQd/AkAgAkEQSQRAIAAhAwwBCyAAQQAgAGtBA3EiBGohBSAEBEAgACEDIAEhBgNAIAMgBi0AADoAACAGQQFqIQYgA0EBaiIDIAVJDQALCyAFIAIgBGsiCEF8cSIHaiEDAkAgASAEaiIEQQNxBEAgB0EATA0BIARBA3QiAkEYcSEJIARBfHEiBkEEaiEBQQAgAmtBGHEhAiAGKAIAIQYDQCAFIAYgCXYgASgCACIGIAJ0cjYCACABQQRqIQEgBUEEaiIFIANJDQALDAELIAdBAEwNACAEIQEDQCAFIAEoAgA2AgAgAUEEaiEBIAVBBGoiBSADSQ0ACwsgCEEDcSECIAQgB2ohAQsgAgRAIAIgA2ohAgNAIAMgAS0AADoAACABQQFqIQEgA0EBaiIDIAJJDQALCyAAC78CAQN/IwBBEGsiAiQAAkAgAUGAAU8EQCACQQA2AgwCfyABQYAQTwRAIAFBgIAETwRAIAJBDGpBA3IhBCACIAFBEnZB8AFyOgAMIAIgAUEGdkE/cUGAAXI6AA4gAiABQQx2QT9xQYABcjoADUEEDAILIAJBDGpBAnIhBCACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwwBCyACQQxqQQFyIQQgAiABQQZ2QcABcjoADEECCyEDIAQgAUE/cUGAAXI6AAAgAyAAKAIAIAAoAggiAWtLBEAgACABIAMQKSAAKAIIIQELIAAoAgQgAWogAkEMaiADEB8aIAAgASADajYCCAwBCyAAKAIIIgMgACgCAEYEQCAAECgLIAAgA0EBajYCCCAAKAIEIANqIAE6AAALIAJBEGokAEEAC70CAQJ/IwBBEGsiAiQAAkAgAUGAAU8EQCACQQA2AgwCfyABQYAQTwRAIAFBgIAETwRAIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAwCCyACIAFBP3FBgAFyOgAOIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAELIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECCyEBIAEgACgCACAAKAIIIgNrSwRAIAAgAyABECUgACgCCCEDCyAAKAIEIANqIAJBDGogARAfGiAAIAEgA2o2AggMAQsgACgCCCIDIAAoAgBGBEAgABAoCyAAIANBAWo2AgggACgCBCADaiABOgAACyACQRBqJABBAAvEAgEEfyAAQgA3AhAgAAJ/QQAgAUGAAkkNABpBHyABQf///wdLDQAaIAFBBiABQQh2ZyIDa3ZBAXEgA0EBdGtBPmoLIgI2AhwgAkECdEHQk8AAaiEEQQEgAnQiA0HslsAAKAIAcUUEQCAEIAA2AgAgACAENgIYIAAgADYCDCAAIAA2AghB7JbAAEHslsAAKAIAIANyNgIADwsCQAJAIAEgBCgCACIDKAIEQXhxRgRAIAMhAgwBCyABQRkgAkEBdmtBACACQR9HG3QhBQNAIAMgBUEddkEEcWpBEGoiBCgCACICRQ0CIAVBAXQhBSACIQMgAigCBEF4cSABRw0ACwsgAigCCCIBIAA2AgwgAiAANgIIIABBADYCGCAAIAI2AgwgACABNgIIDwsgBCAANgIAIAAgAzYCGCAAIAA2AgwgACAANgIIC/MCAQR/IwBBMGsiACQAAkACQEGQksAAKAIARQRAQaiSwAAoAgAhAUGoksAAQQA2AgAgAUUNASAAQRhqIAERBQAgAEEQaiICIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghAUGQksAAKAIAIgMNAgJAIANFDQBBlJLAACgCACICRQ0AQZiSwAAoAgAgAkECdBBlC0GUksAAIAE2AgBBkJLAAEEBNgIAQZiSwAAgACkDCDcCAEGgksAAIABBEGopAwA3AgALIABBMGokAEGUksAADwsgAEEANgIoIABBATYCHCAAQaCHwAA2AhggAEIENwIgIABBGGpBiIjAABBDAAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnQQZQsgAEEANgIoIABBATYCHCAAQaiIwAA2AhggAEIENwIgIAFBsIjAABBDAAuoAgIDfwF+IwBBQGoiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBJGoiBEEANgIAIAJCgICAgBA3AhwgAkEwaiADKAIAIgNBCGopAgA3AwAgAkE4aiADQRBqKQIANwMAIAIgAykCADcDKCACQRxqQcCIwAAgAkEoahAYGiACQRhqIAQoAgAiAzYCACACIAIpAhwiBTcDECABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQQhqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8AALQAAGiACIAU3AwBBDEEEEF0iAUUEQEEEQQwQbQALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEHgisAANgIEIAAgATYCACACQUBrJAAL0gECBH8BfiMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIEQQF0IgEgAiABIAJLGyICIAJBCEkbIgKtIgdCIIhQRQRAQQBBABBSAAsCQCAHpyIFQf////8HTQRAIAMgBAR/IAMgBDYCHCADIAAoAgQ2AhRBAQVBAAs2AhggA0EIakEBIAUgA0EUahAwIAMoAghBAUcNASADKAIMIQYgAygCECEBCyAGIAEQUgALIAMoAgwhASAAIAI2AgAgACABNgIEIANBIGokAAvrAQIEfwF+IwBBIGsiBSQAIAEgASACaiICSwRAQQBBABBSAAtBACEBIAMgBGpBAWtBACADa3GtQQQgACgCACIHQQF0IgYgAiACIAZJGyICIAJBBE0bIgKtfiIJQiCIUEUEQEEAQQAQUgALAkAgCaciBkGAgICAeCADa00EfyAFIAcEfyAFIAQgB2w2AhwgBSAAKAIENgIUIAMFQQALNgIYIAVBCGogAyAGIAVBFGoQMCAFKAIIQQFHDQEgBSgCECEIIAUoAgwFIAELIAgQUgALIAUoAgwhASAAIAI2AgAgACABNgIEIAVBIGokAAvTAQEFfyMAQSBrIgEkACAAKAIAIgJBf0YEQEEAQQAQUgALIAJBAXQiAyACQQFqIgUgAyAFSxsiA0H/////A0sEQEEAQQAQUgALAkBBBCADIANBBE0bIgNBAnQiBUH8////B00EfyABIAIEfyABIAJBAnQ2AhwgASAAKAIENgIUQQQFQQALNgIYIAFBCGpBBCAFIAFBFGoQMCABKAIIQQFHDQEgASgCECEEIAEoAgwFIAQLIAQQUgALIAEoAgwhAiAAIAM2AgAgACACNgIEIAFBIGokAAuyAQEEfyMAQSBrIgEkACAAKAIAIgJBf0YEQEEAQQAQUgALQQggAkEBdCIDIAJBAWoiBCADIARLGyIDIANBCE0bIgNBAEgEQEEAQQAQUgALIAEgAgR/IAEgAjYCHCABIAAoAgQ2AhRBAQVBAAs2AhggAUEIakEBIAMgAUEUahAwIAEoAghBAUYEQCABKAIMIAEoAhAQUgALIAEoAgwhAiAAIAM2AgAgACACNgIEIAFBIGokAAuyAQECfyMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIBQQF0IgQgAiACIARJGyICIAJBCE0bIgRBAEgEQEEAQQAQUgALIAMgAQR/IAMgATYCHCADIAAoAgQ2AhRBAQVBAAs2AhggA0EIakEBIAQgA0EUahAwIAMoAghBAUYEQCADKAIMIAMoAhAQUgALIAMoAgwhASAAIAQ2AgAgACABNgIEIANBIGokAAudAQEDfwJAIAFBEEkEQCAAIQIMAQsgAEEAIABrQQNxIgRqIQMgBARAIAAhAgNAIAJBADoAACACQQFqIgIgA0kNAAsLIAMgASAEayIBQXxxIgRqIQIgBEEASgRAA0AgA0EANgIAIANBBGoiAyACSQ0ACwsgAUEDcSEBCyABBEAgASACaiEBA0AgAkEAOgAAIAJBAWoiAiABSQ0ACwsgAAvBAQIDfwF+IwBBMGsiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBFGoiBEEANgIAIAJCgICAgBA3AgwgAkEgaiADKAIAIgNBCGopAgA3AwAgAkEoaiADQRBqKQIANwMAIAIgAykCADcDGCACQQxqQcCIwAAgAkEYahAYGiACQQhqIAQoAgAiAzYCACACIAIpAgwiBTcDACABQQhqIAM2AgAgASAFNwIACyAAQeCKwAA2AgQgACABNgIAIAJBMGokAAuWAgECfyMAQSBrIgUkAEHMk8AAQcyTwAAoAgAiBkEBajYCAAJAAn9BACAGQQBIDQAaQQFBmJfAAC0AAA0AGkGYl8AAQQE6AABBlJfAAEGUl8AAKAIAQQFqNgIAQQILQf8BcSIGQQJHBEAgBkEBcUUNASAFQQhqIAAgASgCGBEBAAALQcCTwAAoAgAiBkEASA0AQcCTwAAgBkEBajYCAEHAk8AAQcSTwAAoAgAEfyAFIAAgASgCFBEBACAFIAQ6AB0gBSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBxJPAACgCACAFQRBqQciTwAAoAgAoAhQRAQBBwJPAACgCAEEBawUgBgs2AgBBmJfAAEEAOgAAIANFDQAACwALrwEBBn8CQAJAIABBhAFJDQAgANBvJgEQIyIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnQQZQsPCwALowEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAhBlDAELIAMgAkEEIAFBAnQiAhBUIgVFDQILIAAgATYCBCAAIAU2AgAgBkEQaiQADwtBxIbAAEEyEGgAC0EEIAIQUgALrAEBA38gASgCDCECAkACQAJAAkACQAJAIAEoAgQOAgABAgsgAg0BQQEhA0EAIQFBASECDAMLIAJFDQELIAAgARAdDwsgASgCACICKAIEIgFBAEgNASACKAIAIQMgAUUEQEEBIQJBACEBDAELQbGTwAAtAAAaQQEhBCABQQEQXSICRQ0BCyACIAMgARAfIQIgACABNgIIIAAgAjYCBCAAIAE2AgAPCyAEIAEQUgALiQEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhBUDAILCyABIAJFDQAaQbGTwAAtAAAaIAIgARBdCyIDBEAgACACNgIIIAAgAzYCBCAAQQA2AgAPCyAAIAI2AgggACABNgIEDAELIABBADYCBAsgAEEBNgIAC5cBAgR/AW8jAEEgayIDJAAgACgCACIGEHAhACADIAI2AgQgAyAANgIAIAAgAkYEQBBbIgQQUyIFJQEgASACEAQhBxAbIgAgByYBIARBhAFPBEAgBBAtCyAFQYQBTwRAIAUQLQsgBiAAQQAQZCAAQYQBTwRAIAAQLQsgA0EgaiQADwsgA0EANgIIIAMgA0EEaiADQQhqEEAAC3kBAX8jAEEgayICJAACfyAAKAIAQYCAgIB4RwRAIAEgACgCBCAAKAIIEFYMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahAYCyACQSBqJAALewEBfyMAQUBqIgUkACAFIAE2AgwgBSAANgIIIAUgAzYCFCAFIAI2AhAgBUECNgIcIAVBoI/AADYCGCAFQgI3AiQgBSAFQRBqrUKAgICAsAWENwM4IAUgBUEIaq1CgICAgMAFhDcDMCAFIAVBMGo2AiAgBUEYaiAEEEMAC24BAX8jAEEwayIBJAAgASAANgIAIAFBgAE2AgQgAUECNgIMIAFB2JHAADYCCCABQgI3AhQgASABQQRqrUKAgICA4ACENwMoIAEgAa1CgICAgOAAhDcDICABIAFBIGo2AhAgAUEIakHIj8AAEEMAC2kCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQfyNwAA2AgggA0ICNwIUIANCgICAgOAAIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhBDAAtpAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0H4kcAANgIIIANCAjcCFCADQoCAgIDgACIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQQwALZgAjAEEwayIAJABBsJPAAC0AAARAIABBAjYCDCAAQbCKwAA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIDgAIQ3AyAgACAAQSBqNgIQIABBCGpB0IrAABBDAAsgAEEwaiQAC5QBAgN/AW8jAEEgayIDJAAgAyAAKAIAEHAiBDYCACADIAI2AgQgAiAERwRAIANBADYCCCADIANBBGogA0EIahBAAAsQWyIEEFMiBSUBEAUhBhAbIgIgBiYBIAVBhAFPBEAgBRAtCyACIAAoAgAgAUECdhBkIAJBhAFPBEAgAhAtCyAEQYQBTwRAIAQQLQsgA0EgaiQAC08BAX8jAEEwayIAJAAgAEEBNgIMIABBwI3AADYCCCAAQgE3AhQgACAAQS9qrUKAgICAoAWENwMgIAAgAEEgajYCECAAQQhqQcSBwAAQQwALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhAlIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALTQECf0Gxk8AALQAAGiABKAIEIQIgASgCACEDQQhBBBBdIgFFBEBBBEEIEG0ACyABIAI2AgQgASADNgIAIABB8IrAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhApIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALQQEBfyMAQSBrIgIkACACQQA2AhAgAkEBNgIEIAJCBDcCCCACQS42AhwgAiAANgIYIAIgAkEYajYCACACIAEQQwALswIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARBnDwtBACEAIwBBgAFrIgQkACACKAIAIQIDQCAAIARqQf8AaiACQQ9xIgNBMHIgA0E3aiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAhA0AAsgAUHYj8AAQQIgACAEakGAAWpBACAAaxAVIARBgAFqJAAPC0EAIQAjAEGAAWsiBCQAIAIoAgAhAgNAIAAgBGpB/wBqIAJBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAhA0AAsgAUHYj8AAQQIgACAEakGAAWpBACAAaxAVIARBgAFqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAgAL0AIBAX8jAEEQayIDJAAgAyABNgIMIAMgADYCCCMAQfAAayIAJAAgAEG0hsAANgIMIAAgA0EIajYCCCAAQbSGwAA2AhQgACADQQxqNgIQIABBjI7AADYCGCAAQQI2AhwCQCACKAIARQRAIABBAzYCXCAAQciOwAA2AlggAEIDNwJkIAAgAEEQaq1CgICAgLAFhDcDSCAAIABBCGqtQoCAgICwBYQ3A0AMAQsgAEEwaiACQRBqKQIANwMAIABBKGogAkEIaikCADcDACAAIAIpAgA3AyAgAEEENgJcIABB/I7AADYCWCAAQgQ3AmQgACAAQRBqrUKAgICAsAWENwNQIAAgAEEIaq1CgICAgLAFhDcDSCAAIABBIGqtQoCAgIDQBYQ3A0ALIAAgAEEYaq1CgICAgMAFhDcDOCAAIABBOGo2AmAgAEHYAGpBpIbAABBDAAuyAQECfyMAQRBrIgAkACABKAIUQYCKwABBCyABKAIYKAIMEQIAIQMgAEEIaiICQQA6AAUgAiADOgAEIAIgATYCACACIgEtAAQhAiABLQAFBEAgAQJ/QQEgAkEBcQ0AGiABKAIAIgEtABxBBHFFBEAgASgCFEGxj8AAQQIgASgCGCgCDBECAAwBCyABKAIUQbCPwABBASABKAIYKAIMEQIACyICOgAECyACQQFxIABBEGokAAvrEgIYfxB9EBsiDiAJJgEjAEGAAWsiDSQAIA0gDjYCLCANIAg2AiggDSAHOAIkIA0gBjgCICANIAU4AhwgDSAEOAIYIA0gAzgCFCANIAI4AhAgDSABOAIMIA0gADgCCCANIApBAEc6ADMgDSALOAI0IA0gDDgCOCANQQA2AkQgDUKAgICAwAA3AjwgDSANQThqNgJ8IA0gDUE0ajYCeCANIA1BJGo2AnQgDSANQSBqNgJwIA0gDUEcajYCbCANIA1BGGo2AmggDSANQRRqNgJkIA0gDUEQajYCYCANIA1BDGo2AlwgDSANQQhqNgJYIA0gDUE8ajYCVCANIA1BM2o2AlAgDSANQSxqNgJMIA0gDUEoajYCSCANQcgAaiIYIQgjAEEgayIQJAACQEEAQYiAwAAoAgARAwAiEwRAIBMoAgBFBEAgCCgCNCEZIAgoAjAhGiAIKAIsIRsgCCgCKCEcIAgoAiQhHSAIKAIgIR4gCCgCHCEfIAgoAhghICAIKAIUISEgCCgCECEiIAgoAgwhESAIKAIIISMgCCgCBCEkIAgoAgAhFiATQX82AgAgEyAWKAIAIggEfyATQQxqKAIAIRcgE0EIaigCACEKQQAhDgNAIBAgJCAOQQJ0IA5BgIAEIAggDmsiCCAIQYCABE8bIghqIhRBAnQQZjYCDAJAAkAgFyAIQQJ0Ig5PBEAgEEEMaiAKIA4QOCAZKgIAIQAgGioCACEDIBsqAgAhLyAcKgIAITAgHSoCACEEIB4qAgAhBSAfKgIAIQYgICoCACExICEqAgAhMiAiKgIAITMgIy0AAA0BIAAgA5NDAAB+Q5UhACAGIAaUIAUgBZSSIAQgBJSSIQsgCiEIA0AgDkEEIA5BBEkiDxshEgJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgEEEQaiAIIBIQFwJ9AkAgD0UEQCAQKgIYIQEgECoCFCECIBAqAhAhB0MAAAAAIQxDAAAAACElIAgoAgwiD0H/AXEEQCADIAAgD0EBa0H/AXGzlJIQGSElCyAPQQh2IhVB/wFxBEAgAyAAIBVBAWtB/wFxs5SSEBkhDAsgMSABkyEBIDIgApMhAiAzIAeTIQcgD0EQdiIPQf8BcQ0BQwAAAAAMAgtBAyASQZSCwAAQNQALIAMgACAPQQFrQf8BcbOUkhAZCyEpIAYgB5QgBSAClJIgBCABlJIiJiAmlCALIAcgB5QgAiAClJIgASABlJIgJSAMkiApkkMAAEBAlSIBIAGUk5STIgFDAAAAAF0NACAmjCABkZMgC5UiASAwYEUgASAvX0VyDQAgESgCCCIPIBEoAgBGBEAgERAnCyARKAIEIA9BAnRqIAE4AgAgESAPQQFqNgIICyAIIBJBAnRqIQggDiASayIODQALDAILIA4gF0GIg8AAEDYACyAAIAOTQwAAfkOVISwgCiEIA0AgDkEEIA5BBEkiDxshEgJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgEEEQaiAIIBIQFwJ9AkAgD0UEQCAQKgIYIQAgECoCFCEBIBAqAhAhAkMAAAAAIQdDAAAAACELIAgoAgwiD0H/AXEEQCADICwgD0EBa0H/AXGzlJIQGSELCyAPQQh2IhVB/wFxBEAgAyAsIBVBAWtB/wFxs5SSEBkhBwsgMSAAkyEnIDIgAZMhLSAzIAKTIS4gD0EQdiIVQf8BcQ0BQwAAAAAMAgtBAyASQZSCwAAQNQALIAMgLCAVQQFrQf8BcbOUkhAZCyEMIAQgCCgCCCIVQRh1skMAAP5ClSIAIAUgD0EYdbJDAAD+QpUiAZQgBCAAlJMiKJQgFUEQdsCyQwAA/kKVIgIgBCAClCAGIAGUkyIqlJMgBiAAlCAFIAKUkyIrQwAAgD8gAiAClJMgACAAlJMgASABlJNDAAAAABBQkSIllJIiJiAmkpIhJiAFIAIgK5QgASAolJMgKiAllJIiKSApkpIhKSAGIAEgKpQgACArlJMgKCAllJIiKCAokpIhKCAnIAAgLSABlCAnIACUkyIqlCACICcgApQgLiABlJMiK5STIC4gAJQgLSAClJMiNCAllJIiJyAnkpIhJyAtIAIgNJQgASAqlJMgKyAllJIiAiACkpIhAiAuIAEgK5QgACA0lJMgKiAllJIiACAAkpIhAAJAIAwgCyAHEFAgDBBQQwrXIzyUIgFdRQRAIAEgB15FBEAgASALXkUEQEMAAIA/IAyVIgwgJ5QiASAMICaUIgyUQwAAgD8gC5UiCyAAlCIAIAsgKJQiC5RDAACAPyAHlSIHIAKUIgIgByAplCIHlJKSIiUgJZQgDCAMlCALIAuUIAcgB5SSkiIHIAEgAZQgACAAlCACIAKUkpJDAACAv5KUkyIAQwAAAABdDQQgJYwgAJGTIAeVIQAMAwsgKItDvTeGNV0NAyACICkgAIwgKJUiAJSSIAeVIgEgAZQgJyAmIACUkiAMlSIBIAGUkkMAAIA/XkUNAgwDCyApi0O9N4Y1XQ0CIAAgKCACjCAplSIAlJIgC5UiASABlCAnICYgAJSSIAyVIgEgAZSSQwAAgD9eDQIMAQsgJotDvTeGNV0NASAAICggJ4wgJpUiAJSSIAuVIgEgAZQgAiApIACUkiAHlSIBIAGUkkMAAIA/Xg0BCyAAIDBgRSAAIC9fRXINACARKAIIIg8gESgCAEYEQCARECcLIBEoAgQgD0ECdGogADgCACARIA9BAWo2AggLIAggEkECdGohCCAOIBJrIg4NAAsLIBAoAgwiCEGEAU8EQCAIEC0LIBYoAgAiCCAUIg5LDQALIBMoAgBBAWoFQQALNgIAIBBBIGokAAwCCxA5AAtBnIDAAEHGACAQQR9qQYyAwABBtIHAABAzAAsgDSgCRBANIQkQGyIIIAkmASANIAg2AkggDSgCQCERIA0oAkQhDiMAQSBrIgokACAYKAIAIhMlARAKIRQgCiAONgIEIAogFDYCAAJAIA4gFEYEQBBbIhQQUyIQJQEgESAOEAghCRAbIg4gCSYBIBRBhAFPBEAgFBAtCyAQQYQBTwRAIBAQLQsgEyUBIA4lAUEAEAkgDkGEAU8EQCAOEC0LIApBIGokAAwBCyAKQQA2AgggCiAKQQRqIApBCGoQQAALIA0oAjwiCgRAIA0oAkAgCkECdBBlCyANKAIsIgpBhAFPBEAgChAtCyANQYABaiQAIAglASAIEC0L+gECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEGci8AAIAEoAgQgASgCCCIALQAIIAAtAAkQLAALIAAgAzYCBCAAIAI2AgAgAEGAi8AAIAEoAgQgASgCCCIALQAIIAAtAAkQLAALJAAgAEUEQEHEhsAAQTIQaAALIAAgAiADIAQgBSABKAIQEQgACyIAIABFBEBBxIbAAEEyEGgACyAAIAIgAyAEIAEoAhARDQALIgAgAEUEQEHEhsAAQTIQaAALIAAgAiADIAQgASgCEBEPAAsiACAARQRAQcSGwABBMhBoAAsgACACIAMgBCABKAIQERgACyIAIABFBEBBxIbAAEEyEGgACyAAIAIgAyAEIAEoAhARGgALIgAgAEUEQEHEhsAAQTIQaAALIAAgAiADIAQgASgCEBEcAAslAQF/IAAoAgAiAUGAgICAeHJBgICAgHhHBEAgACgCBCABEGULCyAAIABFBEBBxIbAAEEyEGgACyAAIAIgAyABKAIQEQQACx4AIABFBEBBxIbAAEEyEGgACyAAIAIgASgCEBEAAAuvDwEPfxAbIgMgASYBEBsiBCACJgEjAEEgayIKJAAgCiAENgIIIAogAzYCBCAKIAA2AgAgCiAKQQRqIgAoAgAQbzYCDCAKIApBCGo2AhwgCiAKNgIYIAogADYCFCAKIApBDGo2AhAgCkEQaiEAIwBB0ABrIgckAAJAAkACQAJAQQBBgIDAACgCABEDACINBEAgDSgCAEUEQCAAKAIMIREgDUF/NgIAIAAoAgQgACgCCCEOIAAoAgAoAgAiBiANQQRqIgQoAggiA0sEQCAGIAMiAGsiCSAEKAIAIABrSwRAIAQgACAJQQJBAhAmIAQoAgghAAsgBCgCBCIMIABBAXRqIQUgCUECTwRAIAUgA0F/cyAGakEBdBAqGiAAIAZqQQF0IANBAXRrIAxqQQJrIQUgACAJakEBayEACyAFQQA7AQAgBCAAQQFqNgIICyAEKAIUIgMgBkkEQCAGIAMiAGsiCSAEKAIMIABrSwRAIARBDGogACAJQQRBBBAmIAQoAhQhAAsgBCgCECIMIABBAnRqIQUgCUECTwRAIAUgA0F/cyAGakECdBAqGiAAIAZqQQJ0IANBAnRrIAxqQQRrIQUgACAJakEBayEACyAFQQA2AgAgBCAAQQFqNgIUCyAEKAIgIgNBgPgBTQRAQYH4ASADIgBrIgUgBCgCGCAAa0sEQCAEQRhqIAAgBUEEQQQQJiAEKAIgIQALIAQoAhwiBiAAQQJ0IglqIQUgA0GA+AFHBH8gBUGA4AcgA0ECdCIFaxAqGiAAIANrQYD4AWohACAJIAVrIAZqQYDgB2oFIAULQQA2AgAgBCAAQQFqNgIgCygCACUBQQAgDigCACIJEAshARAbIgAgASYBIAcgADYCACAJIA0oAgwiAEsNAiANKAIIIQgjAEEgayIAJAAgACAHKAIAEG8iAzYCACAAIAk2AgQgAyAJRwRAIABBADYCCCAAIABBBGogAEEIahBAAAsQWyIFEFMiBiUBEAEhARAbIgMgASYBIAZBhAFPBEAgBhAtCyADJQEgBygCACUBIAhBAXYQAiADQYQBTwRAIAMQLQsgBUGEAU8EQCAFEC0LIABBIGokACAHQQRqIRBBACEAQQAhBSMAQTBrIgYkAAJAAkACQAJAIAkgBCgCCCIDTQRAIAQoAgQhAyAEQQA2AiAgBCgCGEGA+AFNBEAgBEEYakEAQYH4AUEEQQQQJiAEKAIgIQALIAQoAhwiDiAAQQJ0Ig9qQYDgBxAqIAQgAEGB+AFqIgw2AiBBgOAHakEANgIAAkAgCQRAIAlBAXQhCCADIQADQCAALwEAIgtBgPgBSQRAIAsgDE8NAyAOIAtBAnRqIgsgCygCAEEBajYCAAsgAEECaiEAIAhBAmsiCA0ACwsgBkEANgIEAkAgDEECSQ0AIA4gDEECdGpBCGsiACgCACEFIABBADYCACAGIAU2AgQgACAORg0AIA9B+N8HaiILQQJ2QQFqQQNxIggEQCAIQQJ0IQgDQCAAQQRrIgAoAgAhDyAAIAU2AgAgBiAFIA9qIgU2AgQgCEEEayIIDQALCyALQQxJDQAgAEEQayEAA0AgAEEMaiIIKAIAIQsgCCAFNgIAIAYgBSALaiIFNgIEIABBCGoiCCgCACELIAggBTYCACAGIAUgC2oiBTYCBCAAQQRqIggoAgAhCyAIIAU2AgAgBiAFIAtqIgU2AgQgACgCACEIIAAgBTYCACAGIAUgCGoiBTYCBCAAIA5GIABBEGshAEUNAAsLAkAgCQRAIAlBAXQhCCAEKAIQIQ8gBCgCFCEJQQAhAANAIAMvAQAiBEGA+AFJBEAgBCAMTw0DIAkgDiAEQQJ0aiIEKAIAIgtNBEAgCyAJQZiEwAAQNQALIA8gC0ECdGogADYCACAEIAQoAgBBAWo2AgALIANBAmohAyAAQQFqIQAgCEECayIIDQALCyAMRQ0FIA4oAgAgBUcNAyAQQYCAgIB4NgIAIBAgBTYCBAwECyAEIAxBiITAABA1AAsgCyAMQaiEwAAQNQALIAkgA0G4g8AAEDYACyAGQQI2AgwgBkH4g8AANgIIIAZCAjcCFCAGIA6tQoCAgIDgAIQ3AyggBiAGQQRqrUKAgICA4ACENwMgIAYgBkEgajYCECAQIAZBCGoQHQsgBkEwaiQADAELQQBBAEHIg8AAEDUACyAHKAIEQYCAgIB4Rw0DIAcoAggiAEUNBSAAIA0oAhgiA0sNBCANKAIUIQQgByARQQAgABBmIgM2AiggB0EoaiAEIAAQMSADQYQBSQ0FIAMQLQwFCxA5AAtBnIDAAEHGACAHQc8AakGMgMAAQbSBwAAQMwALIAkgAEHAgsAAEDYACyAHQRhqIAdBDGooAgA2AgAgByAHKQIENwMQIAdBATYCLCAHQeCCwAA2AiggB0IBNwI0IAcgB0EQaq1CgICAgMAAhDcDQCAHIAdBQGs2AjAgB0EcaiAHQShqEC8gBygCICAHKAIkEGgACyAAIANB0ILAABA2AAsgBygCACIDQYQBTwRAIAMQLQsgDSANKAIAQQFqNgIAIAdB0ABqJAAgCigCCCIDQYQBTwRAIAMQLQsgCigCBCIDQYQBTwRAIAMQLQsgCkEgaiQAIAALmA8BE38QGyIEIAEmARAbIg8gAiYBIwBBIGsiCiQAIAogDzYCCCAKIAQ2AgQgCiAANgIAIAogCkEEaiIAKAIAEHA2AgwgCiAKQQhqNgIcIAogCjYCGCAKIAA2AhQgCiAKQQxqNgIQIApBEGohACMAQdAAayIIJAACQAJAAkACQEEAQYSAwAAoAgARAwAiEARAIBAoAgBFBEAgACgCDCEUIBBBfzYCACAAKAIEIQQgACgCCCEPIBBBBGoiCSAAKAIAKAIAIgAQEyAIIARBACAPKAIAIgwQZjYCACAMIBAoAgwiBEsNAiAIIBAoAgggDBA4IwBBMGsiDSQAIAkgABATAkACQCAMIAkoAggiAE0EQCAJKAIEIQ8gCSgCHCEEIAkoAiAiDgRAIAQgDkECdBAqGgsgCSgCKCESIAkoAiwiEQRAIBIgEUECdBAqGgsgDARAIAxBAnQhBSAPIQADQAJAIAAoAgAiA0GAgID8B08NACAOIANBf3MiC0H//wNxIgNLBEAgBCADQQJ0aiIDIAMoAgBBAWo2AgAgESALQRB2IgNLBEAgEiADQQJ0aiIDIAMoAgBBAWo2AgAMAgsgAyARQbiFwAAQNQALIAMgDkGohcAAEDUACyAAQQRqIQAgBUEEayIFDQALCyAORQRAQQAhBQwDCyAOQQFrQf////8DcSIAQQFqIgVBB3EhAyAAQQdJBEBBACEFIAQhAAwCCyAFQfj///8HcSELQQAhBSAEIQADQCAAKAIAIQYgACAFNgIAIAAoAgQhByAAIAUgBmoiBTYCBCAAKAIIIQYgACAFIAdqIgU2AgggACgCDCEHIAAgBSAGaiIFNgIMIAAoAhAhBiAAIAUgB2oiBTYCECAAKAIUIQcgACAFIAZqIgU2AhQgACgCGCEGIAAgBSAHaiIFNgIYIAAoAhwhByAAIAUgBmoiBTYCHCAAQSBqIQAgBSAHaiEFIAtBCGsiCw0ACwwBCyAMIABBuITAABA2AAsgA0UNAANAIAAoAgAhCyAAIAU2AgAgAEEEaiEAIAUgC2ohBSADQQFrIgMNAAsLIA0gBTYCBCAMBEAgDEECdCELIAkoAjQhFSAJKAI4IQZBACEDIA8hAANAAkAgACgCACIHQYCAgPwHTw0AAkAgDiAHQX9zQf//A3EiB0sEQCAEIAdBAnRqIgcoAgAiEyAGTw0BIBUgE0ECdGogAzYCACAHIAcoAgBBAWo2AgAMAgsgByAOQYiFwAAQNQALIBMgBkGYhcAAEDUACyAAQQRqIQAgA0EBaiEDIAtBBGsiCw0ACwsgCEEEaiEOAkAgEUUNACARQQFrQf////8DcSIEQQFqIgZBB3EhC0EAIQMgEiEAIARBB08EQCAGQfj///8HcSEEA0AgACgCACEGIAAgAzYCACAAKAIEIQcgACADIAZqIgM2AgQgACgCCCEGIAAgAyAHaiIDNgIIIAAoAgwhByAAIAMgBmoiAzYCDCAAKAIQIQYgACADIAdqIgM2AhAgACgCFCEHIAAgAyAGaiIDNgIUIAAoAhghBiAAIAMgB2oiAzYCGCAAKAIcIQcgACADIAZqIgM2AhwgAEEgaiEAIAMgB2ohAyAEQQhrIgQNAAsLIAtFDQADQCAAKAIAIQQgACADNgIAIABBBGohACADIARqIQMgC0EBayILDQALCwJAIAVFDQAgCSgCNCEDIAkoAjhBAnQhACAJKAIQIRMgCSgCFCELIAUhBAJAAkADQCAARQ0DIAMoAgAiCSAMTw0CIBEgDyAJQQJ0aigCAEF/c0EQdiIGSwRAIBIgBkECdGoiBigCACIHIAtPDQIgA0EEaiEDIBMgB0ECdGogCTYCACAGIAYoAgBBAWo2AgAgAEEEayEAIARBAWsiBA0BDAQLCyAGIBFB6ITAABA1AAsgByALQfiEwAAQNQALIAkgDEHYhMAAEDUACwJAIBFB//8DSwRAAkAgBSASKAL8/w9GBEAgDkGAgICAeDYCACAOIAU2AgQMAQsgDUECNgIMIA1B+IPAADYCCCANQgI3AhQgDSASQfz/D2qtQoCAgIDgAIQ3AyggDSANQQRqrUKAgICA4ACENwMgIA0gDUEgajYCECAOIA1BCGoQHQsgDUEwaiQADAELQf//AyARQciEwAAQNQALIAgoAgRBgICAgHhHDQMgCCgCCCIARQ0FIAAgECgCGCIESw0EIBAoAhQhDyAIIBRBACAAEGYiBDYCKCAIQShqIA8gABAxIARBhAFJDQUgBBAtDAULEDkAC0GcgMAAQcYAIAhBzwBqQYyAwABBtIHAABAzAAsgDCAEQeiCwAAQNgALIAhBGGogCEEMaigCADYCACAIIAgpAgQ3AxAgCEEBNgIsIAhB4ILAADYCKCAIQgE3AjQgCCAIQRBqrUKAgICAwACENwNAIAggCEFAazYCMCAIQRxqIAhBKGoQLyAIKAIgIAgoAiQQaAALIAAgBEH4gsAAEDYACyAIKAIAIgRBhAFPBEAgBBAtCyAQIBAoAgBBAWo2AgAgCEHQAGokACAKKAIIIgRBhAFPBEAgBBAtCyAKKAIEIgRBhAFPBEAgBBAtCyAKQSBqJAAgAAsXAQF/IAAoAgAiAQRAIAAoAgQgARBlCwsUACABIAEgACAAIAFdGyAAIABcGwscACAAQQA2AhAgAEIANwIIIABCgICAgMAANwIAC0QAIABFBEAjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQeyLwAA2AgggAEIENwIQIABBCGpBiIzAABBDAAsgACABEG0ACxYBAW8gACUBEAAhARAbIgAgASYBIAALzgYBBn8CfwJAAkACQAJAAkAgAEEEayIFKAIAIgZBeHEiBEEEQQggBkEDcSIHGyABak8EQCAHQQAgAUEnaiIJIARJGw0BAkACQCACQQlPBEAgAiADEBwiCA0BQQAMCQsgA0HM/3tLDQFBECADQQtqQXhxIANBC0kbIQECQCAHRQRAIAFBgAJJIAQgAUEEcklyIAQgAWtBgYAIT3INAQwJCyAAQQhrIgIgBGohBwJAAkACQAJAIAEgBEsEQCAHQfyWwAAoAgBGDQQgB0H4lsAAKAIARg0CIAcoAgQiBkECcQ0FIAZBeHEiBiAEaiIEIAFJDQUgByAGEB4gBCABayIDQRBJDQEgBSABIAUoAgBBAXFyQQJyNgIAIAEgAmoiASADQQNyNgIEIAIgBGoiAiACKAIEQQFyNgIEIAEgAxAaDA0LIAQgAWsiA0EPSw0CDAwLIAUgBCAFKAIAQQFxckECcjYCACACIARqIgEgASgCBEEBcjYCBAwLC0HwlsAAKAIAIARqIgQgAUkNAgJAIAQgAWsiA0EPTQRAIAUgBkEBcSAEckECcjYCACACIARqIgEgASgCBEEBcjYCBEEAIQNBACEBDAELIAUgASAGQQFxckECcjYCACABIAJqIgEgA0EBcjYCBCACIARqIgIgAzYCACACIAIoAgRBfnE2AgQLQfiWwAAgATYCAEHwlsAAIAM2AgAMCgsgBSABIAZBAXFyQQJyNgIAIAEgAmoiASADQQNyNgIEIAcgBygCBEEBcjYCBCABIAMQGgwJC0H0lsAAKAIAIARqIgQgAUsNBwsgAxARIgFFDQEgASAAQXxBeCAFKAIAIgFBA3EbIAFBeHFqIgEgAyABIANJGxAfIAAQFgwICyAIIAAgASADIAEgA0kbEB8aIAUoAgAiAkF4cSIDIAFBBEEIIAJBA3EiAhtqSQ0DIAJBACADIAlLGw0EIAAQFgsgCAwGC0GBicAAQbCJwAAQPQALQcCJwABB8InAABA9AAtBgYnAAEGwicAAED0AC0HAicAAQfCJwAAQPQALIAUgASAGQQFxckECcjYCACABIAJqIgIgBCABayIBQQFyNgIEQfSWwAAgATYCAEH8lsAAIAI2AgAgAAwBCyAACwsZACABKAIUQaCNwABBDiABKAIYKAIMEQIACxYAIAAoAhQgASACIAAoAhgoAgwRAgALhwIBA39BnJPAACgCAEUEQAJAAkACQAJAIABFDQAgACgCACAAQQA2AgBBAXFFDQAgACgCECECIAAoAgwhASAAKAIIIQMgACgCBCEADAELQQAhAEGxk8AALQAAGkGAgBAhAkGAgBAhAwJAQYCAwAAQESIBRQ0AIAFBBGstAABBA3FFDQAgAUGAgMAAECoaCyABRQ0BC0Gsk8AAIAI2AgBBoJPAACAANgIAQaiTwAAoAgAhAkGok8AAIAE2AgBBpJPAACgCACEAQaSTwAAgAzYCAEGck8AAKAIAQZyTwABBATYCAEUgAEVyRQRAIAIgAEECdBBlCwwBC0EEQYCAwAAQUgALC0Ggk8AAC/ICAQl/QaySwAAoAgBFBEACfwJAIABFDQAgACgCACAAQQA2AgBBAXFFDQAgACgCKCEBIAAoAiQhByAAKAIgIQIgACgCHCEDIAAoAhghCCAAKAIUIQQgACgCECEFIAAoAgwhCSAAKAIIIQYgACgCBAwBC0ECIQlBBCEHQQAhAUEEIQhBAAshAEHUksAAIAE2AgBByJLAACADNgIAQbySwAAgBTYCAEGwksAAIAA2AgBB0JLAACgCACEFQdCSwAAgBzYCAEHMksAAKAIAIQBBzJLAACACNgIAQcSSwAAoAgAhAUHEksAAIAg2AgBBwJLAACgCACECQcCSwAAgBDYCAEG4ksAAKAIAIQRBuJLAACAJNgIAQbSSwAAoAgAhA0G0ksAAIAY2AgBBrJLAACgCACEGQaySwABBATYCAAJAIAZFDQAgAwRAIAQgA0EBdBBlCyACBEAgASACQQJ0EGULIABFDQAgBSAAQQJ0EGULC0GwksAAC8QEARF/QdiSwAAoAgBFBEACQCAABEAgACgCQCEBIAAoAjwhAiAAKAI4IQMgACgCNCEEIAAoAjAhBSAAKAIsIQYgACgCKCEHIAAoAiQhCCAAKAIgIQkgACgCHCEKIAAoAhghCyAAKAIUIQwgACgCECENIAAoAgwhDiAAKAIIIQ8gACgCBCEQIAAoAgAgAEEANgIAQQFxDQELQQQhAkEAIQFBACEDQQAhBEEEIQVBACEGQQAhB0EEIQhBACEJQQAhCkEEIQtBACEMQQAhDUEEIQ5BACEPQQAhEAtBmJPAACABNgIAQYyTwAAgBDYCAEGAk8AAIAc2AgBB9JLAACAKNgIAQeiSwAAgDTYCAEHcksAAIBA2AgBBlJPAACgCACEHQZSTwAAgAjYCAEGQk8AAKAIAIQBBkJPAACADNgIAQYiTwAAoAgAhCkGIk8AAIAU2AgBBhJPAACgCACEBQYSTwAAgBjYCAEH8ksAAKAIAIQVB/JLAACAINgIAQfiSwAAoAgAhAkH4ksAAIAk2AgBB8JLAACgCACEGQfCSwAAgCzYCAEHsksAAKAIAIQNB7JLAACAMNgIAQeSSwAAoAgAhCEHkksAAIA42AgBB4JLAACgCACEEQeCSwAAgDzYCAEHYksAAKAIAIQlB2JLAAEEBNgIAAkAgCUUNACAEBEAgCCAEQQJ0EGULIAMEQCAGIANBAnQQZQsgAgRAIAUgAkECdBBlCyABBEAgCiABQQJ0EGULIABFDQAgByAAQQJ0EGULC0HcksAACxQAIAAoAgAgASAAKAIEKAIMEQAACxQCAW8BfxAPIQAQGyIBIAAmASABCxAAIAEgACgCBCAAKAIIEBQLGQACfyABQQlPBEAgASAAEBwMAQsgABARCwsiACAAQu26rbbNhdT14wA3AwggAEL4gpm9le7Gxbl/NwMACyAAIABC2KGkg7Hi0d18NwMIIABCldfdmMOXiowLNwMACxMAIABB8IrAADYCBCAAIAE2AgALEAAgASAAKAIAIAAoAgQQVgsQACABIAAoAgAgACgCBBAUCxAAIAEoAhQgASgCGCAAEBgLDgAgACUBIAElASACEAYLWwECfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABAWDAILQYGJwABBsInAABA9AAtBwInAAEHwicAAED0ACwsdAQFvIAAoAgAlASABIAIQDCEDEBsiACADJgEgAAvCAgEGfyAAKAIAIQIjAEEQayIEJABBCiEDAkAgAkGQzgBJBEAgAiEADAELA0AgBEEGaiADaiIGQQRrIAIgAkGQzgBuIgBBkM4AbGsiB0H//wNxQeQAbiIFQQF0QdqPwABqLwAAOwAAIAZBAmsgByAFQeQAbGtB//8DcUEBdEHaj8AAai8AADsAACADQQRrIQMgAkH/wdcvSyAAIQINAAsLAkAgAEHjAE0EQCAAIQIMAQsgA0ECayIDIARBBmpqIAAgAEH//wNxQeQAbiICQeQAbGtB//8DcUEBdEHaj8AAai8AADsAAAsCQCACQQpPBEAgA0ECayIDIARBBmpqIAJBAXRB2o/AAGovAAA7AAAMAQsgA0EBayIDIARBBmpqIAJBMHI6AAALIAFBAUEAIARBBmogA2pBCiADaxAVIARBEGokAAsJACAAIAEQDgALDQAgAEHAiMAAIAEQGAsMACAAIAEpAgA3AwALDQAgAEHAi8AAIAEQGAsNACABQbiLwABBBRBWCxkAIAAgAUG8k8AAKAIAIgBBFSAAGxEBAAALCQAgAEEANgIACwgAIAAlARADCwgAIAAlARAHCwueEgQAQYCAwAALCQEAAAACAAAAAwBBlIDAAAuBDAEAAAAFAAAAY2Fubm90IGFjY2VzcyBhIFRocmVhZCBMb2NhbCBTdG9yYWdlIHZhbHVlIGR1cmluZyBvciBhZnRlciBkZXN0cnVjdGlvbi9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAAABiABAATwAAAAQBAAAaAAAAYgAQAE8AAAD4AQAAJgAAAHNwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJz1AAQACAAAAB+AAAAHAAAANQAEAAgAAAAgAAAABwAAADUABAAIAAAAIUAAAAgAAAAc3BhcmstaW50ZXJuYWwtcnMvc3JjL2xpYi5ycyQBEAAcAAAAHQAAADMAAAAkARAAHAAAACgAAAAtAAAAAQAAAAAAAAAkARAAHAAAADoAAAAzAAAAJAEQABwAAABFAAAALQAAACQBEAAcAAAAXgAAACgAAABzcGFyay1pbnRlcm5hbC1ycy9zcmMvc29ydC5ycwAAAJgBEAAdAAAAGwAAAB0AAACYARAAHQAAADkAAAAPAAAARXhwZWN0ZWQgIGFjdGl2ZSBzcGxhdHMgYnV0IGdvdCDYARAACQAAAOEBEAAXAAAAmAEQAB0AAAAzAAAAHQAAAJgBEAAdAAAAMwAAABUAAACYARAAHQAAACQAAAAUAAAAmAEQAB0AAAB0AAAAGQAAAJgBEAAdAAAApwAAABMAAACYARAAHQAAAJ8AAAATAAAAmAEQAB0AAACiAAAAHQAAAJgBEAAdAAAAogAAABEAAACYARAAHQAAAJAAAAAgAAAAmAEQAB0AAACQAAAAFAAAAJgBEAAdAAAAfAAAABgAAACYARAAHQAAAH0AAAAYAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnPIAhAAXAAAAPsYAAABAAAAAAAAAAQAAAAEAAAAEwAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkTGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkdgMQACoAAAAvVXNlcnMvZG1hcmNvcy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwCoAxAAXwAAAAgDAAAZAAAAcmVlbnRyYW50IGluaXQAABgEEAAOAAAAqAMQAF8AAAB6AgAADQAAABYAAAAMAAAABAAAABcAAAAYAAAAGQAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZABYBBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAWAQQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAAAsFEAAVAAAAIAUQAA0AAABzdGQvc3JjL2FsbG9jLnJzQAUQABAAAABjAQAACQAAABYAAAAMAAAABAAAABoAAAAAAAAACAAAAAQAAAAbAAAAAAAAAAgAAAAEAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAQAAAABAAAACEAAAAiAAAAIwAAACQAAABFcnJvcgAAACUAAAAMAAAABAAAACYAAAAnAAAAKAAAAGNhcGFjaXR5IG92ZXJmbG93AAAA2AUQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5yc/QFEAAUAAAAGAAAAAUAQaCMwAAL8AUBAAAAKQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAfgYQABAAAAB+AgAADgAAAEJvcnJvd011dEVycm9yYWxyZWFkeSBib3Jyb3dlZDogrgYQABIAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAyAYQACAAAADoBhAAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogABcHEAAQAAAAJwcQABcAAAA+BxAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAAAXBxAAEAAAAGAHEAAQAAAAcAcQAAkAAAA+BxAACQAAADogAAABAAAAAAAAAJwHEAACAAAAfSB9Y29yZS9zcmMvZm10L251bS5ycwAAswcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlyYW5nZSBzdGFydCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAACiCBAAEgAAALQIEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgIEAAQAAAAtAgQACIAAAAAAAA/AAAAvwBBqJLAAAsBFABwCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44My4wICg5MGIzNWE2MjMgMjAyNC0xMS0yNikGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4HMC4yLjEwMABJD3RhcmdldF9mZWF0dXJlcwQrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQrD3JlZmVyZW5jZS10eXBlcysKbXVsdGl2YWx1ZQ==", self.location.href);
    }
    const imports = __wbg_get_imports();
    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
      module_or_path = fetch(module_or_path);
    }
    const { instance, module } = await __wbg_load(await module_or_path, imports);
    return __wbg_finalize_init(instance, module);
  }
  var ch2 = {};
  var wk = function(c, id, msg, transfer, cb) {
    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
      c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
    ], { type: "text/javascript" }))));
    w.onmessage = function(e) {
      var d = e.data, ed = d.$e$;
      if (ed) {
        var err2 = new Error(ed[0]);
        err2["code"] = ed[1];
        err2.stack = ed[2];
        cb(err2, null);
      } else
        cb(null, d);
    };
    w.postMessage(msg, transfer);
    return w;
  };
  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b = new u16(31);
    for (var i2 = 0; i2 < 31; ++i2) {
      b[i2] = start += 1 << eb[i2 - 1];
    }
    var r = new i32(b[30]);
    for (var i2 = 1; i2 < 30; ++i2) {
      for (var j = b[i2]; j < b[i2 + 1]; ++j) {
        r[j] = j - b[i2] << 5 | i2;
      }
    }
    return { b, r };
  };
  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0), fd = _b.b;
  var rev = new u16(32768);
  for (var i = 0; i < 32768; ++i) {
    var x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  var hMap = function(cd, mb, r) {
    var s = cd.length;
    var i2 = 0;
    var l = new u16(mb);
    for (; i2 < s; ++i2) {
      if (cd[i2])
        ++l[cd[i2] - 1];
    }
    var le = new u16(mb);
    for (i2 = 1; i2 < mb; ++i2) {
      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
    }
    var co;
    if (r) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i2 = 0; i2 < s; ++i2) {
        if (cd[i2]) {
          var sv = i2 << 4 | cd[i2];
          var r_1 = mb - cd[i2];
          var v = le[cd[i2] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i2 = 0; i2 < s; ++i2) {
        if (cd[i2]) {
          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
        }
      }
    }
    return co;
  };
  var flt = new u8(288);
  for (var i = 0; i < 144; ++i)
    flt[i] = 8;
  for (var i = 144; i < 256; ++i)
    flt[i] = 9;
  for (var i = 256; i < 280; ++i)
    flt[i] = 7;
  for (var i = 280; i < 288; ++i)
    flt[i] = 8;
  var fdt = new u8(32);
  for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a) {
    var m = a[0];
    for (var i2 = 1; i2 < a.length; ++i2) {
      if (a[i2] > m)
        m = a[i2];
    }
    return m;
  };
  var bits = function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
  };
  var bits16 = function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  };
  var shft = function(p) {
    return (p + 7) / 8 | 0;
  };
  var slc = function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    return new u8(v.subarray(s, e));
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt)
      throw e;
    return e;
  };
  var inflt = function(dat, st, buf, dict) {
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    var noBuf = !buf;
    var resize = noBuf || st.i != 2;
    var noSt = st.i;
    if (noBuf)
      buf = new u8(sl * 3);
    var cbuf = function(l2) {
      var bl = buf.length;
      if (l2 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l2));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
          if (t > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + l);
          buf.set(dat.subarray(s, t), bt);
          st.b = bt += l, st.p = pos = t * 8, st.f = final;
          continue;
        } else if (type == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i2 = 0; i2 < hcLen; ++i2) {
            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i2 = 0; i2 < tl; ) {
            var r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            var s = r >> 4;
            if (s < 16) {
              ldt[i2++] = s;
            } else {
              var c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i2++] = c;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (resize)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i2 = sym - 257, b = fleb[i2];
            add = bits(dat, pos, (1 << b) - 1) + fl[i2];
            pos += b;
          }
          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
          if (!d)
            err(3);
          pos += d & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + 131072);
          var end = bt + add;
          if (bt < dt) {
            var shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf[bt] = dict[shift + bt];
          }
          for (; bt < end; ++bt)
            buf[bt] = buf[bt - dt];
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
  };
  var et = /* @__PURE__ */ new u8(0);
  var mrg = function(a, b) {
    var o = {};
    for (var k in a)
      o[k] = a[k];
    for (var k in b)
      o[k] = b[k];
    return o;
  };
  var wcln = function(fn, fnStr, td2) {
    var dt = fn();
    var st = fn.toString();
    var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\\s+/g, "").split(",");
    for (var i2 = 0; i2 < dt.length; ++i2) {
      var v = dt[i2], k = ks[i2];
      if (typeof v == "function") {
        fnStr += ";" + k + "=";
        var st_1 = v.toString();
        if (v.prototype) {
          if (st_1.indexOf("[native code]") != -1) {
            var spInd = st_1.indexOf(" ", 8) + 1;
            fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
          } else {
            fnStr += st_1;
            for (var t in v.prototype)
              fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
          }
        } else
          fnStr += st_1;
      } else
        td2[k] = v;
    }
    return fnStr;
  };
  var ch = [];
  var cbfs = function(v) {
    var tl = [];
    for (var k in v) {
      if (v[k].buffer) {
        tl.push((v[k] = new v[k].constructor(v[k])).buffer);
      }
    }
    return tl;
  };
  var wrkr = function(fns, init, id, cb) {
    if (!ch[id]) {
      var fnStr = "", td_1 = {}, m = fns.length - 1;
      for (var i2 = 0; i2 < m; ++i2)
        fnStr = wcln(fns[i2], fnStr, td_1);
      ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
    }
    var td2 = mrg({}, ch[id].e);
    return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
  };
  var bInflt = function() {
    return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
  };
  var pbf = function(msg) {
    return postMessage(msg, [msg.buffer]);
  };
  var gopt = function(o) {
    return o && {
      out: o.size && new u8(o.size),
      dictionary: o.dictionary
    };
  };
  var cbify = function(dat, opts, fns, init, id, cb) {
    var w = wrkr(fns, init, id, function(err2, dat2) {
      w.terminate();
      cb(err2, dat2);
    });
    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
    return function() {
      w.terminate();
    };
  };
  var b2 = function(d, b) {
    return d[b] | d[b + 1] << 8;
  };
  var b4 = function(d, b) {
    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
  };
  var b8 = function(d, b) {
    return b4(d, b) + b4(d, b + 4) * 4294967296;
  };
  var gzs = function(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
      err(6, "invalid gzip data");
    var flg = d[3];
    var st = 10;
    if (flg & 4)
      st += (d[10] | d[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
      ;
    return st + (flg & 2);
  };
  var Inflate = /* @__PURE__ */ function() {
    function Inflate2(opts, cb) {
      if (typeof opts == "function")
        cb = opts, opts = {};
      this.ondata = cb;
      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
      this.s = { i: 0, b: dict ? dict.length : 0 };
      this.o = new u8(32768);
      this.p = new u8(0);
      if (dict)
        this.o.set(dict);
    }
    Inflate2.prototype.e = function(c) {
      if (!this.ondata)
        err(5);
      if (this.d)
        err(4);
      if (!this.p.length)
        this.p = c;
      else if (c.length) {
        var n = new u8(this.p.length + c.length);
        n.set(this.p), n.set(c, this.p.length), this.p = n;
      }
    };
    Inflate2.prototype.c = function(final) {
      this.s.i = +(this.d = final || false);
      var bts = this.s.b;
      var dt = inflt(this.p, this.s, this.o);
      this.ondata(slc(dt, bts, this.s.b), this.d);
      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    };
    Inflate2.prototype.push = function(chunk, final) {
      this.e(chunk), this.c(final);
    };
    return Inflate2;
  }();
  function inflate(data, opts, cb) {
    if (!cb)
      cb = opts, opts = {};
    if (typeof cb != "function")
      err(7);
    return cbify(data, opts, [
      bInflt
    ], function(ev) {
      return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
    }, 1, cb);
  }
  function inflateSync(data, opts) {
    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  var Gunzip = /* @__PURE__ */ function() {
    function Gunzip2(opts, cb) {
      this.v = 1;
      this.r = 0;
      Inflate.call(this, opts, cb);
    }
    Gunzip2.prototype.push = function(chunk, final) {
      Inflate.prototype.e.call(this, chunk);
      this.r += chunk.length;
      if (this.v) {
        var p = this.p.subarray(this.v - 1);
        var s = p.length > 3 ? gzs(p) : 4;
        if (s > p.length) {
          if (!final)
            return;
        } else if (this.v > 1 && this.onmember) {
          this.onmember(this.r - p.length);
        }
        this.p = p.subarray(s), this.v = 0;
      }
      Inflate.prototype.c.call(this, final);
      if (this.s.f && !this.s.l && !final) {
        this.v = shft(this.s.p) + 9;
        this.s = { i: 0 };
        this.o = new u8(0);
        this.push(new u8(0), final);
      }
    };
    return Gunzip2;
  }();
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  try {
    td.decode(et, { stream: true });
  } catch (e) {
  }
  var dutf8 = function(d) {
    for (var r = "", i2 = 0; ; ) {
      var c = d[i2++];
      var eb = (c > 127) + (c > 223) + (c > 239);
      if (i2 + eb > d.length)
        return { s: r, r: slc(d, i2 - 1) };
      if (!eb)
        r += String.fromCharCode(c);
      else if (eb == 3) {
        c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
      } else if (eb & 1)
        r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);
      else
        r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);
    }
  };
  function strFromU8(dat, latin1) {
    if (latin1) {
      var r = "";
      for (var i2 = 0; i2 < dat.length; i2 += 16384)
        r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));
      return r;
    } else if (td) {
      return td.decode(dat);
    } else {
      var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
      if (r.length)
        err(8);
      return s;
    }
  }
  var slzh = function(d, b) {
    return b + 30 + b2(d, b + 26) + b2(d, b + 28);
  };
  var zh = function(d, b, z) {
    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
    var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
  };
  var z64e = function(d, b) {
    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
      ;
    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
  };
  var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {
    fn();
  };
  function unzip(data, opts, cb) {
    if (!cb)
      cb = opts, opts = {};
    if (typeof cb != "function")
      err(7);
    var term = [];
    var tAll = function() {
      for (var i3 = 0; i3 < term.length; ++i3)
        term[i3]();
    };
    var files = {};
    var cbd = function(a, b) {
      mt(function() {
        cb(a, b);
      });
    };
    mt(function() {
      cbd = cb;
    });
    var e = data.length - 22;
    for (; b4(data, e) != 101010256; --e) {
      if (!e || data.length - e > 65558) {
        cbd(err(13, 0, 1), null);
        return tAll;
      }
    }
    var lft = b2(data, e + 8);
    if (lft) {
      var c = lft;
      var o = b4(data, e + 16);
      var z = o == 4294967295 || c == 65535;
      if (z) {
        var ze = b4(data, e - 12);
        z = b4(data, ze) == 101075792;
        if (z) {
          c = lft = b4(data, ze + 32);
          o = b4(data, ze + 48);
        }
      }
      var fltr = opts && opts.filter;
      var _loop_3 = function(i3) {
        var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
        o = no;
        var cbl = function(e2, d) {
          if (e2) {
            tAll();
            cbd(e2, null);
          } else {
            if (d)
              files[fn] = d;
            if (!--lft)
              cbd(null, files);
          }
        };
        if (!fltr || fltr({
          name: fn,
          size: sc,
          originalSize: su,
          compression: c_1
        })) {
          if (!c_1)
            cbl(null, slc(data, b, b + sc));
          else if (c_1 == 8) {
            var infl = data.subarray(b, b + sc);
            if (su < 524288 || sc > 0.8 * su) {
              try {
                cbl(null, inflateSync(infl, { out: new u8(su) }));
              } catch (e2) {
                cbl(e2, null);
              }
            } else
              term.push(inflate(infl, { size: su }, cbl));
          } else
            cbl(err(14, "unknown compression type " + c_1, 1), null);
        } else
          cbl(null, null);
      };
      for (var i2 = 0; i2 < c; ++i2) {
        _loop_3(i2);
      }
    } else
      cbd(null, {});
    return tAll;
  }
  function unzipSync(data, opts) {
    var files = {};
    var e = data.length - 22;
    for (; b4(data, e) != 101010256; --e) {
      if (!e || data.length - e > 65558)
        err(13);
    }
    var c = b2(data, e + 8);
    if (!c)
      return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295 || c == 65535;
    if (z) {
      var ze = b4(data, e - 12);
      z = b4(data, ze) == 101075792;
      if (z) {
        c = b4(data, ze + 32);
        o = b4(data, ze + 48);
      }
    }
    var fltr = opts && opts.filter;
    for (var i2 = 0; i2 < c; ++i2) {
      var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
      o = no;
      if (!fltr || fltr({
        name: fn,
        size: sc,
        originalSize: su,
        compression: c_2
      })) {
        if (!c_2)
          files[fn] = slc(data, b, b + sc);
        else if (c_2 == 8)
          files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
        else
          err(14, "unknown compression type " + c_2);
      }
    }
    return files;
  }
  /**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const REVISION = "178";
  const NoColorSpace = "";
  const SRGBColorSpace = "srgb";
  const LinearSRGBColorSpace = "srgb-linear";
  const LinearTransfer = "linear";
  const SRGBTransfer = "srgb";
  function clamp(value, min, max2) {
    return Math.max(min, Math.min(max2, value));
  }
  function euclideanModulo(n, m) {
    return (n % m + m) % m;
  }
  function lerp(x2, y, t) {
    return (1 - t) * x2 + t * y;
  }
  class Quaternion {
    /**
     * Constructs a new quaternion.
     *
     * @param {number} [x=0] - The x value of this quaternion.
     * @param {number} [y=0] - The y value of this quaternion.
     * @param {number} [z=0] - The z value of this quaternion.
     * @param {number} [w=1] - The w value of this quaternion.
     */
    constructor(x2 = 0, y = 0, z = 0, w = 1) {
      this.isQuaternion = true;
      this._x = x2;
      this._y = y;
      this._z = z;
      this._w = w;
    }
    /**
     * Interpolates between two quaternions via SLERP. This implementation assumes the
     * quaternion data are managed  in flat arrays.
     *
     * @param {Array<number>} dst - The destination array.
     * @param {number} dstOffset - An offset into the destination array.
     * @param {Array<number>} src0 - The source array of the first quaternion.
     * @param {number} srcOffset0 - An offset into the first source array.
     * @param {Array<number>} src1 -  The source array of the second quaternion.
     * @param {number} srcOffset1 - An offset into the second source array.
     * @param {number} t - The interpolation factor in the range \`[0,1]\`.
     * @see {@link Quaternion#slerp}
     */
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s = 1 - t;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        const tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;
        if (s === 1 - t) {
          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    /**
     * Multiplies two quaternions. This implementation assumes the quaternion data are managed
     * in flat arrays.
     *
     * @param {Array<number>} dst - The destination array.
     * @param {number} dstOffset - An offset into the destination array.
     * @param {Array<number>} src0 - The source array of the first quaternion.
     * @param {number} srcOffset0 - An offset into the first source array.
     * @param {Array<number>} src1 -  The source array of the second quaternion.
     * @param {number} srcOffset1 - An offset into the second source array.
     * @return {Array<number>} The destination array.
     * @see {@link Quaternion#multiplyQuaternions}.
     */
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    /**
     * The x value of this quaternion.
     *
     * @type {number}
     * @default 0
     */
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    /**
     * The y value of this quaternion.
     *
     * @type {number}
     * @default 0
     */
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    /**
     * The z value of this quaternion.
     *
     * @type {number}
     * @default 0
     */
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    /**
     * The w value of this quaternion.
     *
     * @type {number}
     * @default 1
     */
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    /**
     * Sets the quaternion components.
     *
     * @param {number} x - The x value of this quaternion.
     * @param {number} y - The y value of this quaternion.
     * @param {number} z - The z value of this quaternion.
     * @param {number} w - The w value of this quaternion.
     * @return {Quaternion} A reference to this quaternion.
     */
    set(x2, y, z, w) {
      this._x = x2;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
    /**
     * Returns a new quaternion with copied values from this instance.
     *
     * @return {Quaternion} A clone of this instance.
     */
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    /**
     * Copies the values of the given quaternion to this instance.
     *
     * @param {Quaternion} quaternion - The quaternion to copy.
     * @return {Quaternion} A reference to this quaternion.
     */
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    /**
     * Sets this quaternion from the rotation specified by the given
     * Euler angles.
     *
     * @param {Euler} euler - The Euler angles.
     * @param {boolean} [update=true] - Whether the internal \`onChange\` callback should be executed or not.
     * @return {Quaternion} A reference to this quaternion.
     */
    setFromEuler(euler, update = true) {
      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x2 / 2);
      const c2 = cos(y / 2);
      const c3 = cos(z / 2);
      const s1 = sin(x2 / 2);
      const s2 = sin(y / 2);
      const s3 = sin(z / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "YXZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "ZXY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "ZYX":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "YZX":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "XZY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update === true) this._onChangeCallback();
      return this;
    }
    /**
     * Sets this quaternion from the given axis and angle.
     *
     * @param {Vector3} axis - The normalized axis.
     * @param {number} angle - The angle in radians.
     * @return {Quaternion} A reference to this quaternion.
     */
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    /**
     * Sets this quaternion from the given rotation matrix.
     *
     * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
     * @return {Quaternion} A reference to this quaternion.
     */
    setFromRotationMatrix(m) {
      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }
      this._onChangeCallback();
      return this;
    }
    /**
     * Sets this quaternion to the rotation required to rotate the direction vector
     * \`vFrom\` to the direction vector \`vTo\`.
     *
     * @param {Vector3} vFrom - The first (normalized) direction vector.
     * @param {Vector3} vTo - The second (normalized) direction vector.
     * @return {Quaternion} A reference to this quaternion.
     */
    setFromUnitVectors(vFrom, vTo) {
      let r = vFrom.dot(vTo) + 1;
      if (r < 1e-8) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
    /**
     * Returns the angle between this quaternion and the given one in radians.
     *
     * @param {Quaternion} q - The quaternion to compute the angle with.
     * @return {number} The angle in radians.
     */
    angleTo(q) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
    /**
     * Rotates this quaternion by a given angular step to the given quaternion.
     * The method ensures that the final quaternion will not overshoot \`q\`.
     *
     * @param {Quaternion} q - The target quaternion.
     * @param {number} step - The angular step in radians.
     * @return {Quaternion} A reference to this quaternion.
     */
    rotateTowards(q, step) {
      const angle = this.angleTo(q);
      if (angle === 0) return this;
      const t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
    /**
     * Sets this quaternion to the identity quaternion; that is, to the
     * quaternion that represents "no rotation".
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    identity() {
      return this.set(0, 0, 0, 1);
    }
    /**
     * Inverts this quaternion via {@link Quaternion#conjugate}. The
     * quaternion is assumed to have unit length.
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    invert() {
      return this.conjugate();
    }
    /**
     * Returns the rotational conjugate of this quaternion. The conjugate of a
     * quaternion represents the same rotation in the opposite direction about
     * the rotational axis.
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    /**
     * Calculates the dot product of this quaternion and the given one.
     *
     * @param {Quaternion} v - The quaternion to compute the dot product with.
     * @return {number} The result of the dot product.
     */
    dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    /**
     * Computes the squared Euclidean length (straight-line length) of this quaternion,
     * considered as a 4 dimensional vector. This can be useful if you are comparing the
     * lengths of two quaternions, as this is a slightly more efficient calculation than
     * {@link Quaternion#length}.
     *
     * @return {number} The squared Euclidean length.
     */
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    /**
     * Computes the Euclidean length (straight-line length) of this quaternion,
     * considered as a 4 dimensional vector.
     *
     * @return {number} The Euclidean length.
     */
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    /**
     * Normalizes this quaternion - that is, calculated the quaternion that performs
     * the same rotation as this one, but has a length equal to \`1\`.
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    normalize() {
      let l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
    /**
     * Multiplies this quaternion by the given one.
     *
     * @param {Quaternion} q - The quaternion.
     * @return {Quaternion} A reference to this quaternion.
     */
    multiply(q) {
      return this.multiplyQuaternions(this, q);
    }
    /**
     * Pre-multiplies this quaternion by the given one.
     *
     * @param {Quaternion} q - The quaternion.
     * @return {Quaternion} A reference to this quaternion.
     */
    premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
    /**
     * Multiplies the given quaternions and stores the result in this instance.
     *
     * @param {Quaternion} a - The first quaternion.
     * @param {Quaternion} b - The second quaternion.
     * @return {Quaternion} A reference to this quaternion.
     */
    multiplyQuaternions(a, b) {
      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    /**
     * Performs a spherical linear interpolation between quaternions.
     *
     * @param {Quaternion} qb - The target quaternion.
     * @param {number} t - The interpolation factor in the closed interval \`[0, 1]\`.
     * @return {Quaternion} A reference to this quaternion.
     */
    slerp(qb, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(qb);
      const x2 = this._x, y = this._y, z = this._z, w = this._w;
      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x2;
        this._y = y;
        this._z = z;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x2 + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x2 * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    /**
     * Performs a spherical linear interpolation between the given quaternions
     * and stores the result in this quaternion.
     *
     * @param {Quaternion} qa - The source quaternion.
     * @param {Quaternion} qb - The target quaternion.
     * @param {number} t - The interpolation factor in the closed interval \`[0, 1]\`.
     * @return {Quaternion} A reference to this quaternion.
     */
    slerpQuaternions(qa, qb, t) {
      return this.copy(qa).slerp(qb, t);
    }
    /**
     * Sets this quaternion to a uniformly random, normalized quaternion.
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    random() {
      const theta1 = 2 * Math.PI * Math.random();
      const theta2 = 2 * Math.PI * Math.random();
      const x0 = Math.random();
      const r1 = Math.sqrt(1 - x0);
      const r2 = Math.sqrt(x0);
      return this.set(
        r1 * Math.sin(theta1),
        r1 * Math.cos(theta1),
        r2 * Math.sin(theta2),
        r2 * Math.cos(theta2)
      );
    }
    /**
     * Returns \`true\` if this quaternion is equal with the given one.
     *
     * @param {Quaternion} quaternion - The quaternion to test for equality.
     * @return {boolean} Whether this quaternion is equal with the given one.
     */
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    /**
     * Sets this quaternion's components from the given array.
     *
     * @param {Array<number>} array - An array holding the quaternion component values.
     * @param {number} [offset=0] - The offset into the array.
     * @return {Quaternion} A reference to this quaternion.
     */
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
    /**
     * Writes the components of this quaternion to the given array. If no array is provided,
     * the method returns a new instance.
     *
     * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Array<number>} The quaternion components.
     */
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    /**
     * Sets the components of this quaternion from the given buffer attribute.
     *
     * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
     * @param {number} index - The index into the attribute.
     * @return {Quaternion} A reference to this quaternion.
     */
    fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      this._onChangeCallback();
      return this;
    }
    /**
     * This methods defines the serialization result of this class. Returns the
     * numerical elements of this quaternion in an array of format \`[x, y, z, w]\`.
     *
     * @return {Array<number>} The serialized quaternion.
     */
    toJSON() {
      return this.toArray();
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._w;
    }
  }
  class Vector3 {
    /**
     * Constructs a new 3D vector.
     *
     * @param {number} [x=0] - The x value of this vector.
     * @param {number} [y=0] - The y value of this vector.
     * @param {number} [z=0] - The z value of this vector.
     */
    constructor(x2 = 0, y = 0, z = 0) {
      Vector3.prototype.isVector3 = true;
      this.x = x2;
      this.y = y;
      this.z = z;
    }
    /**
     * Sets the vector components.
     *
     * @param {number} x - The value of the x component.
     * @param {number} y - The value of the y component.
     * @param {number} z - The value of the z component.
     * @return {Vector3} A reference to this vector.
     */
    set(x2, y, z) {
      if (z === void 0) z = this.z;
      this.x = x2;
      this.y = y;
      this.z = z;
      return this;
    }
    /**
     * Sets the vector components to the same value.
     *
     * @param {number} scalar - The value to set for all vector components.
     * @return {Vector3} A reference to this vector.
     */
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    /**
     * Sets the vector's x component to the given value
     *
     * @param {number} x - The value to set.
     * @return {Vector3} A reference to this vector.
     */
    setX(x2) {
      this.x = x2;
      return this;
    }
    /**
     * Sets the vector's y component to the given value
     *
     * @param {number} y - The value to set.
     * @return {Vector3} A reference to this vector.
     */
    setY(y) {
      this.y = y;
      return this;
    }
    /**
     * Sets the vector's z component to the given value
     *
     * @param {number} z - The value to set.
     * @return {Vector3} A reference to this vector.
     */
    setZ(z) {
      this.z = z;
      return this;
    }
    /**
     * Allows to set a vector component with an index.
     *
     * @param {number} index - The component index. \`0\` equals to x, \`1\` equals to y, \`2\` equals to z.
     * @param {number} value - The value to set.
     * @return {Vector3} A reference to this vector.
     */
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    /**
     * Returns the value of the vector component which matches the given index.
     *
     * @param {number} index - The component index. \`0\` equals to x, \`1\` equals to y, \`2\` equals to z.
     * @return {number} A vector component value.
     */
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    /**
     * Returns a new vector with copied values from this instance.
     *
     * @return {Vector3} A clone of this instance.
     */
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    /**
     * Copies the values of the given vector to this instance.
     *
     * @param {Vector3} v - The vector to copy.
     * @return {Vector3} A reference to this vector.
     */
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
    /**
     * Adds the given vector to this instance.
     *
     * @param {Vector3} v - The vector to add.
     * @return {Vector3} A reference to this vector.
     */
    add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    /**
     * Adds the given scalar value to all components of this instance.
     *
     * @param {number} s - The scalar to add.
     * @return {Vector3} A reference to this vector.
     */
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
    /**
     * Adds the given vectors and stores the result in this instance.
     *
     * @param {Vector3} a - The first vector.
     * @param {Vector3} b - The second vector.
     * @return {Vector3} A reference to this vector.
     */
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
    /**
     * Adds the given vector scaled by the given factor to this instance.
     *
     * @param {Vector3|Vector4} v - The vector.
     * @param {number} s - The factor that scales \`v\`.
     * @return {Vector3} A reference to this vector.
     */
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
    /**
     * Subtracts the given vector from this instance.
     *
     * @param {Vector3} v - The vector to subtract.
     * @return {Vector3} A reference to this vector.
     */
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    /**
     * Subtracts the given scalar value from all components of this instance.
     *
     * @param {number} s - The scalar to subtract.
     * @return {Vector3} A reference to this vector.
     */
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
    /**
     * Subtracts the given vectors and stores the result in this instance.
     *
     * @param {Vector3} a - The first vector.
     * @param {Vector3} b - The second vector.
     * @return {Vector3} A reference to this vector.
     */
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
    /**
     * Multiplies the given vector with this instance.
     *
     * @param {Vector3} v - The vector to multiply.
     * @return {Vector3} A reference to this vector.
     */
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
    /**
     * Multiplies the given scalar value with all components of this instance.
     *
     * @param {number} scalar - The scalar to multiply.
     * @return {Vector3} A reference to this vector.
     */
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    /**
     * Multiplies the given vectors and stores the result in this instance.
     *
     * @param {Vector3} a - The first vector.
     * @param {Vector3} b - The second vector.
     * @return {Vector3} A reference to this vector.
     */
    multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
    /**
     * Applies the given Euler rotation to this vector.
     *
     * @param {Euler} euler - The Euler angles.
     * @return {Vector3} A reference to this vector.
     */
    applyEuler(euler) {
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    /**
     * Applies a rotation specified by an axis and an angle to this vector.
     *
     * @param {Vector3} axis - A normalized vector representing the rotation axis.
     * @param {number} angle - The angle in radians.
     * @return {Vector3} A reference to this vector.
     */
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    /**
     * Multiplies this vector with the given 3x3 matrix.
     *
     * @param {Matrix3} m - The 3x3 matrix.
     * @return {Vector3} A reference to this vector.
     */
    applyMatrix3(m) {
      const x2 = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x2 + e[3] * y + e[6] * z;
      this.y = e[1] * x2 + e[4] * y + e[7] * z;
      this.z = e[2] * x2 + e[5] * y + e[8] * z;
      return this;
    }
    /**
     * Multiplies this vector by the given normal matrix and normalizes
     * the result.
     *
     * @param {Matrix3} m - The normal matrix.
     * @return {Vector3} A reference to this vector.
     */
    applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
    /**
     * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
     * divides by perspective.
     *
     * @param {Matrix4} m - The matrix to apply.
     * @return {Vector3} A reference to this vector.
     */
    applyMatrix4(m) {
      const x2 = this.x, y = this.y, z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    /**
     * Applies the given Quaternion to this vector.
     *
     * @param {Quaternion} q - The Quaternion.
     * @return {Vector3} A reference to this vector.
     */
    applyQuaternion(q) {
      const vx = this.x, vy = this.y, vz = this.z;
      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      const tx = 2 * (qy * vz - qz * vy);
      const ty = 2 * (qz * vx - qx * vz);
      const tz = 2 * (qx * vy - qy * vx);
      this.x = vx + qw * tx + qy * tz - qz * ty;
      this.y = vy + qw * ty + qz * tx - qx * tz;
      this.z = vz + qw * tz + qx * ty - qy * tx;
      return this;
    }
    /**
     * Projects this vector from world space into the camera's normalized
     * device coordinate (NDC) space.
     *
     * @param {Camera} camera - The camera.
     * @return {Vector3} A reference to this vector.
     */
    project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    /**
     * Unprojects this vector from the camera's normalized device coordinate (NDC)
     * space into world space.
     *
     * @param {Camera} camera - The camera.
     * @return {Vector3} A reference to this vector.
     */
    unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    /**
     * Transforms the direction of this vector by a matrix (the upper left 3 x 3
     * subset of the given 4x4 matrix and then normalizes the result.
     *
     * @param {Matrix4} m - The matrix.
     * @return {Vector3} A reference to this vector.
     */
    transformDirection(m) {
      const x2 = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x2 + e[4] * y + e[8] * z;
      this.y = e[1] * x2 + e[5] * y + e[9] * z;
      this.z = e[2] * x2 + e[6] * y + e[10] * z;
      return this.normalize();
    }
    /**
     * Divides this instance by the given vector.
     *
     * @param {Vector3} v - The vector to divide.
     * @return {Vector3} A reference to this vector.
     */
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
    /**
     * Divides this vector by the given scalar.
     *
     * @param {number} scalar - The scalar to divide.
     * @return {Vector3} A reference to this vector.
     */
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    /**
     * If this vector's x, y or z value is greater than the given vector's x, y or z
     * value, replace that value with the corresponding min value.
     *
     * @param {Vector3} v - The vector.
     * @return {Vector3} A reference to this vector.
     */
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    /**
     * If this vector's x, y or z value is less than the given vector's x, y or z
     * value, replace that value with the corresponding max value.
     *
     * @param {Vector3} v - The vector.
     * @return {Vector3} A reference to this vector.
     */
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    /**
     * If this vector's x, y or z value is greater than the max vector's x, y or z
     * value, it is replaced by the corresponding value.
     * If this vector's x, y or z value is less than the min vector's x, y or z value,
     * it is replaced by the corresponding value.
     *
     * @param {Vector3} min - The minimum x, y and z values.
     * @param {Vector3} max - The maximum x, y and z values in the desired range.
     * @return {Vector3} A reference to this vector.
     */
    clamp(min, max2) {
      this.x = clamp(this.x, min.x, max2.x);
      this.y = clamp(this.y, min.y, max2.y);
      this.z = clamp(this.z, min.z, max2.z);
      return this;
    }
    /**
     * If this vector's x, y or z values are greater than the max value, they are
     * replaced by the max value.
     * If this vector's x, y or z values are less than the min value, they are
     * replaced by the min value.
     *
     * @param {number} minVal - The minimum value the components will be clamped to.
     * @param {number} maxVal - The maximum value the components will be clamped to.
     * @return {Vector3} A reference to this vector.
     */
    clampScalar(minVal, maxVal) {
      this.x = clamp(this.x, minVal, maxVal);
      this.y = clamp(this.y, minVal, maxVal);
      this.z = clamp(this.z, minVal, maxVal);
      return this;
    }
    /**
     * If this vector's length is greater than the max value, it is replaced by
     * the max value.
     * If this vector's length is less than the min value, it is replaced by the
     * min value.
     *
     * @param {number} min - The minimum value the vector length will be clamped to.
     * @param {number} max - The maximum value the vector length will be clamped to.
     * @return {Vector3} A reference to this vector.
     */
    clampLength(min, max2) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));
    }
    /**
     * The components of this vector are rounded down to the nearest integer value.
     *
     * @return {Vector3} A reference to this vector.
     */
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    /**
     * The components of this vector are rounded up to the nearest integer value.
     *
     * @return {Vector3} A reference to this vector.
     */
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    /**
     * The components of this vector are rounded to the nearest integer value
     *
     * @return {Vector3} A reference to this vector.
     */
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    /**
     * The components of this vector are rounded towards zero (up if negative,
     * down if positive) to an integer value.
     *
     * @return {Vector3} A reference to this vector.
     */
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      return this;
    }
    /**
     * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
     *
     * @return {Vector3} A reference to this vector.
     */
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    /**
     * Calculates the dot product of the given vector with this instance.
     *
     * @param {Vector3} v - The vector to compute the dot product with.
     * @return {number} The result of the dot product.
     */
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    /**
     * Computes the square of the Euclidean length (straight-line length) from
     * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
     * compare the length squared instead as it is slightly more efficient to calculate.
     *
     * @return {number} The square length of this vector.
     */
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    /**
     * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
     *
     * @return {number} The length of this vector.
     */
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    /**
     * Computes the Manhattan length of this vector.
     *
     * @return {number} The length of this vector.
     */
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    /**
     * Converts this vector to a unit vector - that is, sets it equal to a vector
     * with the same direction as this one, but with a vector length of \`1\`.
     *
     * @return {Vector3} A reference to this vector.
     */
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    /**
     * Sets this vector to a vector with the same direction as this one, but
     * with the specified length.
     *
     * @param {number} length - The new length of this vector.
     * @return {Vector3} A reference to this vector.
     */
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    /**
     * Linearly interpolates between the given vector and this instance, where
     * alpha is the percent distance along the line - alpha = 0 will be this
     * vector, and alpha = 1 will be the given one.
     *
     * @param {Vector3} v - The vector to interpolate towards.
     * @param {number} alpha - The interpolation factor, typically in the closed interval \`[0, 1]\`.
     * @return {Vector3} A reference to this vector.
     */
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
    /**
     * Linearly interpolates between the given vectors, where alpha is the percent
     * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
     * be the second one. The result is stored in this instance.
     *
     * @param {Vector3} v1 - The first vector.
     * @param {Vector3} v2 - The second vector.
     * @param {number} alpha - The interpolation factor, typically in the closed interval \`[0, 1]\`.
     * @return {Vector3} A reference to this vector.
     */
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    /**
     * Calculates the cross product of the given vector with this instance.
     *
     * @param {Vector3} v - The vector to compute the cross product with.
     * @return {Vector3} The result of the cross product.
     */
    cross(v) {
      return this.crossVectors(this, v);
    }
    /**
     * Calculates the cross product of the given vectors and stores the result
     * in this instance.
     *
     * @param {Vector3} a - The first vector.
     * @param {Vector3} b - The second vector.
     * @return {Vector3} A reference to this vector.
     */
    crossVectors(a, b) {
      const ax = a.x, ay = a.y, az = a.z;
      const bx = b.x, by = b.y, bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    /**
     * Projects this vector onto the given one.
     *
     * @param {Vector3} v - The vector to project to.
     * @return {Vector3} A reference to this vector.
     */
    projectOnVector(v) {
      const denominator = v.lengthSq();
      if (denominator === 0) return this.set(0, 0, 0);
      const scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
    /**
     * Projects this vector onto a plane by subtracting this
     * vector projected onto the plane's normal from this vector.
     *
     * @param {Vector3} planeNormal - The plane normal.
     * @return {Vector3} A reference to this vector.
     */
    projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
    /**
     * Reflects this vector off a plane orthogonal to the given normal vector.
     *
     * @param {Vector3} normal - The (normalized) normal vector.
     * @return {Vector3} A reference to this vector.
     */
    reflect(normal) {
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    /**
     * Returns the angle between the given vector and this instance in radians.
     *
     * @param {Vector3} v - The vector to compute the angle with.
     * @return {number} The angle in radians.
     */
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(clamp(theta, -1, 1));
    }
    /**
     * Computes the distance from the given vector to this instance.
     *
     * @param {Vector3} v - The vector to compute the distance to.
     * @return {number} The distance.
     */
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    /**
     * Computes the squared distance from the given vector to this instance.
     * If you are just comparing the distance with another distance, you should compare
     * the distance squared instead as it is slightly more efficient to calculate.
     *
     * @param {Vector3} v - The vector to compute the squared distance to.
     * @return {number} The squared distance.
     */
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    /**
     * Computes the Manhattan distance from the given vector to this instance.
     *
     * @param {Vector3} v - The vector to compute the Manhattan distance to.
     * @return {number} The Manhattan distance.
     */
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    /**
     * Sets the vector components from the given spherical coordinates.
     *
     * @param {Spherical} s - The spherical coordinates.
     * @return {Vector3} A reference to this vector.
     */
    setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    /**
     * Sets the vector components from the given spherical coordinates.
     *
     * @param {number} radius - The radius.
     * @param {number} phi - The phi angle in radians.
     * @param {number} theta - The theta angle in radians.
     * @return {Vector3} A reference to this vector.
     */
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    /**
     * Sets the vector components from the given cylindrical coordinates.
     *
     * @param {Cylindrical} c - The cylindrical coordinates.
     * @return {Vector3} A reference to this vector.
     */
    setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    /**
     * Sets the vector components from the given cylindrical coordinates.
     *
     * @param {number} radius - The radius.
     * @param {number} theta - The theta angle in radians.
     * @param {number} y - The y value.
     * @return {Vector3} A reference to this vector.
     */
    setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
    /**
     * Sets the vector components to the position elements of the
     * given transformation matrix.
     *
     * @param {Matrix4} m - The 4x4 matrix.
     * @return {Vector3} A reference to this vector.
     */
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
    /**
     * Sets the vector components to the scale elements of the
     * given transformation matrix.
     *
     * @param {Matrix4} m - The 4x4 matrix.
     * @return {Vector3} A reference to this vector.
     */
    setFromMatrixScale(m) {
      const sx = this.setFromMatrixColumn(m, 0).length();
      const sy = this.setFromMatrixColumn(m, 1).length();
      const sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    /**
     * Sets the vector components from the specified matrix column.
     *
     * @param {Matrix4} m - The 4x4 matrix.
     * @param {number} index - The column index.
     * @return {Vector3} A reference to this vector.
     */
    setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
    /**
     * Sets the vector components from the specified matrix column.
     *
     * @param {Matrix3} m - The 3x3 matrix.
     * @param {number} index - The column index.
     * @return {Vector3} A reference to this vector.
     */
    setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
    /**
     * Sets the vector components from the given Euler angles.
     *
     * @param {Euler} e - The Euler angles to set.
     * @return {Vector3} A reference to this vector.
     */
    setFromEuler(e) {
      this.x = e._x;
      this.y = e._y;
      this.z = e._z;
      return this;
    }
    /**
     * Sets the vector components from the RGB components of the
     * given color.
     *
     * @param {Color} c - The color to set.
     * @return {Vector3} A reference to this vector.
     */
    setFromColor(c) {
      this.x = c.r;
      this.y = c.g;
      this.z = c.b;
      return this;
    }
    /**
     * Returns \`true\` if this vector is equal with the given one.
     *
     * @param {Vector3} v - The vector to test for equality.
     * @return {boolean} Whether this vector is equal with the given one.
     */
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    /**
     * Sets this vector's x value to be \`array[ offset ]\`, y value to be \`array[ offset + 1 ]\`
     * and z value to be \`array[ offset + 2 ]\`.
     *
     * @param {Array<number>} array - An array holding the vector component values.
     * @param {number} [offset=0] - The offset into the array.
     * @return {Vector3} A reference to this vector.
     */
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    /**
     * Writes the components of this vector to the given array. If no array is provided,
     * the method returns a new instance.
     *
     * @param {Array<number>} [array=[]] - The target array holding the vector components.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Array<number>} The vector components.
     */
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    /**
     * Sets the components of this vector from the given buffer attribute.
     *
     * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
     * @param {number} index - The index into the attribute.
     * @return {Vector3} A reference to this vector.
     */
    fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
    /**
     * Sets each component of this vector to a pseudo-random value between \`0\` and
     * \`1\`, excluding \`1\`.
     *
     * @return {Vector3} A reference to this vector.
     */
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
    /**
     * Sets this vector to a uniformly random point on a unit sphere.
     *
     * @return {Vector3} A reference to this vector.
     */
    randomDirection() {
      const theta = Math.random() * Math.PI * 2;
      const u = Math.random() * 2 - 1;
      const c = Math.sqrt(1 - u * u);
      this.x = c * Math.cos(theta);
      this.y = u;
      this.z = c * Math.sin(theta);
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
    }
  }
  const _vector$c = /* @__PURE__ */ new Vector3();
  const _quaternion$4 = /* @__PURE__ */ new Quaternion();
  class Matrix3 {
    /**
     * Constructs a new 3x3 matrix. The arguments are supposed to be
     * in row-major order. If no arguments are provided, the constructor
     * initializes the matrix as an identity matrix.
     *
     * @param {number} [n11] - 1-1 matrix element.
     * @param {number} [n12] - 1-2 matrix element.
     * @param {number} [n13] - 1-3 matrix element.
     * @param {number} [n21] - 2-1 matrix element.
     * @param {number} [n22] - 2-2 matrix element.
     * @param {number} [n23] - 2-3 matrix element.
     * @param {number} [n31] - 3-1 matrix element.
     * @param {number} [n32] - 3-2 matrix element.
     * @param {number} [n33] - 3-3 matrix element.
     */
    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      Matrix3.prototype.isMatrix3 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (n11 !== void 0) {
        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
      }
    }
    /**
     * Sets the elements of the matrix.The arguments are supposed to be
     * in row-major order.
     *
     * @param {number} [n11] - 1-1 matrix element.
     * @param {number} [n12] - 1-2 matrix element.
     * @param {number} [n13] - 1-3 matrix element.
     * @param {number} [n21] - 2-1 matrix element.
     * @param {number} [n22] - 2-2 matrix element.
     * @param {number} [n23] - 2-3 matrix element.
     * @param {number} [n31] - 3-1 matrix element.
     * @param {number} [n32] - 3-2 matrix element.
     * @param {number} [n33] - 3-3 matrix element.
     * @return {Matrix3} A reference to this matrix.
     */
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
    /**
     * Sets this matrix to the 3x3 identity matrix.
     *
     * @return {Matrix3} A reference to this matrix.
     */
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      );
      return this;
    }
    /**
     * Copies the values of the given matrix to this instance.
     *
     * @param {Matrix3} m - The matrix to copy.
     * @return {Matrix3} A reference to this matrix.
     */
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
    /**
     * Extracts the basis of this matrix into the three axis vectors provided.
     *
     * @param {Vector3} xAxis - The basis's x axis.
     * @param {Vector3} yAxis - The basis's y axis.
     * @param {Vector3} zAxis - The basis's z axis.
     * @return {Matrix3} A reference to this matrix.
     */
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    /**
     * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
     *
     * @param {Matrix4} m - The 4x4 matrix.
     * @return {Matrix3} A reference to this matrix.
     */
    setFromMatrix4(m) {
      const me = m.elements;
      this.set(
        me[0],
        me[4],
        me[8],
        me[1],
        me[5],
        me[9],
        me[2],
        me[6],
        me[10]
      );
      return this;
    }
    /**
     * Post-multiplies this matrix by the given 3x3 matrix.
     *
     * @param {Matrix3} m - The matrix to multiply with.
     * @return {Matrix3} A reference to this matrix.
     */
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    /**
     * Pre-multiplies this matrix by the given 3x3 matrix.
     *
     * @param {Matrix3} m - The matrix to multiply with.
     * @return {Matrix3} A reference to this matrix.
     */
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    /**
     * Multiples the given 3x3 matrices and stores the result
     * in this matrix.
     *
     * @param {Matrix3} a - The first matrix.
     * @param {Matrix3} b - The second matrix.
     * @return {Matrix3} A reference to this matrix.
     */
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[3], a13 = ae[6];
      const a21 = ae[1], a22 = ae[4], a23 = ae[7];
      const a31 = ae[2], a32 = ae[5], a33 = ae[8];
      const b11 = be[0], b12 = be[3], b13 = be[6];
      const b21 = be[1], b22 = be[4], b23 = be[7];
      const b31 = be[2], b32 = be[5], b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    /**
     * Multiplies every component of the matrix by the given scalar.
     *
     * @param {number} s - The scalar.
     * @return {Matrix3} A reference to this matrix.
     */
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
    /**
     * Computes and returns the determinant of this matrix.
     *
     * @return {number} The determinant.
     */
    determinant() {
      const te = this.elements;
      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
    }
    /**
     * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
     * You can not invert with a determinant of zero. If you attempt this, the method produces
     * a zero matrix instead.
     *
     * @return {Matrix3} A reference to this matrix.
     */
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    /**
     * Transposes this matrix in place.
     *
     * @return {Matrix3} A reference to this matrix.
     */
    transpose() {
      let tmp;
      const m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    }
    /**
     * Computes the normal matrix which is the inverse transpose of the upper
     * left 3x3 portion of the given 4x4 matrix.
     *
     * @param {Matrix4} matrix4 - The 4x4 matrix.
     * @return {Matrix3} A reference to this matrix.
     */
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
    /**
     * Transposes this matrix into the supplied array, and returns itself unchanged.
     *
     * @param {Array<number>} r - An array to store the transposed matrix elements.
     * @return {Matrix3} A reference to this matrix.
     */
    transposeIntoArray(r) {
      const m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
    /**
     * Sets the UV transform matrix from offset, repeat, rotation, and center.
     *
     * @param {number} tx - Offset x.
     * @param {number} ty - Offset y.
     * @param {number} sx - Repeat x.
     * @param {number} sy - Repeat y.
     * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
     * @param {number} cx - Center x of rotation.
     * @param {number} cy - Center y of rotation
     * @return {Matrix3} A reference to this matrix.
     */
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c = Math.cos(rotation);
      const s = Math.sin(rotation);
      this.set(
        sx * c,
        sx * s,
        -sx * (c * cx + s * cy) + cx + tx,
        -sy * s,
        sy * c,
        -sy * (-s * cx + c * cy) + cy + ty,
        0,
        0,
        1
      );
      return this;
    }
    /**
     * Scales this matrix with the given scalar values.
     *
     * @param {number} sx - The amount to scale in the X axis.
     * @param {number} sy - The amount to scale in the Y axis.
     * @return {Matrix3} A reference to this matrix.
     */
    scale(sx, sy) {
      this.premultiply(_m3.makeScale(sx, sy));
      return this;
    }
    /**
     * Rotates this matrix by the given angle.
     *
     * @param {number} theta - The rotation in radians.
     * @return {Matrix3} A reference to this matrix.
     */
    rotate(theta) {
      this.premultiply(_m3.makeRotation(-theta));
      return this;
    }
    /**
     * Translates this matrix by the given scalar values.
     *
     * @param {number} tx - The amount to translate in the X axis.
     * @param {number} ty - The amount to translate in the Y axis.
     * @return {Matrix3} A reference to this matrix.
     */
    translate(tx, ty) {
      this.premultiply(_m3.makeTranslation(tx, ty));
      return this;
    }
    // for 2D Transforms
    /**
     * Sets this matrix as a 2D translation transform.
     *
     * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
     * @param {number} y - The amount to translate in the Y axis.
     * @return {Matrix3} A reference to this matrix.
     */
    makeTranslation(x2, y) {
      if (x2.isVector2) {
        this.set(
          1,
          0,
          x2.x,
          0,
          1,
          x2.y,
          0,
          0,
          1
        );
      } else {
        this.set(
          1,
          0,
          x2,
          0,
          1,
          y,
          0,
          0,
          1
        );
      }
      return this;
    }
    /**
     * Sets this matrix as a 2D rotational transformation.
     *
     * @param {number} theta - The rotation in radians.
     * @return {Matrix3} A reference to this matrix.
     */
    makeRotation(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      this.set(
        c,
        -s,
        0,
        s,
        c,
        0,
        0,
        0,
        1
      );
      return this;
    }
    /**
     * Sets this matrix as a 2D scale transform.
     *
     * @param {number} x - The amount to scale in the X axis.
     * @param {number} y - The amount to scale in the Y axis.
     * @return {Matrix3} A reference to this matrix.
     */
    makeScale(x2, y) {
      this.set(
        x2,
        0,
        0,
        0,
        y,
        0,
        0,
        0,
        1
      );
      return this;
    }
    /**
     * Returns \`true\` if this matrix is equal with the given one.
     *
     * @param {Matrix3} matrix - The matrix to test for equality.
     * @return {boolean} Whether this matrix is equal with the given one.
     */
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i2 = 0; i2 < 9; i2++) {
        if (te[i2] !== me[i2]) return false;
      }
      return true;
    }
    /**
     * Sets the elements of the matrix from the given array.
     *
     * @param {Array<number>} array - The matrix elements in column-major order.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Matrix3} A reference to this matrix.
     */
    fromArray(array, offset = 0) {
      for (let i2 = 0; i2 < 9; i2++) {
        this.elements[i2] = array[i2 + offset];
      }
      return this;
    }
    /**
     * Writes the elements of this matrix to the given array. If no array is provided,
     * the method returns a new instance.
     *
     * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Array<number>} The matrix elements in column-major order.
     */
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
    /**
     * Returns a matrix with copied values from this instance.
     *
     * @return {Matrix3} A clone of this instance.
     */
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const _m3 = /* @__PURE__ */ new Matrix3();
  const _cache = {};
  function warnOnce(message) {
    if (message in _cache) return;
    _cache[message] = true;
    console.warn(message);
  }
  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  );
  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
  function createColorManagement() {
    const ColorManagement2 = {
      enabled: true,
      workingColorSpace: LinearSRGBColorSpace,
      /**
       * Implementations of supported color spaces.
       *
       * Required:
       *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
       *	- whitePoint: reference white [ x y ]
       *	- transfer: transfer function (pre-defined)
       *	- toXYZ: Matrix3 RGB to XYZ transform
       *	- fromXYZ: Matrix3 XYZ to RGB transform
       *	- luminanceCoefficients: RGB luminance coefficients
       *
       * Optional:
       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
       *
       * Reference:
       * - https://www.russellcottrell.com/photo/matrixCalculator.htm
       */
      spaces: {},
      convert: function(color, sourceColorSpace, targetColorSpace) {
        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
          return color;
        }
        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
          color.r = SRGBToLinear(color.r);
          color.g = SRGBToLinear(color.g);
          color.b = SRGBToLinear(color.b);
        }
        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
        }
        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
          color.r = LinearToSRGB(color.r);
          color.g = LinearToSRGB(color.g);
          color.b = LinearToSRGB(color.b);
        }
        return color;
      },
      workingToColorSpace: function(color, targetColorSpace) {
        return this.convert(color, this.workingColorSpace, targetColorSpace);
      },
      colorSpaceToWorking: function(color, sourceColorSpace) {
        return this.convert(color, sourceColorSpace, this.workingColorSpace);
      },
      getPrimaries: function(colorSpace) {
        return this.spaces[colorSpace].primaries;
      },
      getTransfer: function(colorSpace) {
        if (colorSpace === NoColorSpace) return LinearTransfer;
        return this.spaces[colorSpace].transfer;
      },
      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
      },
      define: function(colorSpaces) {
        Object.assign(this.spaces, colorSpaces);
      },
      // Internal APIs
      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
      },
      _getDrawingBufferColorSpace: function(colorSpace) {
        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
      },
      // Deprecated
      fromWorkingColorSpace: function(color, targetColorSpace) {
        warnOnce("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().");
        return ColorManagement2.workingToColorSpace(color, targetColorSpace);
      },
      toWorkingColorSpace: function(color, sourceColorSpace) {
        warnOnce("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().");
        return ColorManagement2.colorSpaceToWorking(color, sourceColorSpace);
      }
    };
    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
    const D65 = [0.3127, 0.329];
    ColorManagement2.define({
      [LinearSRGBColorSpace]: {
        primaries: REC709_PRIMARIES,
        whitePoint: D65,
        transfer: LinearTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
      },
      [SRGBColorSpace]: {
        primaries: REC709_PRIMARIES,
        whitePoint: D65,
        transfer: SRGBTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
      }
    });
    return ColorManagement2;
  }
  const ColorManagement = /* @__PURE__ */ createColorManagement();
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  class Box3 {
    /**
     * Constructs a new bounding box.
     *
     * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
     * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
     */
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {
      this.isBox3 = true;
      this.min = min;
      this.max = max2;
    }
    /**
     * Sets the lower and upper boundaries of this box.
     * Please note that this method only copies the values from the given objects.
     *
     * @param {Vector3} min - The lower boundary of the box.
     * @param {Vector3} max - The upper boundary of the box.
     * @return {Box3} A reference to this bounding box.
     */
    set(min, max2) {
      this.min.copy(min);
      this.max.copy(max2);
      return this;
    }
    /**
     * Sets the upper and lower bounds of this box so it encloses the position data
     * in the given array.
     *
     * @param {Array<number>} array - An array holding 3D position data.
     * @return {Box3} A reference to this bounding box.
     */
    setFromArray(array) {
      this.makeEmpty();
      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {
        this.expandByPoint(_vector$b.fromArray(array, i2));
      }
      return this;
    }
    /**
     * Sets the upper and lower bounds of this box so it encloses the position data
     * in the given buffer attribute.
     *
     * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
     * @return {Box3} A reference to this bounding box.
     */
    setFromBufferAttribute(attribute) {
      this.makeEmpty();
      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {
        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));
      }
      return this;
    }
    /**
     * Sets the upper and lower bounds of this box so it encloses the position data
     * in the given array.
     *
     * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
     * @return {Box3} A reference to this bounding box.
     */
    setFromPoints(points) {
      this.makeEmpty();
      for (let i2 = 0, il = points.length; i2 < il; i2++) {
        this.expandByPoint(points[i2]);
      }
      return this;
    }
    /**
     * Centers this box on the given center vector and sets this box's width, height and
     * depth to the given size values.
     *
     * @param {Vector3} center - The center of the box.
     * @param {Vector3} size - The x, y and z dimensions of the box.
     * @return {Box3} A reference to this bounding box.
     */
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    /**
     * Computes the world-axis-aligned bounding box for the given 3D object
     * (including its children), accounting for the object's, and children's,
     * world transforms. The function may result in a larger box than strictly necessary.
     *
     * @param {Object3D} object - The 3D object to compute the bounding box for.
     * @param {boolean} [precise=false] - If set to \`true\`, the method computes the smallest
     * world-axis-aligned bounding box at the expense of more computation.
     * @return {Box3} A reference to this bounding box.
     */
    setFromObject(object, precise = false) {
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
    /**
     * Returns a new box with copied values from this instance.
     *
     * @return {Box3} A clone of this instance.
     */
    clone() {
      return new this.constructor().copy(this);
    }
    /**
     * Copies the values of the given box to this instance.
     *
     * @param {Box3} box - The box to copy.
     * @return {Box3} A reference to this bounding box.
     */
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    /**
     * Makes this box empty which means in encloses a zero space in 3D.
     *
     * @return {Box3} A reference to this bounding box.
     */
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    /**
     * Returns true if this box includes zero points within its bounds.
     * Note that a box with equal lower and upper bounds still includes one
     * point, the one both bounds share.
     *
     * @return {boolean} Whether this box is empty or not.
     */
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    /**
     * Returns the center point of this box.
     *
     * @param {Vector3} target - The target vector that is used to store the method's result.
     * @return {Vector3} The center point.
     */
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    /**
     * Returns the dimensions of this box.
     *
     * @param {Vector3} target - The target vector that is used to store the method's result.
     * @return {Vector3} The size.
     */
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    /**
     * Expands the boundaries of this box to include the given point.
     *
     * @param {Vector3} point - The point that should be included by the bounding box.
     * @return {Box3} A reference to this bounding box.
     */
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    /**
     * Expands this box equilaterally by the given vector. The width of this
     * box will be expanded by the x component of the vector in both
     * directions. The height of this box will be expanded by the y component of
     * the vector in both directions. The depth of this box will be
     * expanded by the z component of the vector in both directions.
     *
     * @param {Vector3} vector - The vector that should expand the bounding box.
     * @return {Box3} A reference to this bounding box.
     */
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    /**
     * Expands each dimension of the box by the given scalar. If negative, the
     * dimensions of the box will be contracted.
     *
     * @param {number} scalar - The scalar value that should expand the bounding box.
     * @return {Box3} A reference to this bounding box.
     */
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    /**
     * Expands the boundaries of this box to include the given 3D object and
     * its children, accounting for the object's, and children's, world
     * transforms. The function may result in a larger box than strictly
     * necessary (unless the precise parameter is set to true).
     *
     * @param {Object3D} object - The 3D object that should expand the bounding box.
     * @param {boolean} precise - If set to \`true\`, the method expands the bounding box
     * as little as necessary at the expense of more computation.
     * @return {Box3} A reference to this bounding box.
     */
    expandByObject(object, precise = false) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        const positionAttribute = geometry.getAttribute("position");
        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {
            if (object.isMesh === true) {
              object.getVertexPosition(i2, _vector$b);
            } else {
              _vector$b.fromBufferAttribute(positionAttribute, i2);
            }
            _vector$b.applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$b);
          }
        } else {
          if (object.boundingBox !== void 0) {
            if (object.boundingBox === null) {
              object.computeBoundingBox();
            }
            _box$4.copy(object.boundingBox);
          } else {
            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$4.copy(geometry.boundingBox);
          }
          _box$4.applyMatrix4(object.matrixWorld);
          this.union(_box$4);
        }
      }
      const children = object.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        this.expandByObject(children[i2], precise);
      }
      return this;
    }
    /**
     * Returns \`true\` if the given point lies within or on the boundaries of this box.
     *
     * @param {Vector3} point - The point to test.
     * @return {boolean} Whether the bounding box contains the given point or not.
     */
    containsPoint(point) {
      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
    }
    /**
     * Returns \`true\` if this bounding box includes the entirety of the given bounding box.
     * If this box and the given one are identical, this function also returns \`true\`.
     *
     * @param {Box3} box - The bounding box to test.
     * @return {boolean} Whether the bounding box contains the given bounding box or not.
     */
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    /**
     * Returns a point as a proportion of this box's width, height and depth.
     *
     * @param {Vector3} point - A point in 3D space.
     * @param {Vector3} target - The target vector that is used to store the method's result.
     * @return {Vector3} A point as a proportion of this box's width, height and depth.
     */
    getParameter(point, target) {
      return target.set(
        (point.x - this.min.x) / (this.max.x - this.min.x),
        (point.y - this.min.y) / (this.max.y - this.min.y),
        (point.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    /**
     * Returns \`true\` if the given bounding box intersects with this bounding box.
     *
     * @param {Box3} box - The bounding box to test.
     * @return {boolean} Whether the given bounding box intersects with this bounding box.
     */
    intersectsBox(box) {
      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
    }
    /**
     * Returns \`true\` if the given bounding sphere intersects with this bounding box.
     *
     * @param {Sphere} sphere - The bounding sphere to test.
     * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
     */
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$b);
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    /**
     * Returns \`true\` if the given plane intersects with this bounding box.
     *
     * @param {Plane} plane - The plane to test.
     * @return {boolean} Whether the given plane intersects with this bounding box.
     */
    intersectsPlane(plane) {
      let min, max2;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max2 = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max2 = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max2 += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max2 += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max2 += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max2 += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max2 >= -plane.constant;
    }
    /**
     * Returns \`true\` if the given triangle intersects with this bounding box.
     *
     * @param {Triangle} triangle - The triangle to test.
     * @return {boolean} Whether the given triangle intersects with this bounding box.
     */
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$4.subVectors(triangle.c, _center);
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$4, _v1$7);
      _f2.subVectors(_v0$2, _v2$4);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
    }
    /**
     * Clamps the given point within the bounds of this box.
     *
     * @param {Vector3} point - The point to clamp.
     * @param {Vector3} target - The target vector that is used to store the method's result.
     * @return {Vector3} The clamped point.
     */
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    /**
     * Returns the euclidean distance from any edge of this box to the specified point. If
     * the given point lies inside of this box, the distance will be \`0\`.
     *
     * @param {Vector3} point - The point to compute the distance to.
     * @return {number} The euclidean distance.
     */
    distanceToPoint(point) {
      return this.clampPoint(point, _vector$b).distanceTo(point);
    }
    /**
     * Returns a bounding sphere that encloses this bounding box.
     *
     * @param {Sphere} target - The target sphere that is used to store the method's result.
     * @return {Sphere} The bounding sphere that encloses this bounding box.
     */
    getBoundingSphere(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
      } else {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
      }
      return target;
    }
    /**
     * Computes the intersection of this bounding box and the given one, setting the upper
     * bound of this box to the lesser of the two boxes' upper bounds and the
     * lower bound of this box to the greater of the two boxes' lower bounds. If
     * there's no overlap, makes this box empty.
     *
     * @param {Box3} box - The bounding box to intersect with.
     * @return {Box3} A reference to this bounding box.
     */
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty()) this.makeEmpty();
      return this;
    }
    /**
     * Computes the union of this box and another and the given one, setting the upper
     * bound of this box to the greater of the two boxes' upper bounds and the
     * lower bound of this box to the lesser of the two boxes' lower bounds.
     *
     * @param {Box3} box - The bounding box that will be unioned with this instance.
     * @return {Box3} A reference to this bounding box.
     */
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    /**
     * Transforms this bounding box by the given 4x4 transformation matrix.
     *
     * @param {Matrix4} matrix - The transformation matrix.
     * @return {Box3} A reference to this bounding box.
     */
    applyMatrix4(matrix) {
      if (this.isEmpty()) return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    /**
     * Adds the given offset to both the upper and lower bounds of this bounding box,
     * effectively moving it in 3D space.
     *
     * @param {Vector3} offset - The offset that should be used to translate the bounding box.
     * @return {Box3} A reference to this bounding box.
     */
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    /**
     * Returns \`true\` if this bounding box is equal with the given one.
     *
     * @param {Box3} box - The box to test for equality.
     * @return {boolean} Whether this bounding box is equal with the given one.
     */
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
    /**
     * Returns a serialized structure of the bounding box.
     *
     * @return {Object} Serialized structure with fields representing the object state.
     */
    toJSON() {
      return {
        min: this.min.toArray(),
        max: this.max.toArray()
      };
    }
    /**
     * Returns a serialized structure of the bounding box.
     *
     * @param {Object} json - The serialized json to set the box from.
     * @return {Box3} A reference to this bounding box.
     */
    fromJSON(json) {
      this.min.fromArray(json.min);
      this.max.fromArray(json.max);
      return this;
    }
  }
  const _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  const _vector$b = /* @__PURE__ */ new Vector3();
  const _box$4 = /* @__PURE__ */ new Box3();
  const _v0$2 = /* @__PURE__ */ new Vector3();
  const _v1$7 = /* @__PURE__ */ new Vector3();
  const _v2$4 = /* @__PURE__ */ new Vector3();
  const _f0 = /* @__PURE__ */ new Vector3();
  const _f1 = /* @__PURE__ */ new Vector3();
  const _f2 = /* @__PURE__ */ new Vector3();
  const _center = /* @__PURE__ */ new Vector3();
  const _extents = /* @__PURE__ */ new Vector3();
  const _triangleNormal = /* @__PURE__ */ new Vector3();
  const _testAxis = /* @__PURE__ */ new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
      _testAxis.fromArray(axes, i2);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  const _colorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  const _hslA = { h: 0, s: 0, l: 0 };
  const _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  class Color {
    /**
     * Constructs a new color.
     *
     * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
     * and that method is used throughout the rest of the documentation.
     *
     * @param {(number|string|Color)} [r] - The red component of the color. If \`g\` and \`b\` are
     * not provided, it can be hexadecimal triplet, a CSS-style string or another \`Color\` instance.
     * @param {number} [g] - The green component.
     * @param {number} [b] - The blue component.
     */
    constructor(r, g, b) {
      this.isColor = true;
      this.r = 1;
      this.g = 1;
      this.b = 1;
      return this.set(r, g, b);
    }
    /**
     * Sets the colors's components from the given values.
     *
     * @param {(number|string|Color)} [r] - The red component of the color. If \`g\` and \`b\` are
     * not provided, it can be hexadecimal triplet, a CSS-style string or another \`Color\` instance.
     * @param {number} [g] - The green component.
     * @param {number} [b] - The blue component.
     * @return {Color} A reference to this color.
     */
    set(r, g, b) {
      if (g === void 0 && b === void 0) {
        const value = r;
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
      } else {
        this.setRGB(r, g, b);
      }
      return this;
    }
    /**
     * Sets the colors's components to the given scalar value.
     *
     * @param {number} scalar - The scalar value.
     * @return {Color} A reference to this color.
     */
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    /**
     * Sets this color from a hexadecimal value.
     *
     * @param {number} hex - The hexadecimal value.
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setHex(hex, colorSpace = SRGBColorSpace) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.colorSpaceToWorking(this, colorSpace);
      return this;
    }
    /**
     * Sets this color from RGB values.
     *
     * @param {number} r - Red channel value between \`0.0\` and \`1.0\`.
     * @param {number} g - Green channel value between \`0.0\` and \`1.0\`.
     * @param {number} b - Blue channel value between \`0.0\` and \`1.0\`.
     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
      this.r = r;
      this.g = g;
      this.b = b;
      ColorManagement.colorSpaceToWorking(this, colorSpace);
      return this;
    }
    /**
     * Sets this color from RGB values.
     *
     * @param {number} h - Hue value between \`0.0\` and \`1.0\`.
     * @param {number} s - Saturation value between \`0.0\` and \`1.0\`.
     * @param {number} l - Lightness value between \`0.0\` and \`1.0\`.
     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
      h = euclideanModulo(h, 1);
      s = clamp(s, 0, 1);
      l = clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        const q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      ColorManagement.colorSpaceToWorking(this, colorSpace);
      return this;
    }
    /**
     * Sets this color from a CSS-style string. For example, \`rgb(250, 0,0)\`,
     * \`rgb(100%, 0%, 0%)\`, \`hsl(0, 100%, 50%)\`, \`#ff0000\`, \`#f00\`, or \`red\` ( or
     * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
     * all 140 color names are supported).
     *
     * @param {string} style - Color as a CSS-style string.
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setStyle(style, colorSpace = SRGBColorSpace) {
      function handleAlpha(string) {
        if (string === void 0) return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m;
      if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {
        let color;
        const name = m[1];
        const components = m[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(255, parseInt(color[1], 10)) / 255,
                Math.min(255, parseInt(color[2], 10)) / 255,
                Math.min(255, parseInt(color[3], 10)) / 255,
                colorSpace
              );
            }
            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(100, parseInt(color[1], 10)) / 100,
                Math.min(100, parseInt(color[2], 10)) / 100,
                Math.min(100, parseInt(color[3], 10)) / 100,
                colorSpace
              );
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setHSL(
                parseFloat(color[1]) / 360,
                parseFloat(color[2]) / 100,
                parseFloat(color[3]) / 100,
                colorSpace
              );
            }
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + style);
        }
      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {
        const hex = m[1];
        const size = hex.length;
        if (size === 3) {
          return this.setRGB(
            parseInt(hex.charAt(0), 16) / 15,
            parseInt(hex.charAt(1), 16) / 15,
            parseInt(hex.charAt(2), 16) / 15,
            colorSpace
          );
        } else if (size === 6) {
          return this.setHex(parseInt(hex, 16), colorSpace);
        } else {
          console.warn("THREE.Color: Invalid hex color " + style);
        }
      } else if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }
      return this;
    }
    /**
     * Sets this color from a color name. Faster than {@link Color#setStyle} if
     * you don't need the other CSS-style formats.
     *
     * For convenience, the list of names is exposed in \`Color.NAMES\` as a hash.
     * \`\`\`js
     * Color.NAMES.aliceblue // returns 0xF0F8FF
     * \`\`\`
     *
     * @param {string} style - The color name.
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setColorName(style, colorSpace = SRGBColorSpace) {
      const hex = _colorKeywords[style.toLowerCase()];
      if (hex !== void 0) {
        this.setHex(hex, colorSpace);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    /**
     * Returns a new color with copied values from this instance.
     *
     * @return {Color} A clone of this instance.
     */
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    /**
     * Copies the values of the given color to this instance.
     *
     * @param {Color} color - The color to copy.
     * @return {Color} A reference to this color.
     */
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    /**
     * Copies the given color into this color, and then converts this color from
     * \`SRGBColorSpace\` to \`LinearSRGBColorSpace\`.
     *
     * @param {Color} color - The color to copy/convert.
     * @return {Color} A reference to this color.
     */
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    /**
     * Copies the given color into this color, and then converts this color from
     * \`LinearSRGBColorSpace\` to \`SRGBColorSpace\`.
     *
     * @param {Color} color - The color to copy/convert.
     * @return {Color} A reference to this color.
     */
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    /**
     * Converts this color from \`SRGBColorSpace\` to \`LinearSRGBColorSpace\`.
     *
     * @return {Color} A reference to this color.
     */
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    /**
     * Converts this color from \`LinearSRGBColorSpace\` to \`SRGBColorSpace\`.
     *
     * @return {Color} A reference to this color.
     */
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    /**
     * Returns the hexadecimal value of this color.
     *
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {number} The hexadecimal value.
     */
    getHex(colorSpace = SRGBColorSpace) {
      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
    }
    /**
     * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
     *
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {string} The hexadecimal value as a string.
     */
    getHexString(colorSpace = SRGBColorSpace) {
      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
    }
    /**
     * Converts the colors RGB values into the HSL format and stores them into the
     * given target object.
     *
     * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
     * @return {{h:number,s:number,l:number}} The HSL representation of this color.
     */
    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
      const r = _color.r, g = _color.g, b = _color.b;
      const max2 = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let hue, saturation;
      const lightness = (min + max2) / 2;
      if (min === max2) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max2 - min;
        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);
        switch (max2) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    /**
     * Returns the RGB values of this color and stores them into the given target object.
     *
     * @param {Color} target - The target color that is used to store the method's result.
     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
     * @return {Color} The RGB representation of this color.
     */
    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
      target.r = _color.r;
      target.g = _color.g;
      target.b = _color.b;
      return target;
    }
    /**
     * Returns the value of this color as a CSS style string. Example: \`rgb(255,0,0)\`.
     *
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {string} The CSS representation of this color.
     */
    getStyle(colorSpace = SRGBColorSpace) {
      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
      const r = _color.r, g = _color.g, b = _color.b;
      if (colorSpace !== SRGBColorSpace) {
        return \`color(\${colorSpace} \${r.toFixed(3)} \${g.toFixed(3)} \${b.toFixed(3)})\`;
      }
      return \`rgb(\${Math.round(r * 255)},\${Math.round(g * 255)},\${Math.round(b * 255)})\`;
    }
    /**
     * Adds the given HSL values to this color's values.
     * Internally, this converts the color's RGB values to HSL, adds HSL
     * and then converts the color back to RGB.
     *
     * @param {number} h - Hue value between \`0.0\` and \`1.0\`.
     * @param {number} s - Saturation value between \`0.0\` and \`1.0\`.
     * @param {number} l - Lightness value between \`0.0\` and \`1.0\`.
     * @return {Color} A reference to this color.
     */
    offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
    }
    /**
     * Adds the RGB values of the given color to the RGB values of this color.
     *
     * @param {Color} color - The color to add.
     * @return {Color} A reference to this color.
     */
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    /**
     * Adds the RGB values of the given colors and stores the result in this instance.
     *
     * @param {Color} color1 - The first color.
     * @param {Color} color2 - The second color.
     * @return {Color} A reference to this color.
     */
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    /**
     * Adds the given scalar value to the RGB values of this color.
     *
     * @param {number} s - The scalar to add.
     * @return {Color} A reference to this color.
     */
    addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
    /**
     * Subtracts the RGB values of the given color from the RGB values of this color.
     *
     * @param {Color} color - The color to subtract.
     * @return {Color} A reference to this color.
     */
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    /**
     * Multiplies the RGB values of the given color with the RGB values of this color.
     *
     * @param {Color} color - The color to multiply.
     * @return {Color} A reference to this color.
     */
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    /**
     * Multiplies the given scalar value with the RGB values of this color.
     *
     * @param {number} s - The scalar to multiply.
     * @return {Color} A reference to this color.
     */
    multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
    /**
     * Linearly interpolates this color's RGB values toward the RGB values of the
     * given color. The alpha argument can be thought of as the ratio between
     * the two colors, where \`0.0\` is this color and \`1.0\` is the first argument.
     *
     * @param {Color} color - The color to converge on.
     * @param {number} alpha - The interpolation factor in the closed interval \`[0,1]\`.
     * @return {Color} A reference to this color.
     */
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    /**
     * Linearly interpolates between the given colors and stores the result in this instance.
     * The alpha argument can be thought of as the ratio between the two colors, where \`0.0\`
     * is the first and \`1.0\` is the second color.
     *
     * @param {Color} color1 - The first color.
     * @param {Color} color2 - The second color.
     * @param {number} alpha - The interpolation factor in the closed interval \`[0,1]\`.
     * @return {Color} A reference to this color.
     */
    lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
    /**
     * Linearly interpolates this color's HSL values toward the HSL values of the
     * given color. It differs from {@link Color#lerp} by not interpolating straight
     * from one color to the other, but instead going through all the hues in between
     * those two colors. The alpha argument can be thought of as the ratio between
     * the two colors, where 0.0 is this color and 1.0 is the first argument.
     *
     * @param {Color} color - The color to converge on.
     * @param {number} alpha - The interpolation factor in the closed interval \`[0,1]\`.
     * @return {Color} A reference to this color.
     */
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h = lerp(_hslA.h, _hslB.h, alpha);
      const s = lerp(_hslA.s, _hslB.s, alpha);
      const l = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
    /**
     * Sets the color's RGB components from the given 3D vector.
     *
     * @param {Vector3} v - The vector to set.
     * @return {Color} A reference to this color.
     */
    setFromVector3(v) {
      this.r = v.x;
      this.g = v.y;
      this.b = v.z;
      return this;
    }
    /**
     * Transforms this color with the given 3x3 matrix.
     *
     * @param {Matrix3} m - The matrix.
     * @return {Color} A reference to this color.
     */
    applyMatrix3(m) {
      const r = this.r, g = this.g, b = this.b;
      const e = m.elements;
      this.r = e[0] * r + e[3] * g + e[6] * b;
      this.g = e[1] * r + e[4] * g + e[7] * b;
      this.b = e[2] * r + e[5] * g + e[8] * b;
      return this;
    }
    /**
     * Returns \`true\` if this color is equal with the given one.
     *
     * @param {Color} c - The color to test for equality.
     * @return {boolean} Whether this bounding color is equal with the given one.
     */
    equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    /**
     * Sets this color's RGB components from the given array.
     *
     * @param {Array<number>} array - An array holding the RGB values.
     * @param {number} [offset=0] - The offset into the array.
     * @return {Color} A reference to this color.
     */
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    /**
     * Writes the RGB components of this color to the given array. If no array is provided,
     * the method returns a new instance.
     *
     * @param {Array<number>} [array=[]] - The target array holding the color components.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Array<number>} The color components.
     */
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    /**
     * Sets the components of this color from the given buffer attribute.
     *
     * @param {BufferAttribute} attribute - The buffer attribute holding color data.
     * @param {number} index - The index into the attribute.
     * @return {Color} A reference to this color.
     */
    fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      return this;
    }
    /**
     * This methods defines the serialization result of this class. Returns the color
     * as a hexadecimal value.
     *
     * @return {number} The hexadecimal value.
     */
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r;
      yield this.g;
      yield this.b;
    }
  }
  const _color = /* @__PURE__ */ new Color();
  Color.NAMES = _colorKeywords;
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
      revision: REVISION
    } }));
  }
  if (typeof window !== "undefined") {
    if (window.__THREE__) {
      console.warn("WARNING: Multiple instances of Three.js being imported.");
    } else {
      window.__THREE__ = REVISION;
    }
  }
  const LN_SCALE_MIN = -12;
  const LN_SCALE_MAX = 9;
  const LN_SCALE_ZERO = -30;
  const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);
  const SPLAT_TEX_WIDTH_BITS = 11;
  const SPLAT_TEX_HEIGHT_BITS = 11;
  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;
  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;
  const SPLAT_TEX_MIN_HEIGHT = 1;
  function unindentLines(s) {
    var _a2;
    let seenNonEmpty = false;
    const lines = s.split("\\n").map((line) => {
      const trimmedLine = line.trimEnd();
      if (seenNonEmpty) {
        return trimmedLine;
      }
      if (trimmedLine.length > 0) {
        seenNonEmpty = true;
        return trimmedLine;
      }
      return null;
    }).filter((line) => line != null);
    while (lines.length > 0 && lines[lines.length - 1].length === 0) {
      lines.pop();
    }
    if (lines.length === 0) {
      return [];
    }
    const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];
    if (!indent) {
      return lines;
    }
    const regex = new RegExp(\`^\${indent}\`);
    return lines.map((line) => line.replace(regex, ""));
  }
  function unindent(s) {
    return unindentLines(s).join("\\n");
  }
  const f32buffer = new Float32Array(1);
  const u32buffer = new Uint32Array(f32buffer.buffer);
  const supportsFloat16Array = "Float16Array" in globalThis;
  const f16buffer = supportsFloat16Array ? new globalThis["Float16Array"](1) : null;
  const u16buffer = new Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);
  function normalize(vec) {
    const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * v, 0));
    return vec.map((v) => v / norm);
  }
  const toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;
  const fromHalf = supportsFloat16Array ? fromHalfNative : fromHalfJS;
  function toHalfNative(f) {
    f16buffer[0] = f;
    return u16buffer[0];
  }
  function toHalfJS(f) {
    f32buffer[0] = f;
    const bits2 = u32buffer[0];
    const sign = bits2 >> 31 & 1;
    const exp = bits2 >> 23 & 255;
    const frac = bits2 & 8388607;
    const halfSign = sign << 15;
    if (exp === 255) {
      if (frac !== 0) {
        return halfSign | 32767;
      }
      return halfSign | 31744;
    }
    const newExp = exp - 127 + 15;
    if (newExp >= 31) {
      return halfSign | 31744;
    }
    if (newExp <= 0) {
      if (newExp < -10) {
        return halfSign;
      }
      const subFrac = (frac | 8388608) >> 1 - newExp + 13;
      return halfSign | subFrac;
    }
    const halfFrac = frac >> 13;
    return halfSign | newExp << 10 | halfFrac;
  }
  function fromHalfNative(u) {
    u16buffer[0] = u;
    return f16buffer[0];
  }
  function fromHalfJS(h) {
    const sign = h >> 15 & 1;
    const exp = h >> 10 & 31;
    const frac = h & 1023;
    let f32bits;
    if (exp === 0) {
      if (frac === 0) {
        f32bits = sign << 31;
      } else {
        let mant = frac;
        let e = -14;
        while ((mant & 1024) === 0) {
          mant <<= 1;
          e--;
        }
        mant &= 1023;
        const newExp = e + 127;
        const newFrac = mant << 13;
        f32bits = sign << 31 | newExp << 23 | newFrac;
      }
    } else if (exp === 31) {
      if (frac === 0) {
        f32bits = sign << 31 | 2139095040;
      } else {
        f32bits = sign << 31 | 2143289344;
      }
    } else {
      const newExp = exp - 15 + 127;
      const newFrac = frac << 13;
      f32bits = sign << 31 | newExp << 23 | newFrac;
    }
    u32buffer[0] = f32bits;
    return f32buffer[0];
  }
  function floatToUint8(v) {
    return Math.max(0, Math.min(255, Math.round(v * 255)));
  }
  function getArrayBuffers(ctx) {
    const buffers = [];
    const seen = /* @__PURE__ */ new Set();
    function traverse(obj) {
      if (obj && typeof obj === "object" && !seen.has(obj)) {
        seen.add(obj);
        if (obj instanceof ArrayBuffer) {
          buffers.push(obj);
        } else if (ArrayBuffer.isView(obj)) {
          buffers.push(obj.buffer);
        } else if (Array.isArray(obj)) {
          obj.forEach(traverse);
        } else {
          Object.values(obj).forEach(traverse);
        }
      }
    }
    traverse(ctx);
    return buffers;
  }
  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b, encoding) {
    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
    const rgbRange = rgbMax - rgbMin;
    const uR = floatToUint8((r - rgbMin) / rgbRange);
    const uG = floatToUint8((g - rgbMin) / rgbRange);
    const uB = floatToUint8((b - rgbMin) / rgbRange);
    const uA = floatToUint8(opacity);
    const uQuat = encodeQuatOctXy88R8(
      tempQuaternion.set(quatX, quatY, quatZ, quatW)
    );
    const uQuatX = uQuat & 255;
    const uQuatY = uQuat >>> 8 & 255;
    const uQuatZ = uQuat >>> 16 & 255;
    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);
    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uCenterX = toHalf(x2);
    const uCenterY = toHalf(y);
    const uCenterZ = toHalf(z);
    const i4 = index * 4;
    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;
    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;
    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;
  }
  function setPackedSplatCenter(packedSplats, index, x2, y, z) {
    const uCenterX = toHalf(x2);
    const uCenterY = toHalf(y);
    const uCenterZ = toHalf(z);
    const i4 = index * 4;
    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;
  }
  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ, encoding) {
    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);
    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const i4 = index * 4;
    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;
  }
  const tempQuaternion = new Quaternion();
  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {
    const uQuat = encodeQuatOctXy88R8(
      tempQuaternion.set(quatX, quatY, quatZ, quatW)
    );
    const uQuatX = uQuat & 255;
    const uQuatY = uQuat >>> 8 & 255;
    const uQuatZ = uQuat >>> 16 & 255;
    const i4 = index * 4;
    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;
    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;
  }
  function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {
    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
    const rgbRange = rgbMax - rgbMin;
    const uR = floatToUint8((r - rgbMin) / rgbRange);
    const uG = floatToUint8((g - rgbMin) / rgbRange);
    const uB = floatToUint8((b - rgbMin) / rgbRange);
    const uA = floatToUint8(a);
    const i4 = index * 4;
    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;
  }
  function setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {
    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
    const rgbRange = rgbMax - rgbMin;
    const uR = floatToUint8((r - rgbMin) / rgbRange);
    const uG = floatToUint8((g - rgbMin) / rgbRange);
    const uB = floatToUint8((b - rgbMin) / rgbRange);
    const i4 = index * 4;
    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;
  }
  function setPackedSplatOpacity(packedSplats, index, opacity) {
    const uA = floatToUint8(opacity);
    const i4 = index * 4;
    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;
  }
  new Vector3();
  new Vector3();
  new Color();
  function getTextureSize(numSplats) {
    const width = SPLAT_TEX_WIDTH;
    const height = Math.max(
      SPLAT_TEX_MIN_HEIGHT,
      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))
    );
    const depth = Math.ceil(numSplats / (width * height));
    const maxSplats = width * height * depth;
    return { width, height, depth, maxSplats };
  }
  function computeMaxSplats(numSplats) {
    const width = SPLAT_TEX_WIDTH;
    const height = Math.max(
      SPLAT_TEX_MIN_HEIGHT,
      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))
    );
    const depth = Math.ceil(numSplats / (width * height));
    return width * height * depth;
  }
  unindent(\`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
\`);
  const tempNormalizedQuaternion = new Quaternion();
  const tempAxis = new Vector3();
  function encodeQuatOctXy88R8(q) {
    const qnorm = tempNormalizedQuaternion.copy(q).normalize();
    if (qnorm.w < 0) {
      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);
    }
    const theta = 2 * Math.acos(qnorm.w);
    const xyz_norm = Math.sqrt(
      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z
    );
    const axis = xyz_norm < 1e-6 ? tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);
    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);
    let p_x = axis.x / sum;
    let p_y = axis.y / sum;
    if (axis.z < 0) {
      const tmp = p_x;
      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);
      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);
    }
    const u_f = p_x * 0.5 + 0.5;
    const v_f = p_y * 0.5 + 0.5;
    const quantU = Math.round(u_f * 255);
    const quantV = Math.round(v_f * 255);
    const angleInt = Math.round(theta * (255 / Math.PI));
    return angleInt << 16 | quantV << 8 | quantU;
  }
  function packSint8Bytes(b0, b1, b22, b3) {
    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));
    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));
    const clampedB2 = Math.max(-127, Math.min(127, b22 * 127));
    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));
    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;
  }
  function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {
    const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;
    const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;
    const sh1Mid = 0.5 * (sh1Min + sh1Max);
    const sh1Scale = 126 / (sh1Max - sh1Min);
    const base = index * 2;
    for (let i2 = 0; i2 < 9; ++i2) {
      const s = (sh1Rgb[i2] - sh1Mid) * sh1Scale;
      const value = Math.round(Math.max(-63, Math.min(63, s))) & 127;
      const bitStart = i2 * 7;
      const bitEnd = bitStart + 7;
      const wordStart = Math.floor(bitStart / 32);
      const bitOffset = bitStart - wordStart * 32;
      const firstWord = value << bitOffset & 4294967295;
      sh1Array[base + wordStart] |= firstWord;
      if (bitEnd > wordStart * 32 + 32) {
        const secondWord = value >>> 32 - bitOffset & 4294967295;
        sh1Array[base + wordStart + 1] |= secondWord;
      }
    }
  }
  function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {
    const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? -1;
    const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? 1;
    const sh2Mid = 0.5 * (sh2Min + sh2Max);
    const sh2Scale = 2 / (sh2Max - sh2Min);
    sh2Array[index * 4 + 0] = packSint8Bytes(
      (sh2Rgb[0] - sh2Mid) * sh2Scale,
      (sh2Rgb[1] - sh2Mid) * sh2Scale,
      (sh2Rgb[2] - sh2Mid) * sh2Scale,
      (sh2Rgb[3] - sh2Mid) * sh2Scale
    );
    sh2Array[index * 4 + 1] = packSint8Bytes(
      (sh2Rgb[4] - sh2Mid) * sh2Scale,
      (sh2Rgb[5] - sh2Mid) * sh2Scale,
      (sh2Rgb[6] - sh2Mid) * sh2Scale,
      (sh2Rgb[7] - sh2Mid) * sh2Scale
    );
    sh2Array[index * 4 + 2] = packSint8Bytes(
      (sh2Rgb[8] - sh2Mid) * sh2Scale,
      (sh2Rgb[9] - sh2Mid) * sh2Scale,
      (sh2Rgb[10] - sh2Mid) * sh2Scale,
      (sh2Rgb[11] - sh2Mid) * sh2Scale
    );
    sh2Array[index * 4 + 3] = packSint8Bytes(
      (sh2Rgb[12] - sh2Mid) * sh2Scale,
      (sh2Rgb[13] - sh2Mid) * sh2Scale,
      (sh2Rgb[14] - sh2Mid) * sh2Scale,
      0
    );
  }
  function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {
    const sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;
    const sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;
    const sh3Mid = 0.5 * (sh3Min + sh3Max);
    const sh3Scale = 62 / (sh3Max - sh3Min);
    const base = index * 4;
    for (let i2 = 0; i2 < 21; ++i2) {
      const s = (sh3Rgb[i2] - sh3Mid) * sh3Scale;
      const value = Math.round(Math.max(-31, Math.min(31, s))) & 63;
      const bitStart = i2 * 6;
      const bitEnd = bitStart + 6;
      const wordStart = Math.floor(bitStart / 32);
      const bitOffset = bitStart - wordStart * 32;
      const firstWord = value << bitOffset & 4294967295;
      sh3Array[base + wordStart] |= firstWord;
      if (bitEnd > wordStart * 32 + 32) {
        const secondWord = value >>> 32 - bitOffset & 4294967295;
        sh3Array[base + wordStart + 1] |= secondWord;
      }
    }
  }
  function decompressPartialGzip(fileBytes, numBytes) {
    const chunks = [];
    let totalBytes = 0;
    let result = null;
    const gunzip = new Gunzip((data, final) => {
      chunks.push(data);
      totalBytes += data.length;
      if (final || totalBytes >= numBytes) {
        const allBytes = new Uint8Array(totalBytes);
        let offset2 = 0;
        for (const chunk of chunks) {
          allBytes.set(chunk, offset2);
          offset2 += chunk.length;
        }
        result = allBytes.slice(0, numBytes);
      }
    });
    const CHUNK_SIZE = 1024;
    let offset = 0;
    while (result == null && offset < fileBytes.length) {
      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);
      gunzip.push(chunk, false);
      offset += CHUNK_SIZE;
    }
    if (result == null) {
      gunzip.push(new Uint8Array(), true);
      if (result == null) {
        throw new Error("Failed to decompress partial gzip");
      }
    }
    return result;
  }
  class GunzipReader {
    constructor({
      fileBytes,
      chunkBytes = 64 * 1024
    }) {
      this.fileBytes = fileBytes;
      this.chunkBytes = chunkBytes;
      this.offset = 0;
      this.chunks = [];
      this.totalBytes = 0;
      this.gunzip = new Gunzip((chunk, _final) => {
        this.chunks.push(chunk);
        this.totalBytes += chunk.length;
      });
    }
    read(numBytes) {
      while (this.totalBytes < numBytes && this.offset < this.fileBytes.length) {
        const end = Math.min(
          this.offset + this.chunkBytes,
          this.fileBytes.length
        );
        this.gunzip.push(this.fileBytes.subarray(this.offset, end), false);
        this.offset = end;
      }
      if (this.totalBytes < numBytes && this.offset >= this.fileBytes.length) {
        this.gunzip.push(new Uint8Array(0), true);
      }
      if (this.totalBytes < numBytes) {
        throw new Error(
          \`Unexpected EOF: needed \${numBytes}, got \${this.totalBytes}\`
        );
      }
      const allBytes = new Uint8Array(this.totalBytes);
      let outOffset = 0;
      for (const chunk of this.chunks) {
        allBytes.set(chunk, outOffset);
        outOffset += chunk.length;
      }
      const result = allBytes.subarray(0, numBytes);
      this.chunks = [allBytes.subarray(numBytes)];
      this.totalBytes -= numBytes;
      return result;
    }
  }
  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {
    const numSplats = Math.floor(fileBytes.length / 32);
    if (numSplats * 32 !== fileBytes.length) {
      throw new Error("Invalid .splat file size");
    }
    initNumSplats(numSplats);
    const f32 = new Float32Array(fileBytes.buffer);
    for (let i2 = 0; i2 < numSplats; ++i2) {
      const i322 = i2 * 32;
      const i8 = i2 * 8;
      const x2 = f32[i8 + 0];
      const y = f32[i8 + 1];
      const z = f32[i8 + 2];
      const scaleX = f32[i8 + 3];
      const scaleY = f32[i8 + 4];
      const scaleZ = f32[i8 + 5];
      const r = fileBytes[i322 + 24] / 255;
      const g = fileBytes[i322 + 25] / 255;
      const b = fileBytes[i322 + 26] / 255;
      const opacity = fileBytes[i322 + 27] / 255;
      const quatW = (fileBytes[i322 + 28] - 128) / 128;
      const quatX = (fileBytes[i322 + 29] - 128) / 128;
      const quatY = (fileBytes[i322 + 30] - 128) / 128;
      const quatZ = (fileBytes[i322 + 31] - 128) / 128;
      splatCallback(
        i2,
        x2,
        y,
        z,
        scaleX,
        scaleY,
        scaleZ,
        quatX,
        quatY,
        quatZ,
        quatW,
        opacity,
        r,
        g,
        b
      );
    }
  }
  function unpackAntiSplat(fileBytes, splatEncoding) {
    let numSplats = 0;
    let maxSplats = 0;
    let packedArray = new Uint32Array(0);
    decodeAntiSplat(
      fileBytes,
      (cbNumSplats) => {
        numSplats = cbNumSplats;
        maxSplats = computeMaxSplats(numSplats);
        packedArray = new Uint32Array(maxSplats * 4);
      },
      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
        setPackedSplat(
          packedArray,
          index,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b,
          splatEncoding
        );
      }
    );
    return { packedArray, numSplats };
  }
  const KSPLAT_COMPRESSION = {
    0: {
      bytesPerCenter: 12,
      bytesPerScale: 12,
      bytesPerRotation: 16,
      bytesPerColor: 4,
      bytesPerSphericalHarmonicsComponent: 4,
      scaleOffsetBytes: 12,
      rotationOffsetBytes: 24,
      colorOffsetBytes: 40,
      sphericalHarmonicsOffsetBytes: 44,
      scaleRange: 1
    },
    1: {
      bytesPerCenter: 6,
      bytesPerScale: 6,
      bytesPerRotation: 8,
      bytesPerColor: 4,
      bytesPerSphericalHarmonicsComponent: 2,
      scaleOffsetBytes: 6,
      rotationOffsetBytes: 12,
      colorOffsetBytes: 20,
      sphericalHarmonicsOffsetBytes: 24,
      scaleRange: 32767
    },
    2: {
      bytesPerCenter: 6,
      bytesPerScale: 6,
      bytesPerRotation: 8,
      bytesPerColor: 4,
      bytesPerSphericalHarmonicsComponent: 1,
      scaleOffsetBytes: 6,
      rotationOffsetBytes: 12,
      colorOffsetBytes: 20,
      sphericalHarmonicsOffsetBytes: 24,
      scaleRange: 32767
    }
  };
  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {
    0: 0,
    1: 9,
    2: 24,
    3: 45
  };
  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {
    var _a2;
    const HEADER_BYTES = 4096;
    const SECTION_BYTES = 1024;
    let headerOffset = 0;
    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);
    headerOffset += HEADER_BYTES;
    const versionMajor = header.getUint8(0);
    const versionMinor = header.getUint8(1);
    if (versionMajor !== 0 || versionMinor < 1) {
      throw new Error(
        \`Unsupported .ksplat version: \${versionMajor}.\${versionMinor}\`
      );
    }
    const maxSectionCount = header.getUint32(4, true);
    header.getUint32(16, true);
    const compressionLevel = header.getUint16(20, true);
    if (compressionLevel < 0 || compressionLevel > 2) {
      throw new Error(\`Invalid .ksplat compression level: \${compressionLevel}\`);
    }
    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;
    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;
    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;
    for (let section = 0; section < maxSectionCount; ++section) {
      let getSh = function(splatOffset, component) {
        if (compressionLevel === 0) {
          return data.getFloat32(
            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,
            true
          );
        }
        if (compressionLevel === 1) {
          return fromHalf(
            data.getUint16(
              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,
              true
            )
          );
        }
        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;
        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);
      };
      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);
      headerOffset += SECTION_BYTES;
      const sectionSplatCount = section2.getUint32(0, true);
      const sectionMaxSplatCount = section2.getUint32(4, true);
      const bucketSize = section2.getUint32(8, true);
      const bucketCount = section2.getUint32(12, true);
      const bucketBlockSize = section2.getFloat32(16, true);
      const bucketStorageSizeBytes = section2.getUint16(20, true);
      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;
      const fullBucketCount = section2.getUint32(32, true);
      const fullBucketSplats = fullBucketCount * bucketSize;
      const partiallyFilledBucketCount = section2.getUint32(36, true);
      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;
      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;
      const sphericalHarmonicsDegree = section2.getUint16(40, true);
      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];
      const {
        bytesPerCenter,
        bytesPerScale,
        bytesPerRotation,
        bytesPerColor,
        bytesPerSphericalHarmonicsComponent,
        scaleOffsetBytes,
        rotationOffsetBytes,
        colorOffsetBytes,
        sphericalHarmonicsOffsetBytes
      } = KSPLAT_COMPRESSION[compressionLevel];
      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;
      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;
      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;
      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];
      const sh2Index = [
        9,
        14,
        19,
        10,
        15,
        20,
        11,
        16,
        21,
        12,
        17,
        22,
        13,
        18,
        23
      ];
      const sh3Index = [
        24,
        31,
        38,
        25,
        32,
        39,
        26,
        33,
        40,
        27,
        34,
        41,
        28,
        35,
        42,
        29,
        36,
        43,
        30,
        37,
        44
      ];
      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;
      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;
      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;
      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;
      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;
      const dataBase = sectionBase + bucketsStorageSizeBytes;
      const data = new DataView(
        fileBytes.buffer,
        dataBase,
        splatDataStorageSizeBytes
      );
      const bucketArray = new Float32Array(
        fileBytes.buffer,
        bucketsBase,
        bucketCount * 3
      );
      const partiallyFilledBucketLengths = new Uint32Array(
        fileBytes.buffer,
        sectionBase,
        partiallyFilledBucketCount
      );
      let partialBucketIndex = fullBucketCount;
      let partialBucketBase = fullBucketSplats;
      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {
        const splatOffset = i2 * bytesPerSplat;
        let bucketIndex;
        if (i2 < fullBucketSplats) {
          bucketIndex = Math.floor(i2 / bucketSize);
        } else {
          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];
          if (i2 >= partialBucketBase + bucketLength) {
            partialBucketIndex += 1;
            partialBucketBase += bucketLength;
          }
          bucketIndex = partialBucketIndex;
        }
        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];
        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];
        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];
        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));
        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));
        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));
        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)
        );
        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)
        );
        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)
        );
        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)
        );
        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;
        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;
        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;
        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;
        splatCallback(
          i2,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b
        );
        if (sphericalHarmonicsDegree >= 1 && sh1) {
          for (const [i22, key] of sh1Index.entries()) {
            sh1[i22] = getSh(splatOffset, key);
          }
          if (sh2) {
            for (const [i22, key] of sh2Index.entries()) {
              sh2[i22] = getSh(splatOffset, key);
            }
          }
          if (sh3) {
            for (const [i22, key] of sh3Index.entries()) {
              sh3[i22] = getSh(splatOffset, key);
            }
          }
          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);
        }
      }
      sectionBase += storageSizeBytes;
    }
  }
  function unpackKsplat(fileBytes, splatEncoding) {
    var _a2;
    const HEADER_BYTES = 4096;
    const SECTION_BYTES = 1024;
    let headerOffset = 0;
    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);
    headerOffset += HEADER_BYTES;
    const versionMajor = header.getUint8(0);
    const versionMinor = header.getUint8(1);
    if (versionMajor !== 0 || versionMinor < 1) {
      throw new Error(
        \`Unsupported .ksplat version: \${versionMajor}.\${versionMinor}\`
      );
    }
    const maxSectionCount = header.getUint32(4, true);
    const splatCount = header.getUint32(16, true);
    const compressionLevel = header.getUint16(20, true);
    if (compressionLevel < 0 || compressionLevel > 2) {
      throw new Error(\`Invalid .ksplat compression level: \${compressionLevel}\`);
    }
    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;
    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;
    const numSplats = splatCount;
    const maxSplats = computeMaxSplats(numSplats);
    const packedArray = new Uint32Array(maxSplats * 4);
    const extra = {};
    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;
    for (let section = 0; section < maxSectionCount; ++section) {
      let getSh = function(splatOffset, component) {
        if (compressionLevel === 0) {
          return data.getFloat32(
            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,
            true
          );
        }
        if (compressionLevel === 1) {
          return fromHalf(
            data.getUint16(
              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,
              true
            )
          );
        }
        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;
        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);
      };
      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);
      headerOffset += SECTION_BYTES;
      const sectionSplatCount = section2.getUint32(0, true);
      const sectionMaxSplatCount = section2.getUint32(4, true);
      const bucketSize = section2.getUint32(8, true);
      const bucketCount = section2.getUint32(12, true);
      const bucketBlockSize = section2.getFloat32(16, true);
      const bucketStorageSizeBytes = section2.getUint16(20, true);
      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;
      const fullBucketCount = section2.getUint32(32, true);
      const fullBucketSplats = fullBucketCount * bucketSize;
      const partiallyFilledBucketCount = section2.getUint32(36, true);
      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;
      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;
      const sphericalHarmonicsDegree = section2.getUint16(40, true);
      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];
      const {
        bytesPerCenter,
        bytesPerScale,
        bytesPerRotation,
        bytesPerColor,
        bytesPerSphericalHarmonicsComponent,
        scaleOffsetBytes,
        rotationOffsetBytes,
        colorOffsetBytes,
        sphericalHarmonicsOffsetBytes
      } = KSPLAT_COMPRESSION[compressionLevel];
      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;
      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;
      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;
      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];
      const sh2Index = [
        9,
        14,
        19,
        10,
        15,
        20,
        11,
        16,
        21,
        12,
        17,
        22,
        13,
        18,
        23
      ];
      const sh3Index = [
        24,
        31,
        38,
        25,
        32,
        39,
        26,
        33,
        40,
        27,
        34,
        41,
        28,
        35,
        42,
        29,
        36,
        43,
        30,
        37,
        44
      ];
      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;
      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;
      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;
      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;
      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;
      const dataBase = sectionBase + bucketsStorageSizeBytes;
      const data = new DataView(
        fileBytes.buffer,
        dataBase,
        splatDataStorageSizeBytes
      );
      const bucketArray = new Float32Array(
        fileBytes.buffer,
        bucketsBase,
        bucketCount * 3
      );
      const partiallyFilledBucketLengths = new Uint32Array(
        fileBytes.buffer,
        sectionBase,
        partiallyFilledBucketCount
      );
      let partialBucketIndex = fullBucketCount;
      let partialBucketBase = fullBucketSplats;
      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {
        const splatOffset = i2 * bytesPerSplat;
        let bucketIndex;
        if (i2 < fullBucketSplats) {
          bucketIndex = Math.floor(i2 / bucketSize);
        } else {
          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];
          if (i2 >= partialBucketBase + bucketLength) {
            partialBucketIndex += 1;
            partialBucketBase += bucketLength;
          }
          bucketIndex = partialBucketIndex;
        }
        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];
        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];
        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];
        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));
        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));
        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));
        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)
        );
        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)
        );
        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)
        );
        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)
        );
        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;
        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;
        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;
        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;
        setPackedSplat(
          packedArray,
          i2,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b,
          splatEncoding
        );
        if (sphericalHarmonicsDegree >= 1) {
          if (sh1) {
            if (!extra.sh1) {
              extra.sh1 = new Uint32Array(numSplats * 2);
            }
            for (const [i22, key] of sh1Index.entries()) {
              sh1[i22] = getSh(splatOffset, key);
            }
            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);
          }
          if (sh2) {
            if (!extra.sh2) {
              extra.sh2 = new Uint32Array(numSplats * 4);
            }
            for (const [i22, key] of sh2Index.entries()) {
              sh2[i22] = getSh(splatOffset, key);
            }
            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);
          }
          if (sh3) {
            if (!extra.sh3) {
              extra.sh3 = new Uint32Array(numSplats * 4);
            }
            for (const [i22, key] of sh3Index.entries()) {
              sh3[i22] = getSh(splatOffset, key);
            }
            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);
          }
        }
      }
      sectionBase += storageSizeBytes;
    }
    return { packedArray, numSplats, extra };
  }
  const PLY_PROPERTY_TYPES = [
    "char",
    "uchar",
    "short",
    "ushort",
    "int",
    "uint",
    "float",
    "double"
  ];
  const _PlyReader = class _PlyReader {
    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
    constructor({ fileBytes }) {
      this.header = "";
      this.littleEndian = true;
      this.elements = {};
      this.comments = [];
      this.data = null;
      this.numSplats = 0;
      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
    }
    // Identify and parse the PLY text header (assumed to be <64KB in size).
    // this.elements will contain all the elements in the file, typically
    // "vertex" contains the Gsplat data.
    async parseHeader() {
      const bufferStream = new ReadableStream({
        start: (controller) => {
          controller.enqueue(this.fileBytes.slice(0, 65536));
          controller.close();
        }
      });
      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();
      this.header = "";
      const headerTerminator = "end_header\\n";
      while (true) {
        const { value, done } = await decoder.read();
        if (done) {
          throw new Error("Failed to read header");
        }
        this.header += value;
        const endHeader = this.header.indexOf(headerTerminator);
        if (endHeader >= 0) {
          this.header = this.header.slice(0, endHeader + headerTerminator.length);
          break;
        }
      }
      const headerLen = new TextEncoder().encode(this.header).length;
      this.data = new DataView(this.fileBytes.buffer, headerLen);
      this.elements = {};
      let curElement = null;
      this.comments = [];
      this.header.trim().split("\\n").forEach((line, lineIndex) => {
        const trimmedLine = line.trim();
        if (lineIndex === 0) {
          if (trimmedLine !== "ply") {
            throw new Error("Invalid PLY header");
          }
          return;
        }
        if (trimmedLine.length === 0) {
          return;
        }
        const fields = trimmedLine.split(" ");
        switch (fields[0]) {
          case "format":
            if (fields[1] === "binary_little_endian") {
              this.littleEndian = true;
            } else if (fields[1] === "binary_big_endian") {
              this.littleEndian = false;
            } else {
              throw new Error(\`Unsupported PLY format: \${fields[1]}\`);
            }
            if (fields[2] !== "1.0") {
              throw new Error(\`Unsupported PLY version: \${fields[2]}\`);
            }
            break;
          case "end_header":
            break;
          case "comment":
            this.comments.push(trimmedLine.slice("comment ".length));
            break;
          case "element": {
            const name = fields[1];
            curElement = {
              name,
              count: Number.parseInt(fields[2]),
              properties: {}
            };
            this.elements[name] = curElement;
            break;
          }
          case "property":
            if (curElement == null) {
              throw new Error("Property must be inside an element");
            }
            if (fields[1] === "list") {
              curElement.properties[fields[4]] = {
                isList: true,
                type: fields[3],
                countType: fields[2]
              };
            } else {
              curElement.properties[fields[2]] = {
                isList: false,
                type: fields[1]
              };
            }
            break;
        }
      });
      if (this.elements.vertex) {
        this.numSplats = this.elements.vertex.count;
      }
    }
    parseData(elementCallback) {
      let offset = 0;
      const data = this.data;
      if (data == null) {
        throw new Error("No data to parse");
      }
      for (const elementName in this.elements) {
        const element = this.elements[elementName];
        const { count, properties } = element;
        const item = createEmptyItem(properties);
        const parseFn = createParseFn(properties, this.littleEndian);
        const callback = elementCallback(element) ?? (() => {
        });
        for (let index = 0; index < count; index++) {
          offset = parseFn(data, offset, item);
          callback(index, item);
        }
      }
    }
    // Parse all the Gsplat data in the PLY file in go, invoking the given
    // callbacks for each Gsplat.
    parseSplats(splatCallback, shCallback) {
      if (this.elements.vertex == null) {
        throw new Error("No vertex element found");
      }
      let isSuperSplat = false;
      const ssChunks = [];
      let numSh = 0;
      let sh1Props = [];
      let sh2Props = [];
      let sh3Props = [];
      let sh1 = void 0;
      let sh2 = void 0;
      let sh3 = void 0;
      function prepareSh() {
        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];
        sh1Props = new Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => k + d * num_f_rest / 3));
        sh2Props = new Array(5).fill(null).flatMap(
          (_, k) => [0, 1, 2].map((_2, d) => 3 + k + d * num_f_rest / 3)
        );
        sh3Props = new Array(7).fill(null).flatMap(
          (_, k) => [0, 1, 2].map((_2, d) => 8 + k + d * num_f_rest / 3)
        );
        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;
        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;
        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;
      }
      function ssShCallback(index, item) {
        if (!sh1) {
          throw new Error("Missing sh1");
        }
        const sh = item.f_rest;
        for (let i2 = 0; i2 < sh1Props.length; i2++) {
          sh1[i2] = sh[sh1Props[i2]] * 8 / 255 - 4;
        }
        if (sh2) {
          for (let i2 = 0; i2 < sh2Props.length; i2++) {
            sh2[i2] = sh[sh2Props[i2]] * 8 / 255 - 4;
          }
        }
        if (sh3) {
          for (let i2 = 0; i2 < sh3Props.length; i2++) {
            sh3[i2] = sh[sh3Props[i2]] * 8 / 255 - 4;
          }
        }
        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);
      }
      function initSuperSplat(element) {
        const {
          min_x,
          min_y,
          min_z,
          max_x,
          max_y,
          max_z,
          min_scale_x,
          min_scale_y,
          min_scale_z,
          max_scale_x,
          max_scale_y,
          max_scale_z
        } = element.properties;
        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {
          throw new Error("Missing PLY chunk properties");
        }
        isSuperSplat = true;
        return (index, item) => {
          const {
            min_x: min_x2,
            min_y: min_y2,
            min_z: min_z2,
            max_x: max_x2,
            max_y: max_y2,
            max_z: max_z2,
            min_scale_x: min_scale_x2,
            min_scale_y: min_scale_y2,
            min_scale_z: min_scale_z2,
            max_scale_x: max_scale_x2,
            max_scale_y: max_scale_y2,
            max_scale_z: max_scale_z2,
            min_r,
            min_g,
            min_b,
            max_r,
            max_g,
            max_b
          } = item;
          ssChunks.push({
            min_x: min_x2,
            min_y: min_y2,
            min_z: min_z2,
            max_x: max_x2,
            max_y: max_y2,
            max_z: max_z2,
            min_scale_x: min_scale_x2,
            min_scale_y: min_scale_y2,
            min_scale_z: min_scale_z2,
            max_scale_x: max_scale_x2,
            max_scale_y: max_scale_y2,
            max_scale_z: max_scale_z2,
            min_r,
            min_g,
            min_b,
            max_r,
            max_g,
            max_b
          });
        };
      }
      function decodeSuperSplat(element) {
        if (shCallback && element.name === "sh") {
          numSh = getNumSh(element.properties);
          prepareSh();
          return ssShCallback;
        }
        if (element.name !== "vertex") {
          return null;
        }
        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;
        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {
          throw new Error(
            "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
          );
        }
        const SQRT2 = Math.sqrt(2);
        return (index, item) => {
          const chunk = ssChunks[index >>> 8];
          if (chunk == null) {
            throw new Error("Missing PLY chunk");
          }
          const {
            min_x,
            min_y,
            min_z,
            max_x,
            max_y,
            max_z,
            min_scale_x,
            min_scale_y,
            min_scale_z,
            max_scale_x,
            max_scale_y,
            max_scale_z,
            min_r,
            min_g,
            min_b,
            max_r,
            max_g,
            max_b
          } = chunk;
          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;
          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;
          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;
          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;
          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;
          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;
          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;
          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));
          const rOrder = packed_rotation2 >>> 30;
          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;
          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;
          const quatZ = rOrder <= 2 ? r2 : rr;
          const quatW = rOrder === 0 ? rr : r0;
          const scaleX = Math.exp(
            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x
          );
          const scaleY = Math.exp(
            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y
          );
          const scaleZ = Math.exp(
            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z
          );
          const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);
          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);
          const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);
          const opacity = (packed_color2 & 255) / 255;
          splatCallback(
            index,
            x2,
            y,
            z,
            scaleX,
            scaleY,
            scaleZ,
            quatX,
            quatY,
            quatZ,
            quatW,
            opacity,
            r,
            g,
            b
          );
        };
      }
      const elementCallback = (element) => {
        if (element.name === "chunk") {
          return initSuperSplat(element);
        }
        if (isSuperSplat) {
          return decodeSuperSplat(element);
        }
        if (element.name !== "vertex") {
          return null;
        }
        const {
          x: x2,
          y,
          z,
          scale_0,
          scale_1,
          scale_2,
          rot_0,
          rot_1,
          rot_2,
          rot_3,
          opacity,
          f_dc_0,
          f_dc_1,
          f_dc_2,
          red,
          green,
          blue,
          alpha
        } = element.properties;
        if (!x2 || !y || !z) {
          throw new Error("Missing PLY properties: x, y, z");
        }
        const hasScales = scale_0 && scale_1 && scale_2;
        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;
        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;
        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;
        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;
        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;
        numSh = getNumSh(element.properties);
        prepareSh();
        return (index, item) => {
          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;
          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;
          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;
          const quatX = hasRots ? item.rot_1 : 0;
          const quatY = hasRots ? item.rot_2 : 0;
          const quatZ = hasRots ? item.rot_3 : 0;
          const quatW = hasRots ? item.rot_0 : 1;
          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;
          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;
          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;
          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;
          splatCallback(
            index,
            item.x,
            item.y,
            item.z,
            scaleX,
            scaleY,
            scaleZ,
            quatX,
            quatY,
            quatZ,
            quatW,
            op,
            r,
            g,
            b
          );
          if (shCallback && sh1) {
            const sh = item.f_rest;
            if (sh1) {
              for (let i2 = 0; i2 < sh1Props.length; i2++) {
                sh1[i2] = sh[sh1Props[i2]];
              }
            }
            if (sh2) {
              for (let i2 = 0; i2 < sh2Props.length; i2++) {
                sh2[i2] = sh[sh2Props[i2]];
              }
            }
            if (sh3) {
              for (let i2 = 0; i2 < sh3Props.length; i2++) {
                sh3[i2] = sh[sh3Props[i2]];
              }
            }
            shCallback(index, sh1, sh2, sh3);
          }
        };
      };
      this.parseData(elementCallback);
    }
    // Inject RGBA values into original PLY file, which can be used to modify
    // the color/opacity of the Gsplats and write out the modified PLY file.
    injectRgba(rgba) {
      let offset = 0;
      const data = this.data;
      if (data == null) {
        throw new Error("No parsed data");
      }
      if (rgba.length !== this.numSplats * 4) {
        throw new Error("Invalid RGBA array length");
      }
      for (const elementName in this.elements) {
        const element = this.elements[elementName];
        const { count, properties } = element;
        const parsers = [];
        let rgbaOffset = 0;
        const isVertex = elementName === "vertex";
        if (isVertex) {
          for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {
            if (!properties[name] || properties[name].type !== "float") {
              throw new Error(\`Can't injectRgba due to property: \${name}\`);
            }
          }
        }
        for (const [propertyName, property] of Object.entries(properties)) {
          if (!property.isList) {
            if (isVertex) {
              if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {
                const component = Number.parseInt(
                  propertyName.slice("f_dc_".length)
                );
                parsers.push(() => {
                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;
                  SET_FIELD[property.type](
                    data,
                    offset,
                    this.littleEndian,
                    value
                  );
                });
              } else if (propertyName === "opacity") {
                parsers.push(() => {
                  const value = Math.max(
                    -100,
                    Math.min(
                      100,
                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)
                    )
                  );
                  SET_FIELD[property.type](
                    data,
                    offset,
                    this.littleEndian,
                    value
                  );
                });
              }
            }
            parsers.push(() => {
              offset += FIELD_BYTES[property.type];
            });
          } else {
            parsers.push(() => {
              const length = PARSE_FIELD[property.countType](
                data,
                offset,
                this.littleEndian
              );
              offset += FIELD_BYTES[property.countType];
              offset += length * FIELD_BYTES[property.type];
            });
          }
        }
        for (let index = 0; index < count; index++) {
          for (const parser of parsers) {
            parser();
          }
          if (isVertex) {
            rgbaOffset += 4;
          }
        }
      }
    }
  };
  _PlyReader.defaultPointScale = 1e-3;
  let PlyReader = _PlyReader;
  const SH_C0$1 = 0.28209479177387814;
  const PARSE_FIELD = {
    char: (data, offset, littleEndian) => {
      return data.getInt8(offset);
    },
    uchar: (data, offset, littleEndian) => {
      return data.getUint8(offset);
    },
    short: (data, offset, littleEndian) => {
      return data.getInt16(offset, littleEndian);
    },
    ushort: (data, offset, littleEndian) => {
      return data.getUint16(offset, littleEndian);
    },
    int: (data, offset, littleEndian) => {
      return data.getInt32(offset, littleEndian);
    },
    uint: (data, offset, littleEndian) => {
      return data.getUint32(offset, littleEndian);
    },
    float: (data, offset, littleEndian) => {
      return data.getFloat32(offset, littleEndian);
    },
    double: (data, offset, littleEndian) => {
      return data.getFloat64(offset, littleEndian);
    }
  };
  const SET_FIELD = {
    char: (data, offset, littleEndian, value) => {
      data.setInt8(offset, value);
    },
    uchar: (data, offset, littleEndian, value) => {
      data.setUint8(offset, value);
    },
    short: (data, offset, littleEndian, value) => {
      data.setInt16(offset, value, littleEndian);
    },
    ushort: (data, offset, littleEndian, value) => {
      data.setUint16(offset, value, littleEndian);
    },
    int: (data, offset, littleEndian, value) => {
      data.setInt32(offset, value, littleEndian);
    },
    uint: (data, offset, littleEndian, value) => {
      data.setUint32(offset, value, littleEndian);
    },
    float: (data, offset, littleEndian, value) => {
      data.setFloat32(offset, value, littleEndian);
    },
    double: (data, offset, littleEndian, value) => {
      data.setFloat64(offset, value, littleEndian);
    }
  };
  const FIELD_BYTES = {
    char: 1,
    uchar: 1,
    short: 2,
    ushort: 2,
    int: 4,
    uint: 4,
    float: 4,
    double: 8
  };
  const FIELD_SCALE = {
    char: 127,
    uchar: 255,
    short: 32767,
    ushort: 65535,
    int: 2147483647,
    uint: 4294967295,
    float: 1,
    double: 1
  };
  const NUM_F_REST_TO_NUM_SH = {
    0: 0,
    9: 1,
    24: 2,
    45: 3
  };
  const NUM_SH_TO_NUM_F_REST = {
    0: 0,
    1: 9,
    2: 24,
    3: 45
  };
  const F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;
  function createEmptyItem(properties) {
    const item = {};
    for (const [propertyName, property] of Object.entries(properties)) {
      if (F_REST_REGEX.test(propertyName)) {
        item.f_rest = new Array(getNumSh(properties));
      } else {
        item[propertyName] = property.isList ? [] : 0;
      }
    }
    return item;
  }
  function createParseFn(properties, littleEndian) {
    if (safeToCompile(properties)) {
      return createCompiledParserFn(properties, littleEndian);
    }
    return createDynamicParserFn(properties, littleEndian);
  }
  const UNSAFE_EVAL_ALLOWED = (() => {
    try {
      new Function("return 42;");
    } catch (e) {
      return false;
    }
    return true;
  })();
  const PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;
  function safeToCompile(properties) {
    if (!UNSAFE_EVAL_ALLOWED) {
      return false;
    }
    for (const [propertyName, property] of Object.entries(properties)) {
      if (!PROPERTY_NAME_REGEX.test(propertyName)) {
        return false;
      }
      if (property.isList && !PLY_PROPERTY_TYPES.includes(property.countType)) {
        return false;
      }
      if (!PLY_PROPERTY_TYPES.includes(property.type)) {
        return false;
      }
    }
    return true;
  }
  function createCompiledParserFn(properties, littleEndian) {
    const parserSrc = ["let list;"];
    for (const [propertyName, property] of Object.entries(properties)) {
      const fRestMatch = propertyName.match(F_REST_REGEX);
      if (fRestMatch) {
        const fRestIndex = +fRestMatch[1];
        parserSrc.push(
          /*js*/
          \`
        item.f_rest[\${fRestIndex}] = PARSE_FIELD['\${property.type}'](data, offset, \${littleEndian});
        offset += \${FIELD_BYTES[property.type]};
      \`
        );
      } else if (!property.isList) {
        parserSrc.push(
          /*js*/
          \`
        item['\${propertyName}'] = PARSE_FIELD['\${property.type}'](data, offset, \${littleEndian});
        offset += \${FIELD_BYTES[property.type]};
      \`
        );
      } else {
        parserSrc.push(
          /*js*/
          \`
        list = item['\${propertyName}'];
        list.length = PARSE_FIELD['\${property.countType}'](data, offset, \${littleEndian});
        offset += \${FIELD_BYTES[property.countType]};
        for (let i = 0; i < list.length; i++) {
          list[i] = PARSE_FIELD['\${property.type}'](data, offset, \${littleEndian});
          offset += \${FIELD_BYTES[property.type]};
        }
      \`
        );
      }
    }
    parserSrc.push("return offset;");
    const fn = new Function(
      "data",
      "offset",
      "item",
      "PARSE_FIELD",
      parserSrc.join("\\n")
    );
    return (data, offset, item) => fn(data, offset, item, PARSE_FIELD);
  }
  function createDynamicParserFn(properties, littleEndian) {
    const parsers = [];
    for (const [propertyName, property] of Object.entries(properties)) {
      const fRestMatch = propertyName.match(F_REST_REGEX);
      if (fRestMatch) {
        const fRestIndex = +fRestMatch[1];
        parsers.push(
          (data, offset, item) => {
            item.f_rest[fRestIndex] = PARSE_FIELD[property.type](
              data,
              offset,
              littleEndian
            );
            return offset + FIELD_BYTES[property.type];
          }
        );
      } else if (!property.isList) {
        parsers.push(
          (data, offset, item) => {
            item[propertyName] = PARSE_FIELD[property.type](
              data,
              offset,
              littleEndian
            );
            return offset + FIELD_BYTES[property.type];
          }
        );
      } else {
        parsers.push(
          (data, offset, item) => {
            const list = item[propertyName];
            list.length = PARSE_FIELD[property.countType](
              data,
              offset,
              littleEndian
            );
            let currentOffset = offset + FIELD_BYTES[property.countType];
            for (let i2 = 0; i2 < list.length; i2++) {
              list[i2] = PARSE_FIELD[property.type](
                data,
                currentOffset,
                littleEndian
              );
              currentOffset += FIELD_BYTES[property.type];
            }
            return currentOffset;
          }
        );
      }
    }
    return (data, offset, item) => {
      let currentOffset = offset;
      for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {
        currentOffset = parsers[parserIndex](data, currentOffset, item);
      }
      return currentOffset;
    };
  }
  function getNumSh(properties) {
    let num_f_rest = 0;
    while (properties[\`f_rest_\${num_f_rest}\`]) {
      num_f_rest += 1;
    }
    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];
    if (numSh == null) {
      throw new Error(\`Unsupported number of SH coefficients: \${num_f_rest}\`);
    }
    return numSh;
  }
  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {
    SplatFileType2["PLY"] = "ply";
    SplatFileType2["SPZ"] = "spz";
    SplatFileType2["SPLAT"] = "splat";
    SplatFileType2["KSPLAT"] = "ksplat";
    SplatFileType2["PCSOGS"] = "pcsogs";
    SplatFileType2["PCSOGSZIP"] = "pcsogszip";
    return SplatFileType2;
  })(SplatFileType || {});
  function getSplatFileType(fileBytes) {
    const view = new DataView(fileBytes.buffer);
    if ((view.getUint32(0, true) & 16777215) === 7957616) {
      return "ply";
    }
    if ((view.getUint32(0, true) & 16777215) === 559903) {
      const header = decompressPartialGzip(fileBytes, 4);
      const gView = new DataView(header.buffer);
      if (gView.getUint32(0, true) === 1347635022) {
        return "spz";
      }
      return void 0;
    }
    if (view.getUint32(0, true) === 67324752) {
      if (tryPcSogsZip(fileBytes)) {
        return "pcsogszip";
      }
      return void 0;
    }
    return void 0;
  }
  function getFileExtension(pathOrUrl) {
    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];
    const lastSlash = Math.max(
      noTrailing.lastIndexOf("/"),
      noTrailing.lastIndexOf("\\\\")
    );
    const filename = noTrailing.slice(lastSlash + 1);
    const lastDot = filename.lastIndexOf(".");
    if (lastDot <= 0 || lastDot === filename.length - 1) {
      return "";
    }
    return filename.slice(lastDot + 1).toLowerCase();
  }
  function getSplatFileTypeFromPath(pathOrUrl) {
    const extension = getFileExtension(pathOrUrl);
    if (extension === "ply") {
      return "ply";
    }
    if (extension === "spz") {
      return "spz";
    }
    if (extension === "splat") {
      return "splat";
    }
    if (extension === "ksplat") {
      return "ksplat";
    }
    return void 0;
  }
  function tryPcSogs(input) {
    try {
      let text;
      if (typeof input === "string") {
        text = input;
      } else {
        const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
        if (fileBytes.length > 65536) {
          return void 0;
        }
        text = new TextDecoder().decode(fileBytes);
      }
      const json = JSON.parse(text);
      if (!json || typeof json !== "object" || Array.isArray(json)) {
        return void 0;
      }
      for (const key of ["means", "scales", "quats", "sh0"]) {
        if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {
          return void 0;
        }
        if (!json[key].shape || !json[key].files) {
          return void 0;
        }
        if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {
          return void 0;
        }
      }
      return json;
    } catch {
      return void 0;
    }
  }
  function tryPcSogsZip(input) {
    try {
      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
      let metaFilename = null;
      const unzipped = unzipSync(fileBytes, {
        filter: ({ name }) => {
          const filename = name.split(/[\\\\/]/).pop();
          if (filename === "meta.json") {
            metaFilename = name;
            return true;
          }
          return false;
        }
      });
      if (!metaFilename) {
        return void 0;
      }
      const json = tryPcSogs(unzipped[metaFilename]);
      if (!json) {
        return void 0;
      }
      return { name: metaFilename, json };
    } catch {
      return void 0;
    }
  }
  class SplatData {
    constructor({ maxSplats = 1 } = {}) {
      this.numSplats = 0;
      this.maxSplats = getTextureSize(maxSplats).maxSplats;
      this.centers = new Float32Array(this.maxSplats * 3);
      this.scales = new Float32Array(this.maxSplats * 3);
      this.quaternions = new Float32Array(this.maxSplats * 4);
      this.opacities = new Float32Array(this.maxSplats);
      this.colors = new Float32Array(this.maxSplats * 3);
    }
    pushSplat() {
      const index = this.numSplats;
      this.ensureIndex(index);
      this.numSplats += 1;
      return index;
    }
    unpushSplat(index) {
      if (index === this.numSplats - 1) {
        this.numSplats -= 1;
      } else {
        throw new Error("Cannot unpush splat from non-last position");
      }
    }
    ensureCapacity(numSplats) {
      if (numSplats > this.maxSplats) {
        const targetSplats = Math.max(numSplats, this.maxSplats * 2);
        const newCenters = new Float32Array(targetSplats * 3);
        const newScales = new Float32Array(targetSplats * 3);
        const newQuaternions = new Float32Array(targetSplats * 4);
        const newOpacities = new Float32Array(targetSplats);
        const newColors = new Float32Array(targetSplats * 3);
        newCenters.set(this.centers);
        newScales.set(this.scales);
        newQuaternions.set(this.quaternions);
        newOpacities.set(this.opacities);
        newColors.set(this.colors);
        this.centers = newCenters;
        this.scales = newScales;
        this.quaternions = newQuaternions;
        this.opacities = newOpacities;
        this.colors = newColors;
        if (this.sh1) {
          const newSh1 = new Float32Array(targetSplats * 9);
          newSh1.set(this.sh1);
          this.sh1 = newSh1;
        }
        if (this.sh2) {
          const newSh2 = new Float32Array(targetSplats * 15);
          newSh2.set(this.sh2);
          this.sh2 = newSh2;
        }
        if (this.sh3) {
          const newSh3 = new Float32Array(targetSplats * 21);
          newSh3.set(this.sh3);
          this.sh3 = newSh3;
        }
        this.maxSplats = targetSplats;
      }
    }
    ensureIndex(index) {
      this.ensureCapacity(index + 1);
    }
    setCenter(index, x2, y, z) {
      this.centers[index * 3] = x2;
      this.centers[index * 3 + 1] = y;
      this.centers[index * 3 + 2] = z;
    }
    setScale(index, scaleX, scaleY, scaleZ) {
      this.scales[index * 3] = scaleX;
      this.scales[index * 3 + 1] = scaleY;
      this.scales[index * 3 + 2] = scaleZ;
    }
    setQuaternion(index, x2, y, z, w) {
      this.quaternions[index * 4] = x2;
      this.quaternions[index * 4 + 1] = y;
      this.quaternions[index * 4 + 2] = z;
      this.quaternions[index * 4 + 3] = w;
    }
    setOpacity(index, opacity) {
      this.opacities[index] = opacity;
    }
    setColor(index, r, g, b) {
      this.colors[index * 3] = r;
      this.colors[index * 3 + 1] = g;
      this.colors[index * 3 + 2] = b;
    }
    setSh1(index, sh1) {
      if (!this.sh1) {
        this.sh1 = new Float32Array(this.maxSplats * 9);
      }
      for (let j = 0; j < 9; ++j) {
        this.sh1[index * 9 + j] = sh1[j];
      }
    }
    setSh2(index, sh2) {
      if (!this.sh2) {
        this.sh2 = new Float32Array(this.maxSplats * 15);
      }
      for (let j = 0; j < 15; ++j) {
        this.sh2[index * 15 + j] = sh2[j];
      }
    }
    setSh3(index, sh3) {
      if (!this.sh3) {
        this.sh3 = new Float32Array(this.maxSplats * 21);
      }
      for (let j = 0; j < 21; ++j) {
        this.sh3[index * 21 + j] = sh3[j];
      }
    }
  }
  async function unpackPcSogs(json, extraFiles, splatEncoding) {
    if (json.quats.encoding !== "quaternion_packed") {
      throw new Error("Unsupported quaternion encoding");
    }
    const numSplats = json.means.shape[0];
    const maxSplats = computeMaxSplats(numSplats);
    const packedArray = new Uint32Array(maxSplats * 4);
    const extra = {};
    const meansPromise = Promise.all([
      decodeImageRgba(extraFiles[json.means.files[0]]),
      decodeImageRgba(extraFiles[json.means.files[1]])
    ]).then((means) => {
      for (let i2 = 0; i2 < numSplats; ++i2) {
        const i4 = i2 * 4;
        const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / 65535;
        const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / 65535;
        const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / 65535;
        let x2 = json.means.mins[0] + (json.means.maxs[0] - json.means.mins[0]) * fx;
        let y = json.means.mins[1] + (json.means.maxs[1] - json.means.mins[1]) * fy;
        let z = json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;
        x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);
        y = Math.sign(y) * (Math.exp(Math.abs(y)) - 1);
        z = Math.sign(z) * (Math.exp(Math.abs(z)) - 1);
        setPackedSplatCenter(packedArray, i2, x2, y, z);
      }
    });
    const scalesPromise = decodeImageRgba(extraFiles[json.scales.files[0]]).then(
      (scales) => {
        const xLookup = new Array(256).fill(0).map(
          (_, i2) => json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * (i2 / 255)
        ).map((x2) => Math.exp(x2));
        const yLookup = new Array(256).fill(0).map(
          (_, i2) => json.scales.mins[1] + (json.scales.maxs[1] - json.scales.mins[1]) * (i2 / 255)
        ).map((x2) => Math.exp(x2));
        const zLookup = new Array(256).fill(0).map(
          (_, i2) => json.scales.mins[2] + (json.scales.maxs[2] - json.scales.mins[2]) * (i2 / 255)
        ).map((x2) => Math.exp(x2));
        for (let i2 = 0; i2 < numSplats; ++i2) {
          const i4 = i2 * 4;
          setPackedSplatScales(
            packedArray,
            i2,
            xLookup[scales[i4 + 0]],
            yLookup[scales[i4 + 1]],
            zLookup[scales[i4 + 2]],
            splatEncoding
          );
        }
      }
    );
    const quatsPromise = decodeImageRgba(extraFiles[json.quats.files[0]]).then(
      (quats) => {
        const SQRT2 = Math.sqrt(2);
        const lookup = new Array(256).fill(0).map((_, i2) => (i2 / 255 - 0.5) * SQRT2);
        for (let i2 = 0; i2 < numSplats; ++i2) {
          const i4 = i2 * 4;
          const r0 = lookup[quats[i4 + 0]];
          const r1 = lookup[quats[i4 + 1]];
          const r2 = lookup[quats[i4 + 2]];
          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));
          const rOrder = quats[i4 + 3] - 252;
          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;
          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;
          const quatZ = rOrder <= 2 ? r2 : rr;
          const quatW = rOrder === 0 ? rr : r0;
          setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);
        }
      }
    );
    const sh0Promise = decodeImageRgba(extraFiles[json.sh0.files[0]]).then(
      (sh0) => {
        const SH_C02 = 0.28209479177387814;
        const rLookup = new Array(256).fill(0).map(
          (_, i2) => json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * (i2 / 255)
        ).map((x2) => SH_C02 * x2 + 0.5);
        const gLookup = new Array(256).fill(0).map(
          (_, i2) => json.sh0.mins[1] + (json.sh0.maxs[1] - json.sh0.mins[1]) * (i2 / 255)
        ).map((x2) => SH_C02 * x2 + 0.5);
        const bLookup = new Array(256).fill(0).map(
          (_, i2) => json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * (i2 / 255)
        ).map((x2) => SH_C02 * x2 + 0.5);
        const aLookup = new Array(256).fill(0).map(
          (_, i2) => json.sh0.mins[3] + (json.sh0.maxs[3] - json.sh0.mins[3]) * (i2 / 255)
        ).map((x2) => 1 / (1 + Math.exp(-x2)));
        for (let i2 = 0; i2 < numSplats; ++i2) {
          const i4 = i2 * 4;
          setPackedSplatRgba(
            packedArray,
            i2,
            rLookup[sh0[i4 + 0]],
            gLookup[sh0[i4 + 1]],
            bLookup[sh0[i4 + 2]],
            aLookup[sh0[i4 + 3]],
            splatEncoding
          );
        }
      }
    );
    const promises = [meansPromise, scalesPromise, quatsPromise, sh0Promise];
    if (json.shN) {
      const useSH3 = json.shN.shape[1] >= 48 - 3;
      const useSH2 = json.shN.shape[1] >= 27 - 3;
      const useSH1 = json.shN.shape[1] >= 12 - 3;
      if (useSH1) extra.sh1 = new Uint32Array(numSplats * 2);
      if (useSH2) extra.sh2 = new Uint32Array(numSplats * 4);
      if (useSH3) extra.sh3 = new Uint32Array(numSplats * 4);
      const sh1 = new Float32Array(9);
      const sh2 = new Float32Array(15);
      const sh3 = new Float32Array(21);
      const shN = json.shN;
      const shNPromise = Promise.all([
        decodeImage(extraFiles[json.shN.files[0]]),
        decodeImage(extraFiles[json.shN.files[1]])
      ]).then(([centroids, labels]) => {
        const lookup = new Array(256).fill(0).map((_, i2) => shN.mins + (shN.maxs - shN.mins) * (i2 / 255));
        for (let i2 = 0; i2 < numSplats; ++i2) {
          const i4 = i2 * 4;
          const label = labels.rgba[i4 + 0] + (labels.rgba[i4 + 1] << 8);
          const col = (label & 63) * 15;
          const row = label >>> 6;
          const offset = row * centroids.width + col;
          for (let d = 0; d < 3; ++d) {
            if (useSH1) {
              for (let k = 0; k < 3; ++k) {
                sh1[k * 3 + d] = lookup[centroids.rgba[(offset + k) * 4 + d]];
              }
            }
            if (useSH2) {
              for (let k = 0; k < 5; ++k) {
                sh2[k * 3 + d] = lookup[centroids.rgba[(offset + 3 + k) * 4 + d]];
              }
            }
            if (useSH3) {
              for (let k = 0; k < 7; ++k) {
                sh3[k * 3 + d] = lookup[centroids.rgba[(offset + 8 + k) * 4 + d]];
              }
            }
          }
          if (useSH1)
            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);
          if (useSH2)
            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);
          if (useSH3)
            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);
        }
      });
      promises.push(shNPromise);
    }
    await Promise.all(promises);
    return { packedArray, numSplats, extra };
  }
  let offscreenGlContext = null;
  async function decodeImage(fileBytes) {
    if (!offscreenGlContext) {
      const canvas = new OffscreenCanvas(1, 1);
      offscreenGlContext = canvas.getContext("webgl2");
      if (!offscreenGlContext) {
        throw new Error("Failed to create WebGL2 context");
      }
    }
    const imageBlob = new Blob([fileBytes]);
    const bitmap = await createImageBitmap(imageBlob, {
      premultiplyAlpha: "none"
    });
    const gl = offscreenGlContext;
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    const data = new Uint8Array(bitmap.width * bitmap.height * 4);
    gl.readPixels(
      0,
      0,
      bitmap.width,
      bitmap.height,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      data
    );
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(framebuffer);
    return { rgba: data, width: bitmap.width, height: bitmap.height };
  }
  async function decodeImageRgba(fileBytes) {
    const { rgba } = await decodeImage(fileBytes);
    return rgba;
  }
  async function unpackPcSogsZip(fileBytes, splatEncoding) {
    var _a2;
    const nameJson = tryPcSogsZip(fileBytes);
    if (!nameJson) {
      throw new Error("Invalid PC SOGS zip file");
    }
    const { name, json } = nameJson;
    const lastSlash = name.lastIndexOf("/");
    const lastBackslash = name.lastIndexOf("\\\\");
    const prefix = name.slice(0, Math.max(lastSlash, lastBackslash) + 1);
    const fileMap = /* @__PURE__ */ new Map();
    const refFiles = [
      ...json.means.files,
      ...json.scales.files,
      ...json.quats.files,
      ...json.sh0.files,
      ...((_a2 = json.shN) == null ? void 0 : _a2.files) ?? []
    ];
    for (const file of refFiles) {
      fileMap.set(prefix + file, file);
    }
    const unzipped = await new Promise(
      (resolve, reject) => {
        unzip(
          fileBytes,
          {
            filter: ({ name: name2 }) => {
              return fileMap.has(name2);
            }
          },
          (err2, files) => {
            if (err2) {
              reject(err2);
            } else {
              resolve(files);
            }
          }
        );
      }
    );
    const extraFiles = {};
    for (const [full, name2] of fileMap.entries()) {
      extraFiles[name2] = unzipped[full];
    }
    return await unpackPcSogs(json, extraFiles, splatEncoding);
  }
  class SpzReader {
    constructor({ fileBytes }) {
      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
      this.reader = new GunzipReader({ fileBytes: this.fileBytes });
      const header = new DataView(this.reader.read(16).buffer);
      if (header.getUint32(0, true) !== 1347635022) {
        throw new Error("Invalid SPZ file");
      }
      this.version = header.getUint32(4, true);
      if (this.version < 1 || this.version > 3) {
        throw new Error(\`Unsupported SPZ version: \${this.version}\`);
      }
      this.numSplats = header.getUint32(8, true);
      this.shDegree = header.getUint8(12);
      this.fractionalBits = header.getUint8(13);
      this.flags = header.getUint8(14);
      this.flagAntiAlias = (this.flags & 1) !== 0;
      this.reserved = header.getUint8(15);
      this.parsed = false;
    }
    parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {
      if (this.parsed) {
        throw new Error("SPZ file already parsed");
      }
      this.parsed = true;
      if (this.version === 1) {
        const centerBytes = this.reader.read(this.numSplats * 3 * 2);
        const centerUint16 = new Uint16Array(centerBytes.buffer);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const x2 = fromHalf(centerUint16[i3]);
          const y = fromHalf(centerUint16[i3 + 1]);
          const z = fromHalf(centerUint16[i3 + 2]);
          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);
        }
      } else if (this.version === 2 || this.version === 3) {
        const fixed = 1 << this.fractionalBits;
        const centerBytes = this.reader.read(this.numSplats * 3 * 3);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i9 = i2 * 9;
          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;
          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;
          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;
          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);
        }
      } else {
        throw new Error("Unreachable");
      }
      {
        const bytes = this.reader.read(this.numSplats);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);
        }
      }
      {
        const rgbBytes = this.reader.read(this.numSplats * 3);
        const scale = SH_C0 / 0.15;
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;
          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;
          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;
          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);
        }
      }
      {
        const scalesBytes = this.reader.read(this.numSplats * 3);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);
          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);
          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);
          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);
        }
      }
      if (this.version === 3) {
        const maxValue = 1 / Math.sqrt(2);
        const quatBytes = this.reader.read(this.numSplats * 4);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 4;
          const quaternion = [0, 0, 0, 0];
          const values = [
            quatBytes[i3],
            quatBytes[i3 + 1],
            quatBytes[i3 + 2],
            quatBytes[i3 + 3]
          ];
          const combinedValues = values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);
          const valueMask = (1 << 9) - 1;
          const largestIndex = combinedValues >>> 30;
          let remainingValues = combinedValues;
          let sumSquares = 0;
          for (let i22 = 3; i22 >= 0; --i22) {
            if (i22 !== largestIndex) {
              const value = remainingValues & valueMask;
              const sign = remainingValues >>> 9 & 1;
              remainingValues = remainingValues >>> 10;
              quaternion[i22] = maxValue * (value / valueMask);
              quaternion[i22] = sign === 0 ? quaternion[i22] : -quaternion[i22];
              sumSquares += quaternion[i22] * quaternion[i22];
            }
          }
          const square = 1 - sumSquares;
          quaternion[largestIndex] = Math.sqrt(Math.max(square, 0));
          quatCallback == null ? void 0 : quatCallback(
            i2,
            quaternion[0],
            quaternion[1],
            quaternion[2],
            quaternion[3]
          );
        }
      } else {
        const quatBytes = this.reader.read(this.numSplats * 3);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const quatX = quatBytes[i3] / 127.5 - 1;
          const quatY = quatBytes[i3 + 1] / 127.5 - 1;
          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;
          const quatW = Math.sqrt(
            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)
          );
          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);
        }
      }
      if (shCallback && this.shDegree >= 1) {
        const sh1 = new Float32Array(3 * 3);
        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;
        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;
        const shBytes = this.reader.read(
          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3
        );
        let offset = 0;
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          for (let j = 0; j < 9; ++j) {
            sh1[j] = (shBytes[offset + j] - 128) / 128;
          }
          offset += 9;
          if (sh2) {
            for (let j = 0; j < 15; ++j) {
              sh2[j] = (shBytes[offset + j] - 128) / 128;
            }
            offset += 15;
          }
          if (sh3) {
            for (let j = 0; j < 21; ++j) {
              sh3[j] = (shBytes[offset + j] - 128) / 128;
            }
            offset += 21;
          }
          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);
        }
      }
    }
  }
  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };
  const SH_C0 = 0.28209479177387814;
  const SPZ_MAGIC = 1347635022;
  const SPZ_VERSION = 3;
  const FLAG_ANTIALIASED = 1;
  class SpzWriter {
    constructor({
      numSplats,
      shDegree,
      fractionalBits = 12,
      flagAntiAlias = true
    }) {
      this.clippedCount = 0;
      const splatSize = 9 + // Position
      1 + // Opacity
      3 + // Scale
      3 + // DC-rgb
      4 + // Rotation
      (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);
      const bufferSize = 16 + numSplats * splatSize;
      this.buffer = new ArrayBuffer(bufferSize);
      this.view = new DataView(this.buffer);
      this.view.setUint32(0, SPZ_MAGIC, true);
      this.view.setUint32(4, SPZ_VERSION, true);
      this.view.setUint32(8, numSplats, true);
      this.view.setUint8(12, shDegree);
      this.view.setUint8(13, fractionalBits);
      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);
      this.view.setUint8(15, 0);
      this.numSplats = numSplats;
      this.shDegree = shDegree;
      this.fractionalBits = fractionalBits;
      this.fraction = 1 << fractionalBits;
      this.flagAntiAlias = flagAntiAlias;
    }
    setCenter(index, x2, y, z) {
      const xRounded = Math.round(x2 * this.fraction);
      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));
      const yRounded = Math.round(y * this.fraction);
      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));
      const zRounded = Math.round(z * this.fraction);
      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));
      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;
      if (clipped) {
        this.clippedCount += 1;
      }
      const i9 = index * 9;
      const base = 16 + i9;
      this.view.setUint8(base, xInt & 255);
      this.view.setUint8(base + 1, xInt >> 8 & 255);
      this.view.setUint8(base + 2, xInt >> 16 & 255);
      this.view.setUint8(base + 3, yInt & 255);
      this.view.setUint8(base + 4, yInt >> 8 & 255);
      this.view.setUint8(base + 5, yInt >> 16 & 255);
      this.view.setUint8(base + 6, zInt & 255);
      this.view.setUint8(base + 7, zInt >> 8 & 255);
      this.view.setUint8(base + 8, zInt >> 16 & 255);
    }
    setAlpha(index, alpha) {
      const base = 16 + this.numSplats * 9 + index;
      this.view.setUint8(
        base,
        Math.max(0, Math.min(255, Math.round(alpha * 255)))
      );
    }
    static scaleRgb(r) {
      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;
      return Math.max(0, Math.min(255, Math.round(v)));
    }
    setRgb(index, r, g, b) {
      const base = 16 + this.numSplats * 10 + index * 3;
      this.view.setUint8(base, SpzWriter.scaleRgb(r));
      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));
      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));
    }
    setScale(index, scaleX, scaleY, scaleZ) {
      const base = 16 + this.numSplats * 13 + index * 3;
      this.view.setUint8(
        base,
        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))
      );
      this.view.setUint8(
        base + 1,
        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))
      );
      this.view.setUint8(
        base + 2,
        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))
      );
    }
    setQuat(index, ...q) {
      const base = 16 + this.numSplats * 16 + index * 4;
      const quat = normalize(q);
      let iLargest = 0;
      for (let i2 = 1; i2 < 4; ++i2) {
        if (Math.abs(quat[i2]) > Math.abs(quat[iLargest])) {
          iLargest = i2;
        }
      }
      const negate = quat[iLargest] < 0 ? 1 : 0;
      let comp = iLargest;
      for (let i2 = 0; i2 < 4; ++i2) {
        if (i2 !== iLargest) {
          const negbit = (quat[i2] < 0 ? 1 : 0) ^ negate;
          const mag = Math.floor(
            ((1 << 9) - 1) * (Math.abs(quat[i2]) / Math.SQRT1_2) + 0.5
          );
          comp = comp << 10 | negbit << 9 | mag;
        }
      }
      this.view.setUint8(base, comp & 255);
      this.view.setUint8(base + 1, comp >> 8 & 255);
      this.view.setUint8(base + 2, comp >> 16 & 255);
      this.view.setUint8(base + 3, comp >>> 24 & 255);
    }
    static quantizeSh(sh, bits2) {
      const value = Math.round(sh * 128) + 128;
      const bucketSize = 1 << 8 - bits2;
      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;
      return Math.max(0, Math.min(255, quantized));
    }
    setSh(index, sh1, sh2, sh3) {
      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;
      const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;
      for (let j = 0; j < 9; ++j) {
        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));
      }
      if (sh2) {
        const base2 = base1 + 9;
        for (let j = 0; j < 15; ++j) {
          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));
        }
        if (sh3) {
          const base3 = base2 + 15;
          for (let j = 0; j < 21; ++j) {
            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));
          }
        }
      }
    }
    async finalize() {
      const input = new Uint8Array(this.buffer);
      const stream = new ReadableStream({
        async start(controller) {
          controller.enqueue(input);
          controller.close();
        }
      });
      const compressed = stream.pipeThrough(new CompressionStream("gzip"));
      const response = new Response(compressed);
      const buffer = await response.arrayBuffer();
      console.log(
        "Compressed",
        input.length,
        "bytes to",
        buffer.byteLength,
        "bytes"
      );
      return new Uint8Array(buffer);
    }
  }
  async function transcodeSpz(input) {
    var _a2, _b2, _c;
    const splats = new SplatData();
    const {
      inputs,
      clipXyz,
      maxSh,
      fractionalBits = 12,
      opacityThreshold
    } = input;
    for (const input2 of inputs) {
      let transformPos = function(pos) {
        pos.multiplyScalar(scale);
        pos.applyQuaternion(quaternion);
        pos.add(translate);
        return pos;
      }, transformScales = function(scales) {
        scales.multiplyScalar(scale);
        return scales;
      }, transformQuaternion = function(quat) {
        quat.premultiply(quaternion);
        return quat;
      }, withinClip = function(p) {
        return !clip || clip.containsPoint(p);
      }, withinOpacity = function(opacity) {
        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;
      };
      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;
      const quaternion = new Quaternion().fromArray(
        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]
      );
      const translate = new Vector3().fromArray(
        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]
      );
      const clip = clipXyz ? new Box3(
        new Vector3().fromArray(clipXyz.min),
        new Vector3().fromArray(clipXyz.max)
      ) : void 0;
      let fileType = input2.fileType;
      if (!fileType) {
        fileType = getSplatFileType(input2.fileBytes);
        if (!fileType && input2.pathOrUrl) {
          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);
        }
      }
      switch (fileType) {
        case SplatFileType.PLY: {
          const ply = new PlyReader({ fileBytes: input2.fileBytes });
          await ply.parseHeader();
          let lastIndex = null;
          ply.parseSplats(
            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
              const center = transformPos(new Vector3(x2, y, z));
              if (withinClip(center) && withinOpacity(opacity)) {
                lastIndex = splats.pushSplat();
                splats.setCenter(lastIndex, center.x, center.y, center.z);
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(lastIndex, scales.x, scales.y, scales.z);
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  lastIndex,
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
                splats.setOpacity(lastIndex, opacity);
                splats.setColor(lastIndex, r, g, b);
              } else {
                lastIndex = null;
              }
            },
            (index, sh1, sh2, sh3) => {
              if (sh1 && lastIndex !== null) {
                splats.setSh1(lastIndex, sh1);
              }
              if (sh2 && lastIndex !== null) {
                splats.setSh2(lastIndex, sh2);
              }
              if (sh3 && lastIndex !== null) {
                splats.setSh3(lastIndex, sh3);
              }
            }
          );
          break;
        }
        case SplatFileType.SPZ: {
          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });
          const mapping = new Int32Array(spz2.numSplats);
          mapping.fill(-1);
          const centers = new Float32Array(spz2.numSplats * 3);
          const center = new Vector3();
          spz2.parseSplats(
            (index, x2, y, z) => {
              const center2 = transformPos(new Vector3(x2, y, z));
              centers[index * 3] = center2.x;
              centers[index * 3 + 1] = center2.y;
              centers[index * 3 + 2] = center2.z;
            },
            (index, alpha) => {
              center.fromArray(centers, index * 3);
              if (withinClip(center) && withinOpacity(alpha)) {
                mapping[index] = splats.pushSplat();
                splats.setCenter(mapping[index], center.x, center.y, center.z);
                splats.setOpacity(mapping[index], alpha);
              }
            },
            (index, r, g, b) => {
              if (mapping[index] >= 0) {
                splats.setColor(mapping[index], r, g, b);
              }
            },
            (index, scaleX, scaleY, scaleZ) => {
              if (mapping[index] >= 0) {
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(mapping[index], scales.x, scales.y, scales.z);
              }
            },
            (index, quatX, quatY, quatZ, quatW) => {
              if (mapping[index] >= 0) {
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  mapping[index],
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
              }
            },
            (index, sh1, sh2, sh3) => {
              if (mapping[index] >= 0) {
                splats.setSh1(mapping[index], sh1);
                if (sh2) {
                  splats.setSh2(mapping[index], sh2);
                }
                if (sh3) {
                  splats.setSh3(mapping[index], sh3);
                }
              }
            }
          );
          break;
        }
        case SplatFileType.SPLAT:
          decodeAntiSplat(
            input2.fileBytes,
            (numSplats) => {
            },
            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
              const center = transformPos(new Vector3(x2, y, z));
              if (withinClip(center) && withinOpacity(opacity)) {
                const index2 = splats.pushSplat();
                splats.setCenter(index2, center.x, center.y, center.z);
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(index2, scales.x, scales.y, scales.z);
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  index2,
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
                splats.setOpacity(index2, opacity);
                splats.setColor(index2, r, g, b);
              }
            }
          );
          break;
        case SplatFileType.KSPLAT: {
          let lastIndex = null;
          decodeKsplat(
            input2.fileBytes,
            (numSplats) => {
            },
            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
              const center = transformPos(new Vector3(x2, y, z));
              if (withinClip(center) && withinOpacity(opacity)) {
                lastIndex = splats.pushSplat();
                splats.setCenter(lastIndex, center.x, center.y, center.z);
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(lastIndex, scales.x, scales.y, scales.z);
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  lastIndex,
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
                splats.setOpacity(lastIndex, opacity);
                splats.setColor(lastIndex, r, g, b);
              } else {
                lastIndex = null;
              }
            },
            (index, sh1, sh2, sh3) => {
              if (lastIndex !== null) {
                splats.setSh1(lastIndex, sh1);
                if (sh2) {
                  splats.setSh2(lastIndex, sh2);
                }
                if (sh3) {
                  splats.setSh3(lastIndex, sh3);
                }
              }
            }
          );
          break;
        }
        default:
          throw new Error(\`transcodeSpz not implemented for \${fileType}\`);
      }
    }
    const shDegree = Math.min(
      maxSh ?? 3,
      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0
    );
    const spz = new SpzWriter({
      numSplats: splats.numSplats,
      shDegree,
      fractionalBits,
      flagAntiAlias: true
    });
    for (let i2 = 0; i2 < splats.numSplats; ++i2) {
      const i3 = i2 * 3;
      const i4 = i2 * 4;
      spz.setCenter(
        i2,
        splats.centers[i3],
        splats.centers[i3 + 1],
        splats.centers[i3 + 2]
      );
      spz.setScale(
        i2,
        splats.scales[i3],
        splats.scales[i3 + 1],
        splats.scales[i3 + 2]
      );
      spz.setQuat(
        i2,
        splats.quaternions[i4],
        splats.quaternions[i4 + 1],
        splats.quaternions[i4 + 2],
        splats.quaternions[i4 + 3]
      );
      spz.setAlpha(i2, splats.opacities[i2]);
      spz.setRgb(
        i2,
        splats.colors[i3],
        splats.colors[i3 + 1],
        splats.colors[i3 + 2]
      );
      if (splats.sh1 && shDegree >= 1) {
        spz.setSh(
          i2,
          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),
          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,
          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0
        );
      }
    }
    const spzBytes = await spz.finalize();
    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };
  }
  async function onMessage(event) {
    const { name, args, id } = event.data;
    let result = void 0;
    let error = void 0;
    try {
      switch (name) {
        case "unpackPly": {
          const { packedArray, fileBytes, splatEncoding } = args;
          const decoded = await unpackPly({
            packedArray,
            fileBytes,
            splatEncoding
          });
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodeSpz": {
          const { fileBytes, splatEncoding } = args;
          const decoded = unpackSpz(fileBytes, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodeAntiSplat": {
          const { fileBytes, splatEncoding } = args;
          const decoded = unpackAntiSplat(fileBytes, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray
          };
          break;
        }
        case "decodeKsplat": {
          const { fileBytes, splatEncoding } = args;
          const decoded = unpackKsplat(fileBytes, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodePcSogs": {
          const { fileBytes, extraFiles, splatEncoding } = args;
          const json = JSON.parse(
            new TextDecoder().decode(fileBytes)
          );
          const decoded = await unpackPcSogs(json, extraFiles, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodePcSogsZip": {
          const { fileBytes, splatEncoding } = args;
          const decoded = await unpackPcSogsZip(fileBytes, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "sortSplats": {
          const { totalSplats, readback, ordering } = args;
          result = {
            id,
            readback,
            ...sortSplats({ totalSplats, readback, ordering })
          };
          break;
        }
        case "sortDoubleSplats": {
          const { numSplats, readback, ordering } = args;
          {
            result = {
              id,
              readback,
              ordering,
              activeSplats: sort_splats(numSplats, readback, ordering)
            };
          }
          break;
        }
        case "sort32Splats": {
          const { numSplats, readback, ordering } = args;
          {
            result = {
              id,
              readback,
              ordering,
              activeSplats: sort32_splats(numSplats, readback, ordering)
            };
          }
          break;
        }
        case "transcodeSpz": {
          const input = args;
          const spzBytes = await transcodeSpz(input);
          result = {
            id,
            fileBytes: spzBytes,
            input
          };
          break;
        }
        default: {
          throw new Error(\`Unknown name: \${name}\`);
        }
      }
    } catch (e) {
      error = e;
      console.error(error);
    }
    self.postMessage(
      { id, result, error },
      { transfer: getArrayBuffers(result) }
    );
  }
  async function unpackPly({
    packedArray,
    fileBytes,
    splatEncoding
  }) {
    const ply = new PlyReader({ fileBytes });
    await ply.parseHeader();
    const numSplats = ply.numSplats;
    const extra = {};
    ply.parseSplats(
      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
        setPackedSplat(
          packedArray,
          index,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b,
          splatEncoding
        );
      },
      (index, sh1, sh2, sh3) => {
        if (sh1) {
          if (!extra.sh1) {
            extra.sh1 = new Uint32Array(numSplats * 2);
          }
          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);
        }
        if (sh2) {
          if (!extra.sh2) {
            extra.sh2 = new Uint32Array(numSplats * 4);
          }
          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);
        }
        if (sh3) {
          if (!extra.sh3) {
            extra.sh3 = new Uint32Array(numSplats * 4);
          }
          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);
        }
      }
    );
    return { packedArray, numSplats, extra };
  }
  function unpackSpz(fileBytes, splatEncoding) {
    const spz = new SpzReader({ fileBytes });
    const numSplats = spz.numSplats;
    const maxSplats = computeMaxSplats(numSplats);
    const packedArray = new Uint32Array(maxSplats * 4);
    const extra = {};
    spz.parseSplats(
      (index, x2, y, z) => {
        setPackedSplatCenter(packedArray, index, x2, y, z);
      },
      (index, alpha) => {
        setPackedSplatOpacity(packedArray, index, alpha);
      },
      (index, r, g, b) => {
        setPackedSplatRgb(packedArray, index, r, g, b, splatEncoding);
      },
      (index, scaleX, scaleY, scaleZ) => {
        setPackedSplatScales(
          packedArray,
          index,
          scaleX,
          scaleY,
          scaleZ,
          splatEncoding
        );
      },
      (index, quatX, quatY, quatZ, quatW) => {
        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);
      },
      (index, sh1, sh2, sh3) => {
        if (sh1) {
          if (!extra.sh1) {
            extra.sh1 = new Uint32Array(numSplats * 2);
          }
          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);
        }
        if (sh2) {
          if (!extra.sh2) {
            extra.sh2 = new Uint32Array(numSplats * 4);
          }
          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);
        }
        if (sh3) {
          if (!extra.sh3) {
            extra.sh3 = new Uint32Array(numSplats * 4);
          }
          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);
        }
      }
    );
    return { packedArray, numSplats, extra };
  }
  const DEPTH_INFINITY_F16 = 31744;
  const DEPTH_SIZE_16 = DEPTH_INFINITY_F16 + 1;
  let depthArray16 = null;
  function sortSplats({
    totalSplats,
    readback,
    ordering
  }) {
    if (!depthArray16) {
      depthArray16 = new Uint32Array(DEPTH_SIZE_16);
    }
    depthArray16.fill(0);
    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));
    const layerSize = readbackUint32[0].length;
    const numLayers = Math.ceil(totalSplats / layerSize);
    let layerBase = 0;
    for (let layer = 0; layer < numLayers; ++layer) {
      const readbackLayer = readbackUint32[layer];
      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);
      for (let i2 = 0; i2 < layerSplats; ++i2) {
        const pri = readbackLayer[i2] & 32767;
        if (pri < DEPTH_INFINITY_F16) {
          depthArray16[pri] += 1;
        }
      }
      layerBase += layerSplats;
    }
    let activeSplats = 0;
    for (let j = 0; j < DEPTH_SIZE_16; ++j) {
      const nextIndex = activeSplats + depthArray16[j];
      depthArray16[j] = activeSplats;
      activeSplats = nextIndex;
    }
    layerBase = 0;
    for (let layer = 0; layer < numLayers; ++layer) {
      const readbackLayer = readbackUint32[layer];
      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);
      for (let i2 = 0; i2 < layerSplats; ++i2) {
        const pri = readbackLayer[i2] & 32767;
        if (pri < DEPTH_INFINITY_F16) {
          ordering[depthArray16[pri]] = layerBase + i2;
          depthArray16[pri] += 1;
        }
      }
      layerBase += layerSplats;
    }
    if (depthArray16[DEPTH_SIZE_16 - 1] !== activeSplats) {
      throw new Error(
        \`Expected \${activeSplats} active splats but got \${depthArray16[DEPTH_SIZE_16 - 1]}\`
      );
    }
    return { activeSplats, ordering };
  }
  const messageBuffer = [];
  function bufferMessage(event) {
    messageBuffer.push(event);
  }
  async function initialize() {
    self.addEventListener("message", bufferMessage);
    await __wbg_init();
    self.removeEventListener("message", bufferMessage);
    self.addEventListener("message", onMessage);
    for (const event of messageBuffer) {
      onMessage(event);
    }
    messageBuffer.length = 0;
  }
  initialize().catch(console.error);
})();
//# sourceMappingURL=worker-erPBjhH-.js.map
`,WD=typeof self<"u"&&self.Blob&&new Blob([wV],{type:"text/javascript;charset=utf-8"});function uPe(n){let e;try{if(e=WD&&(self.URL||self.webkitURL).createObjectURL(WD),!e)throw"";const t=new Worker(e,{name:n?.name});return t.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(e)}),t}catch{return new Worker("data:text/javascript;charset=utf-8,"+encodeURIComponent(wV),{name:n?.name})}finally{e&&(self.URL||self.webkitURL).revokeObjectURL(e)}}class hPe{constructor(){this.messages={},this.messageIdNext=0,this.worker=new uPe,this.worker.onmessage=e=>this.onMessage(e)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const e=this.makeMessageId(),t=new Promise((s,i)=>{this.messages[e]={resolve:s,reject:i}});return{id:e,promise:t}}onMessage(e){const{id:t,result:s,error:i}=e.data,r=this.messages[t];r&&(delete this.messages[t],i?r.reject(i):r.resolve(s))}async call(e,t){const{id:s,promise:i}=this.makeMessagePromiseId();return this.worker.postMessage({name:e,args:t,id:s},{transfer:YFe(t)}),i}}let vV=4,hI=0;const SV=[],EV=[];async function dPe(){const n=SV.shift();if(n)return n;if(hI<vV){const e=new hPe;return hI+=1,e}return new Promise(e=>{EV.push(e)})}function pPe(n){if(hI>vV){hI-=1;return}const e=EV.shift();if(e){e(n);return}SV.push(n)}async function Uc(n){const e=await dPe();try{return await n(e)}finally{pPe(e)}}class fPe extends rr{constructor(e){super(e),this.fileLoader=new ma(e)}load(e,t,s,i){const r=this.manager.resolveURL((this.path??"")+(e??"")),o=new Headers(this.requestHeader),a=this.withCredentials?"include":"same-origin",l=new Request(r,{headers:o,credentials:a});let c=this.fileType;this.manager.itemStart(r),HD(l,s).then(async u=>{var h;const d=[new ProgressEvent("progress",{lengthComputable:!0,loaded:u.byteLength,total:u.byteLength})];function p(){if(s){const A=d.every(x=>x.lengthComputable||x.loaded===0&&x.total===0),y=d.reduce((x,C)=>x+C.loaded,0),b=d.reduce((x,C)=>x+C.total,0);s(new ProgressEvent("progress",{lengthComputable:A,loaded:y,total:b}))}}const f={},g=[],m=_V(u);if(c==="pcsogs"&&m===void 0)throw new Error("Invalid PC SOGS file");if(m!==void 0){c="pcsogs";for(const A of["means","scales","quats","sh0","shN"]){const y=m[A];if(y)for(const b of y.files){const x=new URL(b,r).toString(),C=d.length;d.push(new ProgressEvent("progress")),this.manager.itemStart(x);const w=new Request(x,{headers:o,credentials:a}),E=HD(w,T=>{d[C]=T,p()}).then(T=>{f[b]=T}).catch(T=>{throw this.manager.itemError(x),T}).finally(()=>{this.manager.itemEnd(x)});g.push(E)}}}if(await Promise.all(g),t){const A=((h=this.packedSplats)==null?void 0:h.splatEncoding)??qw,y=await TV({input:u,extraFiles:f,fileType:c,pathOrUrl:r,splatEncoding:A});this.packedSplats?(this.packedSplats.initialize(y),t(this.packedSplats)):t(new Uu(y))}}).catch(u=>{this.manager.itemError(r),i?.(u)}).finally(()=>{this.manager.itemEnd(r)})}async loadAsync(e,t){return new Promise((s,i)=>{this.load(e,r=>{s(r)},t,i)})}parse(e){return new zu({packedSplats:e})}}async function HD(n,e){const t=await fetch(n);if(!t.ok)throw new Error(`${t.status} "${t.statusText}" fetching URL: ${n.url}`);if(!t.body)throw new Error(`Response body is null for URL: ${n.url}`);const s=t.body.getReader(),i=Number.parseInt(t.headers.get("Content-Length")||"0"),r=Number.isNaN(i)?0:i;let o=0;const a=[];for(;;){const{done:u,value:h}=await s.read();if(u)break;a.push(h),o+=h.length,e&&e(new ProgressEvent("progress",{lengthComputable:r!==0,loaded:o,total:r}))}const l=new Uint8Array(o);let c=0;for(const u of a)l.set(u,c),c+=u.length;return l.buffer}function mPe(n){const e=new DataView(n.buffer);if((e.getUint32(0,!0)&16777215)===7957616)return"ply";if((e.getUint32(0,!0)&16777215)===559903){const t=u$e(n,4);return new DataView(t.buffer).getUint32(0,!0)===1347635022?"spz":void 0}if(e.getUint32(0,!0)===67324752)return yPe(n)?"pcsogszip":void 0}function gPe(n){const e=n.split(/[?#]/,1)[0],t=Math.max(e.lastIndexOf("/"),e.lastIndexOf("\\")),s=e.slice(t+1),i=s.lastIndexOf(".");return i<=0||i===s.length-1?"":s.slice(i+1).toLowerCase()}function APe(n){const e=gPe(n);if(e==="ply")return"ply";if(e==="spz")return"spz";if(e==="splat")return"splat";if(e==="ksplat")return"ksplat"}function _V(n){try{let e;if(typeof n=="string")e=n;else{const s=n instanceof ArrayBuffer?new Uint8Array(n):n;if(s.length>65536)return;e=new TextDecoder().decode(s)}const t=JSON.parse(e);if(!t||typeof t!="object"||Array.isArray(t))return;for(const s of["means","scales","quats","sh0"])if(!t[s]||typeof t[s]!="object"||Array.isArray(t[s])||!t[s].shape||!t[s].files||s!=="quats"&&(!t[s].mins||!t[s].maxs))return;return t}catch{return}}function yPe(n){try{const e=n instanceof ArrayBuffer?new Uint8Array(n):n;let t=null;const s=gFe(e,{filter:({name:r})=>r.split(/[\\/]/).pop()==="meta.json"?(t=r,!0):!1});if(!t)return;const i=_V(s[t]);return i?{name:t,json:i}:void 0}catch{return}}async function TV({input:n,extraFiles:e,fileType:t,pathOrUrl:s,splatEncoding:i}){const r=n instanceof ArrayBuffer?new Uint8Array(n):n;let o=t;switch(t||(o=mPe(r),!o&&s&&(o=APe(s))),o){case"ply":{const a=new ePe({fileBytes:r});await a.parseHeader();const l=a.numSplats,c=ro(l).maxSplats,u={fileBytes:r,packedArray:new Uint32Array(c*4),splatEncoding:i};return await Uc(async h=>{const{packedArray:d,numSplats:p,extra:f}=await h.call("unpackPly",u);return{packedArray:d,numSplats:p,extra:f}})}case"spz":return await Uc(async a=>{const{packedArray:l,numSplats:c,extra:u}=await a.call("decodeSpz",{fileBytes:r,splatEncoding:i});return{packedArray:l,numSplats:c,extra:u}});case"splat":return await Uc(async a=>{const{packedArray:l,numSplats:c}=await a.call("decodeAntiSplat",{fileBytes:r,splatEncoding:i});return{packedArray:l,numSplats:c}});case"ksplat":return await Uc(async a=>{const{packedArray:l,numSplats:c,extra:u}=await a.call("decodeKsplat",{fileBytes:r,splatEncoding:i});return{packedArray:l,numSplats:c,extra:u}});case"pcsogs":return await Uc(async a=>{const{packedArray:l,numSplats:c,extra:u}=await a.call("decodePcSogs",{fileBytes:r,extraFiles:e,splatEncoding:i});return{packedArray:l,numSplats:c,extra:u}});case"pcsogszip":return await Uc(async a=>{const{packedArray:l,numSplats:c,extra:u}=await a.call("decodePcSogsZip",{fileBytes:r,splatEncoding:i});return{packedArray:l,numSplats:c,extra:u}});default:throw new Error(`Unknown splat file type: ${o}`)}}var xPe=`precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out uvec4 target;

{{ GLOBALS }}

void produceSplat(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        produceSplat(index);
    } else {
        target = uvec4(0u, 0u, 0u, 0u);
    }
}`;const qw={rgbMin:0,rgbMax:1,lnScaleMin:al,lnScaleMax:ll,sh1Min:-1,sh1Max:1,sh2Min:-1,sh2Max:1,sh3Min:-1,sh3Max:1},ex=class vi{constructor(e={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new rk({packedSplats:this}),this.dynoRgbMinMaxLnScaleMinMax=new Ww({key:"rgbMinMaxLnScaleMinMax",value:new Yt(0,1,al,ll),update:t=>{var s,i,r,o;return t.set(((s=this.splatEncoding)==null?void 0:s.rgbMin)??0,((i=this.splatEncoding)==null?void 0:i.rgbMax)??1,((r=this.splatEncoding)==null?void 0:r.lnScaleMin)??al,((o=this.splatEncoding)==null?void 0:o.lnScaleMax)??ll),t}}),this.dynoSh1MinMax=new _S({key:"sh1MinMax",value:new $e(-1,1),update:t=>{var s,i;return t.set(((s=this.splatEncoding)==null?void 0:s.sh1Min)??-1,((i=this.splatEncoding)==null?void 0:i.sh1Max)??1),t}}),this.dynoSh2MinMax=new _S({key:"sh2MinMax",value:new $e(-1,1),update:t=>{var s,i;return t.set(((s=this.splatEncoding)==null?void 0:s.sh2Min)??-1,((i=this.splatEncoding)==null?void 0:i.sh2Max)??1),t}}),this.dynoSh3MinMax=new _S({key:"sh3MinMax",value:new $e(-1,1),update:t=>{var s,i;return t.set(((s=this.splatEncoding)==null?void 0:s.sh3Min)??-1,((i=this.splatEncoding)==null?void 0:i.sh3Max)??1),t}}),this.initialized=Promise.resolve(this),this.reinitialize(e)}reinitialize(e){this.isInitialized=!1,this.extra={},this.splatEncoding=e.splatEncoding,e.url||e.fileBytes||e.construct?this.initialized=this.asyncInitialize(e).then(()=>(this.isInitialized=!0,this)):(this.initialize(e),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(e){e.packedArray?(this.packedArray=e.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/Pn)*Pn,this.numSplats=Math.min(this.maxSplats,e.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=e.maxSplats??0,this.numSplats=0),this.extra=e.extra??{}}async asyncInitialize(e){const{url:t,fileBytes:s,construct:i}=e;if(t){const r=new fPe;r.packedSplats=this,await r.loadAsync(t)}else if(s){const r=await TV({input:s,fileType:e.fileType,pathOrUrl:e.fileName??t,splatEncoding:e.splatEncoding??qw});this.initialize(r)}if(i){const r=i(this);r instanceof Promise&&await r}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(e){const t=e<=this.maxSplats?this.maxSplats:Math.max(e,2*this.maxSplats),s=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||t>s){this.maxSplats=ro(t).maxSplats;const i=new Uint32Array(this.maxSplats*4);this.packedArray&&i.set(this.packedArray),this.packedArray=i}return this.packedArray}ensureSplatsSh(e,t){let s,i;if(e===0)return this.ensureSplats(t);if(e===1)s=2,i="sh1";else if(e===2)s=4,i="sh2";else if(e===3)s=4,i="sh3";else throw new Error(`Invalid level: ${e}`);let r=this.extra[i]?this.extra[i].length/s:0;const o=t<=r?r:Math.max(t,2*r);if(!this.extra[i]||o>r){r=ro(o).maxSplats;const a=new Uint32Array(r*s);this.extra[i]&&a.set(this.extra[i]),this.extra[i]=a}return this.extra[i]}getSplat(e){if(!this.packedArray||e>=this.numSplats)throw new Error("Invalid index");return OD(this.packedArray,e,this.splatEncoding)}setSplat(e,t,s,i,r,o){const a=this.ensureSplats(e+1);LD(a,e,t.x,t.y,t.z,s.x,s.y,s.z,i.x,i.y,i.z,i.w,r,o.r,o.g,o.b),this.numSplats=Math.max(this.numSplats,e+1)}pushSplat(e,t,s,i,r){const o=this.ensureSplats(this.numSplats+1);LD(o,this.numSplats,e.x,e.y,e.z,t.x,t.y,t.z,s.x,s.y,s.z,s.w,i,r.r,r.g,r.b),++this.numSplats}forEachSplat(e){if(!(!this.packedArray||!this.numSplats))for(let t=0;t<this.numSplats;++t){const s=OD(this.packedArray,t,this.splatEncoding);e(t,s.center,s.scales,s.quaternion,s.opacity,s.color)}}ensureGenerate(e){if(this.target&&(e??1)<=this.maxSplats)return!1;this.dispose();const t=ro(e??1),{width:s,height:i,depth:r}=t;return this.maxSplats=t.maxSplats,this.target=new RE(s,i,r,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:bs,minFilter:bs}),this.target.texture.format=ha,this.target.texture.type=Ri,this.target.texture.internalFormat="RGBA32UI",this.target.scissorTest=!0,!0}generateMapping(e){let t=0;const s=e.map(i=>{const r=t,o=Math.ceil(i/Pn)*Pn;return t+=o,{base:r,count:i}});return{maxSplats:t,mapping:s}}getTexture(){return this.target?this.target.texture:this.source||this.packedArray?this.maybeUpdateSource():vi.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:e,height:t,depth:s}=this.source.image;this.maxSplats!==e*t*s&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:e,height:t,depth:s}=ro(this.maxSplats);this.source=new ko(this.packedArray,e,t,s),this.source.format=ha,this.source.type=Ri,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!vi.emptySource){const{width:e,height:t,depth:s,maxSplats:i}=ro(1),r=new Uint32Array(i*4);vi.emptySource=new ko(r,e,t,s),vi.emptySource.format=ha,vi.emptySource.type=Ri,vi.emptySource.internalFormat="RGBA32UI",vi.emptySource.needsUpdate=!0}return vi.emptySource}prepareProgramMaterial(e){let t=vi.generatorProgram.get(e);if(!t){const i=cl({index:"int"},{output:"uvec4"},({index:r})=>{e.inputs.index=r;const o=e.outputs.gsplat;return{output:UFe(o,this.dynoRgbMinMaxLnScaleMinMax)}});vi.programTemplate||(vi.programTemplate=new hV(xPe)),t=new uV({graph:i,inputs:{index:"index"},outputs:{output:"target"},template:vi.programTemplate}),Object.assign(t.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),vi.generatorProgram.set(e,t)}const s=t.prepareMaterial();return vi.fullScreenQuad.material=s,{program:t,material:s}}saveRenderState(e){return{xrEnabled:e.xr.enabled,autoClear:e.autoClear}}resetRenderState(e,t){e.setRenderTarget(null),e.xr.enabled=t.xrEnabled,e.autoClear=t.autoClear}generate({generator:e,base:t,count:s,renderer:i}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(t+s>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:r,material:o}=this.prepareProgramMaterial(e);r.update();const a=this.saveRenderState(i),l=Math.ceil((t+s)/Pn)*Pn,c=Pn*su;for(o.uniforms.targetBase.value=t,o.uniforms.targetCount.value=s;t<l;){const u=Math.floor(t/c);o.uniforms.targetLayer.value=u;const h=u*c,d=Math.floor((t-h)/Pn),p=Math.min(su,Math.ceil((l-h)/Pn));this.target.scissor.set(0,d,Pn,p-d),i.setRenderTarget(this.target,u),i.xr.enabled=!1,i.autoClear=!1,vi.fullScreenQuad.render(i),t+=Pn*(p-d)}return this.resetRenderState(i,a),{nextBase:l}}};ex.emptySource=null;ex.programTemplate=null;ex.generatorProgram=new Map;ex.fullScreenQuad=new q4(new rA({visible:!1}));let Uu=ex;class rk extends Qo{constructor({packedSplats:e}={}){super({key:"packedSplats",type:Gw,globals:()=>[ek],value:{texture:Uu.getEmpty(),numSplats:0,rgbMinMaxLnScaleMinMax:new Yt(0,1,al,ll)},update:t=>{var s,i,r,o,a,l,c,u,h,d;return t.texture=((s=this.packedSplats)==null?void 0:s.getTexture())??Uu.getEmpty(),t.numSplats=((i=this.packedSplats)==null?void 0:i.numSplats)??0,t.rgbMinMaxLnScaleMinMax.set(((o=(r=this.packedSplats)==null?void 0:r.splatEncoding)==null?void 0:o.rgbMin)??0,((l=(a=this.packedSplats)==null?void 0:a.splatEncoding)==null?void 0:l.rgbMax)??1,((u=(c=this.packedSplats)==null?void 0:c.splatEncoding)==null?void 0:u.lnScaleMin)??al,((d=(h=this.packedSplats)==null?void 0:h.splatEncoding)==null?void 0:d.lnScaleMax)??ll),t}}),this.packedSplats=e}}class uE extends r2{constructor(e,t){super(),this.ordering=e,this.setAttribute("position",new Sn(bPe,3)),this.setIndex(new Sn(IPe,1)),this._maxInstanceCount=e.length,this.instanceCount=t,this.attribute=new bu(e,1,!1,1),this.attribute.setUsage(W3),this.setAttribute("splatIndex",this.attribute)}update(e,t){this.ordering=e,this.attribute.array=e,this.instanceCount=t,this.attribute.addUpdateRange(0,t),this.attribute.needsUpdate=!0}}const bPe=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0]),IPe=new Uint16Array([0,1,2,0,2,3]),ok=class Gm{constructor(e){if(this.lastTime=null,this.encodeLinear=!1,this.superXY=1,this.display=null,this.sorting=null,this.pending=null,this.sortingCheck=!1,this.readback16=new Uint16Array(0),this.readback32=new Uint32Array(0),this.spark=e.spark,this.camera=e.camera,this.viewToWorld=e.viewToWorld??new kt,e.target){const{width:t,height:s,doubleBuffer:i}=e.target,r=Math.max(1,Math.min(4,e.target.superXY??1));if(this.superXY=r,t*r>8192||s*r>8192)throw new Error("Target size too large");this.target=new ao(t*r,s*r,{format:ys,type:Di,colorSpace:Ei}),i&&(this.back=new ao(t*r,s*r,{format:ys,type:Di,colorSpace:Ei})),this.encodeLinear=!0}this.onTextureUpdated=e.onTextureUpdated,this.sortRadial=e.sortRadial??!0,this.sortDistance=e.sortDistance,this.sortCoorient=e.sortCoorient,this.depthBias=e.depthBias,this.sort360=e.sort360,this.sort32=e.sort32,this.stochastic=e.stochastic??!1,this.orderingFreelist=new XFe({allocate:t=>new Uint32Array(t),valid:(t,s)=>t.length===s}),this.autoUpdate=!1,this.setAutoUpdate(e.autoUpdate??!1)}dispose(){var e;this.setAutoUpdate(!1),this.target&&(this.target.dispose(),this.target=void 0),this.back&&(this.back.dispose(),this.back=void 0),this.display&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.geometry.dispose(),this.display=null),(e=this.pending)!=null&&e.accumulator&&(this.spark.releaseAccumulator(this.pending.accumulator),this.pending=null)}setAutoUpdate(e){!this.autoUpdate&&e?this.spark.autoViewpoints.push(this):this.autoUpdate&&!e&&(this.spark.autoViewpoints=this.spark.autoViewpoints.filter(t=>t!==this)),this.autoUpdate=e}async prepare({scene:e,camera:t,viewToWorld:s,update:i,forceOrigin:r}){var o;for(s?this.viewToWorld=s:(this.camera=t??this.camera,this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone()));i??!0;){const l=r?this.viewToWorld:void 0;if(this.spark.updateInternal({scene:e,originToWorld:l}))break;await new Promise(u=>setTimeout(u,10))}const a=this.spark.active;a!==((o=this.display)==null?void 0:o.accumulator)&&(this.spark.active.refCount+=1),await this.sortUpdate({accumulator:a,viewToWorld:this.viewToWorld})}renderTarget({scene:e,camera:t}){var s;const i=this.back??this.target;if(!i)throw new Error("Must initialize SparkViewpoint with target");if(t=t??this.camera,!t)throw new Error("Must provide camera");if(t instanceof Es){const r=new Es().copy(t,!1);r.aspect=i.width/i.height,r.updateProjectionMatrix(),t=r}this.viewToWorld=t.matrixWorld.clone();try{this.spark.renderer.setRenderTarget(i),this.spark.prepareViewpoint(this),this.spark.renderer.render(e,t)}finally{this.spark.prepareViewpoint(this.spark.defaultView),this.spark.renderer.setRenderTarget(null)}i!==this.target&&([this.target,this.back]=[this.back,this.target]),(s=this.onTextureUpdated)==null||s.call(this,i.texture)}async readTarget(){if(!this.target)throw new Error("Must initialize SparkViewpoint with target");const{width:e,height:t}=this.target,s=e*t*4;(!this.superPixels||this.superPixels.length<s)&&(this.superPixels=new Uint8Array(s)),await this.spark.renderer.readRenderTargetPixelsAsync(this.target,0,0,e,t,this.superPixels);const{superXY:i}=this;if(i===1)return this.superPixels;const r=e/i,o=t/i,a=r*o*4;(!this.pixels||this.pixels.length<a)&&(this.pixels=new Uint8Array(a));const{superPixels:l,pixels:c}=this,u=i*i;for(let h=0;h<o;h++){const d=h*r;for(let p=0;p<r;p++){const f=p*i;let g=0,m=0,A=0,y=0;for(let x=0;x<i;x++){const C=(h*i+x)*this.target.width;for(let w=0;w<i;w++){const E=(C+f+w)*4;g+=l[E],m+=l[E+1],A+=l[E+2],y+=l[E+3]}}const b=(d+p)*4;c[b]=g/u,c[b+1]=m/u,c[b+2]=A/u,c[b+3]=y/u}}return c}async prepareRenderPixels({scene:e,camera:t,viewToWorld:s,update:i,forceOrigin:r}){return await this.prepare({scene:e,camera:t,viewToWorld:s,update:i,forceOrigin:r}),this.renderTarget({scene:e,camera:t}),this.readTarget()}autoPoll({accumulator:e}){var t,s,i,r;this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone());let o=!1,a=!1;if(!this.display)o=!0;else if(e){o=!0;const{mappingVersion:c}=this.display.accumulator;e.mappingVersion===c&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=e,a=!0)}const l=((t=this.sorting)==null?void 0:t.viewToWorld)??((s=this.display)==null?void 0:s.viewToWorld);l&&!rE({matrix1:this.viewToWorld,matrix2:l,maxDistance:this.sortDistance??.01,minCoorient:this.sortCoorient??this.sortRadial?.99:.999})&&(o=!0),o&&(e&&(e.refCount+=1),e&&((i=this.pending)!=null&&i.accumulator)&&this.pending.accumulator!==((r=this.display)==null?void 0:r.accumulator)&&this.spark.releaseAccumulator(this.pending.accumulator),this.pending={accumulator:e,viewToWorld:this.viewToWorld,displayed:a},this.driveSort())}async driveSort(){for(var e;;){if(this.sorting||!this.pending)return;const{viewToWorld:t,displayed:s}=this.pending;let i=this.pending.accumulator??((e=this.display)==null?void 0:e.accumulator);if(i||(i=this.spark.active,i.refCount+=1),this.pending=null,!i)throw new Error("No accumulator to sort");this.sorting={viewToWorld:t},await this.sortUpdate({accumulator:i,viewToWorld:t,displayed:s}),this.sorting=null}}async sortUpdate({accumulator:e,viewToWorld:t,displayed:s=!1}){if(this.sortingCheck)throw new Error("Only one sort at a time");this.sortingCheck=!0,e=e??this.spark.active;const{numSplats:i,maxSplats:r}=e.splats;let o=0,a=this.orderingFreelist.alloc(r);if(this.stochastic){o=i;for(let l=0;l<i;++l)a[l]=l}else if(i>0){const{reader:l,doubleSortReader:c,sort32Reader:u,dynoSortRadial:h,dynoOrigin:d,dynoDirection:p,dynoDepthBias:f,dynoSort360:g,dynoSplats:m}=Gm.makeSorter(),A=this.sort32??!1;let y;if(A)this.readback32=l.ensureBuffer(r,this.readback32),y=this.readback32;else{const T=Math.ceil(r/2);this.readback16=l.ensureBuffer(T,this.readback16),y=this.readback16}const b=e.toWorld.clone().invert(),x=t.clone().premultiply(b);h.value=this.sort360?!0:this.sortRadial,d.value.set(0,0,0).applyMatrix4(x),p.value.set(0,0,-1).applyMatrix4(x).sub(d.value).normalize(),f.value=this.depthBias??1,g.value=this.sort360??!1,m.packedSplats=e.splats;const C=A?u:c,w=A?i:Math.ceil(i/2);await l.renderReadback({renderer:this.spark.renderer,reader:C,count:w,readback:y});const E=await Uc(async T=>{const v=A?"sort32Splats":"sortDoubleSplats";return T.call(v,{maxSplats:r,numSplats:i,readback:y,ordering:a})});A?this.readback32=E.readback:this.readback16=E.readback,a=E.ordering,o=E.activeSplats}this.updateDisplay({accumulator:e,viewToWorld:t,ordering:a,activeSplats:o,displayed:s}),this.sortingCheck=!1}updateDisplay({accumulator:e,viewToWorld:t,ordering:s,activeSplats:i,displayed:r=!1}){if(!this.display)this.display={accumulator:e,viewToWorld:t,geometry:new uE(s,i)};else{!r&&e!==this.display.accumulator&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=e),this.display.viewToWorld=t;const o=this.display.geometry.ordering;o.length===s.length?this.display.geometry.update(s,i):(this.display.geometry.dispose(),this.display.geometry=new uE(s,i)),this.orderingFreelist.free(o)}this.spark.viewpoint===this&&this.spark.prepareViewpoint(this)}static makeSorter(){if(!Gm.dynos){const e=new PD({value:!0}),t=new cI({value:new U}),s=new cI({value:new U}),i=new Yg({value:1}),r=new PD({value:!1}),o=new rk,a=new pV,l=cl({index:"int"},{rgba8:"vec4"},({index:u})=>{if(!u)throw new Error("No index");const h={sortRadial:e,sortOrigin:t,sortDirection:s,sortDepthBias:i,sort360:r},d=Vm(u,ig("int",2)),p=rg(o,d),f=MS({gsplat:p,...h}),g=rg(o,Xc(d,ig("int",1))),m=MS({gsplat:g,...h}),A=v$e({vectorType:"vec2",x:f,y:m});return{rgba8:QD(y$e(A))}}),c=cl({index:"int"},{rgba8:"vec4"},({index:u})=>{if(!u)throw new Error("No index");const h={sortRadial:e,sortOrigin:t,sortDirection:s,sortDepthBias:i,sort360:r},d=rg(o,u),p=MS({gsplat:d,...h});return{rgba8:QD(A$e(p))}});Gm.dynos={dynoSortRadial:e,dynoOrigin:t,dynoDirection:s,dynoDepthBias:i,dynoSort360:r,dynoSplats:o,reader:a,doubleSortReader:l,sort32Reader:c}}return Gm.dynos}};ok.EMPTY_TEXTURE=new cs;ok.dynos=null;let qD=ok;const CPe=_r(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);function MS({gsplat:n,sortRadial:e,sortOrigin:t,sortDirection:s,sortDepthBias:i,sort360:r}){return Uw({inTypes:{gsplat:Ys,sortRadial:"bool",sortOrigin:"vec3",sortDirection:"vec3",sortDepthBias:"float",sort360:"bool"},outTypes:{metric:"float"},globals:()=>[Ba,CPe],inputs:{gsplat:n,sortRadial:e,sortOrigin:t,sortDirection:s,sortDepthBias:i,sort360:r},statements:({inputs:o,outputs:a})=>{const{gsplat:l,sortRadial:c,sortOrigin:u,sortDirection:h,sortDepthBias:d,sort360:p}=o;return Ta(`
        ${a.metric} = computeSort(${l}, ${c}, ${u}, ${h}, ${d}, ${p});
      `)}}).outputs.metric}class NS{constructor(){this.splats=new Uu,this.toWorld=new kt,this.mapping=[],this.refCount=0,this.splatsVersion=-1,this.mappingVersion=-1}ensureGenerate(e){this.splats.ensureGenerate(e)&&(this.mapping=[])}generateSplats({renderer:e,modifier:t,generators:s,forceUpdate:i,originToWorld:r}){const o=this.mapping.reduce((c,u)=>(c.set(u.node,u),c),new Map);let a=0,l=0;for(const{node:c,generator:u,version:h,base:d,count:p}of s){const f=o.get(c);if((i||u!==f?.generator||h!==f?.version||d!==f?.base||p!==f?.count)&&u&&p>0){const g=t.apply(u);try{this.splats.generate({generator:g,base:d,count:p,renderer:e})}catch(m){c.generator=void 0,c.generatorError=m}a+=1}l=Math.max(l,d+p)}return this.splats.numSplats=l,this.toWorld=r,this.mapping=s,a!==0}hasCorrespondence(e){return this.mapping.length!==e.mapping.length?!1:this.mapping.every(({node:t,base:s,count:i},r)=>{const{node:o,base:a,count:l}=e.mapping[r];return t===o&&s===a&&i===l})}}var wPe=`const float LN_SCALE_MIN = -12.0;
const float LN_SCALE_MAX = 9.0;

const uint SPLAT_TEX_WIDTH_BITS = 11u;
const uint SPLAT_TEX_HEIGHT_BITS = 11u;
const uint SPLAT_TEX_DEPTH_BITS = 11u;
const uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;

const uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;
const uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;
const uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;

const uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;
const uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;
const uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;

const uint F16_INF = 0x7c00u;
const float PI = 3.1415926535897932384626433832795;

const float INFINITY = 1.0 / 0.0;
const float NEG_INFINITY = -INFINITY;

float sqr(float x) {
    return x * x;
}

float pow4(float x) {
    float x2 = x * x;
    return x2 * x2;
}

float pow8(float x) {
    float x4 = pow4(x);
    return x4 * x4;
}

vec3 srgbToLinear(vec3 rgb) {
    return pow(rgb, vec3(2.2));
}

vec3 linearToSrgb(vec3 rgb) {
    return pow(rgb, vec3(1.0 / 2.2));
}

uint encodeQuatOctXy88R8(vec4 q) {
    
    if (q.w < 0.0) {
        q = -q;
    }
    
    float theta = 2.0 * acos(q.w);
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    
    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;
    
    
    
    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);
    vec2 p = vec2(axis.x, axis.y) / sum;
    
    if (axis.z < 0.0) {
        float oldPx = p.x;
        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);
        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);
    }
    
    float u_f = p.x * 0.5 + 0.5;
    float v_f = p.y * 0.5 + 0.5;
    
    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));
    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));
    
    
    
    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));
    
    
    return (angleInt << 16u) | (quantV << 8u) | quantU;
}

vec4 decodeQuatOctXy88R8(uint encoded) {
    
    uint quantU = encoded & uint(0xFFu);               
    uint quantV = (encoded >> 8u) & uint(0xFFu);         
    uint angleInt = encoded >> 16u;                      

    
    float u_f = float(quantU) / 255.0;
    float v_f = float(quantV) / 255.0;
    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);

    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-axis.z, 0.0);
    axis.x += (axis.x >= 0.0) ? -t : t;
    axis.y += (axis.y >= 0.0) ? -t : t;
    axis = normalize(axis);
    
    
    float theta = (float(angleInt) / 255.0) * 3.14159265359;
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    float w = cos(halfTheta);
    
    return vec4(axis * s, w);
}

    

    

    

    

    

    

    

    

    

    

uvec4 packSplatEncoding(
    vec3 center, vec3 scales, vec4 quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax
) {
    float rgbMin = rgbMinMaxLnScaleMinMax.x;
    float rgbMax = rgbMinMaxLnScaleMinMax.y;
    vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);
    uvec4 uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));

    uint uQuat = encodeQuatOctXy88R8(quaternion);
    
    
    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);

    
    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;
    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;
    float lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);
    uvec3 uScales = uvec3(
        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,
        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,
        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u
    );

    
    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);
    uint word1 = packHalf2x16(center.xy);
    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);
    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);
    return uvec4(word0, word1, word2, word3);
}

uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {
    return packSplatEncoding(center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));
}

void unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {
    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;

    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);
    float rgbMin = rgbMinMaxLnScaleMinMax.x;
    float rgbMax = rgbMinMaxLnScaleMinMax.y;
    rgba = (vec4(uRgba) / 255.0);
    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) + rgbMin;

    center = vec4(
        unpackHalf2x16(word1),
        unpackHalf2x16(word2 & 0xffffu)
    ).xyz;

    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);
    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;
    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;
    float lnScaleScale = (lnScaleMax - lnScaleMin) / 254.0;
    scales = vec3(
        (uScales.x == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),
        (uScales.y == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),
        (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * lnScaleScale)
    );

    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);
    quaternion = decodeQuatOctXy88R8(uQuat);
    
    
}

void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {
    unpackSplatEncoding(packed, center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));
}

vec3 quatVec(vec4 q, vec3 v) {
    
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 quatQuat(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    );
}

mat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {
    
    return mat3(
        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),
        s.x * (2.0 * (q.x * q.y + q.w * q.z)),
        s.x * (2.0 * (q.x * q.z - q.w * q.y)),
        s.y * (2.0 * (q.x * q.y - q.w * q.z)),
        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),
        s.y * (2.0 * (q.y * q.z + q.w * q.x)),
        s.z * (2.0 * (q.x * q.z + q.w * q.y)),
        s.z * (2.0 * (q.y * q.z - q.w * q.x)),
        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))
    );
}

vec4 slerp(vec4 q1, vec4 q2, float t) {
    
    float cosHalfTheta = dot(q1, q2);

    
    if (abs(cosHalfTheta) >= 0.999) {
        return q1;
    }
    
    
    
    if (cosHalfTheta < 0.0) {
        q2 = -q2;
        cosHalfTheta = -cosHalfTheta;
    }

    
    float halfTheta = acos(cosHalfTheta);
    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    
    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;
    float ratioB = sin(t * halfTheta) / sinHalfTheta;

    
    return q1 * ratioA + q2 * ratioB;
}

ivec3 splatTexCoord(int index) {
    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;
    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;
    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;
    return ivec3(x, y, z);
}`,vPe=`precision highp float;
precision highp int;

#include <splatDefines>

uniform float near;
uniform float far;
uniform bool encodeLinear;
uniform float time;
uniform bool debugFlag;
uniform float maxStdDev;
uniform float minAlpha;
uniform bool stochastic;
uniform bool disableFalloff;
uniform float falloff;

uniform bool splatTexEnable;
uniform sampler3D splatTexture;
uniform mat2 splatTexMul;
uniform vec2 splatTexAdd;
uniform float splatTexNear;
uniform float splatTexFar;
uniform float splatTexMid;

out vec4 fragColor;

in vec4 vRgba;
in vec2 vSplatUv;
in vec3 vNdc;
flat in uint vSplatIndex;

void main() {
    vec4 rgba = vRgba;

    float z = dot(vSplatUv, vSplatUv);
    if (!splatTexEnable) {
        if (z > (maxStdDev * maxStdDev)) {
            discard;
        }
    } else {
        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;
        float ndcZ = vNdc.z;
        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));
        float clampedFar = max(splatTexFar, splatTexNear);
        float clampedDepth = clamp(depth, splatTexNear, clampedFar);
        float logDepth = log2(clampedDepth + 1.0);
        float logNear = log2(splatTexNear + 1.0);
        float logFar = log2(clampedFar + 1.0);

        float texZ;
        if (splatTexMid > 0.0) {
            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);
            float logMid = log2(clampedMid + 1.0);
            texZ = (clampedDepth <= clampedMid) ?
                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :
                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);
        } else {
            texZ = (logDepth - logNear) / (logFar - logNear);
        }

        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));
        rgba *= modulate;
    }

    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);

    if (rgba.a < minAlpha) {
        discard;
    }
    if (encodeLinear) {
        rgba.rgb = srgbToLinear(rgba.rgb);
    }

    if (stochastic) {
        const bool STEADY = false;
        uint uTime = STEADY ? 0u : floatBitsToUint(time);
        uvec2 coord = uvec2(gl_FragCoord.xy);
        uint state = uTime + 0x9e3779b9u * coord.x + 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);
        state = state * 747796405u + 2891336453u;
        uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
        hash = (hash >> 22u) ^ hash;
        float rand = float(hash) / 4294967296.0;
        if (rand < rgba.a) {
            fragColor = vec4(rgba.rgb, 1.0);
        } else {
            discard;
        }
    } else {
        #ifdef PREMULTIPLIED_ALPHA
            fragColor = vec4(rgba.rgb * rgba.a, rgba.a);
        #else
            fragColor = rgba;
        #endif
    }
}`,SPe=`precision highp float;
precision highp int;
precision highp usampler2DArray;

#include <splatDefines>

attribute uint splatIndex;

out vec4 vRgba;
out vec2 vSplatUv;
out vec3 vNdc;
flat out uint vSplatIndex;

uniform vec2 renderSize;
uniform uint numSplats;
uniform vec4 renderToViewQuat;
uniform vec3 renderToViewPos;
uniform float maxStdDev;
uniform float maxPixelRadius;
uniform float time;
uniform float deltaTime;
uniform bool debugFlag;
uniform float minAlpha;
uniform bool stochastic;
uniform bool enable2DGS;
uniform float blurAmount;
uniform float preBlurAmount;
uniform float focalDistance;
uniform float apertureAngle;
uniform float clipXY;
uniform float focalAdjustment;

uniform usampler2DArray packedSplats;
uniform vec4 rgbMinMaxLnScaleMinMax;

void main() {
    
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    if (uint(gl_InstanceID) >= numSplats) {
        return;
    }

    ivec3 texCoord;
    if (stochastic) {
        texCoord = ivec3(
            uint(gl_InstanceID) & SPLAT_TEX_WIDTH_MASK,
            (uint(gl_InstanceID) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
            (uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)
        );
    } else {
        if (splatIndex == 0xffffffffu) {
            
            return;
        }
        texCoord = ivec3(
            splatIndex & SPLAT_TEX_WIDTH_MASK,
            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
            splatIndex >> SPLAT_TEX_LAYER_BITS
        );
    }
    uvec4 packed = texelFetch(packedSplats, texCoord, 0);

    vec3 center, scales;
    vec4 quaternion, rgba;
    unpackSplatEncoding(packed, center, scales, quaternion, rgba, rgbMinMaxLnScaleMinMax);

    if (rgba.a < minAlpha) {
        return;
    }
    bvec3 zeroScales = equal(scales, vec3(0.0));
    if (all(zeroScales)) {
        return;
    }

    
    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;

    
    if (viewCenter.z >= 0.0) {
        return;
    }

    
    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);

    
    if (abs(clipCenter.z) >= clipCenter.w) {
        return;
    }

    
    float clip = clipXY * clipCenter.w;
    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {
        return;
    }

    
    vSplatIndex = splatIndex;

    
    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);

    if (enable2DGS && any(zeroScales)) {
        vRgba = rgba;
        vSplatUv = position.xy * maxStdDev;

        vec3 offset;
        if (zeroScales.z) {
            offset = vec3(vSplatUv.xy * scales.xy, 0.0);
        } else if (zeroScales.y) {
            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);
        } else {
            offset = vec3(0.0, vSplatUv.xy * scales.yz);
        }

        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);
        gl_Position = projectionMatrix * vec4(viewPos, 1.0);
        vNdc = gl_Position.xyz / gl_Position.w;
        return;
    }

    
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

    
    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);
    mat3 cov3D = RS * transpose(RS);

    
    vec2 scaledRenderSize = renderSize * focalAdjustment;
    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);

    mat3 J;
    if(isOrthographic) {
        J = mat3(
            focal.x, 0.0, 0.0,
            0.0, focal.y, 0.0,
            0.0, 0.0, 0.0
        );
    } else {
        float invZ = 1.0 / viewCenter.z;
        vec2 J1 = focal * invZ;
        vec2 J2 = -(J1 * viewCenter.xy) * invZ;
        J = mat3(
            J1.x, 0.0, J2.x,
            0.0, J1.y, J2.y,
            0.0, 0.0, 0.0
        );
    }

    
    
    
    
    
    
    
    mat3 cov2D = transpose(J) * cov3D * J;
    float a = cov2D[0][0];
    float d = cov2D[1][1];
    float b = cov2D[0][1];

    
    a += preBlurAmount;
    d += preBlurAmount;

    float fullBlurAmount = blurAmount;
    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {
        float focusRadius = maxPixelRadius;
        if (viewCenter.z < 0.0) {
            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);
            float apertureRadius = focal.x * tan(0.5 * apertureAngle);
            focusRadius = focusBlur * apertureRadius;
        }
        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(maxPixelRadius));
    }

    
    float detOrig = a * d - b * b;
    a += fullBlurAmount;
    d += fullBlurAmount;
    float det = a * d - b * b;

    
    float blurAdjust = sqrt(max(0.0, detOrig / det));
    rgba.a *= blurAdjust;
    if (rgba.a < minAlpha) {
        return;
    }

    
    float eigenAvg = 0.5 * (a + d);
    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));
    float eigen1 = eigenAvg + eigenDelta;
    float eigen2 = eigenAvg - eigenDelta;

    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));
    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);

    float scale1 = position.x * min(maxPixelRadius, maxStdDev * sqrt(eigen1));
    float scale2 = position.y * min(maxPixelRadius, maxStdDev * sqrt(eigen2));

    
    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;
    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;
    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);

    vRgba = rgba;
    vSplatUv = position.xy * maxStdDev;
    vNdc = ndc;
    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);
}`;let RS=null;function EPe(){return RS||(Kt.splatDefines=wPe,RS={splatVertex:SPe,splatFragment:vPe}),RS}const YD=5,Yw=class Si extends On{constructor(e){const t=Si.makeUniforms(),s=EPe(),i=e.premultipliedAlpha??!0,r=new Hr({glslVersion:pg,vertexShader:s.splatVertex,fragmentShader:s.splatFragment,uniforms:t,premultipliedAlpha:i,transparent:!0,depthTest:!0,depthWrite:!1,side:io});super(XD,r),this.splatTexture=null,this.autoViewpoints=[],this.rotateToAccumulator=new Ww({value:new $n}),this.translateToAccumulator=new cI({value:new U}),this.lastFrame=-1,this.lastUpdateTime=null,this.defaultCameras=[],this.lastStochastic=null,this.pendingUpdate={scene:null,originToWorld:new kt,timeoutId:-1},this.envViewpoint=null,this.frustumCulled=!1,this.renderer=e.renderer,this.material=r,this.uniforms=t;const o=cl({gsplat:Ys},{gsplat:Ys},({gsplat:a})=>{if(!a)throw new Error("gsplat not defined");return a=oV(a,{rotate:this.rotateToAccumulator,translate:this.translateToAccumulator}),{gsplat:a}});this.modifier=new G$e(o),this.premultipliedAlpha=i,this.autoUpdate=e.autoUpdate??!0,this.preUpdate=e.preUpdate??!1,this.needsUpdate=!1,this.originDistance=e.originDistance??1,this.maxStdDev=e.maxStdDev??Math.sqrt(8),this.maxPixelRadius=e.maxPixelRadius??512,this.minAlpha=e.minAlpha??.5*(1/255),this.enable2DGS=e.enable2DGS??!1,this.preBlurAmount=e.preBlurAmount??0,this.blurAmount=e.blurAmount??.3,this.focalDistance=e.focalDistance??0,this.apertureAngle=e.apertureAngle??0,this.falloff=e.falloff??1,this.clipXY=e.clipXY??1.4,this.focalAdjustment=e.focalAdjustment??1,this.splatEncoding=e.splatEncoding??{...qw},this.active=new NS,this.accumulatorCount=1,this.freeAccumulators=[];for(let a=0;a<1;++a)this.freeAccumulators.push(new NS),this.accumulatorCount+=1;this.defaultView=new qD({...e.view,autoUpdate:!0,spark:this}),this.viewpoint=this.defaultView,this.prepareViewpoint(this.viewpoint),this.clock=e.clock?n$e(e.clock):new VI}static makeUniforms(){return{renderSize:{value:new $e},near:{value:.1},far:{value:1e3},numSplats:{value:0},renderToViewQuat:{value:new $n},renderToViewPos:{value:new U},maxStdDev:{value:1},maxPixelRadius:{value:512},minAlpha:{value:.00196078431372549},stochastic:{value:!1},enable2DGS:{value:!1},preBlurAmount:{value:0},blurAmount:{value:.3},focalDistance:{value:0},apertureAngle:{value:0},falloff:{value:1},clipXY:{value:1.4},focalAdjustment:{value:1},splatTexEnable:{value:!1},splatTexture:{type:"t",value:Si.EMPTY_SPLAT_TEXTURE},splatTexMul:{value:new cA},splatTexAdd:{value:new $e},splatTexNear:{value:.1},splatTexFar:{value:1e3},splatTexMid:{value:0},packedSplats:{type:"t",value:Uu.getEmpty()},rgbMinMaxLnScaleMinMax:{value:new Yt},time:{value:0},deltaTime:{value:0},encodeLinear:{value:!1},debugFlag:{value:!1}}}canAllocAccumulator(){return this.freeAccumulators.length>0||this.accumulatorCount<YD}maybeAllocAccumulator(){let e=this.freeAccumulators.pop();if(e===void 0){if(this.accumulatorCount>=YD)return null;e=new NS,this.accumulatorCount+=1}return e.refCount=1,e}releaseAccumulator(e){e.refCount-=1,e.refCount===0&&this.freeAccumulators.push(e)}newViewpoint(e){return new qD({...e,spark:this})}onBeforeRender(e,t,s){var i,r;const o=this.time??this.clock.getElapsedTime(),a=o-(this.viewpoint.lastTime??o);this.viewpoint.lastTime=o;const l=e.info.render.frame,c=l!==this.lastFrame;this.lastFrame=l;const u=this.viewpoint;if(u===this.defaultView){if(c)if(!e.xr.isPresenting)this.defaultView.viewToWorld=s.matrixWorld.clone(),this.defaultCameras=[this.defaultView.viewToWorld];else{const g=e.xr.getCamera().cameras;this.defaultCameras=g.map(m=>m.matrixWorld),this.defaultView.viewToWorld=_Pe(this.defaultCameras)??new kt}this.autoUpdate&&this.update({scene:t,viewToWorld:this.defaultView.viewToWorld})}if(c&&(this.material.premultipliedAlpha!==this.premultipliedAlpha&&(this.material.premultipliedAlpha=this.premultipliedAlpha,this.material.needsUpdate=!0),this.uniforms.time.value=o,this.uniforms.deltaTime.value=a,this.uniforms.debugFlag.value=performance.now()/1e3%2<1,u.display&&u.stochastic&&(this.geometry.instanceCount=this.uniforms.numSplats.value)),u.target)this.uniforms.renderSize.value.set(u.target.width,u.target.height);else{const g=e.getDrawingBufferSize(this.uniforms.renderSize.value);if(g.x===1&&g.y===1){const m=(i=e.xr.getSession())==null?void 0:i.renderState.baseLayer;m&&(g.x=m.framebufferWidth,g.y=m.framebufferHeight)}}const h=s;if(this.uniforms.near.value=h.near,this.uniforms.far.value=h.far,this.uniforms.encodeLinear.value=u.encodeLinear,this.uniforms.maxStdDev.value=this.maxStdDev,this.uniforms.maxPixelRadius.value=this.maxPixelRadius,this.uniforms.minAlpha.value=this.minAlpha,this.uniforms.stochastic.value=u.stochastic,this.uniforms.enable2DGS.value=this.enable2DGS,this.uniforms.preBlurAmount.value=this.preBlurAmount,this.uniforms.blurAmount.value=this.blurAmount,this.uniforms.focalDistance.value=this.focalDistance,this.uniforms.apertureAngle.value=this.apertureAngle,this.uniforms.falloff.value=this.falloff,this.uniforms.clipXY.value=this.clipXY,this.uniforms.focalAdjustment.value=this.focalAdjustment,this.lastStochastic!==!u.stochastic&&(this.lastStochastic=!u.stochastic,this.material.transparent=!u.stochastic,this.material.depthWrite=u.stochastic,this.material.needsUpdate=!0),this.splatTexture){const{enable:g,texture:m,multiply:A,add:y,near:b,far:x,mid:C}=this.splatTexture;g&&m?(this.uniforms.splatTexEnable.value=!0,this.uniforms.splatTexture.value=m,A?this.uniforms.splatTexMul.value.fromArray(A.elements):this.uniforms.splatTexMul.value.set(.5/this.maxStdDev,0,0,.5/this.maxStdDev),this.uniforms.splatTexAdd.value.set(y?.x??.5,y?.y??.5),this.uniforms.splatTexNear.value=b??this.uniforms.near.value,this.uniforms.splatTexFar.value=x??this.uniforms.far.value,this.uniforms.splatTexMid.value=C??0):(this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=Si.EMPTY_SPLAT_TEXTURE)}else this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=Si.EMPTY_SPLAT_TEXTURE;const d=((r=u.display)==null?void 0:r.accumulator.toWorld)??new kt,p=s.matrixWorld.clone().invert();d.clone().premultiply(p).decompose(this.uniforms.renderToViewPos.value,this.uniforms.renderToViewQuat.value,new U)}prepareViewpoint(e){var t,s,i,r;if(this.viewpoint=e??this.viewpoint,this.viewpoint.display){const{accumulator:o,geometry:a}=this.viewpoint.display;this.uniforms.numSplats.value=o.splats.numSplats,this.uniforms.packedSplats.value=o.splats.getTexture(),this.uniforms.rgbMinMaxLnScaleMinMax.value.set(((t=o.splats.splatEncoding)==null?void 0:t.rgbMin)??0,((s=o.splats.splatEncoding)==null?void 0:s.rgbMax)??1,((i=o.splats.splatEncoding)==null?void 0:i.lnScaleMin)??al,((r=o.splats.splatEncoding)==null?void 0:r.lnScaleMax)??ll),this.geometry=a,this.material.transparent=!this.viewpoint.stochastic,this.material.depthWrite=this.viewpoint.stochastic,this.material.needsUpdate=!0}else this.uniforms.numSplats.value=0,this.uniforms.packedSplats.value=Uu.getEmpty(),this.geometry=XD}update({scene:e,viewToWorld:t}){const s=this.matrixWorld;this.preUpdate?this.updateInternal({scene:e,originToWorld:s.clone(),viewToWorld:t}):(this.pendingUpdate.scene=e,this.pendingUpdate.originToWorld.copy(s),this.pendingUpdate.timeoutId===-1&&(this.pendingUpdate.timeoutId=setTimeout(()=>{const{scene:i,originToWorld:r}=this.pendingUpdate;this.pendingUpdate.scene=null,this.pendingUpdate.timeoutId=-1,this.updateInternal({scene:i,originToWorld:r,viewToWorld:t})&&this.renderer.getContext().flush()},1)))}updateInternal({scene:e,originToWorld:t,viewToWorld:s}){var i;if(!this.canAllocAccumulator())return!1;t||(t=this.active.toWorld),s=s??t.clone();const r=this.time??this.clock.getElapsedTime(),o=r-(this.lastUpdateTime??r);this.lastUpdateTime=r;const a=this.active.mapping.reduce((g,m)=>(g.set(m.node,m),g),new Map),{generators:l,visibleGenerators:c,globalEdits:u}=this.compileScene(e);for(const g of l)(i=g.frameUpdate)==null||i.call(g,{object:g,time:r,deltaTime:o,viewToWorld:s,globalEdits:u});const h=new Set(c.map(g=>g.uuid));for(const g of l){const m=a.get(g),y=g.generator&&h.has(g.uuid)?g.numSplats:0;(this.needsUpdate||g.generator!==m?.generator||y!==m?.count)&&g.updateVersion()}const d=!rE({matrix1:t,matrix2:this.active.toWorld,maxDistance:this.originDistance}),p=this.needsUpdate||d||l.length!==a.size||l.some(g=>{var m;return g.version!==((m=a.get(g))==null?void 0:m.version)});this.needsUpdate=!1;let f=null;if(p){if(f=this.maybeAllocAccumulator(),!f)throw new Error("Unreachable");const g=!rE({matrix1:t,matrix2:this.active.toWorld,maxDistance:1e-5,minCoorient:.99999}),A=c.map((E,T)=>{const v=a.get(E);return v?[E.version-v.version,v.base,E]:[Number.POSITIVE_INFINITY,E.version,E]}).sort((E,T)=>E[0]!==T[0]?E[0]-T[0]:E[1]-T[1]).map(([E,T,v])=>v),y=A.map(E=>E.numSplats),{maxSplats:b,mapping:x}=f.splats.generateMapping(y),C=A.map((E,T)=>{const{base:v,count:S}=x[T];return{node:E,generator:E.generator,version:E.version,base:v,count:S}});t.clone().invert().decompose(this.translateToAccumulator.value,this.rotateToAccumulator.value,new U),f.ensureGenerate(b),f.splats.splatEncoding={...this.splatEncoding},f.generateSplats({renderer:this.renderer,modifier:this.modifier,generators:C,forceUpdate:g,originToWorld:t}),f.splatsVersion=this.active.splatsVersion+1;const w=f.hasCorrespondence(this.active);f.mappingVersion=this.active.mappingVersion+(w?0:1),this.releaseAccumulator(this.active),this.active=f,this.prepareViewpoint()}return setTimeout(()=>{for(const g of this.autoViewpoints)g.autoPoll({accumulator:f??void 0})},1),!0}compileScene(e){const t=[];e.traverse(r=>{r instanceof aE&&t.push(r)});const s=[];e.traverseVisible(r=>{r instanceof aE&&s.push(r)});const i=new Set;return e.traverseVisible(r=>{if(r instanceof yV){let o=r.parent;for(;o!=null&&!(o instanceof zu);)o=o.parent;o==null&&i.add(r)}}),{generators:t,visibleGenerators:s,globalEdits:Array.from(i)}}async renderEnvMap({renderer:e,scene:t,worldCenter:s,size:i=256,near:r=.1,far:o=1e3,hideObjects:a=[],update:l=!1}){var c,u;if(this.envViewpoint||(this.envViewpoint=this.newViewpoint({sort360:!0})),!Si.cubeRender||Si.cubeRender.target.width!==i||Si.cubeRender.near!==r||Si.cubeRender.far!==o){Si.cubeRender&&Si.cubeRender.target.dispose();const g=new PE(i,{format:ys,generateMipmaps:!0,minFilter:M3}),m=new $E(r,o,g);Si.cubeRender={target:g,camera:m,near:r,far:o}}Si.pmrem||(Si.pmrem=new Mb(e??this.renderer));const h=new kt().setPosition(s);await((c=this.envViewpoint)==null?void 0:c.prepare({scene:t,viewToWorld:h,update:l}));const{target:d,camera:p}=Si.cubeRender;p.position.copy(s);const f=new Map;for(const g of a)f.set(g,g.visible),g.visible=!1;this.prepareViewpoint(this.envViewpoint),p.update(e??this.renderer,t),this.prepareViewpoint(this.defaultView);for(const[g,m]of f.entries())g.visible=m;return(u=Si.pmrem)==null?void 0:u.fromCubemap(d.texture).texture}recurseSetEnvMap(e,t){e.traverse(s=>{if(s instanceof On)if(Array.isArray(s.material))for(const i of s.material)i instanceof xg&&(i.envMap=t);else s.material instanceof xg&&(s.material.envMap=t)})}getRgba({generator:e,rgba:t}){const s=this.active.mapping.find(({node:i})=>i===e);if(!s)throw new Error("Generator not found");return t=t??new P$e,t.fromPackedSplats({packedSplats:this.active.splats,base:s.base,count:s.count,renderer:this.renderer}),t}async readRgba({generator:e,rgba:t}){return t=this.getRgba({generator:e,rgba:t}),t.read()}};Yw.cubeRender=null;Yw.pmrem=null;Yw.EMPTY_SPLAT_TEXTURE=new Zg;let hE=Yw;const XD=new uE(new Uint32Array(1),0);cl({packedSplats:Gw,index:"int"},{gsplat:Ys},({packedSplats:n,index:e})=>{if(!n||!e)throw new Error("Invalid input");return{gsplat:rg(n,e)}});function _Pe(n){if(n.length===0)return null;const e=new U,t=new $n,s=new U,i=[],r=[];for(const o of n)o.decompose(e,t,s),i.push(e),r.push(t);return new kt().compose(i$e(i),r$e(r),new U(1,1,1))}_r(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`);_r(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);new Us(new U(-1,-1,-1),new U(1,1,1)),new U(-1,-3,1).normalize(),new ot(1,1,1),new ot(.5,.5,1),new U(1,1,1);new Us(new U(-2,-1,-2),new U(2,5,2)),new U(0,-1,0),new ot(1,1,1),new ot(.25,.25,.5),new U(.1,1,.1);const BV=class dE{static createButton(e,t={}){const s=navigator.xr;if(!s)return null;const i=s,r=document.createElement("button");e.xr.enabled=!0,e.xr.setReferenceSpaceType("local");function o(){let h=null;async function d(g){console.log("onSessionStarted"),g.addEventListener("end",p),await e.xr.setSession(g),r.textContent="EXIT VR",h=g}function p(){console.log("onSessionEnded"),h?.removeEventListener("end",p),r.textContent="ENTER VR",h=null}r.style.display="",r.style.cursor="pointer",r.style.left="calc(50% - 100px)",r.style.width="200px",r.style.height="100px",r.textContent="ENTER VR";const f={...t,optionalFeatures:[...t.optionalFeatures||[]]};r.onmouseenter=()=>{r.style.opacity="1.0"},r.onmouseleave=()=>{r.style.opacity="0.5"},r.onclick=()=>{h===null?(console.log("requesting session"),i.requestSession("immersive-vr",f).then(d)):(console.log("ending session"),h.end())}}function a(){r.style.display="none",r.style.cursor="auto",r.style.left="calc(50% - 75px)",r.style.width="150px",r.onmouseenter=null,r.onmouseleave=null,r.onclick=null}function l(){a(),r.textContent="VR NOT SUPPORTED"}function c(h){a(),console.warn("Exception when trying to call xr.isSessionSupported",h),r.textContent="VR NOT ALLOWED"}function u(h){h.style.position="absolute",h.style.bottom="20px",h.style.padding="12px 6px",h.style.border="1px solid #fff",h.style.borderRadius="4px",h.style.background="rgba(0,0,0,0.1)",h.style.color="#fff",h.style.font="normal 13px sans-serif",h.style.textAlign="center",h.style.opacity="0.5",h.style.outline="none",h.style.zIndex="999"}return r.id="VRButton",r.style.display="none",u(r),i.isSessionSupported("immersive-vr").then(h=>{h?o():l(),h&&dE.xrSessionIsGranted&&r.click()}).catch(c),r}static registerSessionGrantedListener(){const e=navigator.xr;if(!e)return null;const t=e;/WebXRViewer\//i.test(navigator.userAgent)||t.addEventListener("sessiongranted",()=>{dE.xrSessionIsGranted=!0})}};BV.xrSessionIsGranted=!1;let TPe=BV;TPe.registerSessionGrantedListener();var kV=(n=>(n.w="wrist",n.t0="thumb-metacarpal",n.t1="thumb-phalanx-proximal",n.t2="thumb-phalanx-distal",n.t3="thumb-tip",n.i0="index-finger-metacarpal",n.i1="index-finger-phalanx-proximal",n.i2="index-finger-phalanx-intermediate",n.i3="index-finger-phalanx-distal",n.i4="index-finger-tip",n.m0="middle-finger-metacarpal",n.m1="middle-finger-phalanx-proximal",n.m2="middle-finger-phalanx-intermediate",n.m3="middle-finger-phalanx-distal",n.m4="middle-finger-tip",n.r0="ring-finger-metacarpal",n.r1="ring-finger-phalanx-proximal",n.r2="ring-finger-phalanx-intermediate",n.r3="ring-finger-phalanx-distal",n.r4="ring-finger-tip",n.p0="pinky-finger-metacarpal",n.p1="pinky-finger-phalanx-proximal",n.p2="pinky-finger-phalanx-intermediate",n.p3="pinky-finger-phalanx-distal",n.p4="pinky-finger-tip",n))(kV||{});const BPe=Object.keys(kV);BPe.length;new U(0,0,-1),new U(0,0,1),new U(-1,0,0),new U(1,0,0),new U(0,1,0),new U(0,-1,0);new U(0,0,-1),new U(0,0,1),new U(-1,0,0),new U(1,0,0),new U(0,1,0),new U(0,-1,0);new U(0,0,1),new U(0,0,-1);new U(0,-1,0),new U(0,1,0),new U(-1,0,0),new U(1,0,0);let ea,U0,au,Bi,ki,ei,Ps,lu,pE,dI,xn,ak=!1,DS=0,FS=Date.now(),sa,fE=!1,lk=!1,Od=null;const kPe=3;let $S=0,Nr={x:0,y:0,z:0};const Q0=.6,mE=new URL(""+new URL("leftwing-Bgqn-mX7.ksplat",import.meta.url).href,import.meta.url).href,gE=new URL(""+new URL("rightwing-uLicuznU.ksplat",import.meta.url).href,import.meta.url).href,MV=1.8;let AE=MV,pI=0;const MPe=.5,NPe=.55,RPe=.25,PS=Math.PI/6,DPe=150;let $r="environment";const FPe=-5,$Pe=-5,jD=-10,KD=Math.PI/12;class PPe{constructor(){this.logsContainer=document.getElementById("debug-logs"),this.statusText=document.getElementById("status-text"),this.videoStatus=document.getElementById("video-status"),this.modelStatus=document.getElementById("model-status"),this.poseStatus=document.getElementById("pose-status"),this.assetStatus=document.getElementById("asset-status"),this.fpsCounter=document.getElementById("fps-counter"),this.positionStatus=document.getElementById("position-status"),this.maxLogs=30,this.setupControls()}setupControls(){const e=document.getElementById("debug-panel");e&&(document.getElementById("toggle-debug").addEventListener("click",()=>{e.classList.toggle("minimized"),document.getElementById("toggle-debug").textContent=e.classList.contains("minimized")?"+":""}),document.getElementById("clear-debug").addEventListener("click",()=>{this.logsContainer.innerHTML=""}))}log(e,t){const s=document.createElement("div");s.className=`debug-log ${e}`,s.textContent=`[${new Date().toLocaleTimeString()}] ${t}`,this.logsContainer&&this.logsContainer.children.length>=this.maxLogs&&this.logsContainer.removeChild(this.logsContainer.lastChild),this.logsContainer&&this.logsContainer.prepend(s)}updateStatus(e){this.statusText&&(this.statusText.textContent=e)}updateVideoStatus(e){this.videoStatus&&(this.videoStatus.textContent=e)}updateModelStatus(e){this.modelStatus&&(this.modelStatus.textContent=e)}updatePoseStatus(e){this.poseStatus&&(this.poseStatus.textContent=e)}updateAssetStatus(e){this.assetStatus&&(this.assetStatus.textContent=e)}updateFPS(e){this.fpsCounter&&(this.fpsCounter.textContent=e.toFixed(1))}updatePositionStatus(e,t,s,i){this.positionStatus&&(this.positionStatus.textContent=`L P: (${e.x.toFixed(2)}, ${e.y.toFixed(2)}) R P: (${s.x.toFixed(2)}, ${s.y.toFixed(2)}) Offset: ${pI.toFixed(2)}`)}}function LPe(){const n=document.getElementById("camera-toggle-btn");n&&(n.textContent=`Switch to ${$r==="user"?"Rear":"Front"} Camera`,n.addEventListener("click",OPe))}async function OPe(){xn.log("info",`Switching camera from ${$r} to ${$r==="user"?"environment":"user"}...`),ak=!1,Ps&&Ps.srcObject&&(Ps.srcObject.getTracks().forEach(t=>t.stop()),Ps.srcObject=null),$r=$r==="user"?"environment":"user";const n=document.getElementById("camera-toggle-btn");n&&(n.textContent=`Switch to ${$r==="user"?"Rear":"Front"} Camera`),Nr={x:0,y:0,z:0},Od=null,await NV()}function zPe(n,e,t){const s=n/e;let i=1;s<1?i=.85:s>1.7&&(i=1.1);const r=window.innerHeight/800;return t*i*Math.min(1,r)}async function UPe(){dI===void 0&&(xn.updateStatus("Initializing TensorFlow..."),C$("webgl"),await w$(),xn.log("success",`TensorFlow backend ready (${vu()}).`),xn.updateStatus("Loading AI model (MoveNet)..."),dI=await W4(di.MoveNet,{modelType:H4.modelType.SINGLEPOSE_LIGHTNING}),xn.log("success","AI model loaded!"),xn.updateModelStatus("MoveNet Loaded"))}function QPe(){if(xn=new PPe,xn.log("info","=== AR Back Wings Starting ==="),typeof RX>"u"||typeof oEe>"u"||typeof Y3e>"u"||typeof zu>"u"){xn.log("error","Module imports failed."),document.getElementById("instructions").innerHTML="<h2>Initialization Failed!</h2><p>Error: Required libraries failed to load.</p>";return}xn.log("success","Core libraries loaded (THREE, TF, Spark.js)"),UPe().catch(t=>{xn.log("error",`FATAL: Could not load Pose Model: ${t.message}`)});const n=document.getElementById("start-btn"),e=document.getElementById("instructions");n&&e&&n.addEventListener("click",async()=>{e.classList.add("hidden"),await NV(),LPe();const t=document.getElementById("camera-toggle-btn");t&&(t.style.display="block")}),xn.updateStatus("Ready - Tap Start")}async function NV(){try{const n=document.getElementById("three-container");lu=document.getElementById("output-canvas"),pE=lu.getContext("2d"),Ps=document.getElementById("video");const e=await navigator.mediaDevices.getUserMedia({video:{facingMode:$r,width:{ideal:1280},height:{ideal:720}}});Ps.srcObject=e,Ps.play().catch(i=>{xn.log("warning",`Video play() failed: ${i.message}`)}),xn.updateVideoStatus(`Camera stream active (${$r})`),await new Promise(i=>{Ps.onloadedmetadata=()=>{i(Ps)}});const t=Ps.videoWidth,s=Ps.videoHeight;lu.width=t,lu.height=s,n.style.width="100vw",n.style.height="100vh",au&&(n.removeChild(au.domElement),au.dispose(),au=null),xn.updateStatus("Setting up 3D renderer..."),VPe(t,s),xn.log("success","3D renderer ready"),AE=zPe(t,s,MV),xn.log("info",`Set initial wing scale to: ${AE.toFixed(2)}`),xn.updateStatus("Running - Stand back!"),ak=!0,RV()}catch(n){xn.log("error",`INIT ERROR: ${n.name}: ${n.message}`),xn.updateStatus("FATAL ERROR");const e=document.getElementById("instructions");e&&e.classList.add("hidden")}}function VPe(n,e){const t=document.getElementById("three-container"),s=t.getBoundingClientRect(),i=new jF({alpha:!0,antialias:!0});i.setPixelRatio(window.devicePixelRatio),i.setSize(s.width,s.height),i.setClearColor(0,0),t.appendChild(i.domElement),au=i,new hE(i),ea?(sa&&ea.remove(sa),ei&&ea.remove(ei)):ea=new LE,ei=new Jc,ea.add(ei);const r=s.width/s.height;U0=new Es(65,r,.1,100),U0.position.set(0,0,0),ea.add(new i2(16777215,1));const o=new QE(Ps);o.flipY=!1,$r==="user"?(o.wrapS=Xd,o.offset.x=1,o.repeat.x=-1):(o.wrapS=Pr,o.offset.x=0,o.repeat.x=1);const a=new Qu(1,1);a.scale(1,-1,1);const l=new wa({map:o,side:io,depthTest:!1});sa=new On(a,l);const c=s.width/s.height,u=ME.degToRad(U0.fov),h=Math.abs(2*Math.tan(u/2)*jD),d=h*c;sa.scale.set(d,h,1),sa.position.z=jD,sa.renderOrder=0,ea.add(sa),fE?ei&&!ea.children.includes(ei)&&ea.add(ei):typeof zu<"u"?(xn.updateAssetStatus(`Checking ${mE} and ${gE}...`),Promise.all([fetch(mE).then(p=>{if(!p.ok)throw new Error(`Left asset failed: ${p.status}`);return p}),fetch(gE).then(p=>{if(!p.ok)throw new Error(`Right asset failed: ${p.status}`);return p})]).then(()=>GPe()).catch(p=>{xn.log("error",`FATAL Asset Load Error: ${p.message}. Falling back to boxes.`),yE()}),fE=!0):yE()}function GPe(){Bi&&ei.remove(Bi),ki&&ei.remove(ki),xn.updateAssetStatus("Loading Gaussian Splats...");try{Bi=new zu({url:mE,fileType:"ksplat",onLoad:n=>{n.scale.set(1,1,-1),JD()}}),Bi.visible=!1,Bi.renderOrder=1,ei.add(Bi),ki=new zu({url:gE,fileType:"ksplat",onLoad:n=>{n.scale.set(1,1,-1),JD()}}),ki.visible=!1,ki.renderOrder=1,ei.add(ki)}catch(n){xn.log("error",`Splat instantiation error: ${n.message}. Falling back to boxes.`),yE()}}let LS=0;function JD(){LS++,LS===2&&(lk=!0,xn.log("success","Gaussian Splat data loaded and ready!"),xn.updateAssetStatus("Gaussian Splats active"),LS=0)}function yE(){Bi&&ei.remove(Bi),ki&&ei.remove(ki);const n=new rc(.5,.8,.08),e=new wa({color:52479,transparent:!0,opacity:.8});Bi=new On(n,e),ki=new On(n.clone(),e.clone()),ei.add(Bi),ei.add(ki),Bi.visible=!1,ki.visible=!1,fE=!1,lk=!0,xn.updateAssetStatus("Box placeholder active (Fallback)")}async function RV(){if(!ak)return;requestAnimationFrame(RV),DS++;const n=Date.now();if(n-FS>=1e3){const s=DS/((n-FS)/1e3);xn.updateFPS(s),DS=0,FS=n}pE.clearRect(0,0,lu.width,lu.height);let e=!1,t=Od;if(Ps.readyState>=Ps.HAVE_ENOUGH_DATA&&dI&&($S++,$S>=kPe)){$S=0;try{const s=await dI.estimatePoses(Ps);if(s.length>0){const i=s[0].keypoints,r=i.find(a=>a.name==="left_shoulder"),o=i.find(a=>a.name==="right_shoulder");r&&o&&r.score>.4&&o.score>.4?(Od=i,t=i,xn.updatePoseStatus(`Detected (L:${r.score.toFixed(2)}, R:${o.score.toFixed(2)})`)):(Od=null,t=null,xn.updatePoseStatus("Low confidence / Person too far"))}else Od=null,t=null,xn.updatePoseStatus("No person detected")}catch(s){xn.log("error",`Pose detection error: ${s.message}`),Od=null,t=null}}if(t&&lk){e=!0;const s=t,i=s.find(A=>A.name==="left_shoulder"),r=s.find(A=>A.name==="right_shoulder"),o=(i.x+r.x)/2,a=(i.y+r.y)/2;WPe(ei,o,a);const l=(A,y)=>A/y*2-1,c=l(i.x,Ps.videoWidth),u=l(r.x,Ps.videoWidth);let h=c,d=u;$r==="user"&&(h=-h,d=-d);let f=Math.abs(d-h)/2*NPe;pI=Math.max(f,RPe);let m=(i.y-r.y)/DPe*PS;m=ME.clamp(m,-PS,PS),$r==="user"&&(m=-m),ei.rotation.x+=(m-ei.rotation.x)*Q0,ZD(Bi,"left"),ZD(ki,"right"),HPe(pE,[i,r]),xn.updatePositionStatus(Bi.position,Bi.rotation,ki.position,ki.rotation)}Bi&&ki&&(Bi.visible=e,ki.visible=e),au&&(sa&&sa.material.map&&(sa.material.map.needsUpdate=!0),au.render(ea,U0))}function WPe(n,e,t){const s=FPe,i=(c,u)=>c/u*2-1,r=(c,u)=>-(c/u)*2+1;let o=i(e,Ps.videoWidth),a=r(t,Ps.videoHeight),l=s;$r==="user"&&(o=-o),a-=MPe*1,l+=$Pe,Nr.x=Nr.x+(o-Nr.x)*Q0,Nr.y=Nr.y+(a-Nr.y)*Q0,Nr.z=Nr.z+(l-Nr.z)*Q0,n.position.set(Nr.x,Nr.y,Nr.z)}function ZD(n,e){e==="left"?n.position.set(pI*1,0,0):e==="right"&&n.position.set(-pI*1,0,0);let s=n instanceof zu?AE:1.2;n.scale.set(s,s,s*1.5);const i=-Math.PI*.2,r=Math.PI;let o=0;e==="left"?o=Math.PI+KD:e==="right"&&(o=-Math.PI-KD),n.rotation.set(i,r,o)}function HPe(n,e){n.fillStyle="#00ff88",e.forEach(t=>{if(t.score>.4){let s=t.x;const i=t.y;$r==="user"&&(s=lu.width-s),n.beginPath(),n.arc(s,i,5,0,Math.PI*2),n.fill()}})}window.addEventListener("DOMContentLoaded",()=>{QPe()});
